<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cs on 愿星光伴随你左右</title>
    <link>http://shanks.link/tags/cs/</link>
    <description>Recent content in Cs on 愿星光伴随你左右</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 12 May 2023 11:13:52 +0800</lastBuildDate>
    <atom:link href="http://shanks.link/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CPU 是如何读写内存的</title>
      <link>http://shanks.link/blog/2023/05/12/cpu-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E7%9A%84/</link>
      <pubDate>Fri, 12 May 2023 11:13:52 +0800</pubDate>
      <guid>http://shanks.link/blog/2023/05/12/cpu-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E7%9A%84/</guid>
      <description>&lt;h2 id=&#34;谁来告诉cpu读写内存&#34;&gt;&lt;strong&gt;谁来告诉CPU读写内存&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们第一个要搞清楚的问题是：谁来告诉CPU去读写内存？答案很明显，是程序员，更具体的是编译器。CPU只是按照指令按部就班的执行，机器指令从哪里来的呢？是编译器生成的，程序员通过高级语言编写程序，编译器将其翻译为机器指令，机器指令来告诉CPU去读写内存。在精简指令集架构下会有特定的机器指令，Load/Store指令来读写内存，以x86为代表的复杂指令集架构下没有特定的访存指令。精简指令集下，一条机器指令操作的数据必须来存放在寄存器中，不能直接操作内存数据，因此RISC下，数据必须先从内存搬运到寄存器，这就是为什么RISC下会有特定的Load/Store访存指令，明白了吧。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP可靠性传输初探</title>
      <link>http://shanks.link/blog/2022/04/27/tcp%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Wed, 27 Apr 2022 11:20:55 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/27/tcp%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%E5%88%9D%E6%8E%A2/</guid>
      <description>&lt;p&gt;众所周知，TCP/IP协议栈是事实的网络通信协议，而在保证可靠的网络通信上理解TCP至关重要，本文尝试从工程的视角分析为了保障可靠传输，可能会面对那些问题即对应策略，以及在保证可靠传输时同时提高传输效率，最后给出实际TCP的处理策略。&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式事务重复消费顺序消费</title>
      <link>http://shanks.link/blog/2022/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/</link>
      <pubDate>Sun, 24 Apr 2022 22:21:52 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904003877208071&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;上一期，简单的介绍了一下&lt;strong&gt;消息队列&lt;/strong&gt;的基础知识，里面有消息队列的应用场景，以及使用之后可能带来的问题，但是上期没对怎么解决这些问题做回答，因为要控制篇幅嘛（明明是自己觉得MQ写不了多少期，要多怼一期出来！渣男）&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis系列总结</title>
      <link>http://shanks.link/blog/2022/04/24/redis%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 24 Apr 2022 22:16:39 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/redis%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/247766&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;redis-总体介绍&#34;&gt;Redis 总体介绍&lt;/h1&gt;&#xA;&lt;p&gt;Redis 是 key-value 型的 memory 缓存中间件，相信大部分程序员都在项目中使用过它。我们也可以利用 memory 来实现缓存，只是使用 redis 的话，可以将缓存功能统一到一个组件里，方便后续重用拓展。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于分布式系统共识的思考</title>
      <link>http://shanks.link/blog/2022/04/24/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 24 Apr 2022 22:13:24 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/247776&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;分布式系统的挑战&#34;&gt;分布式系统的挑战&lt;/h1&gt;&#xA;&lt;p&gt;在前面的文章里，我们分析了分布式系统在业务上的一致性技术，即分布式事务，它的结果导向是面向用户的。然而在我们的系统内部，有时也需要面对来自软件架构等更高层次上的一致性要求，比如 Redis 的哨兵模式，Zookeeper 的选举过程等。它们所考虑的一致性更多的是服务节点之间一个&lt;code&gt;共识&lt;/code&gt;&#xA;的达成，当共识达成之后，就可以以此为指导原则，展开更多的协同操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于分布式事务的思考</title>
      <link>http://shanks.link/blog/2022/04/24/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Sun, 24 Apr 2022 22:10:50 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/247777&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;现象&#34;&gt;现象&lt;/h1&gt;&#xA;&lt;p&gt;互联网的世界与十几年前相比，已经大不相同。以往的单体服务就可以支撑起大多数的用户需求。然而随着手机等电子产品的普及，用户想要的服务已经是越来越复杂，各种需求相互关联。而这也给软件开发带来了更多的挑战。为了应付随时会变化的代码世界，现有的开发趋势都在逐渐的化整为零。其中最具代表性的就是&lt;strong&gt;微服务&lt;/strong&gt;的流行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>架构理解总结</title>
      <link>http://shanks.link/blog/2022/04/24/%E6%9E%B6%E6%9E%84%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 24 Apr 2022 18:46:17 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/%E6%9E%B6%E6%9E%84%E7%90%86%E8%A7%A3%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/247774&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;一怎么理解架构&#34;&gt;一、怎么理解架构？&lt;/h1&gt;&#xA;&lt;p&gt;假如给你一个项目开发，你会怎么开始它？对于这个问题，我想很多猿友们都应该经历过吧。很多时候，我们会直接开干，让自己快速的进入 coding 状态。&lt;/p&gt;&#xA;&lt;p&gt;然而一旦遇上稍微有点规模，比如涉及到多个业务功能的开发，那大概率会在开发过程中经常的怀疑自己，甚至产生推倒重来的想法；又或者眼看就要交付了，只能将错就错，修修补补。最后，一个让人揪心的系统又诞生了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis面试总结</title>
      <link>http://shanks.link/blog/2022/04/24/redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 24 Apr 2022 16:47:59 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h1 id=&#34;1-redis-为什么快&#34;&gt;1. redis 为什么快？&lt;/h1&gt;&#xA;&lt;p&gt;在底层上， redis 使用了 IO 多路复用技术，像 select、epoll 等。能较好的保障吞吐量。而且 redis 采用了单线程处理请求，避免了线程切换和锁竞争锁带来的额外消耗。&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机网络面试知识点</title>
      <link>http://shanks.link/blog/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sun, 24 Apr 2022 15:14:30 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>&lt;h1 id=&#34;计算机网络面试知识点&#34;&gt;计算机网络面试知识点&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/332622&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;计算机网络体系模型&#34;&gt;计算机网络体系模型&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;物理层：建立、维护、断开物理连接。&lt;/li&gt;&#xA;&lt;li&gt;数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。&lt;/li&gt;&#xA;&lt;li&gt;网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。&lt;/li&gt;&#xA;&lt;li&gt;传输层：定义传输数据的协议端口号，以及流控和差错校验。&lt;/li&gt;&#xA;&lt;li&gt;会话层：建立、管理、终止会话，（在五层模型里面已经合并到了应用层） 会话的一端是本地主机，另一端是远程主机。&lt;/li&gt;&#xA;&lt;li&gt;表示层：数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 格式有，JPEG、ASCll、EBCDIC、加密格式等。&lt;/li&gt;&#xA;&lt;li&gt;应用层：网络服务与最终用户的一个接口。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/tcpip/modb_20220222_6694eb70-9395-11ec-90a4-fa163eb4f6be.png&#34; alt=&#34;&#34;&gt;计算机网络模型&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式系统的Raft算法</title>
      <link>http://shanks.link/blog/2021/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84raft%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 Sep 2021 17:38:11 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84raft%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;　　过去, Paxos一直是分布式协议的标准，但是Paxos难于理解，更难以实现，Google的分布式锁系统Chubby作为Paxos实现曾经遭遇到很多坑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解Linux IO模型(二)</title>
      <link>http://shanks.link/blog/2021/08/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-io%E6%A8%A1%E5%9E%8B%E4%BA%8C/</link>
      <pubDate>Thu, 26 Aug 2021 18:09:43 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-io%E6%A8%A1%E5%9E%8B%E4%BA%8C/</guid>
      <description>&lt;h1 id=&#34;深入理解linux-io模型二&#34;&gt;深入理解Linux IO模型(二)&lt;/h1&gt;&#xA;&lt;p&gt;原创 Pearl &lt;a href=&#34;javascript:void(0);&#34;&gt;Pearl的仲夏夜之梦&lt;/a&gt; &lt;em&gt;6月13日&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;为何使用epollselect的缺陷epoll的提出epoll的原理数据结构实现原理高效原因epoll的API创建epoll控制epoll等待epoll使用epoll API触发方式水平触发(Level Triggered, LT)边缘触发(Edge Triggered, ET)两者对比Reference&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解Linux IO模型(一)</title>
      <link>http://shanks.link/blog/2021/08/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-io%E6%A8%A1%E5%9E%8B%E4%B8%80/</link>
      <pubDate>Thu, 26 Aug 2021 17:50:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux-io%E6%A8%A1%E5%9E%8B%E4%B8%80/</guid>
      <description>&lt;h3 id=&#34;深入理解linux-io模型一&#34;&gt;深入理解Linux IO模型(一)&lt;/h3&gt;&#xA;&lt;p&gt;原创 Pearl &lt;a href=&#34;javascript:void(0);&#34;&gt;Pearl的仲夏夜之梦&lt;/a&gt; &lt;em&gt;6月12日&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;Linux IO模型是后端工程师的必备技能。从以往的面试中看，部分后端开发人员对它的理解停留在调API的层面，我自己也理解欠缺。最近系统学习了一下，整理了此文。本文参考了一些文章，放在本文最后，大家可以直接去看这些文章，值得阅读。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis的47连环炮，试试你能看住几个 -面前复习</title>
      <link>http://shanks.link/blog/2021/08/26/redis%E7%9A%8447%E8%BF%9E%E7%8E%AF%E7%82%AE%E8%AF%95%E8%AF%95%E4%BD%A0%E8%83%BD%E7%9C%8B%E4%BD%8F%E5%87%A0%E4%B8%AA-%E9%9D%A2%E5%89%8D%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Thu, 26 Aug 2021 00:59:58 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/26/redis%E7%9A%8447%E8%BF%9E%E7%8E%AF%E7%82%AE%E8%AF%95%E8%AF%95%E4%BD%A0%E8%83%BD%E7%9C%8B%E4%BD%8F%E5%87%A0%E4%B8%AA-%E9%9D%A2%E5%89%8D%E5%A4%8D%E4%B9%A0/</guid>
      <description>&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;&#xA;&lt;p&gt;大家好，我是老田，前面我们已经分享了五篇连环炮文章，今天我们继续。今天我们接着来聊聊Redis。Redis已经成为我们开发者必备技能之一了，同时面试也是必问的。下面就来对Redis进行一个总结，然后赠送43连环炮。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础56-磁盘调度算法</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8056-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 25 Aug 2021 11:30:26 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8056-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础56-磁盘调度算法&#34;&gt;操作系统基础56-磁盘调度算法&lt;/h1&gt;&#xA;&lt;p&gt;2021-02-08 02:15·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;操作系统的职责之一是有效使用硬件。对于磁盘驱动器，满足这个要求具有较快的访问速度和较宽的磁盘带宽。&#xA;对于磁盘，访问时间包括两个主要部分：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础55-磁盘冗余阵列RAID</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8055-%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97raid/</link>
      <pubDate>Wed, 25 Aug 2021 11:29:04 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8055-%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97raid/</guid>
      <description>&lt;h1 id=&#34;操作系统基础55-磁盘冗余阵列raid&#34;&gt;操作系统基础55-磁盘冗余阵列RAID&lt;/h1&gt;&#xA;&lt;p&gt;2021-02-07 01:17·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;磁盘驱动器继续变得更小更便宜，如今在一台计算机系统上连接许多磁盘从经济上来说已经可行了。一个系统拥有大量磁盘，就有机会改善数据的读写速率，因为磁盘操作可以并行进行。此外，这种设置提供能力，以提高数据存储的可靠性，因为冗佘信息可以存储在多 个磁盘上。因此，单个磁盘的故障不会导致数据丢失。&#xA;多种磁盘组织技术统称为磁盘冗余阵列(RAID)技术，通常用于处理性能与可靠性问题。过去，RAID是由小且便宜的磁盘组成，可作为大且昂贵的磁盘的有效替代品。现在，RAID的使用主要是因为高可靠性和高数据传输率，而不是经济原因。因此，RAID中的 I 表示“独立”(independent)而不是“廉价”(inexpensive)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础54-磁盘管理</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8054-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 25 Aug 2021 11:27:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8054-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;操作系统基础54-磁盘管理&#34;&gt;操作系统基础54-磁盘管理&lt;/h1&gt;&#xA;&lt;p&gt;2021-02-06 01:09·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;操作系统还负责磁盘管理的其他几个方面。本节讨论磁盘初始化、磁盘引导、坏块恢复等。&lt;/p&gt;&#xA;&lt;h1 id=&#34;磁盘格式化&#34;&gt;磁盘格式化&lt;/h1&gt;&#xA;&lt;p&gt;一个新的磁盘是一个空白盘，它只是一个磁性记录材料的盘子。在磁盘可以存储数据之前，它必须分成扇区，以便磁盘控制器能够读写，这个过程称为低级格式化或物理格式化。&#xA;低级格式化为每个扇区使用特殊的数据结构，填充磁盘。每个扇区的数据结构通常由头部、数据区域(通常为512字节大小)和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息，如扇区号和纠错代码(ECC)。&#xA;当控制器通过正常I/O写入一个扇区的数据时，ECC采用根据数据区域所有字节而计算的新值来加以更新。在读取一个扇区时，ECC值会重新计算，并与原来存储的值相比较，如果存储和计算的数值不一样，则表示扇区数据区已损坏，并且磁盘扇区可能已坏。&#xA;ECC是纠错代码，因为它有足够的信息，以便在只有少数数据损坏时，控制器能够识别哪些位已经改变，并且计算它们的正确值应该是什么。然后它会报告可恢复的软错误。当读或写一个扇区时，控制器自动进行ECC处理。&#xA;大多数磁盘在工厂时作为制造过程的一部分就已低级格式化。这种格式化能让制造商测试磁盘，并且初始化逻辑块号到无损磁盘扇区的映射。对于许多磁盘，当磁盘控制器低级格式化磁盘时，还能指定在头部和尾部之间留下多长的数据区。通常有几个选择，如256、512和1024字节等。采用较大扇区来低级格式化磁盘，意味着每个磁道的扇区数会更少，但也意味着每个磁道的头部和尾部信息会更少，用户数据的可用空间会更多。有的操作系统只能处理512字节的扇区大小。&#xA;在可以使用磁盘存储文件之前，操作系统仍然需要将自己的数据结构记录在磁盘上。这分为两步：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础53-磁盘连接</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8053-%E7%A3%81%E7%9B%98%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Wed, 25 Aug 2021 11:26:11 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8053-%E7%A3%81%E7%9B%98%E8%BF%9E%E6%8E%A5/</guid>
      <description>&lt;h1 id=&#34;操作系统基础53-磁盘连接&#34;&gt;操作系统基础53-磁盘连接&lt;/h1&gt;&#xA;&lt;p&gt;2021-02-04 02:24·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;计算机访问磁盘存储有3种方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过 I/O 端口（或直接连接存储(又称“直连式存储”，DAS))，小系统常采用这种方式；&lt;/li&gt;&#xA;&lt;li&gt;通过分布式文件系统的远程主机，这称为网络连接存储(NAS)；&lt;/li&gt;&#xA;&lt;li&gt;存储区域网络(SAN)适用于大型客户机-服务器环境；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;直接连接存储das&#34;&gt;直接连接存储(DAS)&lt;/h1&gt;&#xA;&lt;p&gt;直接连接存储是通过本地 I/O 端口来访问的存储。这些端口使用多种技术。典型的台式PC采用I/O 总线架构，如IDE或 ATA。这类架构允许每条I/O总线最多支持两个驱动器。SATA 为更新的、类似的、布线更加简化的一个协议。&#xA;高端工作站和服务器通常采用更复杂的I/O架构，例如光纤通道(FC)。FC是一个高速的串行架构，运行在光纤或四芯铜线上。它有两个变体。一个是大的交换结构，具有24位地址空间。这个变体预计未来将占主导地位，是存储域网(SAN)的基础。&#xA;由于通信的较大地址空间和交换性质，多个主机和存储设备可以连到架构，使得 I/O 通信具有极大的灵活性。另一个FC变体是FC仲裁环路(FC-AL)，可以寻址126个设备（驱动器和控制器）。&#xA;多种存储设备适合用作主机连接存储；包括硬盘驱动器、RAID阵列、CD、DVD 和磁带驱动器。对主机连接存储设备进行数据传输的I/O命令是，针对特定存储单元（例如总线 ID 和目标逻辑单元）的逻辑数据块的读和写。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础52-磁盘物理结构</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8052-%E7%A3%81%E7%9B%98%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 25 Aug 2021 11:18:53 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8052-%E7%A3%81%E7%9B%98%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;操作系统基础52-磁盘物理结构&#34;&gt;操作系统基础52-磁盘物理结构&lt;/h1&gt;&#xA;&lt;p&gt;2021-02-03 01:25·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;磁盘&#34;&gt;磁盘&lt;/h1&gt;&#xA;&lt;p&gt;由于内存通常太小而且不能永久保存所有数据和程序，因此计算机系统必须提供外存来备份内存。现代计算机系统采用磁盘（硬盘）作为信息（程序与数据）的主要在线存储介质。换句话说，硬盘或磁盘为现代计算机系统提供大量外存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础51-磁盘空间的分配方法</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8051-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 25 Aug 2021 11:17:42 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8051-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础51-磁盘空间的分配方法&#34;&gt;操作系统基础51-磁盘空间的分配方法&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-31 20:49·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;磁盘直接访问的特点在文件实现时提供了灵活性。在几乎每种情况下，很多文件都是存储在同一个磁盘上的。主要的问题是，如何为这些文件分配空间，以便有效使用磁盘空间和快速访问文件。&#xA;磁盘空间分配的主要常用方法有三个：&lt;strong&gt;连续分配、链接分配&lt;/strong&gt;和&lt;strong&gt;索引分配&lt;/strong&gt;。每个方法各有优缺点。虽然有些系统对这三种方法都支持。但是更为常见的是，一个系统只对同一文件系统类型的所有文件采用一种方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础50-文件系统实现</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8050-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 25 Aug 2021 11:16:12 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8050-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h1 id=&#34;操作系统基础50-文件系统实现&#34;&gt;操作系统基础50-文件系统实现&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-30 02:32·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;文件系统提供了在线存储和访问包括数据和程序在内的文件内容的机制，文件系统永久地驻留在外存上，外存可以永久存储大量数据。&lt;/p&gt;&#xA;&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;1、&lt;strong&gt;在磁盘上，文件系统可能包括如下信息：&#xA;①如何启动所存储的操作系统②总的块数③空闲块的数目和位置④目录结构以及各个具体文件等&lt;/strong&gt;2、&lt;strong&gt;磁盘结构包括：&#xA;①(每个卷的)&lt;strong&gt;引导控制块(boot control block\Volume)&lt;/strong&gt;：通常为分区的第一块。如果该分区没有OS，则为空。(其他名称：引导块(Linux)、分区引导扇区(WindowsNT))&#xA;②(每个卷的)&lt;strong&gt;卷控制块(Volume control block (/volume）&lt;/strong&gt;：包括分区详细信息，如分区的块数、块的大小、空闲块的数量和指针、空闲FCB的数量和指针等(亦称为超级块(Linux)、主控文件表(WindowsNT))&#xA;③&lt;/strong&gt;目录结构&lt;/strong&gt;：用来组织文件&#xA;④&lt;strong&gt;文件控制块&lt;/strong&gt;（&lt;strong&gt;FCB&lt;/strong&gt;）：包括很多文件信息，如文件许可、拥有者、大小和数据块的位置等&#xA;**3、**一个典型的文件控制块包括：&#xA;文件权限、文件日期、文件所有者，组，ACL、文件尺寸、文件数据块&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/6c42b8afcb5242008421b91aff8b12c9?from=pc&#34; alt=&#34;操作系统基础50-文件系统实现&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础49-文件共享与保护</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8049-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/</link>
      <pubDate>Wed, 25 Aug 2021 11:14:52 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8049-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/</guid>
      <description>&lt;h1 id=&#34;操作系统基础49-文件共享与保护&#34;&gt;操作系统基础49-文件共享与保护&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-29 02:34·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/bc2abd1f53eb406ba6848e352c66a3f4?from=pc&#34; alt=&#34;操作系统基础49-文件共享与保护&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;文件共享&#34;&gt;文件共享&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;1、多用户&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Linux是一个真实的、完整的多用户多任务操作系统，多用户多任务就是可以在系统上建立多个用户，而多个用户可以在同一时间内登录同一个系统执行各自不同的任务，而互不影响，例如某台linux服务器上有4个用户，分别是root、www、ftp和mysql，在同一时间内，root用户可能在查看系统日志，管理维护系统，www用户可能在修改自己的网页程序，ftp用户可能在上传软件到服务器，mysql用户可能在执行自己的SQL查询，每个用户互不干扰，有条不紊的进行着自己的工作，而每个用户之间不能越权访问，比如www用户不能执行mysql用户的SQL查询操作，ftp用户也不能修改www用户的网页程序，因此可知，不同用户具有不同的权限，每个用户是在权限允许的范围内完成不同的任务，linux正是通过这种权限的划分与管理，实现了多用户多任务的运行机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础48-目录结构</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8048-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 25 Aug 2021 11:13:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8048-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;操作系统基础48-目录结构&#34;&gt;操作系统基础48-目录结构&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-28 02:06·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;1-存储结构&#34;&gt;1. 存储结构&lt;/h1&gt;&#xA;&lt;p&gt;文件存储在随机存取设备上，包括硬盘、光盘和固态(基于内存)盘。&lt;/p&gt;&#xA;&lt;p&gt;一个磁盘可以划分多个分区(partition)，每个分区可以有多个单独的文件系统。存储设备可以组成RAID集。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础47-文件访问方法</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8047-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 25 Aug 2021 11:12:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8047-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础47-文件访问方法&#34;&gt;操作系统基础47-文件访问方法&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-27 01:58·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;文件存储信息。当使用时，必须访问这种信息，并将其读到计算机内存。文件信息可按多种方式来访问。&lt;/p&gt;&#xA;&lt;h1 id=&#34;顺序访问sequential-access&#34;&gt;顺序访问(sequential access)&lt;/h1&gt;&#xA;&lt;p&gt;顺序访问就是打开文件后，一个字节一个字节的读，一个20Kb的文件，必须先读完前10Kb（即使不做任何操作），才能访问到第11Kb。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础46-文件系统</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8046-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 25 Aug 2021 11:11:07 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8046-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;操作系统基础46-文件系统&#34;&gt;操作系统基础46-文件系统&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-26 01:05·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/d9d47449d6ba4cd289f2cd1bac9a8af8?from=pc&#34; alt=&#34;操作系统基础46-文件系统&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;计算机可以在各种存储介质（诸如磁盘、磁带和光盘）上存储信息。为了方便使用计算机系统，操作系统提供了信息存储的统一逻辑视图。操作系统对存储设备的物理属性加以抽象，从而定义逻辑存储单位，即文件(&lt;strong&gt;file&lt;/strong&gt;)。文件由操作系统映射到物理设备上。这些存储设备通常是非易失性的，因此在系统重新启动之间内容可以持久。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础45-伙伴系统和slab内存分配</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8045-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8Cslab%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Wed, 25 Aug 2021 00:13:53 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8045-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8Cslab%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>&lt;h1 id=&#34;操作系统基础45-伙伴系统和slab内存分配&#34;&gt;操作系统基础45-伙伴系统和slab内存分配&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-25 13:48·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;当在用户模式下运行进程请求额外内存时，从内核维护的空闲页帧列表上分配页面。这个列表通常使用页面置换算法来填充，如前所述，它很可能包含散布在&lt;strong&gt;物理内存&lt;/strong&gt;中的空闲页面。也要记住，如果用户进程请求单个字节内存，那么就会导致内部碎片，因为进程会得到整个帧。&#xA;用于分配内核内存的空闲内存池通常不同于用于普通用户模式进程的列表。这有两个主要原因：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础44-内存映射文件</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8044-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 25 Aug 2021 00:11:31 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8044-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;h1 id=&#34;操作系统基础44-内存映射文件&#34;&gt;操作系统基础44-内存映射文件&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-23 11:17·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;假设采用标准系统调用 &lt;strong&gt;open()、read()&lt;/strong&gt; 和 &lt;strong&gt;write()&lt;/strong&gt; 来顺序读取磁盘文件，每个文件访问都需要系统调用和磁盘访问。又或者采用虚拟内存技术，以将文件&lt;strong&gt;I/O&lt;/strong&gt;作为常规内存访问，这种方法称为内存映射文件，允许一部分虚拟内存与文件进行逻辑关联，这会导致显著的性能提高。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础43-帧分配</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8043-%E5%B8%A7%E5%88%86%E9%85%8D/</link>
      <pubDate>Wed, 25 Aug 2021 00:09:58 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8043-%E5%B8%A7%E5%88%86%E9%85%8D/</guid>
      <description>&lt;h1 id=&#34;操作系统基础43-帧分配&#34;&gt;操作系统基础43-帧分配&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-22 23:00·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;如何在各个进程之间分配一定的空闲内存？&#xA;简单办法是将帧挂在空闲帧链表上，当发生页错误之时即进行分配。进程终止时帧再次放回空闲帧链表。&#xA;帧分配策略受到多方面限制。例如， 分配数不能超过可用帧数，也必须分配至少&lt;strong&gt;最少数量&lt;/strong&gt;。保证最少量的原因之一是涉及&lt;strong&gt;性能&lt;/strong&gt;。&lt;em&gt;&lt;strong&gt;缺页错误&lt;/strong&gt;&lt;/em&gt;增加会减慢进程的执行。并且，在指令完成前出现缺页错误，该指令必须重新执行。所以有足够的帧至关重要。&#xA;每个进程最少帧数由体系结构决定，而最大帧数是由可用物理内存的数量决定。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础42-系统抖动及解决方法</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8042-%E7%B3%BB%E7%BB%9F%E6%8A%96%E5%8A%A8%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 25 Aug 2021 00:08:22 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8042-%E7%B3%BB%E7%BB%9F%E6%8A%96%E5%8A%A8%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础42-系统抖动及解决方法&#34;&gt;操作系统基础42-系统抖动及解决方法&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-21 21:14·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;什么是系统抖动&#34;&gt;什么是系统抖动&lt;/h1&gt;&#xA;&lt;p&gt;如果低优先级进程所分配的帧数低于计算机体系结构所需的最小数量，那么必须暂停该进程执行。然后，应调出它的所有剩余页面，以便释放所有分配的帧。这个规定引入了中级CPU调度的换进换出层。&#xA;事实上，需要研究一下没有“足够”帧的进程。如果进程没有需要支持活动使用页面的帧数，那么它会很快产生缺页错误。此时，必须置换某个页面。然而，由于它的所有页面都在使用中，所以必须立即置换需要再次使用的页面。因此，它会再次快速产生缺页错误，再一次置换必须立即返回的页面，如此快速进行。&#xA;这种高度的页面调度活动称为抖动。如果一个进程的调页时间多于它的执行时间，那么这个进程就在抖动。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础41-LRU页面置换</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8041-lru%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/</link>
      <pubDate>Wed, 25 Aug 2021 00:07:03 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8041-lru%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/</guid>
      <description>&lt;h1 id=&#34;操作系统基础41-lru页面置换&#34;&gt;操作系统基础41-LRU页面置换&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-06 11:53·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果最优算法不可行，那么最优算法的近似或许成为可能。&lt;strong&gt;FIFO&lt;/strong&gt;和&lt;strong&gt;最优页面置换(OPT)&lt;strong&gt;算法的关键区别在于，除了在时间上向后或向前看之外，&lt;strong&gt;FIFO&lt;/strong&gt;算法使用的是页面调入内存的时间，&lt;strong&gt;OPT&lt;/strong&gt;算法使用的是页面将来使用的时间。&#xA;如果我们使用最近的过去作为不远将来的近似，那么可以置换最长时间没有使用的页。这种方法称为&lt;/strong&gt;最近最少使用&lt;/strong&gt;(&lt;strong&gt;LRU&lt;/strong&gt;)算法。&#xA;&lt;strong&gt;LRU&lt;/strong&gt;置换将每个页面与它的上次使用的时间关联起来。当需要置换页面时，&lt;strong&gt;LRU&lt;/strong&gt;选择最长时间没有使用的页面。这种策略可当作在时间上向后看而不是向前看的最优页面置换算法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础40-最优页面置换</title>
      <link>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8040-%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/</link>
      <pubDate>Wed, 25 Aug 2021 00:05:44 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8040-%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/</guid>
      <description>&lt;h1 id=&#34;操作系统基础40-最优页面置换&#34;&gt;操作系统基础40-最优页面置换&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-06 01:28·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;发现 Belady 异常的一个结果是寻找&lt;strong&gt;最优页面置换算&lt;/strong&gt;法，这个算法具有所有算法的最低的缺页错误率，并且不会遭受Belady异常。这种算法确实存在，它被称为OPT或MIN。该算法的思想是：置换最长时间不会使用的页面。&#xA;这种页面置换算法确保对于给定数量的帧会产生最低的可能的缺页错误率。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础39-FIFO页面置换</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8039-fifo%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/</link>
      <pubDate>Tue, 24 Aug 2021 23:33:30 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8039-fifo%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/</guid>
      <description>&lt;h1 id=&#34;操作系统基础39-fifo页面置换&#34;&gt;操作系统基础39-FIFO页面置换&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-04 01:25·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，其中选择调出页面的算法就称为&lt;strong&gt;页面置换算法&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础38-写时复制技术</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8038-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Tue, 24 Aug 2021 23:31:51 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8038-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF/</guid>
      <description>&lt;h1 id=&#34;操作系统基础38-写时复制技术&#34;&gt;操作系统基础38-写时复制技术&lt;/h1&gt;&#xA;&lt;p&gt;2021-01-03 17:04·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前面学习一个进程如何采用请求调页，仅调入包括第一条指令的页面，从而能够很 快开始执行。然而，通过系统调用 fork() 的进程创建最初可以通过使用类似于页面共享的技术，绕过请求调页的需要。这种技术提供了快速的进程创建，并最小化必须分配给新创建进程的新页面的数量&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础37-请求调页的性能</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8037-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%9A%84%E6%80%A7%E8%83%BD/</link>
      <pubDate>Tue, 24 Aug 2021 23:30:08 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8037-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
      <description>&lt;h1 id=&#34;操作系统基础37-请求调页的性能&#34;&gt;操作系统基础37-请求调页的性能&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-29 01:08·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;请求调页可以显著影响计算机系统的性能。为了说明起见，下面计算一下请求调页内存的有效访问时间。&#xA;对大多数计算机系统而言，&lt;strong&gt;内存访问时间&lt;/strong&gt;(用&lt;strong&gt;ma&lt;/strong&gt;表示)的范围为10〜200ns。只要没有出现缺页错误，有效访问时间就等于内存访问时间。然而，如果出现缺页错误，那么就应先从磁盘中读入相关页面，再访问所需要的字。&#xA;设 &lt;strong&gt;p&lt;/strong&gt; 为&lt;strong&gt;缺页错误的概率&lt;/strong&gt;(&lt;strong&gt;0≤p≤1&lt;/strong&gt;)。希望&lt;strong&gt;p&lt;/strong&gt;接近于&lt;strong&gt;0&lt;/strong&gt;，即缺页错误很少。那么有效访问时间为：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础36-请求页面调度概念</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8036-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Tue, 24 Aug 2021 22:36:26 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8036-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;h1 id=&#34;操作系统基础36-请求页面调度概念&#34;&gt;操作系统基础36-请求页面调度概念&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-28 10:54·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;如何从磁盘加载可执行程序到内存?&#xA;一种选择是在程序执行时将整个程序加载到物理内存，这种方法的问题是最初可能不需要整个程序都处于内存。假设程序开始时带有一组用户可选的选项。加载整个程序会导致所有选项的执行代码都加载到内存中，而不管这些选项是否最终使用。&#xA;另一种策略是仅在需要时才加载页面。这种技术被称为&lt;strong&gt;请求调页&lt;/strong&gt;，常常用于&lt;strong&gt;虚拟内存系统&lt;/strong&gt;。对于请求调页的虚拟内存，页面只有在程序执行期间被请求时才被加载。因此，从未访问的那些页从不加载到物理内存中。&#xA;&lt;strong&gt;请求调页&lt;/strong&gt;系统类似于具有交换的分页系统，如下图所示，这里进程驻留在外存上（通常为磁盘）。当进程需要执行时，它被交换到内存中。不过，不是将整个进程交换到内存中，而是采用惰性交换器。惰性交换器除非需要某个页面，否则从不将它交换到内存中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础35-什么是虚拟内存</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8035-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 24 Aug 2021 22:25:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8035-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>&lt;h1 id=&#34;操作系统基础35-什么是虚拟内存&#34;&gt;操作系统基础35-什么是虚拟内存&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-27 15:32·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;分页，分段这些策略都有相同的目标，就是同时将多个进程保存在内存中，以便允许多道程序。然而，这些策略都倾向于要求每个进程在执行之前应完全处于内存中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础34-页表结构</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8034-%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 24 Aug 2021 22:24:42 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8034-%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;操作系统基础34-页表结构&#34;&gt;操作系统基础34-页表结构&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-24 13:01·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;下面将探讨组织页表的一些最常用技术，包括&lt;strong&gt;分层分页&lt;/strong&gt;、&lt;strong&gt;哈希页表&lt;/strong&gt;和&lt;strong&gt;倒置页表&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h1 id=&#34;分层分页&#34;&gt;分层分页&lt;/h1&gt;&#xA;&lt;p&gt;大多数现代计算机系统支持大逻辑地址空间（2^32〜2^64）。在这种情况下，页表本身可以非常大。例如，假设具有 32 位逻辑地址空间的一个计算机系统。如果系统的页大小为4KB（2^12），那么页表可以多达 100万的条目（2^32/2^12）。假设每个条目有4字节，那么每个进程需要4MB 物理地址空间来存储页表本身。显然，我们并不想在内存中连续地分配这个页表。这个问题的一个简单解决方法是将页表划分为更小的块。完成这种划分有多个方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础33-内存管理-分页</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8033-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%88%86%E9%A1%B5/</link>
      <pubDate>Tue, 24 Aug 2021 22:23:15 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8033-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%88%86%E9%A1%B5/</guid>
      <description>&lt;h1 id=&#34;操作系统基础33-内存管理-分页&#34;&gt;操作系统基础33-内存管理-分页&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-21 12:10·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分段&lt;/strong&gt;允许进程的物理地址空间是非连续的。&lt;strong&gt;分页&lt;/strong&gt;是提供这种优势的另一种内存管理方案。然而，分页避免了外部碎片和紧缩，而分段不可以。分页还避免了将不同大小的内存块匹配到交换空间的问题，在分页引入之前采用的内存管理方案都有这个问题。由于比早期方法更加优越，各种形式的分页为大多数操作系统采用，包括大型机的和智能手机的操作系统。实现分页需要操作系统和计算机硬件的协作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础32-内存管理-分段</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8032-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%88%86%E6%AE%B5/</link>
      <pubDate>Tue, 24 Aug 2021 22:21:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8032-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%88%86%E6%AE%B5/</guid>
      <description>&lt;h1 id=&#34;操作系统基础32-内存管理-分段&#34;&gt;操作系统基础32-内存管理-分段&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-20 03:27·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过前面的学习我们知道，用户的&lt;strong&gt;内存视图&lt;/strong&gt;与实际的&lt;strong&gt;物理内存&lt;/strong&gt;不一样。这同样适用于程序员的内存视图。&lt;/p&gt;&#xA;&lt;p&gt;事实上，对操作系统和程序员来说，按物理性质来处理内存是不方便的。如果硬件可以提供内存机制，以便将程序员的内存视图映射到实际的物理内存，系统将有更多的自由来管理内存，而程序员将有一个更自然的编程环境。&lt;strong&gt;分段&lt;/strong&gt;提供了这种机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础31-连续内存分配</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8031-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Tue, 24 Aug 2021 22:19:46 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8031-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>&lt;h1 id=&#34;操作系统基础31-连续内存分配&#34;&gt;操作系统基础31-连续内存分配&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-19 03:40·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;内存应容纳操作系统和各种用户进程，因此应该尽可能有效地分配内存。下面介绍一种早期方法：连续内存分配。&#xA;内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。操作系统可以放在低内存，也可放在高内存，这取决于中断向量的位置。由于中断向量通常位于低内存，因此程序员通常将操作系统也放在低内存。因此，这里只讨论操作系统位于低内存的情况，其他情况的讨论也类似。&#xA;通常，我们需要将多个进程同时放在内存中。因此我们需要考虑，如何为输入队列中需要调入内存的进程分配内存空间。在采用连续内存分配时，每个进程位于一个连续的内存区域，与包含下一个进程的内存相连。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础30-内存交换</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8030-%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2/</link>
      <pubDate>Tue, 24 Aug 2021 11:50:20 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8030-%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2/</guid>
      <description>&lt;h1 id=&#34;操作系统基础30-内存交换&#34;&gt;操作系统基础30-内存交换&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-17 15:21·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;进程必须在内存中以便执行。不过，进程可以暂时从内存交换到备份存储，当再次执行时再调回到内存中(图 1)。交换有可能让所有进程的总的物理地址空间超过真实系统的物理地址空间，从而增加了系统的多道程序程度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础29-内存管理的概念</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8029-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Tue, 24 Aug 2021 11:44:12 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8029-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;h1 id=&#34;操作系统基础29-内存管理的概念&#34;&gt;操作系统基础29-内存管理的概念&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-18 03:37·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢?&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;\1. 操作系统负责内存空间的分配与回收。&lt;/p&gt;&#xA;&lt;p&gt;\2. 操作系统需要提供某种技术从逻辑.上对内存空间进行扩充。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础28-内存基础知识</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8028-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 24 Aug 2021 11:42:30 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8028-%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;操作系统基础28-内存基础知识&#34;&gt;操作系统基础28-内存基础知识&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-16 05:59·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;什么是内存有何作用&#34;&gt;什么是内存，有何作用&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/f73fa5bc910441aab424f5f90f574333?from=pc&#34; alt=&#34;操作系统基础28-内存基础知识&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;进程运行的原理-指令&#34;&gt;进程运行的原理-指令&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/a1580be9b97d4614b0c22efc54294e0e?from=pc&#34; alt=&#34;操作系统基础28-内存基础知识&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们写的代码要翻译成&lt;strong&gt;CPU&lt;/strong&gt;能识别的指令。这些指令会告诉CPU应该去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址(物理地址)。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用&lt;strong&gt;逻辑地址&lt;/strong&gt;(相对地址)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础27-存储器管理</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8027-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 24 Aug 2021 11:40:53 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8027-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;操作系统基础27-存储器管理&#34;&gt;操作系统基础27-存储器管理&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-15 13:37·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;　　在前面学习了处理器调度后，下面接着学习存储器管理，如何对存储器进行有效的管理，直接影响着存储器的利用率和系统性能。&lt;/p&gt;&#xA;&lt;h1 id=&#34;存储器的层次结构&#34;&gt;存储器的层次结构&lt;/h1&gt;&#xA;&lt;p&gt;　　1.&lt;strong&gt;主存储器&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础26-多级反馈队列调度算法</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8026-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 24 Aug 2021 01:11:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8026-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础26-多级反馈队列调度算法&#34;&gt;操作系统基础26-多级反馈队列调度算法&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-02 01:54·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;通常在使用**&lt;a href=&#34;https://www.toutiao.com/i6901145871342109196/?group_id=6901145871342109196&#34;&gt;多级队列调度算法&lt;/a&gt;**时，进程进入系统时被永久地分配到某个队列。例如，如果前台和后台进程分别具有单独队列，那么进程并不从一个队列移到另一个队列，这是因为进程不会改变前台或后台的性质。这种设置的优点是调度开销低，缺点是不够灵活。&lt;/p&gt;&#xA;&lt;p&gt;相反，&lt;strong&gt;多级反馈队列(multievel feedback queue)调度算法&lt;/strong&gt;允许进程在队列之间迁移。这种想法是，根据不同&lt;strong&gt;CPU&lt;/strong&gt;执行的特点来区分进程。如果进程使用过多的&lt;strong&gt;CPU&lt;/strong&gt;时间，那么它会被移到更低的优先级队列。这种方案将&lt;strong&gt;I/O&lt;/strong&gt;密集型和交互进程放在更高优先级队列上。 此外，在较低优先级队列中等待过长的进程会被移到更高优先级队列。这种形式的优化可阻止饥饿的发生。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础25-多级队列调度算法</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8025-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 24 Aug 2021 01:10:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8025-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础25-多级队列调度算法&#34;&gt;操作系统基础25-多级队列调度算法&lt;/h1&gt;&#xA;&lt;p&gt;2020-12-01 13:30·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在&lt;strong&gt;进程&lt;/strong&gt;容易分成不同组的情况下，可以有另一类调度算法。例如，进程通常分为&lt;strong&gt;前台进程(foreground process)&lt;/strong&gt;(或交互进程)和&lt;strong&gt;后台进程(background process)&lt;/strong&gt;(或批处理进程)。这两种类型的进程具有不同的响应时间要求，进而也有不同调度需要。另外，与&lt;strong&gt;后台进程&lt;/strong&gt;相比，&lt;strong&gt;前台进程&lt;/strong&gt;可能要有更高的优先级(外部定义)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础24-轮转调度</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8024-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Tue, 24 Aug 2021 01:09:12 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8024-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;操作系统基础24-轮转调度rr算法&#34;&gt;操作系统基础24-轮转调度(RR)算法&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-30 11:05·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;时间片轮转（RR）&lt;strong&gt;调度算法是专门为分时系统设计的。它类似于&lt;/strong&gt;FCFS&lt;/strong&gt;调度，但是增加了抢占以切换进程。也称为&lt;strong&gt;时间片技术&lt;/strong&gt;(&lt;strong&gt;time slicing，SL&lt;/strong&gt;)。&#xA;该算法中，将一个较小时间单元定义为&lt;strong&gt;时间量&lt;/strong&gt;或&lt;strong&gt;时间片&lt;/strong&gt;。时间片的大小通常为10~100ms。就绪队列作为循环队列。&lt;strong&gt;CPU&lt;/strong&gt;调度程序循环整个就绪队列，为每个进程分配不超过一个时间片的&lt;strong&gt;CPU&lt;/strong&gt;。&#xA;为了实现&lt;strong&gt;RR&lt;/strong&gt;调度，我们再次将就绪队列视为进程的&lt;strong&gt;FIFO&lt;/strong&gt; 队列。新进程添加到就绪队列的尾部。&lt;strong&gt;CPU&lt;/strong&gt;调度程序从就绪队列中选择第一个进程，将定时器设置在一个时间片后中断，最后分派这个进程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础23-优先级调度算法</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8023-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 24 Aug 2021 01:07:39 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8023-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础23-优先级调度算法&#34;&gt;操作系统基础23-优先级调度算法&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-29 17:17·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;上一篇学习了&lt;a href=&#34;https://www.toutiao.com/i6900087980027838980/?group_id=6900087980027838980&#34;&gt;最短作业优先(SJF)算法&lt;/a&gt;是通用&lt;strong&gt;优先级调度(priority-scheduling)&lt;strong&gt;算法的一个特例。每个进程都有一个优先级与其关联，而具有最高优先级的进程会分配到&lt;/strong&gt;CPU&lt;/strong&gt;。具有相同优先级的进程按&lt;strong&gt;FCFS&lt;/strong&gt;顺序调度。&lt;strong&gt;SJF&lt;/strong&gt;算法是一个简单的优先级算法，其优先级(p)为下次（预测的）&lt;strong&gt;CPU&lt;/strong&gt; 执行的倒数。&lt;strong&gt;CPU&lt;/strong&gt; 执行越长，则优先级越小；反之亦然。&lt;/p&gt;&#xA;&lt;p&gt;举个例子，假设有如下一组进程，它们在时间 0 按顺序 P1，P2，…，P5 到达，其&lt;strong&gt;CPU&lt;/strong&gt;执行时间以 ms 计：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础22-最短作业优先(SJF)调度算法</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8022-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88sjf%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 24 Aug 2021 01:04:12 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8022-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88sjf%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础22-最短作业优先sjf调度算法&#34;&gt;操作系统基础22-最短作业优先(SJF)调度算法&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-28 17:16·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;最短作业优先&lt;/strong&gt;( &lt;strong&gt;Shortest Job First&lt;/strong&gt; &lt;strong&gt;SJF&lt;/strong&gt;)调度算法将每个进程与其下次&lt;strong&gt;CPU&lt;/strong&gt;执行的长度关联起来。当&lt;strong&gt;CPU&lt;/strong&gt;变为空闲时，它会被赋给具有最短&lt;strong&gt;CPU&lt;/strong&gt;执行的进程。如果两个进程具有同样长度的&lt;strong&gt;CPU&lt;/strong&gt;执行，那么可以由**先到先服务(FCFS)**调度算法来处理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础21-先来先服务调度(FCFS)算法</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8021-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6fcfs%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 24 Aug 2021 00:35:44 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8021-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6fcfs%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;操作系统基础21-先来先服务调度fcfs算法&#34;&gt;操作系统基础21-先来先服务调度(FCFS)算法&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-24 09:51·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;作业、进程和程序之间的联系：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;一个&lt;strong&gt;作业&lt;/strong&gt;(&lt;strong&gt;job&lt;/strong&gt;)通常包括&lt;strong&gt;程序&lt;/strong&gt;、&lt;strong&gt;数据&lt;/strong&gt;和&lt;strong&gt;操作说明书&lt;/strong&gt;3部分。每一个&lt;strong&gt;进程&lt;/strong&gt;由&lt;strong&gt;PCB&lt;/strong&gt;、&lt;strong&gt;程序&lt;/strong&gt;和&lt;strong&gt;数据集合&lt;/strong&gt;组成。这说明程序是进程的一部分，是进程的实体。因此，一个作业可划分为若干个进程来完成，而每一个进程有其实体——程序和数据集合&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础20-调度算法的评价指标</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8020-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</link>
      <pubDate>Tue, 24 Aug 2021 00:28:29 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8020-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</guid>
      <description>&lt;h1 id=&#34;操作系统基础20-调度算法的评价指标&#34;&gt;操作系统基础20-调度算法的评价指标&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-23 10:08·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;不同的&lt;strong&gt;CPU&lt;/strong&gt;调度算法具有不同属性，选择一个特定算法会对某些进程更为有利。为了选择算法以便用于特定情景，我们必须考虑各个算法的属性。&#xA;为了比较&lt;strong&gt;CPU&lt;/strong&gt;调度算法，可以采用许多比较准则。选择哪些特征来比较，对于确定哪种算法是最好的有本质上的区别。这些准则包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础19-CPU调度</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8019-cpu%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Tue, 24 Aug 2021 00:26:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8019-cpu%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;操作系统基础19-cpu调度&#34;&gt;操作系统基础19-CPU调度&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-20 13:11·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本节是对&lt;a href=&#34;https://www.toutiao.com/i6889224598341190155/?group_id=6889224598341190155&#34;&gt;操作系统基础12-进程调度&lt;/a&gt;的一个补充学习。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;CPU调度&lt;/strong&gt;是&lt;strong&gt;多道程序&lt;/strong&gt;操作系统的基础。通过在进程间切换&lt;strong&gt;CPU&lt;/strong&gt;，操作系统可以使得计算机更加高效。&#xA;对于&lt;strong&gt;单处理器系统&lt;/strong&gt;，同一时间只有一个进程可以运行；其他进程都应等待，直到&lt;strong&gt;CPU&lt;/strong&gt;空闲并可调度为止。&lt;strong&gt;多道程序&lt;/strong&gt;的目标是，始终允许某个进程运行以最大化CPU利用率。这种想法比较简单。一个进程执行直到它应等待为止，通常等待某个 &lt;strong&gt;I/O&lt;/strong&gt; 请求的完成。对于简单的计算机系统，&lt;strong&gt;CPU&lt;/strong&gt;就处于闲置状态。所有这些等待时间就会浪费，没有完成任何有用的工作。采用多道程序，我们试图有效利用这个时间。多个进程同时处于内存。当一个进程等待时，操作系统就从该进程接管&lt;strong&gt;CPU&lt;/strong&gt;控制，并将&lt;strong&gt;CPU&lt;/strong&gt;交给另一进程。这种方式不断重复。当一个进程必须等待时，另一进程接管&lt;strong&gt;CPU&lt;/strong&gt;使用权。&#xA;这种调度是操作系统的基本功能。几乎所有计算机资源在使用前都要调度。当然，&lt;strong&gt;CPU&lt;/strong&gt;是最重要的计算机资源之一。因此，&lt;strong&gt;CPU&lt;/strong&gt;调度是操作系统设计的重要部分。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础18-死锁</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8018-%E6%AD%BB%E9%94%81/</link>
      <pubDate>Tue, 24 Aug 2021 00:25:10 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8018-%E6%AD%BB%E9%94%81/</guid>
      <description>&lt;h1 id=&#34;操作系统基础18-死锁&#34;&gt;操作系统基础18-死锁&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-18 10:19·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在多道程序环境中，多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为&lt;strong&gt;死锁&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础17-哲学家就餐问题</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8017-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 24 Aug 2021 00:23:44 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8017-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;操作系统基础17-哲学家就餐问题&#34;&gt;操作系统基础17-哲学家就餐问题&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-13 15:55·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;哲学家就餐问题&lt;/strong&gt;(&lt;strong&gt;dining-philosophers problem&lt;/strong&gt;)是一个经典的进程之间的同步互斥问题。该问题是&lt;strong&gt;1965&lt;/strong&gt;年由荷兰学者Dijkstra提出的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础16-读者写者问题</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8016-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 24 Aug 2021 00:22:24 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8016-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;操作系统基础16-读者写者问题&#34;&gt;操作系统基础16-读者写者问题&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-12 00:56·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;进程同步问题&lt;/strong&gt;是一个非常重要且相当有趣的问题，本篇我们对其中比较有名的&lt;strong&gt;读者-写者问题&lt;/strong&gt;来进行学习。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/e0e739ded63642ff8f0ec46654168d2f?from=pc&#34; alt=&#34;操作系统基础16-读者写者问题&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;读者-写者&lt;/p&gt;&#xA;&lt;h1 id=&#34;问题描述&#34;&gt;问题描述&lt;/h1&gt;&#xA;&lt;p&gt;假设一个数据库为多个并发进程所共享。有的进程可能只需要读数据库，而另一些进程可能更新(即&lt;strong&gt;读&lt;/strong&gt;和&lt;strong&gt;写&lt;/strong&gt;)数据库。为了区分这两种类型的进程，我们称前者为&lt;strong&gt;读者&lt;/strong&gt;(&lt;strong&gt;Reader&lt;/strong&gt;)，称后者为&lt;strong&gt;写者&lt;/strong&gt;(&lt;strong&gt;Writer&lt;/strong&gt;)。显然，如果多个&lt;strong&gt;读者同时访问&lt;/strong&gt;共享数据，而不会产生副作用。但如果某个&lt;strong&gt;写者&lt;/strong&gt;和其他进程**(或读者或写者)**同时访问数据库时可能导致数据不一致的错误。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础15-生产者消费者问题</title>
      <link>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8015-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 24 Aug 2021 00:20:52 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8015-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;操作系统基础15-生产者消费者问题&#34;&gt;操作系统基础15-生产者消费者问题&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-11 11:37·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://www.toutiao.com/i6893419548255453700/?group_id=6893419548255453700&#34;&gt;上一篇操作系统基础14&lt;/a&gt;提到通过&lt;strong&gt;信号量&lt;/strong&gt;解决生产者消费者问题。本篇来详细说说&lt;strong&gt;操作系统中的经典问题-生成者消费者问题&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;生产者消费者问题-producer-consumer-problem&#34;&gt;生产者消费者问题 (Producer-consumer problem)&lt;/h1&gt;&#xA;&lt;p&gt;该问题是一个著名的同步问题。通俗的描述是：一群生产者进程正在生产产品，并将这些产品提供给消费者进程去消费。为使生产者和消费者能够并发执行。在两者之间设置了一个公共区域，生产者进入公共区域生产产品并放入其中。消费者进入公共区域并取走产品进行消费。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础14-同步与互斥机制</title>
      <link>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8014-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 22 Aug 2021 11:49:52 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8014-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;操作系统基础14-同步与互斥机制&#34;&gt;操作系统基础14-同步与互斥机制&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-10 22:55·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;上一篇介绍操心系统中的同步互斥的基本概念，本篇继续对同步互斥进行学习&lt;/p&gt;&#xA;&lt;h1 id=&#34;锁机制&#34;&gt;锁机制&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;锁是一个更高等级的编程抽象。&lt;/p&gt;&#xA;&lt;p&gt;包含一个二进制变量（锁定/解锁），两个操作：&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础13-进程同步与互斥的概念</title>
      <link>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8013-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 22 Aug 2021 11:22:53 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8013-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;h1 id=&#34;操作系统基础13-进程同步与互斥的概念&#34;&gt;操作系统基础13-进程同步与互斥的概念&lt;/h1&gt;&#xA;&lt;p&gt;2020-11-02 11:26·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;进程同步是一个操作系统级别的概念，在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了&lt;strong&gt;进程同步&lt;/strong&gt;的概念。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础12-进程调度</title>
      <link>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8012-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Sun, 22 Aug 2021 11:13:38 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8012-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;操作系统基础12-进程调度&#34;&gt;操作系统基础12-进程调度&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-30 11:59·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前面&lt;a href=&#34;https://www.toutiao.com/i6885577093749408260/?group_id=6885577093749408260&#34;&gt;操作系统基础8&lt;/a&gt;和&lt;a href=&#34;https://www.toutiao.com/i6886370746575094286/?group_id=6886370746575094286&#34;&gt;操作系统基础10&lt;/a&gt;已经学习关于进程和线程的的基础知识，本次我们继续学习关于操作系统中调度的概念。&lt;/p&gt;&#xA;&lt;p&gt;前面学习了线程相关内容，我们知道对于支持线程的操作系统，操作系统实际调度的是内核级线程而非进程。对于术语&lt;strong&gt;进程调度(process scheduling)&lt;strong&gt;或&lt;/strong&gt;线程调度(thread scheduling)&lt;strong&gt;常常交替使用，在一般说到调度概念时，采用&lt;/strong&gt;进程调度&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础11-关于多核编程</title>
      <link>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8011-%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 22 Aug 2021 11:06:27 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8011-%E5%85%B3%E4%BA%8E%E5%A4%9A%E6%A0%B8%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;p&gt;2020-10-26 12:43·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;之前，&lt;strong&gt;CPU&lt;/strong&gt;的性能还主要取决于CPU的主频，经过超&lt;strong&gt;摩尔定律&lt;/strong&gt;的发展后，没过多长时间CPU的主频速度就已接近“极限”，使得单单靠提高CPU的主频来提升性能变得非常困难。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础10-线程及多线程模型</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8010-%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 21 Aug 2021 20:26:22 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%8010-%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;操作系统基础10-线程及多线程模型&#34;&gt;操作系统基础10-线程及多线程模型&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-23 14:42·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;什么是线程&#34;&gt;什么是线程&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;（&lt;strong&gt;thread&lt;/strong&gt;）是操作系统能够进行运算调度的最小单位。它被包含在&lt;strong&gt;进程&lt;/strong&gt;之中，是进程中的&lt;strong&gt;实际运作单位&lt;/strong&gt;。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础9-进程通信IPC</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%809-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1ipc/</link>
      <pubDate>Sat, 21 Aug 2021 17:54:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%809-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1ipc/</guid>
      <description>&lt;h1 id=&#34;操作系统基础9-进程通信ipc&#34;&gt;操作系统基础9-进程通信IPC&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-21 18:00·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;什么是进程通信&#34;&gt;什么是进程通信？&lt;/h1&gt;&#xA;&lt;p&gt;&lt;strong&gt;进程通信(Interprocess Communication&lt;/strong&gt;)就是指进程之间的信息交换。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;是分配系统资源的单位(包括内存地址空间) ，各个进程拥有的内存地址空间相互独立，为了保证安全， 操作系统中规定一个进程不能直接访问另一个进程的地址空间。如下图中的进程1就不能直接访问进程2的地址空间。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础8-进程及进程控制</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%808-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 21 Aug 2021 15:58:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%808-%E8%BF%9B%E7%A8%8B%E5%8F%8A%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;操作系统基础8-进程及进程控制&#34;&gt;操作系统基础8-进程及进程控制&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-20 17:44·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;进程process-的定义&#34;&gt;进程(Process) 的定义&lt;/h1&gt;&#xA;&lt;p&gt;从不同的角度，进程可以有不同的定义，传统典型的定义：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;是程序的一次执行过程。 或者：一个正在执行的程序的实例&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;是一个程序及其数据在处理机上顺序执行所发生的活动&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/0c3913a87d044e77b519bf21683a46f1?from=pc&#34; alt=&#34;操作系统基础8-进程及进程控制&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础7-支持操作系统的最基本的硬件-时钟</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%807-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%A1%AC%E4%BB%B6-%E6%97%B6%E9%92%9F/</link>
      <pubDate>Sat, 21 Aug 2021 15:23:29 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%807-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%A1%AC%E4%BB%B6-%E6%97%B6%E9%92%9F/</guid>
      <description>&lt;p&gt;操作系统基础7-支持操作系统的最基本的硬件-时钟&#xA;2020-10-19 13:21·重学IT的老猫&#xA;时钟又称为计时器，简单来说作用就是负责维护时间。&lt;/p&gt;&#xA;&lt;p&gt;可以分为两种时间：硬件时钟、系统时钟&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础6-支持操作系统的最基本的硬件-中断</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%806-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%A1%AC%E4%BB%B6-%E4%B8%AD%E6%96%AD/</link>
      <pubDate>Sat, 21 Aug 2021 15:05:05 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%806-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%A1%AC%E4%BB%B6-%E4%B8%AD%E6%96%AD/</guid>
      <description>&lt;h1 id=&#34;操作系统基础6-支持操作系统的最基本的硬件-中断&#34;&gt;操作系统基础6-支持操作系统的最基本的硬件-中断&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-17 20:54·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即便在硬件成本逐渐下降，而硬件配置直线上升的今天，PC机的核心可能已经达到４核心，８核心，而手机移动设备更不可思议的达到16核心，32核心，处理器的数量依然不可能做到每个任务一个&lt;strong&gt;CPU&lt;/strong&gt;，所以&lt;strong&gt;CPU&lt;/strong&gt;必须作为一种全局的资源让所有任务共享。说到共享，如何共享呢？什么时候给任务A用，什么时候给任务B用&amp;hellip;&amp;hellip;这就是&lt;strong&gt;进程调度&lt;/strong&gt;，具体的安排就由调度算法决定了。进程如何去调度？现代操作系统一般都是采用基于&lt;strong&gt;时间片的优先级&lt;/strong&gt;调度算法，把&lt;strong&gt;CPU&lt;/strong&gt;的时间划分为很细粒度的时间片，一个任务每次只能占用这么多的时间，时间到了就必须交出使用权，换由其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要性，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，计算机并不知道什么时候数据包会来到，能保证的就是数据来了能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？答：中断！&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础5-支持操作系统的最基本的硬件-内存</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%805-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%A1%AC%E4%BB%B6-%E5%86%85%E5%AD%98/</link>
      <pubDate>Sat, 21 Aug 2021 14:51:33 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%805-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%A1%AC%E4%BB%B6-%E5%86%85%E5%AD%98/</guid>
      <description>&lt;h1 id=&#34;操作系统基础5-支持操作系统的最基本的硬件-内存&#34;&gt;操作系统基础5-支持操作系统的最基本的硬件-内存&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-15 16:23·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://www.toutiao.com/i6883040524463407630/?group_id=6883040524463407630&#34;&gt;操心系统基础4&lt;/a&gt;我们已经介绍了OS依赖的重要硬件CPU，下面我们来介绍操心系统依赖的另一类重要部件-内存，这里说的内存是比较宽泛的概念，是指存储器(Memory)。&lt;/p&gt;&#xA;&lt;h1 id=&#34;存储器memory&#34;&gt;存储器(Memory)&lt;/h1&gt;&#xA;&lt;p&gt;是用来存储程序和数据的部件。&lt;/p&gt;&#xA;&lt;p&gt;存储器的概念很广，有很多层次，在数字系统中，只要能保存二进制数据的都可以是存储器；在集成电路中，一个没有实物形式的具有存储功能的电路也叫存储器，如RAM、FIFO等；在计算机系统中，具有实物形式的存储设备也叫存储器，如内存条、TF卡等。计算机中全部信息，包括输入的原始数据、计算机程序、中间运行结果和最终运行结果都保存在存储器中。存储器根据控制器指定的位置存入和取出信息。对于计算机来说，有了存储器，才有了记忆功能，才能保证正常工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础4-支持操作系统的最基本硬件-CPU</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%804-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6-cpu/</link>
      <pubDate>Sat, 21 Aug 2021 11:05:01 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%804-%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6-cpu/</guid>
      <description>&lt;h1 id=&#34;操作系统基础4-支持操作系统的最基本硬件-cpu&#34;&gt;操作系统基础4-支持操作系统的最基本硬件-CPU&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-14 11:24·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;从&lt;a href=&#34;https://www.toutiao.com/i6881510359304405517/?group_id=6881510359304405517&#34;&gt;操作系统基础1&lt;/a&gt;我们已经知道：操作系统作为用户与计算机硬件直接的接口，是配置在计算机硬件上的第一层软件，所以操作系统的运行必须要依赖一些基本的硬件，或者说需要一些基本硬件的支持。主要包括以下几种：CPU(Central Processing Unit)中央处理器、内存、中断、时钟&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/35739dcd226a47ca8c376e60543da766?from=pc&#34; alt=&#34;操作系统基础4-支持操作系统的最基本硬件-CPU&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;cpu中央处理器&#34;&gt;CPU中央处理器&lt;/h1&gt;&#xA;&lt;p&gt;中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础3-宏内核与微内核</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%803-%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8/</link>
      <pubDate>Sat, 21 Aug 2021 10:15:56 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%803-%E5%AE%8F%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8/</guid>
      <description>&lt;h1 id=&#34;操作系统基础3-宏内核与微内核&#34;&gt;操作系统基础3-宏内核与微内核&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-11 22:04·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;转载自重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;操作系统的内核&#34;&gt;操作系统的内核&lt;/h1&gt;&#xA;&lt;p&gt;内核 是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p3-tt.byteimg.com/origin/pgc-image/7f4376eeaa9449a78100f6eba2d2b1f7?from=pc&#34; alt=&#34;操作系统基础3-宏内核与微内核&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以看到内核的主要功能有：时钟管理、中断管理、原语(设备驱动、CPU切换等)。还有对系统资源的管理功能：进程管理、存储器管理、设备管理等功能。有些操作系统不把这部分功能归为&amp;quot;内核&amp;quot;功能，不同的操作系统对内核功能的划分可能不一样。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础2-发展及分类</title>
      <link>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%802-%E5%8F%91%E5%B1%95%E5%8F%8A%E5%88%86%E7%B1%BB/</link>
      <pubDate>Sat, 21 Aug 2021 09:36:47 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%802-%E5%8F%91%E5%B1%95%E5%8F%8A%E5%88%86%E7%B1%BB/</guid>
      <description>&lt;h1 id=&#34;操作系统基础2-发展及分类&#34;&gt;操作系统基础2-发展及分类&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-10 17:50·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/a04b0ec9d8794bfdb17e9b6b5b4bbd5b?from=pc&#34; alt=&#34;操作系统基础2-发展及分类&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/2b31ee5da6274d3e9d4071cc17186820?from=pc&#34; alt=&#34;操作系统基础2-发展及分类&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/985edc2ffceb4328b546188caef3b8db?from=pc&#34; alt=&#34;操作系统基础2-发展及分类&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;穿孔卡片&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p6-tt.byteimg.com/origin/pgc-image/c57059a680744dcb9c33f7ffe46bfa48?from=pc&#34; alt=&#34;操作系统基础2-发展及分类&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;图形操作系统鼻祖-Alto&lt;/p&gt;&#xA;&lt;p&gt;按照操作系统的使用环境及处理方式的不同，一般可以把操作系统分为3个基本类型：&lt;/p&gt;&#xA;&lt;h1 id=&#34;批处理操作系统batch-processing-operating-system&#34;&gt;批处理操作系统(Batch Processing Operating System)：&lt;/h1&gt;&#xA;&lt;p&gt;将用户作业按照一定的顺序排列，统一交给计算机系统,由计算机自动地、顺序地完成作业的系统。批处理采用尽量避免人机交互的方式来提高CPU的运行效率.常用的系统有&lt;strong&gt;IBM&lt;/strong&gt;的*&lt;strong&gt;OS/360&lt;/strong&gt;、*&lt;strong&gt;MVX&lt;/strong&gt;等。&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统基础1-功能目标及特征</title>
      <link>http://shanks.link/blog/2021/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%801-%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87%E5%8F%8A%E7%89%B9%E5%BE%81/</link>
      <pubDate>Fri, 20 Aug 2021 17:15:15 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%801-%E5%8A%9F%E8%83%BD%E7%9B%AE%E6%A0%87%E5%8F%8A%E7%89%B9%E5%BE%81/</guid>
      <description>&lt;h1 id=&#34;操作系统基础1-功能目标及特征&#34;&gt;操作系统基础1-功能目标及特征&lt;/h1&gt;&#xA;&lt;p&gt;2020-10-09 15:03·&lt;a href=&#34;https://www.toutiao.com/c/user/token/MS4wLjABAAAAQN9l7B0O7YxEym7_bMZQaTheh3CQz_W6SC-j3N36vPo/?source=tuwen_detail&#34;&gt;重学IT的老猫&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;操作系统(Operating System，简称OS)是管理计算机硬件与软件资源的计算机程序。&lt;/p&gt;&#xA;&lt;p&gt;操作系统是配置在计算机硬件上的&lt;strong&gt;第一层软件&lt;/strong&gt;，是对硬件系统的&lt;strong&gt;首次扩充&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>动图图解！既然IP层会分片，为什么TCP层也还要分段？</title>
      <link>http://shanks.link/blog/2021/08/20/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%E6%97%A2%E7%84%B6ip%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5/</link>
      <pubDate>Fri, 20 Aug 2021 16:42:21 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/20/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%E6%97%A2%E7%84%B6ip%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5/</guid>
      <description>&lt;h1 id=&#34;动图图解既然ip层会分片为什么tcp层也还要分段&#34;&gt;动图图解！既然IP层会分片，为什么TCP层也还要分段？&lt;/h1&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/4a52b9606d0cb1e552cf1eb6e87a2f5a.png&#34; alt=&#34;动图图解！既然IP层会分片，为什么TCP层也还要分段？&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;什么是tcp分段和ip分片&#34;&gt;什么是TCP分段和IP分片&lt;/h1&gt;&#xA;&lt;p&gt;我们知道网络就像一根管子，而管子吧，就会有粗细。&lt;/p&gt;&#xA;&lt;p&gt;一个数据包想从管子的一端到另一端，得过这个管子。&lt;em&gt;（废话）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;但数据包的量&lt;strong&gt;有大有小&lt;/strong&gt;，想过管子，数据包不能大于这根管子的粗细。&lt;/p&gt;</description>
    </item>
    <item>
      <title>linux环境内存分配原理</title>
      <link>http://shanks.link/blog/2021/08/18/linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 18 Aug 2021 18:28:18 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/18/linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;linux环境内存分配原理-mallocinfo&#34;&gt;linux环境内存分配原理 mallocinfo&lt;/h1&gt;&#xA;&lt;p&gt;Linux的虚拟内存管理有几个关键概念：&lt;/p&gt;&#xA;&lt;p&gt;Linux 虚拟地址空间如何分布？malloc和free是如何分配和释放内存？如何查看堆内内存的碎片情况？既然堆内内存brk和sbrk不能直接释放，为什么不全部使用 mmap 来分配，munmap直接释放呢 ？&lt;/p&gt;</description>
    </item>
    <item>
      <title>redis基础数据结构-dict简介</title>
      <link>http://shanks.link/blog/2021/08/09/redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dict%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 09 Aug 2021 15:57:56 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/09/redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-dict%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; dictEntry {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;void&lt;/span&gt; *key;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;void&lt;/span&gt; *val;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; dictEntry *next;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} dictEntry;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* This is our hash table structure. Every dictionary has two of this as we&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt; * implement incremental rehashing, for the old to the new table. */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; dictht {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictEntry **table;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;long&lt;/span&gt; size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;long&lt;/span&gt; sizemask;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;long&lt;/span&gt; used;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} dictht;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; dict {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictType *type;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;void&lt;/span&gt; *privdata;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictht ht[2];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; rehashidx; &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* rehashing not in progress if rehashidx == -1 */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; iterators; &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* number of iterators currently running */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} dict;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; dictIterator {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dict *d;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; table;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; index;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictEntry *entry, *nextEntry;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} dictIterator;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2个ht,用于循环渐进式的rehash，避免ht过大的情况下一次性rehash而卡住程序&lt;/li&gt;&#xA;&lt;li&gt;底层实现为哈希桶&lt;/li&gt;&#xA;&lt;li&gt;fingerprint：指纹值方法用于粗略判断两个时间戳之间ht是否有被修改&lt;/li&gt;&#xA;&lt;li&gt;rehash的条件考虑到了存档RDB时的linux操作系统的写时复制策略&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;主要接口实现&#34;&gt;主要接口实现&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;插入节点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Add an element to the target hash table */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;dictAdd&lt;/span&gt;(dict *d, &lt;span style=&#34;color:#00f&#34;&gt;void&lt;/span&gt; *key, &lt;span style=&#34;color:#00f&#34;&gt;void&lt;/span&gt; *val)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; index;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictEntry *entry;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dictht *ht;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* 执行一次rehash */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#c34e00&#34;&gt;dictIsRehashing&lt;/span&gt;(d)) &lt;span style=&#34;color:#c34e00&#34;&gt;_dictRehashStep&lt;/span&gt;(d);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Get the index of the new element, or -1 if&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;     * the element already exists. */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; ((index = &lt;span style=&#34;color:#c34e00&#34;&gt;_dictKeyIndex&lt;/span&gt;(d, key)) == -1)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; DICT_ERR;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Allocates the memory and stores key&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;&#x9; * 正在rehash则存入ht[0]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;    ht = dictIsRehashing(d) ? &amp;amp;d-&amp;gt;ht[1] : &amp;amp;d-&amp;gt;ht[0];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;    entry = _dictAlloc(sizeof(*entry));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;    entry-&amp;gt;next = ht-&amp;gt;table[index];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;    ht-&amp;gt;table[index] = entry;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;    ht-&amp;gt;used++;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;    /* Set the hash entry fields. */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#c34e00&#34;&gt;dictSetHashKey&lt;/span&gt;(d, entry, key);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#c34e00&#34;&gt;dictSetHashVal&lt;/span&gt;(d, entry, val);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; DICT_OK;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;rehash&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;dictRehash&lt;/span&gt;(dict *d, &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; n) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; (!&lt;span style=&#34;color:#c34e00&#34;&gt;dictIsRehashing&lt;/span&gt;(d)) &lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;while&lt;/span&gt;(n--) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dictEntry *de, *nextde;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Check if we already rehashed the whole table... */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; (d-&amp;gt;ht[0].used == 0) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#c34e00&#34;&gt;_dictFree&lt;/span&gt;(d-&amp;gt;ht[0].table);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d-&amp;gt;ht[0] = d-&amp;gt;ht[1];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#c34e00&#34;&gt;_dictReset&lt;/span&gt;(&amp;amp;d-&amp;gt;ht[1]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d-&amp;gt;rehashidx = -1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Note that rehashidx can&amp;#39;t overflow as we are sure there are more&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;         * elements because ht[0].used != 0 &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;         * 因为上面used的判断，这里可以确定不会溢出 */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;while&lt;/span&gt;(d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx] == NULL) d-&amp;gt;rehashidx++;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        de = d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Move all the keys in this bucket from the old to the new hash HT */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;while&lt;/span&gt;(de) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#00f&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt; h;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            nextde = de-&amp;gt;next;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;/* Get the index in the new hash table */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            h = &lt;span style=&#34;color:#c34e00&#34;&gt;dictHashKey&lt;/span&gt;(d, de-&amp;gt;key) &amp;amp; d-&amp;gt;ht[1].sizemask;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            de-&amp;gt;next = d-&amp;gt;ht[1].table[h];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d-&amp;gt;ht[1].table[h] = de;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d-&amp;gt;ht[0].used--;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            d-&amp;gt;ht[1].used++;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            de = nextde;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d-&amp;gt;ht[0].table[d-&amp;gt;rehashidx] = NULL;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d-&amp;gt;rehashidx++;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>彻底弄懂TCP协议：从三次握手说起</title>
      <link>http://shanks.link/blog/2021/07/30/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82tcp%E5%8D%8F%E8%AE%AE%E4%BB%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%B4%E8%B5%B7/</link>
      <pubDate>Fri, 30 Jul 2021 17:36:14 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/30/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82tcp%E5%8D%8F%E8%AE%AE%E4%BB%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%B4%E8%B5%B7/</guid>
      <description>&lt;p&gt;作者：morganhuang，腾讯 IEG 后台开发工程师&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;说到 TCP 协议，相信大家都比较熟悉了，对于 TCP 协议总能说个一二三来，但是 TCP 协议又是一个非常复杂的协议，其中有不少细节点让人头疼点。本文就是来说说这些头疼点的，浅谈一些 TCP 的疑难杂症。那么从哪说起呢？当然是从三次握手和四次挥手说起啦，可能大家都知道 TCP 是三次交互完成连接的建立，四次交互来断开一个连接，那为什么是三次握手和四次挥手呢？反过来不行吗？&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库面试简答、30道高频面试题</title>
      <link>http://shanks.link/blog/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%9430%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Tue, 27 Jul 2021 16:16:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%9430%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/ZhuChangwu/&#34;&gt;&lt;img src=&#34;https://www.cnblogs.com/skins/custom/images/logo.gif&#34; alt=&#34;返回主页&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;数据库面试简答30道高频面试题&#34;&gt;&lt;a href=&#34;shankusu.me/%E8%81%8C%E5%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%9430%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/#more&#34;&gt;数据库面试简答、30道高频面试题&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;一mysql问答&#34;&gt;一、MySQL问答&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1数据库sql语句查询跨表查询有哪几种方式&#34;&gt;1、数据库sql语句查询，跨表查询有哪几种方式&lt;/h4&gt;&#xA;&lt;p&gt;内连接(inner可以不写)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;select&lt;/span&gt; e.name e.age p.product_name p.saled&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;from&lt;/span&gt; employee e，product p &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;where&lt;/span&gt; e.id = p.id&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;select&lt;/span&gt; e.name e.age p.product_name p.saled&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;from&lt;/span&gt; employee &lt;span style=&#34;color:#00f&#34;&gt;inner&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;join&lt;/span&gt; e，product p &lt;span style=&#34;color:#00f&#34;&gt;on&lt;/span&gt; e.id = p.id&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就是内连接，它要求数据必须On条件必须百分百匹配才会符合条件并返回。当不满足时，他会返回空。&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务架构中如何优雅地重试？</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/</link>
      <pubDate>Tue, 27 Jul 2021 17:38:46 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%87%8D%E8%AF%95/</guid>
      <description>&lt;h1 id=&#34;字节跳动--微服务架构中如何优雅地重试&#34;&gt;字节跳动 | 微服务架构中如何优雅地重试？&lt;/h1&gt;&#xA;&lt;h1 id=&#34;背景&#34;&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在微服务架构中，一个大系统被拆分成多个小服务，小服务之间大量 RPC 调用，经常可能因为网络抖动等原因导致 RPC 调用失败，这时候使用重试机制可以提高请求的最终成功率，减少故障影响，让系统运行更稳定。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动分布式表格存储系统的演进</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E8%BF%9B/</link>
      <pubDate>Tue, 27 Jul 2021 17:08:00 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E8%BF%9B/</guid>
      <description>&lt;h1 id=&#34;跳动分布式表格存储系统的演进&#34;&gt;跳动分布式表格存储系统的演进&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动自研线上引流回放系统的架构演进</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E7%BA%BF%E4%B8%8A%E5%BC%95%E6%B5%81%E5%9B%9E%E6%94%BE%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</link>
      <pubDate>Tue, 27 Jul 2021 16:56:51 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E7%BA%BF%E4%B8%8A%E5%BC%95%E6%B5%81%E5%9B%9E%E6%94%BE%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</guid>
      <description>&lt;h1 id=&#34;字节跳动自研线上引流回放系统的架构演进&#34;&gt;字节跳动自研线上引流回放系统的架构演进&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动表格存储中的事务</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 27 Jul 2021 16:54:59 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h1 id=&#34;表格存储中的事务&#34;&gt;表格存储中的事务&lt;/h1&gt;&#xA;&lt;h1 id=&#34;1-背景&#34;&gt;1. 背景&lt;/h1&gt;&#xA;&lt;p&gt;分布式表格存储系统在业界拥有广泛的应用场景。Google 先后发布了 Bigtable 和 Spanner 两代分布式表格存储系统，承接了其公司内部和外部云服务中的所有表格存储需求，其中 Bigtable 的开源实现 HBase 在国内外公司中都得到了广泛的使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动自研强一致在线 KV &amp;表格存储实践 - 下篇</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E5%BC%BA%E4%B8%80%E8%87%B4%E5%9C%A8%E7%BA%BF-kv-%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5-%E4%B8%8B%E7%AF%87/</link>
      <pubDate>Tue, 27 Jul 2021 16:45:17 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E5%BC%BA%E4%B8%80%E8%87%B4%E5%9C%A8%E7%BA%BF-kv-%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5-%E4%B8%8B%E7%AF%87/</guid>
      <description>&lt;h1 id=&#34;字节跳动自研强一致在线-kv-表格存储实践---下篇&#34;&gt;字节跳动自研强一致在线 KV &amp;amp;表格存储实践 - 下篇&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动自研强一致在线 KV &amp;表格存储实践 - 上篇</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E5%BC%BA%E4%B8%80%E8%87%B4%E5%9C%A8%E7%BA%BF-kv-%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5-%E4%B8%8A%E7%AF%87/</link>
      <pubDate>Tue, 27 Jul 2021 16:43:26 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E5%BC%BA%E4%B8%80%E8%87%B4%E5%9C%A8%E7%BA%BF-kv-%E8%A1%A8%E6%A0%BC%E5%AD%98%E5%82%A8%E5%AE%9E%E8%B7%B5-%E4%B8%8A%E7%AF%87/</guid>
      <description>&lt;h1 id=&#34;字节跳动自研强一致在线-kv-表格存储实践---上篇&#34;&gt;字节跳动自研强一致在线 KV &amp;amp;表格存储实践 - 上篇&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动自研万亿级图数据库 &amp; 图计算实践</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E4%B8%87%E4%BA%BF%E7%BA%A7%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 27 Jul 2021 16:39:57 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E4%B8%87%E4%BA%BF%E7%BA%A7%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h1 id=&#34;跳动自研万亿级图数据库--图计算实践&#34;&gt;跳动自研万亿级图数据库 &amp;amp; 图计算实践&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动混沌工程实践总结</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 27 Jul 2021 15:34:27 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h2 id=&#34;字节跳动混沌工程实践总结&#34;&gt;字节跳动混沌工程实践总结&lt;/h2&gt;&#xA;&lt;p&gt;原创 基础架构团队 &lt;a href=&#34;javascript:void(0);&#34;&gt;字节跳动技术团队&lt;/a&gt; &lt;em&gt;2020-04-27&lt;/em&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动 EB 级 HDFS 实践</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-eb-%E7%BA%A7-hdfs-%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 27 Jul 2021 15:23:52 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-eb-%E7%BA%A7-hdfs-%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;字节跳动-eb-级-hdfs-实践&#34;&gt;字节跳动 EB 级 HDFS 实践&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>亿级系统的Redis缓存如何设计???</title>
      <link>http://shanks.link/blog/2021/07/05/%E4%BA%BF%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%9A%84redis%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 05 Jul 2021 20:24:32 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/07/05/%E4%BA%BF%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%9A%84redis%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;亿级系统的redis缓存如何设计&#34;&gt;亿级系统的Redis缓存如何设计？？？&lt;/h2&gt;&#xA;&lt;p&gt;以下文章来源于微观技术 ，作者TomGE&lt;/p&gt;&#xA;&lt;p&gt;缓存设计可谓老生常谈了，早些时候都是采用&lt;code&gt;memcache&lt;/code&gt;，现在大家更多倾向使用&lt;code&gt;redis&lt;/code&gt;，除了知晓常用的数据存储类型，结合业务场景有针对性选择，好像其他也没有什么大的难点。&lt;/p&gt;</description>
    </item>
    <item>
      <title>分布式锁实现原理与最佳实践</title>
      <link>http://shanks.link/blog/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 15 Jun 2021 19:57:11 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;分布式锁实现原理与最佳实践&#34;&gt;分布式锁实现原理与最佳实践&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;分布式锁应用场景&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;很多应用场景是需要系统保证幂等性的（如api服务或消息消费者），并发情况下或消息重复很容易造成系统重入，那么分布式锁是保障幂等的一个重要手段。&lt;/p&gt;</description>
    </item>
    <item>
      <title>漫画 | 一台Linux服务器最多能支撑多少个TCP连接？</title>
      <link>http://shanks.link/blog/2021/05/06/%E6%BC%AB%E7%94%BB-%E4%B8%80%E5%8F%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%9A%E8%83%BD%E6%94%AF%E6%92%91%E5%A4%9A%E5%B0%91%E4%B8%AAtcp%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Thu, 06 May 2021 18:03:28 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/05/06/%E6%BC%AB%E7%94%BB-%E4%B8%80%E5%8F%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%9A%E8%83%BD%E6%94%AF%E6%92%91%E5%A4%9A%E5%B0%91%E4%B8%AAtcp%E8%BF%9E%E6%8E%A5/</guid>
      <description>&lt;h2 id=&#34;漫画--一台linux服务器最多能支撑多少个tcp连接&#34;&gt;漫画 | 一台Linux服务器最多能支撑多少个TCP连接？&lt;/h2&gt;&#xA;&lt;p&gt;编者荐语：&lt;/p&gt;&#xA;&lt;p&gt;这篇文章作者用通俗易懂的语言，图文并茂的为大家深入讲解了一台Linux服务器究竟能支撑多少个TCP，相信绝大多数读者对这个概念都或多或少有一定了解，但这篇文章会深入细节的每一个本质，非常值得大家一读。&lt;/p&gt;</description>
    </item>
    <item>
      <title>os精讲</title>
      <link>http://shanks.link/blog/2020/08/20/os%E7%B2%BE%E8%AE%B2/</link>
      <pubDate>Thu, 20 Aug 2020 09:02:11 +0000</pubDate>
      <guid>http://shanks.link/blog/2020/08/20/os%E7%B2%BE%E8%AE%B2/</guid>
      <description>&lt;h3 id=&#34;本文目标&#34;&gt;本文目标&lt;/h3&gt;&#xA;&lt;p&gt;    收录OS方面主要知识点，方便面试前复习&lt;/p&gt;&#xA;&lt;h3 id=&#34;功能&#34;&gt;功能&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理机管理&lt;/li&gt;&#xA;&lt;li&gt;存储器管理&lt;/li&gt;&#xA;&lt;li&gt;文件系统&lt;/li&gt;&#xA;&lt;li&gt;网络系统&lt;/li&gt;&#xA;&lt;li&gt;驱动系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;特征&#34;&gt;特征&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;并发 宏观上多个进程同时运行（微观上交替运行）， （并行：微观上一起运行）&lt;/li&gt;&#xA;&lt;li&gt;共享 资源共享（系统中的资源可供多个并发的进程共享，eg:MEM）&lt;/li&gt;&#xA;&lt;li&gt;虚拟 空分复用（存储器管理），时分复用（处理机管理）&lt;/li&gt;&#xA;&lt;li&gt;异步 时分复用的特征下，各进程交替运行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;指令分类&#34;&gt;指令分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一般指令 普通进程都能执行的指令&lt;/li&gt;&#xA;&lt;li&gt;特权指令 操作系统才能执行的特权指令，包括不限于输入输出，停机等(普通进程通过系统调用的方式请求操作系统代运行)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;宏内核和微内核&#34;&gt;宏内核和微内核&lt;/h3&gt;&#xA;&lt;h3 id=&#34;cpu&#34;&gt;CPU&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://p1-tt.byteimg.com/origin/pgc-image/a000e6c65f864a4fad812aab9ec67870?from=pc&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
