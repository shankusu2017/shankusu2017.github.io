<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Golang入门指南</title>
    <link>http://shanks.link/categories/go/</link>
    <description>Recent content in Go on Golang入门指南</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 24 Jan 2024 14:07:06 +0800</lastBuildDate>
    <atom:link href="http://shanks.link/categories/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 内存分析和动态追踪 pprof</title>
      <link>http://shanks.link/blog/2024/01/24/golang-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA-pprof/</link>
      <pubDate>Wed, 24 Jan 2024 14:07:06 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/01/24/golang-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA-pprof/</guid>
      <description>&lt;p&gt;当你的golang程序在运行过程中消耗了超出你理解的内存时，你就需要搞明白，到底是 程序中哪些代码导致了这些内存消耗。此时golang编译好的程序对你来说是个黑盒，该 如何搞清其中的内存使用呢？幸好golang已经内置了一些机制来帮助我们进行分析和追 踪。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang使用gopacket包进行数据包捕获，注入和分析</title>
      <link>http://shanks.link/blog/2023/12/13/golang%E4%BD%BF%E7%94%A8gopacket%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8D%95%E8%8E%B7%E6%B3%A8%E5%85%A5%E5%92%8C%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 13 Dec 2023 09:18:12 +0800</pubDate>
      <guid>http://shanks.link/blog/2023/12/13/golang%E4%BD%BF%E7%94%A8gopacket%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8C%85%E6%8D%95%E8%8E%B7%E6%B3%A8%E5%85%A5%E5%92%8C%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;使用 golang 实现网络抓包是非常容易的，可以使用谷歌的包 github.com/google/gopacket。由于 gopacket 构建在 libp­cap 之上，我强烈建议您了解该库的工作原理。您可以在 C 中学习如何使用 libp­cap 进行更深入的了解。&#xA;1.libp­cap&lt;/p&gt;</description>
    </item>
    <item>
      <title>go flags包简介 go flags package introduction</title>
      <link>http://shanks.link/blog/2023/12/08/go-flags%E5%8C%85%E7%AE%80%E4%BB%8B-go-flags-package-introduction/</link>
      <pubDate>Fri, 08 Dec 2023 16:05:12 +0800</pubDate>
      <guid>http://shanks.link/blog/2023/12/08/go-flags%E5%8C%85%E7%AE%80%E4%BB%8B-go-flags-package-introduction/</guid>
      <description>&lt;h3 id=&#34;flag包是go语言标准库提供用来解析命令行参数的包使得开发命令行工具更为简单&#34;&gt;flag包是Go语言标准库提供用来解析命令行参数的包，使得开发命令行工具更为简单&lt;/h3&gt;&#xA;&lt;h3 id=&#34;常用方法&#34;&gt;常用方法&lt;/h3&gt;&#xA;&lt;p&gt;1.flag.Usage&#xA;输出使用方法，如linux下ls -h的帮助输出&lt;/p&gt;&#xA;&lt;p&gt;2.flag.Type(参数名, 默认值, 使用提示)&#xA;Type为类型 如String, Int, Uint 调用相应的flag.Sring flag.Int flag.Uint方法&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 常用命令 Go Common commands</title>
      <link>http://shanks.link/blog/2023/12/07/go-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-go-common-commands/</link>
      <pubDate>Thu, 07 Dec 2023 10:34:12 +0800</pubDate>
      <guid>http://shanks.link/blog/2023/12/07/go-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-go-common-commands/</guid>
      <description>&lt;h3 id=&#34;一键安装-go-one-key-install-go&#34;&gt;一键安装 go one key install go&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;apt-get install go&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;设置代理-set-proxy&#34;&gt;设置代理 set proxy&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go env -w GOPROXY=https://goproxy.cn,direct&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;构建-gomod-create-gomod&#34;&gt;构建 go.mod create go.mod&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go mod init xxx.com/xxx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;设置模块代理-关于go-mod安装第三方包提示-module-declares-its-path-as-xxx-but-was-required-as-yyy-解决办法&#34;&gt;设置模块代理 关于go mod安装第三方包提示： module declares its path as: xxx but was required as: yyy 解决办法&lt;/h3&gt;&#xA;&lt;p&gt;在 go.mod 中手动添加&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;replace yyy v0.16.0 =&amp;gt; xxx v0.16.0&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;v0.16.0 是版本号，是否指定看具体情况&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang 获取本机网卡IP、网关，可以通过IP地址来进行路由选择（多网卡）</title>
      <link>http://shanks.link/blog/2022/12/07/golang-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%BD%91%E5%8D%A1ip%E7%BD%91%E5%85%B3%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87ip%E5%9C%B0%E5%9D%80%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BD%91%E5%8D%A1/</link>
      <pubDate>Wed, 07 Dec 2022 13:23:06 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/12/07/golang-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%BD%91%E5%8D%A1ip%E7%BD%91%E5%85%B3%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87ip%E5%9C%B0%E5%9D%80%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BD%91%E5%8D%A1/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;package&lt;/span&gt; main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;syscall&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;net&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;unsafe&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;sort&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;type&lt;/span&gt; rtInfo &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Dst net.IPNet&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Gateway, PrefSrc net.IP&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;OutputIface &lt;span style=&#34;color:#00f&#34;&gt;uint32&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;Priority &lt;span style=&#34;color:#00f&#34;&gt;uint32&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;type&lt;/span&gt; routeSlice []*rtInfo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;type&lt;/span&gt; router &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;ifaces []net.Interface&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;addrs []net.IP&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;v4 routeSlice&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;getRouteInfo&lt;/span&gt;() (*router, &lt;span style=&#34;color:#00f&#34;&gt;error&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;rtr := &amp;amp;router{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;tab, err := syscall.&lt;span style=&#34;color:#c34e00&#34;&gt;NetlinkRIB&lt;/span&gt;(syscall.RTM_GETROUTE, syscall.AF_INET)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt;, err&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;msgs, err := syscall.&lt;span style=&#34;color:#c34e00&#34;&gt;ParseNetlinkMessage&lt;/span&gt;(tab)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt;, err&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; _, m := &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; msgs {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;switch&lt;/span&gt; m.Header.Type {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.NLMSG_DONE:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;break&lt;/span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.RTM_NEWROUTE:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;rtmsg := (*syscall.RtMsg)(unsafe.&lt;span style=&#34;color:#c34e00&#34;&gt;Pointer&lt;/span&gt;(&amp;amp;m.Data[0]))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;attrs, err := syscall.&lt;span style=&#34;color:#c34e00&#34;&gt;ParseNetlinkRouteAttr&lt;/span&gt;(&amp;amp;m)&#x9;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt;, err&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;routeInfo := rtInfo{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;rtr.v4 = append(rtr.v4, &amp;amp;routeInfo)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; _, attr:= &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; attrs {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;switch&lt;/span&gt; attr.Attr.Type {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.RTA_DST:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;routeInfo.Dst.IP = net.&lt;span style=&#34;color:#c34e00&#34;&gt;IP&lt;/span&gt;(attr.Value)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;routeInfo.Dst.Mask = net.&lt;span style=&#34;color:#c34e00&#34;&gt;CIDRMask&lt;/span&gt;(int(rtmsg.Dst_len), len(attr.Value)*8)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.RTA_GATEWAY:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;routeInfo.Gateway = net.&lt;span style=&#34;color:#c34e00&#34;&gt;IPv4&lt;/span&gt;(attr.Value[0], attr.Value[1], attr.Value[2], attr.Value[3])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.RTA_OIF:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;routeInfo.OutputIface = *(*&lt;span style=&#34;color:#00f&#34;&gt;uint32&lt;/span&gt;)(unsafe.&lt;span style=&#34;color:#c34e00&#34;&gt;Pointer&lt;/span&gt;(&amp;amp;attr.Value[0]))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.RTA_PRIORITY:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;routeInfo.Priority = *(*&lt;span style=&#34;color:#00f&#34;&gt;uint32&lt;/span&gt;)(unsafe.&lt;span style=&#34;color:#c34e00&#34;&gt;Pointer&lt;/span&gt;(&amp;amp;attr.Value[0]))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;case&lt;/span&gt; syscall.RTA_PREFSRC:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;routeInfo.PrefSrc = net.&lt;span style=&#34;color:#c34e00&#34;&gt;IPv4&lt;/span&gt;(attr.Value[0], attr.Value[1], attr.Value[2], attr.Value[3])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;sort.&lt;span style=&#34;color:#c34e00&#34;&gt;Slice&lt;/span&gt;(rtr.v4, &lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt;(i, j &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#00f&#34;&gt;bool&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; rtr.v4[i].Priority &amp;lt; rtr.v4[j].Priority&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;ifaces, err := net.&lt;span style=&#34;color:#c34e00&#34;&gt;Interfaces&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt;, err&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; i, iface := &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; ifaces {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; i != iface.Index - 1 {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;break&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; iface.Flags &amp;amp; net.FlagUp == 0{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;continue&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;rtr.ifaces = append(rtr.ifaces, iface)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;ifaceAddrs, err := iface.&lt;span style=&#34;color:#c34e00&#34;&gt;Addrs&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt;, err&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;var&lt;/span&gt; addrs net.IP&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; _, addr := &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; ifaceAddrs {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; inet, ok := addr.(*net.IPNet); ok {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; v4 := inet.IP.&lt;span style=&#34;color:#c34e00&#34;&gt;To4&lt;/span&gt;(); v4 != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; addrs == &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addrs = v4&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;rtr.addrs = append(rtr.addrs, addrs)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; rtr, &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; (r *router)&lt;span style=&#34;color:#c34e00&#34;&gt;getRoute&lt;/span&gt;(dst net.IP) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; _, rt := &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; r.v4 { &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; rt.Dst.IP != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; !rt.Dst.&lt;span style=&#34;color:#c34e00&#34;&gt;Contains&lt;/span&gt;(dst) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;continue&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;%-15v : &amp;#34;&lt;/span&gt;, dst.&lt;span style=&#34;color:#c34e00&#34;&gt;String&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; rt.PrefSrc == &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(r.ifaces[rt.OutputIface - 1].Name, rt.Gateway.&lt;span style=&#34;color:#c34e00&#34;&gt;String&lt;/span&gt;(), r.addrs[rt.OutputIface - 1].&lt;span style=&#34;color:#c34e00&#34;&gt;String&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;} &lt;span style=&#34;color:#00f&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(r.ifaces[rt.OutputIface - 1].Name, rt.Gateway.&lt;span style=&#34;color:#c34e00&#34;&gt;String&lt;/span&gt;(), rt.PrefSrc.&lt;span style=&#34;color:#c34e00&#34;&gt;String&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;newRoute, err := &lt;span style=&#34;color:#c34e00&#34;&gt;getRouteInfo&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;return&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;**************************************&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;%-15v %-15v %-15v\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;interfaceName&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;gateway&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;ip&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; _, rt := &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; newRoute.v4 { &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; rt.Gateway != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;%-15v %-15v %-15v\n&amp;#34;&lt;/span&gt;, newRoute.ifaces[rt.OutputIface - 1].Name, rt.Gateway.&lt;span style=&#34;color:#c34e00&#34;&gt;String&lt;/span&gt;(), newRoute.addrs[rt.OutputIface - 1])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;**************************************&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;newRoute.&lt;span style=&#34;color:#c34e00&#34;&gt;getRoute&lt;/span&gt;(net.&lt;span style=&#34;color:#c34e00&#34;&gt;ParseIP&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;192.168.2.100&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;newRoute.&lt;span style=&#34;color:#c34e00&#34;&gt;getRoute&lt;/span&gt;(net.&lt;span style=&#34;color:#c34e00&#34;&gt;ParseIP&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;10.10.100.100&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;newRoute.&lt;span style=&#34;color:#c34e00&#34;&gt;getRoute&lt;/span&gt;(net.&lt;span style=&#34;color:#c34e00&#34;&gt;ParseIP&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;172.1.2.100&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/go/b5aa2e9ef836408cb18b90ee54a3cd52.png&#34; alt=&#34;运行输出&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installing Go from source and cross compile</title>
      <link>http://shanks.link/blog/2022/11/08/installing-go-from-source-and-cross-compile/</link>
      <pubDate>Tue, 08 Nov 2022 13:53:12 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/11/08/installing-go-from-source-and-cross-compile/</guid>
      <description>&lt;p&gt;This topic describes how to build and run Go from source code. To install with an installer, see &lt;a href=&#34;https://go.dev/doc/install&#34;&gt;Download and install&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Go is an open source project, distributed under a &lt;a href=&#34;https://go.dev/LICENSE&#34;&gt;BSD-style license&lt;/a&gt;. This document explains how to check out the sources, build them on your own machine, and run them.&lt;/p&gt;&#xA;&lt;p&gt;Most users don&amp;rsquo;t need to do this, and will instead install from precompiled binary packages as described in &lt;a href=&#34;https://go.dev/doc/install&#34;&gt;Download and install&lt;/a&gt;, a much simpler process. If you want to help develop what goes into those precompiled packages, though, read on.&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang 中 channel 的详细使用、使用注意事项及死锁分析</title>
      <link>http://shanks.link/blog/2022/09/29/golang-%E4%B8%AD-channel-%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%8F%8A%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 29 Sep 2022 18:16:16 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/09/29/golang-%E4%B8%AD-channel-%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%8F%8A%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;golang-中-channel-的详细使用使用注意事项及死锁分析&#34;&gt;&lt;a href=&#34;https://www.cnblogs.com/jiujuan/p/16014608.html&#34;&gt;golang 中 channel 的详细使用、使用注意事项及死锁分析&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是-channel-管道&#34;&gt;什么是 channel 管道&lt;a href=&#34;https://www.cnblogs.com/jiujuan/p/16014608.html#3042963189&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;它是一个数据管道，可以往里面写数据，从里面读数据。&lt;/p&gt;&#xA;&lt;p&gt;channel 是 goroutine 之间数据通信桥梁，而且是线程安全的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Copy a slice in Go</title>
      <link>http://shanks.link/blog/2022/09/29/copy-a-slice-in-go/</link>
      <pubDate>Thu, 29 Sep 2022 18:12:12 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/09/29/copy-a-slice-in-go/</guid>
      <description>&lt;p&gt;To duplicate a slice in Go, getting a deep copy of its contents, you need to either use the built-in &lt;a href=&#34;https://pkg.go.dev/builtin#copy&#34;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; function, or create a new empty slice and add all the elements of the first slice to it using the &lt;a href=&#34;https://pkg.go.dev/builtin#append&#34;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; function. &lt;a href=&#34;https://gosamples.dev/capacity-and-length&#34;&gt;Because of how slices are built in Go&lt;/a&gt;, assigning one slice to another only makes a shallow copy, and you should not use it if you want to clone the slice in a deep way.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go更细粒度的读写锁设计</title>
      <link>http://shanks.link/blog/2022/09/20/go%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 20 Sep 2022 23:30:34 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/09/20/go%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;go更细粒度的读写锁设计&#34;&gt;Go更细粒度的读写锁设计&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzIwNTA4MDAwMQ==&amp;amp;mid=2247484613&amp;amp;idx=1&amp;amp;sn=d79c33be877e8124d050ed3669b26e24&amp;amp;chksm=9737106ba040997d4bdd3aa077186d89568b0019b4b83164dc59b9b2e8c4a408e4496aa93d1a&amp;amp;scene=21#wechat_redirect&#34;&gt;《Go精妙的互斥锁设计》&lt;/a&gt;一文中，我们详细地讲解了互斥锁的实现原理。互斥锁为了避免竞争条件，它只允许一个线程进入代码临界区，而由于锁竞争的存在，程序的执行效率会被降低。同时我们知道，只有多线程在共享资源中有写操作，才会引发竞态问题，只要资源没有发生变化，多线程读取相同的资源就是安全的。因此，我们引申出更细粒度的锁：读写锁。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;什么是读写锁&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;读写锁是一种多读单写锁，分读和写两种锁，多个线程可以同时加读锁，但是写锁和写锁、写锁与读锁之间是互斥的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E8%AF%BB%E5%86%99%E9%94%81/1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;读写锁对临界区的处理如上图所示。其中，t1时刻，由于线程1已加写锁，线程2被互斥等待写锁的释放；t2时刻，线程2已加读锁，线程3可以对其继续加读锁并进入临界区；t3时刻，线程3加了读锁，线程4被互斥等待读锁的释放。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之九：操作系统线程及线程调度</title>
      <link>http://shanks.link/blog/2022/09/20/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B9%9D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Tue, 20 Sep 2022 23:30:34 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/09/20/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B9%9D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h3 id=&#34;原创-爱写程序的阿波张-源码游记-2019-04-25&#34;&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/OvGlI5VvvRdMRuJegNrOMg&#34;&gt;源码游记&lt;/a&gt; 2019-04-25&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;本文是《go调度器源代码情景分析》系列 第一章 预备知识的第九小节。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;要深入理解goroutine的调度器，就需要对操作系统线程有个大致的了解，因为go的调度系统是建立在操作系统线程之上的，所以接下来我们对其做一个简单的介绍。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入了解map</title>
      <link>http://shanks.link/blog/2022/04/24/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3map/</link>
      <pubDate>Sun, 24 Apr 2022 22:19:30 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3map/</guid>
      <description>&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;&#xA;&lt;p&gt;map 通过 hasTable 实现了我们最常见的 key-value 存储，能快速的对数据集增删查改。同时 Go 里的 map 也有很多特殊的地方，比如它的无序性、并发不安全等。今天，就让我们对 map 进行深入研究，看看它是怎么设计的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang系列之channel全面解析</title>
      <link>http://shanks.link/blog/2022/04/24/golang%E7%B3%BB%E5%88%97%E4%B9%8Bchannel%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 24 Apr 2022 18:39:34 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/golang%E7%B3%BB%E5%88%97%E4%B9%8Bchannel%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/247758&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;&#xA;&lt;p&gt;channel 是 goroutine 与 goroutine 之间通信的重要桥梁，借助 channel，我们能很轻易的写出一个&lt;strong&gt;多协程&lt;/strong&gt;通信程序。今天，我们就来看看这个 channel 的常用用法以及底层原理。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一channel-的概念&#34;&gt;一、channel 的概念&lt;/h3&gt;&#xA;&lt;p&gt;channel 是一个通道，用于&lt;strong&gt;端到端&lt;/strong&gt;的数据传输，这有点像我们平常使用的消息队列，只不过 channel 的发送方和接受方是 &lt;strong&gt;goroutine&lt;/strong&gt; 对象，属于&lt;strong&gt;内存级别&lt;/strong&gt;的通信。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goroutinue理解</title>
      <link>http://shanks.link/blog/2022/04/24/goroutinue%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 24 Apr 2022 15:53:47 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/goroutinue%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000018150987&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Go语言最大的特色就是从语言层面支持并发（Goroutine），Goroutine是Go中最基本的执行单元。事实上每一个Go程序至少有一个Goroutine：主Goroutine。当程序启动时，它会自动创建。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go面试总结</title>
      <link>http://shanks.link/blog/2022/04/24/go%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 24 Apr 2022 15:08:40 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/04/24/go%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.modb.pro/db/247446&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;相比较于其他语言-go-有什么优势或者特点&#34;&gt;相比较于其他语言, Go 有什么优势或者特点？&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go 允许跨平台编译，编译出来的是二进制的可执行文件，直接部署在对应系统上即可运行。&lt;/li&gt;&#xA;&lt;li&gt;Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型， 即所谓的&lt;code&gt;通过通信来共享内存&lt;/code&gt;&#xA;；Go 在 runtime 运行时里实现了属于自己的调度机制：GPM，降低了内核态和用户态的切换成本。&lt;/li&gt;&#xA;&lt;li&gt;Go 的代码风格是强制性的统一，如果没有按照规定来，会编译不通过。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;golang-里的-gpm-模型&#34;&gt;Golang 里的 GPM 模型？&lt;/h1&gt;&#xA;&lt;p&gt;GPM 模型是 golang 自己的一个调度模型，它抽象出了下面三个结构：&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang 中slice 、map、chan作为函数参数分析</title>
      <link>http://shanks.link/blog/2021/08/20/golang-%E4%B8%ADslice-mapchan%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 20 Aug 2021 11:07:45 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/20/golang-%E4%B8%ADslice-mapchan%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;golang-中slice-mapchan作为函数参数分析&#34;&gt;golang 中slice 、map、chan作为函数参数分析&lt;/h1&gt;&#xA;&lt;p&gt;写这篇文章之前考虑一个问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;go里面都是值传递，不存在引用传递？&lt;/strong&gt;&#xA;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1416563&#34;&gt;https://cloud.tencent.com/developer/article/1416563&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;先来总结一下slice、map、chan的特性：&#xA;&lt;strong&gt;slice：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang知识小结</title>
      <link>http://shanks.link/blog/2021/08/10/golang%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Tue, 10 Aug 2021 10:53:12 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/08/10/golang%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</guid>
      <description>&lt;h3 id=&#34;string&#34;&gt;string&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;string类型采用UTF-8编码，且不可修的，len返回byte数量而不是字符数量，eg(len(你好)==6&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;数组和slice&#34;&gt;数组和slice&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数组在函数调用的参数传递模式是独立复制一份数据给被调用函数&lt;/li&gt;&#xA;&lt;li&gt;slice以及map,chan对应的的函数传参知识参考这里&lt;a href=&#34;http://shankusu.me/go/golang%20%E4%B8%ADslice_map_chan%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/#more&#34;&gt;Golang函数参数传递&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;map&#34;&gt;map&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化： h := map[int]string{} 显示构造，或者 h = make(map[int]string),&lt;/li&gt;&#xA;&lt;li&gt;空值 h := map[int]string 将构造一个nil的map，可以调用range, len, 读，但不能写值&lt;/li&gt;&#xA;&lt;li&gt;map是指针数据结构，即当作函数参数传递时，函数内部修改了其值，会影响函数外部原始的map&lt;/li&gt;&#xA;&lt;li&gt;var = map[k],若对应的k不存在，则返回零值，故而要判断时候存在，需引入第二个参数eg: val, exist := map[k]&lt;/li&gt;&#xA;&lt;li&gt;不可对map中的元素取地址eg:&amp;amp;tbl[k]是非法的（map的大小可能随时调整故取地址无意义)。&lt;/li&gt;&#xA;&lt;li&gt;可以采用range风格对其轮询，顺序是随机的（设计如此）。如果需要按照一定的规则读取map，一个办法是先把key排好序，再用map[key]的的方法读写&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;struct&#34;&gt;struct&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;导出规则与模块一样&lt;/li&gt;&#xA;&lt;li&gt;一般而言一行定义一个成员&lt;/li&gt;&#xA;&lt;li&gt;不能递归定义自己，但可以在内部使用自己类型的指针&lt;/li&gt;&#xA;&lt;li&gt;其零值是每个成员的零值，如果内部有(map,chan)，还需要在struct{}构造后，显式的对其初始化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;type&lt;/span&gt;  sh &lt;span style=&#34;color:#00f&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;m &lt;span style=&#34;color:#00f&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;var&lt;/span&gt; st = sh{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;st.m = make(&lt;span style=&#34;color:#00f&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;function&#34;&gt;function&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;参数是传值模式，没有默认值，数量可以是可变模式&lt;/li&gt;&#xA;&lt;li&gt;可以递归调用自己&lt;/li&gt;&#xA;&lt;li&gt;函数名是第一类值，可以和nil比较，但不能作为map的key&lt;/li&gt;&#xA;&lt;li&gt;支持闭包(closures)，这点和lua中的函数一致，与之对应，C语言不支持闭包&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;&#xA;&lt;h3 id=&#34;变量类型&#34;&gt;变量类型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;七个小矮人（slice,map,func,channel,pointer, string, interface），自带魔法绳（指针）, 所以没必要将它定义成引用类型&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Go学习建议</title>
      <link>http://shanks.link/blog/2021/08/04/go%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Wed, 04 Aug 2021 20:10:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/08/04/go%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE/</guid>
      <description>&lt;h1 id=&#34;如果学习-go&#34;&gt;如果学习 Go&lt;/h1&gt;&#xA;&lt;p&gt;整理了目前市面上的各类图书，特别是开源的图书，阅读学习建议分享给你&lt;/p&gt;&#xA;&lt;h2 id=&#34;入门建议&#34;&gt;入门建议&lt;/h2&gt;&#xA;&lt;p&gt;Go 语言入门图书挺多的，根据我的了解和大家的反馈、讨论，比较推荐如下图书，选择一本认真看即可，没必要那么多。&lt;/p&gt;</description>
    </item>
    <item>
      <title>gdb 提示 coredump 文件 truncated 问题排查</title>
      <link>http://shanks.link/blog/2021/07/27/gdb-%E6%8F%90%E7%A4%BA-coredump-%E6%96%87%E4%BB%B6-truncated-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Tue, 27 Jul 2021 18:28:34 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/gdb-%E6%8F%90%E7%A4%BA-coredump-%E6%96%87%E4%BB%B6-truncated-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</guid>
      <description>&lt;h1 id=&#34;gdb-提示-coredump-文件-truncated-问题排查&#34;&gt;gdb 提示 coredump 文件 truncated 问题排查&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go的一次故障排除</title>
      <link>http://shanks.link/blog/2021/07/27/go%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</link>
      <pubDate>Tue, 27 Jul 2021 18:25:31 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/go%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/</guid>
      <description>&lt;h1 id=&#34;引发的线上事故&#34;&gt;“���”引发的线上事故&lt;/h1&gt;&#xA;&lt;p&gt;最近遇到了一起依赖升级 + 异常数据引发的线上事故，教训惨痛，本文对此进行回故和总结。&lt;/p&gt;&#xA;&lt;h1 id=&#34;背景&#34;&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h1&gt;&#xA;&lt;p&gt;起因是我们使用的服务框架版本比较老，GC 次数的 metrics 打点一直为 0，咨询了相关同学后，决定升级框架。升级的过程中，出现了 &lt;code&gt;useofinternalpackagexxxnotallowed&lt;/code&gt; 的报错，又咨询了一下相关同学后，尝试使用 &lt;code&gt;go mod&lt;/code&gt; 解决。&lt;/p&gt;</description>
    </item>
    <item>
      <title>字节跳动在 Go 网络库上的实践</title>
      <link>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 27 Jul 2021 17:11:01 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h1 id=&#34;字节跳动在-go-网络库上的实践&#34;&gt;字节跳动在 Go 网络库上的实践&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文选自“字节跳动基础架构实践”系列文章。&lt;/p&gt;&#xA;&lt;p&gt;“字节跳动基础架构实践”系列文章是由字节跳动基础架构部门各技术团队及专家倾力打造的技术干货内容，和大家分享团队在基础架构发展和演进过程中的实践经验与教训，与各位技术同学一起交流成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang 的channels 行为</title>
      <link>http://shanks.link/blog/2021/07/19/golang-%E7%9A%84channels-%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Mon, 19 Jul 2021 16:22:27 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/19/golang-%E7%9A%84channels-%E8%A1%8C%E4%B8%BA/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;当我第一次使用 Go 的 channels 工作的时候，我犯了一个错误，把 channels 考虑为一个数据结构。我把 channels 看作为 goroutines 之间提供自动同步访问的队列。这种结构上的理解导致我写了很多不好且结构复杂的并发代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>GO 开发者对 GO 初学者的建议</title>
      <link>http://shanks.link/blog/2021/07/19/go-%E5%BC%80%E5%8F%91%E8%80%85%E5%AF%B9-go-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 19 Jul 2021 16:02:51 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/19/go-%E5%BC%80%E5%8F%91%E8%80%85%E5%AF%B9-go-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;注：原文地址为 &lt;a href=&#34;http://www.gophercon.in/blog/2014/08/23/adviceforgonewbies/&#34;&gt;Advise from Go developers to Go programming newbies&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;以促进 India 的 go 编程作为 GopherConIndia 承诺的一部分。我们采访了 &lt;a href=&#34;http://list.ly/list/Pak-gopher-interviews&#34;&gt;40 位 Gophers&lt;/a&gt;（一个 Gopher 代表一个 GO 项目或是任何地方的 GO 程序员），得到了他们关于 GO 的意见。从 2014 年的八月到十一月，我们将每个星期发表两篇采访稿。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 为什么这么快 GPM模型简介</title>
      <link>http://shanks.link/blog/2021/07/08/go-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB-gpm%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 08 Jul 2021 11:28:22 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/07/08/go-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB-gpm%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;作者：joellwang，腾讯 CSIG 后台开发工程师&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;本文主要介绍了 Go 程序为了实现极高的并发性能，其内部调度器的实现架构（G-P-M 模型），以及为了最大限度利用计算资源，Go 调度器是如何处理线程阻塞的场景。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何避免Go变量被GC</title>
      <link>http://shanks.link/blog/2021/06/15/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dgo%E5%8F%98%E9%87%8F%E8%A2%ABgc/</link>
      <pubDate>Tue, 15 Jun 2021 17:15:06 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/06/15/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dgo%E5%8F%98%E9%87%8F%E8%A2%ABgc/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E9%81%BF%E5%85%8D%E5%8F%98%E9%87%8F%E8%A2%ABGC/1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French.&lt;/p&gt;&#xA;&lt;p&gt;本文基于 Go 1.13。&lt;/p&gt;&#xA;&lt;p&gt;在 Go 中，我们不需要自己管理内存分配和释放。然而，有些时候我们需要对程序进行更细粒度的控制。Go 运行时提供了很多种控制运行时状态及其与内存管理器之间相互影响的方式。本文中，我们来审查让变量不被 GC 回收的能力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go内存分配器的核心思想</title>
      <link>http://shanks.link/blog/2021/05/06/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</link>
      <pubDate>Thu, 06 May 2021 17:45:50 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/05/06/go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</guid>
      <description>&lt;h3 id=&#34;1内存分配器的核心思想&#34;&gt;1、内存分配器的核心思想&lt;/h3&gt;&#xA;&lt;p&gt;Go 的内存分配器核心思想是将内存使用多级管理，降低锁的粒度。每个线程都有自己的本地内存，使用时先从线程本地的内存池进行分配，当内存池不足时，才会从全局内存池中进行申请。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go工具之generate</title>
      <link>http://shanks.link/blog/2021/05/06/go%E5%B7%A5%E5%85%B7%E4%B9%8Bgenerate/</link>
      <pubDate>Thu, 06 May 2021 17:13:09 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/05/06/go%E5%B7%A5%E5%85%B7%E4%B9%8Bgenerate/</guid>
      <description>&lt;p&gt;Go语言提供了一系列强大的工具，灵活使用这些工具，能够让我们的项目开发更加容易，工具集包含如下。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;bug         start a bug report&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;build       compile packages and dependencies&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clean       remove object files and cached files&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;doc         show documentation &lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; package or symbol&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;env         print Go environment information&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fix         update packages to use new APIs&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fmt         gofmt (reformat) package sources&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;generate    generate Go files by processing source&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;get         add dependencies to current module and install them&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;install     compile and install packages and dependencies&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;list        list packages or modules&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mod         module maintenance&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;run         compile and run Go program&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;test        test packages&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;tool&lt;/span&gt;        run specified go &lt;span style=&#34;color:#00f&#34;&gt;tool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;version     print Go version&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vet         report likely mistakes in packages&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;工具的源码位于$GOPATH/src/cmd/internal，本篇文章主要讨论Go工具generate。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go是如何设计Map的</title>
      <link>http://shanks.link/blog/2021/05/06/go%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1map%E7%9A%84/</link>
      <pubDate>Thu, 06 May 2021 15:36:51 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/05/06/go%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1map%E7%9A%84/</guid>
      <description>&lt;h2 id=&#34;由于本文篇幅较长故将目录整理如下&#34;&gt;由于本文篇幅较长，故将目录整理如下&lt;/h2&gt;&#xA;&lt;p&gt;**&#xA;**&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;什么是Map&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;维基百科的定义&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;em&gt;In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;说明：在计算机科学中，包含键值对（key-value）集合的抽象数据结构（关联数组、符号表或字典），其每个可能的键在该集合中最多出现一次，这样的数据结构就是一种Map。&lt;/p&gt;</description>
    </item>
    <item>
      <title>详解内联优化</title>
      <link>http://shanks.link/blog/2021/04/30/%E8%AF%A6%E8%A7%A3%E5%86%85%E8%81%94%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 30 Apr 2021 17:54:15 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/%E8%AF%A6%E8%A7%A3%E5%86%85%E8%81%94%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;详解内联优化&#34;&gt;详解内联优化&lt;/h2&gt;&#xA;&lt;p&gt;为了保证程序的执行高效与安全，现代编译器并不会将程序员的代码直接翻译成相应地机器码，它需要做一系列的检查与优化。Go编译器默认做了很多相关工作，例如&lt;strong&gt;未使用的引用包检查、未使用的声明变量检查、有效的括号检查、逃逸分析、内联优化、删除无用代码&lt;/strong&gt;等。本文重点讨论内联优化相关内容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go精妙的互斥锁设计</title>
      <link>http://shanks.link/blog/2021/04/30/go%E7%B2%BE%E5%A6%99%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 30 Apr 2021 16:46:29 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/go%E7%B2%BE%E5%A6%99%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;p&gt;*&lt;strong&gt;Some people, when confronted with a problem, think, “I know, I’ll use threads,” and then two they hav erpoblesms.*&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. 竞争条件&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;多线程程序在多核CPU机器上访问共享资源时，难免会遇到问题。我们可以来看一个例子&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go中看似简单的WaitGroup源码设计，竟然暗含这么多知识？</title>
      <link>http://shanks.link/blog/2021/04/30/go%E4%B8%AD%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E7%9A%84waitgroup%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E7%AB%9F%E7%84%B6%E6%9A%97%E5%90%AB%E8%BF%99%E4%B9%88%E5%A4%9A%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Fri, 30 Apr 2021 16:30:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/go%E4%B8%AD%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E7%9A%84waitgroup%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E7%AB%9F%E7%84%B6%E6%9A%97%E5%90%AB%E8%BF%99%E4%B9%88%E5%A4%9A%E7%9F%A5%E8%AF%86/</guid>
      <description>&lt;h2 id=&#34;go中看似简单的waitgroup源码设计竟然暗含这么多知识&#34;&gt;Go中看似简单的WaitGroup源码设计，竟然暗含这么多知识？&lt;/h2&gt;&#xA;&lt;p&gt;Go语言提供的协程goroutine可以让我们很容易地写出多线程程序，但是，如何让这些并发执行的goroutine得到有效地控制，这是我们需要探讨的问题。正如小菜刀在&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&amp;amp;mid=2247484551&amp;amp;idx=1&amp;amp;sn=8e9e48659b06aa510ef935183e0e2d98&amp;amp;chksm=c1e91d8bf69e949d3e8de373d341a9c880d07076804f491f60acba691071dd8a542df643c20c&amp;amp;scene=21#wechat_redirect&#34;&gt;《Golang并发控制简述》&lt;/a&gt;中所述，Go标准库为我们提供的同步原语中，锁与原子操作注重控制goroutine之间的数据安全，WaitGroup、channel与Context控制的是它们的并发行为。关于&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&amp;amp;mid=2247484581&amp;amp;idx=1&amp;amp;sn=90aa7d00490fa9e3dd3f8d061e927bba&amp;amp;chksm=c1e91da9f69e94bfb46c76d9d8b587a837425fd7fcae3773ed5b573d5e856373210ac9011e45&amp;amp;scene=21#wechat_redirect&#34;&gt;锁&lt;/a&gt;、&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&amp;amp;mid=2247484580&amp;amp;idx=1&amp;amp;sn=08c7add8b5cc005bc796ab807168293a&amp;amp;chksm=c1e91da8f69e94be310035348b358e0319a99a1fba0e680f779e860676d355f4780f436b9181&amp;amp;scene=21#wechat_redirect&#34;&gt;原子操作&lt;/a&gt;、&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&amp;amp;mid=2247484573&amp;amp;idx=1&amp;amp;sn=805f9cd855fc55b53ddb8500a93a401f&amp;amp;chksm=c1e91d91f69e94872a0525a35c36ace458ce907796b4bdc91944e87594e7a18c1075a2225a57&amp;amp;scene=21#wechat_redirect&#34;&gt;channel&lt;/a&gt; 的实现原理小菜刀均有详细地解析过。因此本文，我们将重点放在WaitGroup上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何有效地测试Go代码</title>
      <link>http://shanks.link/blog/2021/04/30/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E6%B5%8B%E8%AF%95go%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Fri, 30 Apr 2021 16:21:08 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E6%B5%8B%E8%AF%95go%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;h2 id=&#34;如何有效地测试go代码&#34;&gt;如何有效地测试Go代码&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;单元测试&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果把开发程序比作盖房子，那么我们必须确保所有的用料都是合格的，否则盖起来的房子就会存在问题。对于程序而言，我们可以将盖房子的砖头、钢筋、水泥等当做一个个功能单元，如果每个单元是合格的，我们将有信心认为程序是健壮的。单元测试（Unit Test,UT）就是检验功能单元是否合格的工具。&lt;/p&gt;</description>
    </item>
    <item>
      <title>同步原理的基石</title>
      <link>http://shanks.link/blog/2021/04/30/%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/</link>
      <pubDate>Fri, 30 Apr 2021 15:56:17 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3/</guid>
      <description>&lt;h2 id=&#34;同步原语的基石&#34;&gt;同步原语的基石&lt;/h2&gt;&#xA;&lt;p&gt;Go是一门以并发编程见长的语言，它提供了一系列的同步原语方便开发者使用，例如&lt;code&gt;sync&lt;/code&gt;包下的&lt;code&gt;Mutex&lt;/code&gt;、&lt;code&gt;RWMutex&lt;/code&gt;、&lt;code&gt;WaitGroup&lt;/code&gt;、&lt;code&gt;Once&lt;/code&gt;、&lt;code&gt;Cond&lt;/code&gt;，以及抽象层级更高的&lt;code&gt;Channel&lt;/code&gt;。但是，它们的实现基石是原子操作。需要记住的是：&lt;strong&gt;软件原子操作离不开硬件指令的支持&lt;/strong&gt;。本文拟通过探讨原子操作——**比较并交换(compare and swap, CAS)**的实现，来理解Go是如何借助硬件指令来实现这一过程的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang append扩容机制</title>
      <link>http://shanks.link/blog/2021/04/30/golang-append%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 30 Apr 2021 11:37:56 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/golang-append%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;append扩容机制&#34;&gt;append扩容机制&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzIwNTA4MDAwMQ==&amp;amp;mid=2247484382&amp;amp;idx=1&amp;amp;sn=5140908b6ab1bf176cc4e7fa9b167de9&amp;amp;chksm=97371770a0409e6633202e6bbc1193cdfd8aa57dbdf7bb2aa493a2a6ab55ff464c8eadc0068a&amp;amp;scene=21#wechat_redirect&#34;&gt;《切片传递的隐藏危机》&lt;/a&gt;一文，小菜刀有简单地提及到切片扩容的问题。在读者讨论群，有人举了以下例子，并想得到一个合理的回答。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;1package main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;3&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; main() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;4    s := []int{1,2}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;5    s = append(s, 3,4,5)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;6    println(cap(s))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;7}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;9// output: 6&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么结果不是5，不是8，而是6呢？由于小菜刀在该文中关于扩容的描述不够准确，让读者产生了疑惑。因此本文想借此机会细致分析一下&lt;code&gt;append&lt;/code&gt;函数及其背后的扩容机制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>浅谈逃逸分析</title>
      <link>http://shanks.link/blog/2021/04/30/%E6%B5%85%E8%B0%88%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 30 Apr 2021 11:31:37 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/30/%E6%B5%85%E8%B0%88%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;详解逃逸分析&#34;&gt;详解逃逸分析&lt;/h2&gt;&#xA;&lt;p&gt;Go是一门带有垃圾回收的现代语言，它抛弃了传统C/C++的开发者需要手动管理内存的方式，实现了内存的主动申请和释放的管理。Go的垃圾回收，让堆和栈的概念对程序员保持透明，它增加的逃逸分析与GC，使得程序员的双手真正地得到了解放，给了开发者更多的精力去关注软件设计本身。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Once函数单次调用</title>
      <link>http://shanks.link/blog/2021/04/29/once%E5%87%BD%E6%95%B0%E5%8D%95%E6%AC%A1%E8%B0%83%E7%94%A8/</link>
      <pubDate>Thu, 29 Apr 2021 17:59:10 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/29/once%E5%87%BD%E6%95%B0%E5%8D%95%E6%AC%A1%E8%B0%83%E7%94%A8/</guid>
      <description>&lt;p&gt;&lt;strong&gt;认识单例&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;超超：您好，面试官~&lt;/p&gt;&#xA;&lt;p&gt;面试官：你好，你平时开发是用 windows 还是 linux 居多？&lt;/p&gt;&#xA;&lt;p&gt;超超：￣□￣｜｜我平时都是用windows开发的。&lt;/p&gt;&#xA;&lt;p&gt;面试官：那你知道 windows 的资源管理器只能单开，但是cmd命令行可以开很多个，有想过这是为什么吗？&lt;/p&gt;</description>
    </item>
    <item>
      <title>切片传递的隐藏危机</title>
      <link>http://shanks.link/blog/2021/04/29/%E5%88%87%E7%89%87%E4%BC%A0%E9%80%92%E7%9A%84%E9%9A%90%E8%97%8F%E5%8D%B1%E6%9C%BA/</link>
      <pubDate>Thu, 29 Apr 2021 11:47:34 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/29/%E5%88%87%E7%89%87%E4%BC%A0%E9%80%92%E7%9A%84%E9%9A%90%E8%97%8F%E5%8D%B1%E6%9C%BA/</guid>
      <description>&lt;h2 id=&#34;切片传递的隐藏危机&#34;&gt;切片传递的隐藏危机&lt;/h2&gt;&#xA;&lt;p&gt;在Go的源码库或者其他开源项目中，会发现有些函数在需要用到切片入参时，它采用是指向切片类型的指针，而非切片类型。这里未免会产生疑问：&lt;strong&gt;切片底层不就是指针指向底层数组数据吗，为何不直接传递切片，两者有什么区别&lt;/strong&gt;？&lt;/p&gt;</description>
    </item>
    <item>
      <title>一文读懂channel设计</title>
      <link>http://shanks.link/blog/2021/04/29/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82channel%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 29 Apr 2021 11:30:12 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/29/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82channel%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;p&gt;在Go中，要理解channel，首先需要认识goroutine。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E4%B9%8BChannel%E8%AE%BE%E8%AE%A1/1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;为什么会有goroutine&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;现代操作系统中为我们提供了三种基本的构造并发程序的方法：多进程、I/O多路复用和多线程。其中最简单的构造方式当属多进程，但是多进程的并发程序，由于对进程控制和进程间通信开销巨大，这样的并发方式往往会很慢。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go函数调用惯例</title>
      <link>http://shanks.link/blog/2021/04/28/go%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B/</link>
      <pubDate>Wed, 28 Apr 2021 11:59:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/28/go%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B/</guid>
      <description>&lt;h2 id=&#34;go函数调用惯例&#34;&gt;Go函数调用惯例&lt;/h2&gt;&#xA;&lt;p&gt;本文旨在探讨Go函数中的一个问题：**为什么Go函数能支持多参数返回，而C/C++、java不行？**这其实牵涉到了一个叫做函数调用惯例的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的string与[]byte转换原理</title>
      <link>http://shanks.link/blog/2021/04/27/go%E7%9A%84string%E4%B8%8Ebyte%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 27 Apr 2021 15:13:15 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/27/go%E7%9A%84string%E4%B8%8Ebyte%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;string类型和[]byte类型是我们编程时最常使用到的数据结构。本文将探讨两者之间的转换方式，通过分析它们之间的内在联系来拨开迷雾。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;两种转换方式&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go工具之vet静态诊断器</title>
      <link>http://shanks.link/blog/2021/04/27/go%E5%B7%A5%E5%85%B7%E4%B9%8Bvet%E9%9D%99%E6%80%81%E8%AF%8A%E6%96%AD%E5%99%A8/</link>
      <pubDate>Tue, 27 Apr 2021 15:06:32 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/27/go%E5%B7%A5%E5%85%B7%E4%B9%8Bvet%E9%9D%99%E6%80%81%E8%AF%8A%E6%96%AD%E5%99%A8/</guid>
      <description>&lt;h2 id=&#34;go工具之vet静态诊断器&#34;&gt;Go工具之vet——静态诊断器&lt;/h2&gt;&#xA;&lt;p&gt;go的vet工具是go代码静态诊断器，可以用以检查go项目中可通过编译但仍可能存在错误的代码，例如无法访问的代码、错误的锁使用、不必要的赋值、布尔运算错误等。&lt;/p&gt;</description>
    </item>
    <item>
      <title>不能忽略GoRoutinue的启动时间</title>
      <link>http://shanks.link/blog/2021/04/27/%E4%B8%8D%E8%83%BD%E5%BF%BD%E7%95%A5goroutinue%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/</link>
      <pubDate>Tue, 27 Apr 2021 14:48:35 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/27/%E4%B8%8D%E8%83%BD%E5%BF%BD%E7%95%A5goroutinue%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/</guid>
      <description>&lt;h2 id=&#34;不要忽略goroutine的启动时间&#34;&gt;不要忽略goroutine的启动时间&lt;/h2&gt;&#xA;&lt;p&gt;项目中需要将数据推给多个服务器，大致如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#00f&#34;&gt;package&lt;/span&gt; main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#00f&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;sync&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; )&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;mockSendToServer&lt;/span&gt;(url &lt;span style=&#34;color:#00f&#34;&gt;string&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;server url: %s\n&amp;#34;&lt;/span&gt;, url)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    urls := []&lt;span style=&#34;color:#00f&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;0.0.0.0:5000&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;0.0.0.0:6000&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;0.0.0.0:7000&amp;#34;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    wg := sync.WaitGroup{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; _, url := &lt;span style=&#34;color:#00f&#34;&gt;range&lt;/span&gt; urls {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        wg.&lt;span style=&#34;color:#c34e00&#34;&gt;Add&lt;/span&gt;(1)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#00f&#34;&gt;defer&lt;/span&gt; wg.&lt;span style=&#34;color:#c34e00&#34;&gt;Done&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#c34e00&#34;&gt;mockSendToServer&lt;/span&gt;(url)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    wg.&lt;span style=&#34;color:#c34e00&#34;&gt;Wait&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请读者停来下思考一下，以上代码会得到什么样的输出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解sync.Once</title>
      <link>http://shanks.link/blog/2021/04/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sync.once/</link>
      <pubDate>Tue, 27 Apr 2021 11:43:13 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sync.once/</guid>
      <description>&lt;h2 id=&#34;深入理解synconce&#34;&gt;深入理解sync.Once&lt;/h2&gt;&#xA;&lt;p&gt;sync.Once是让函数方法只被调用执行一次的实现，其最常应用于单例模式之下，例如初始化系统配置、保持数据库唯一连接等。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;sync.Once的单例模式示例&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go no copy 机制</title>
      <link>http://shanks.link/blog/2021/04/27/go-no-copy-%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 27 Apr 2021 11:11:13 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/27/go-no-copy-%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;no-copy机制&#34;&gt;no copy机制&lt;/h2&gt;&#xA;&lt;p&gt;小菜刀读Go源码时，发现一个高频注释语句“&lt;strong&gt;XXX must not be copied after first use&lt;/strong&gt;“。例如sync包下的Pool、Cond、WaitGroup、Mutex、Map和atomoic.Vaule、strings.Builder等，都有该句注释。&lt;/p&gt;</description>
    </item>
    <item>
      <title>信号处理与Go程序的优雅退出</title>
      <link>http://shanks.link/blog/2021/04/26/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8Ego%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA/</link>
      <pubDate>Mon, 26 Apr 2021 19:00:14 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/26/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8Ego%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E9%9B%85%E9%80%80%E5%87%BA/</guid>
      <description>&lt;h2 id=&#34;信号处理与go程序的优雅退出&#34;&gt;信号处理与Go程序的优雅退出&lt;/h2&gt;&#xA;&lt;p&gt;学过计算机系统的人，应该知道异常控制流（ECF）。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解syncMap</title>
      <link>http://shanks.link/blog/2021/04/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3syncmap/</link>
      <pubDate>Mon, 26 Apr 2021 18:45:00 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3syncmap/</guid>
      <description>&lt;h2 id=&#34;深入理解syncmap&#34;&gt;深入理解sync.Map&lt;/h2&gt;&#xA;&lt;p&gt;golang中内置了map关键字，但是它是非线程安全的。从go 1.9开始，标准库加入了sync.Map，提供用于并发安全的map。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;普通map的并发问题&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang开发者学习图鉴</title>
      <link>http://shanks.link/blog/2021/04/26/golang%E5%BC%80%E5%8F%91%E8%80%85%E5%AD%A6%E4%B9%A0%E5%9B%BE%E9%89%B4/</link>
      <pubDate>Mon, 26 Apr 2021 18:08:01 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/26/golang%E5%BC%80%E5%8F%91%E8%80%85%E5%AD%A6%E4%B9%A0%E5%9B%BE%E9%89%B4/</guid>
      <description>&lt;h2 id=&#34;golang开发者学习图鉴&#34;&gt;Golang开发者学习图鉴&lt;/h2&gt;&#xA;&lt;p&gt;想成为一名优秀的Golang开发者，你知道需要掌握哪些技能吗？为了帮助你更好的上🚗，本文为你提供了2020版Go开发者成长路线图。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E5%AD%A6%E4%B9%A0%E5%9B%BE%E9%89%B4/1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. 先决条件&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go并发控制</title>
      <link>http://shanks.link/blog/2021/04/26/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 26 Apr 2021 17:54:51 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/26/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;golang并发控制简述&#34;&gt;Golang并发控制简述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;引言&#34;&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Golang中通过go关键字就可开启一个goroutine，因此，在Go中可以轻松写出并发代码。但是，如何对这些并发执行的groutines有效地控制？&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go之Sort排序</title>
      <link>http://shanks.link/blog/2021/04/26/go%E4%B9%8Bsort%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 26 Apr 2021 17:43:34 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/26/go%E4%B9%8Bsort%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;h2 id=&#34;golang之sort包&#34;&gt;Golang之sort包&lt;/h2&gt;&#xA;&lt;p&gt;Go语言是一门非常简单优雅的语言，其源码更是其风格标杆。看源码，不仅能学习Go的设计哲学，了解如何调用库函数，同时帮助我们写出更优雅的go代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言内部包--控制包成员的对外暴露</title>
      <link>http://shanks.link/blog/2021/04/26/go%E8%AF%AD%E8%A8%80%E5%86%85%E9%83%A8%E5%8C%85--%E6%8E%A7%E5%88%B6%E5%8C%85%E6%88%90%E5%91%98%E7%9A%84%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2/</link>
      <pubDate>Mon, 26 Apr 2021 11:21:21 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/26/go%E8%AF%AD%E8%A8%80%E5%86%85%E9%83%A8%E5%8C%85--%E6%8E%A7%E5%88%B6%E5%8C%85%E6%88%90%E5%91%98%E7%9A%84%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2/</guid>
      <description>&lt;h2 id=&#34;go语言内部包控制包成员的对外暴露&#34;&gt;Go语言内部包&amp;ndash;控制包成员的对外暴露&lt;/h2&gt;&#xA;&lt;p&gt;Go 语言中的软件包推荐按照：&lt;strong&gt;组织名/项目名&lt;/strong&gt; 的形式安排软件包的文件目录结构，一般「项目名」文件目录下还会按照功能、抽象约定、具体实现等维度再划分一些子目录。在 Go 语言里包的导入路径不同则被判定为不同的包，所以同一个软件包项目下的「功能一」包依赖「功能二」包里的成员时，那么成员必须是导出成员才能被「功能一」包引用。但是这样一来，其他项目或者其他组织的代码也就都可以使用这个导出的成员了，&lt;strong&gt;假如包里的一些成员我们只想在指定的包之间共享而不想对外暴露该怎么办呢？&lt;/strong&gt; Go 语言内部包这个特性可以让我们实现这个目标。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 面试官：什么是协程，协程和线程的区别和联系？</title>
      <link>http://shanks.link/blog/2021/04/25/go-%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</link>
      <pubDate>Sun, 25 Apr 2021 11:17:04 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/25/go-%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</guid>
      <description>&lt;p&gt;既要理解线程，还要讲解协程，并且诠释两者间的区别，但是由于提到线程，就必然涉及进程，因此本文将会同时梳理介绍 “进程、协程、协程” 三者的随笔知识，希望能引发大家的一些思考。&lt;/p&gt;</description>
    </item>
    <item>
      <title>从底层到应用，想深入Map这篇文章千万不要错过！</title>
      <link>http://shanks.link/blog/2021/04/20/%E4%BB%8E%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%94%E7%94%A8%E6%83%B3%E6%B7%B1%E5%85%A5map%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E9%94%99%E8%BF%87/</link>
      <pubDate>Tue, 20 Apr 2021 15:25:11 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/20/%E4%BB%8E%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%94%E7%94%A8%E6%83%B3%E6%B7%B1%E5%85%A5map%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E9%94%99%E8%BF%87/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/nZWGvE8CMRg9rX6m0GUYSQ&#34;&gt;转载自上山打老虎的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;超超经过了一番磨难通过了面试官单例的灵魂拷问，面试官貌似想通过一道场景应用题来考验超超对Golang的容器是否足够熟悉。下面来看看超超是如何解答的吧！&lt;/p&gt;</description>
    </item>
    <item>
      <title>嗯，你觉得 Go 在什么时候会抢占 P？</title>
      <link>http://shanks.link/blog/2021/04/19/%E5%97%AF%E4%BD%A0%E8%A7%89%E5%BE%97-go-%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%8A%A2%E5%8D%A0-p/</link>
      <pubDate>Mon, 19 Apr 2021 20:13:34 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/19/%E5%97%AF%E4%BD%A0%E8%A7%89%E5%BE%97-go-%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%8A%A2%E5%8D%A0-p/</guid>
      <description>&lt;h2 id=&#34;嗯你觉得-go-在什么时候会抢占-p&#34;&gt;嗯，你觉得 Go 在什么时候会抢占 P？&lt;/h2&gt;&#xA;&lt;p&gt;前几天我们有聊到《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247487643&amp;amp;idx=1&amp;amp;sn=f81b18a12ab156feebb9fc9329e1c8f4&amp;amp;chksm=f90405c6ce738cd0763e5687508d3f09c7fe30e0da582ec0290c26b84cf2867698423c5a341b&amp;amp;scene=21#wechat_redirect&#34;&gt;单核 CPU，开两个 Goroutine，其中一个死循环，会怎么样？&lt;/a&gt;》的问题，我们在一个细节部分有提到：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go%E6%8A%A2%E5%8D%A0P/1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;有新的小伙伴会产生更多的疑问，那就是在 Go 语言中，是如何抢占 P 的呢，这里面是怎么做的？&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Go runtime scheduler&#39;s clever way of dealing with system calls</title>
      <link>http://shanks.link/blog/2021/04/19/the-go-runtime-schedulers-clever-way-of-dealing-with-system-calls/</link>
      <pubDate>Mon, 19 Apr 2021 17:53:16 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/19/the-go-runtime-schedulers-clever-way-of-dealing-with-system-calls/</guid>
      <description>&lt;h2 id=&#34;the-go-runtime-schedulers-clever-way-of-dealing-with-system-calls&#34;&gt;The Go runtime scheduler&amp;rsquo;s clever way of dealing with system calls&lt;/h2&gt;&#xA;&lt;p&gt;One of Go&amp;rsquo;s signature features is &lt;a href=&#34;https://tour.golang.org/concurrency/1&#34;&gt;goroutines&lt;/a&gt;, which are lightweight threads that are managed by the Go runtime. The Go runtime implements goroutines using &lt;a href=&#34;https://rakyll.org/scheduler/&#34;&gt;a M:N work stealing scheduler&lt;/a&gt; to multiplex goroutines on to operating system threads. The scheduler has special terminology for three important entities; a G is a goroutine, an M is an OS thread (a &amp;lsquo;machine&amp;rsquo;), and a P is a &amp;lsquo;processor&amp;rsquo;, which at its core is a limited resource that must be claimed by an M in order to run Go code. Having a limited supply of Ps is how Go limits how many things it will do at once, so as to not overload the overall system; generally there is one P per actual CPU that the OS reports (the number of Ps is &lt;a href=&#34;https://golang.org/pkg/runtime/&#34;&gt;&lt;code&gt;GOMAXPROCS&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>用 Go struct 不能犯的一个低级错误！</title>
      <link>http://shanks.link/blog/2021/04/18/%E7%94%A8-go-struct-%E4%B8%8D%E8%83%BD%E7%8A%AF%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BD%8E%E7%BA%A7%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sun, 18 Apr 2021 00:42:39 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/18/%E7%94%A8-go-struct-%E4%B8%8D%E8%83%BD%E7%8A%AF%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BD%8E%E7%BA%A7%E9%94%99%E8%AF%AF/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/K5B2ItkzOb4eCFLxZI5Wvw&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;用-go-struct-不能犯的一个低级错误&#34;&gt;用 Go struct 不能犯的一个低级错误！&lt;/h2&gt;&#xA;&lt;p&gt;原创 陈煎鱼 &lt;a href=&#34;javascript:void(0);&#34;&gt;脑子进煎鱼了&lt;/a&gt; &lt;em&gt;3天前&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;收录于话题&lt;/p&gt;&#xA;&lt;p&gt;#Go45&lt;/p&gt;&#xA;&lt;p&gt;#面试题13&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。&lt;/p&gt;&#xA;&lt;p&gt;前段时间我分享了 《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247487631&amp;amp;idx=1&amp;amp;sn=0c6d3e548573197e8281f622d8d5b0d7&amp;amp;chksm=f90405d2ce738cc401029885459b1ef29095a429ac7d71667e94750966b3dae1044e09fbdc77&amp;amp;scene=21#wechat_redirect&#34;&gt;手撕 Go 面试官：Go 结构体是否可以比较，为什么？&lt;/a&gt;》的文章，把基本 Go struct 的比较依据研究了一番。这不，最近有一位读者，遇到了一个关于 struct 的新问题，踩到了雷区。不得解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goroutine 泄露的 N 种方法，真刺激！</title>
      <link>http://shanks.link/blog/2021/04/18/goroutine-%E6%B3%84%E9%9C%B2%E7%9A%84-n-%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9C%9F%E5%88%BA%E6%BF%80/</link>
      <pubDate>Sun, 18 Apr 2021 00:10:42 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/18/goroutine-%E6%B3%84%E9%9C%B2%E7%9A%84-n-%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9C%9F%E5%88%BA%E6%BF%80/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/ql01K1nOnEZpdbp--6EDYw&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。&lt;/p&gt;&#xA;&lt;p&gt;前几天分享 Go 群友提问的文章时，有读者在朋友圈下提到，希望我能够针对 Goroutine 泄露这块进行讲解，他在面试的时候经常被问到。&lt;/p&gt;&#xA;&lt;p&gt;另外我也相信很多小伙伴，在做救火队长时排查过 Goroutine 泄露的问题，因为 Goroutine 作为一个载体，基本跑不了干系。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你知道 Go 结构体和结构体指针调用有什么区别吗？</title>
      <link>http://shanks.link/blog/2021/04/17/%E4%BD%A0%E7%9F%A5%E9%81%93-go-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97/</link>
      <pubDate>Sat, 17 Apr 2021 23:59:23 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/17/%E4%BD%A0%E7%9F%A5%E9%81%93-go-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/g-D_eVh-8JaIoRne09bJ3Q&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本期的男主角是《&lt;strong&gt;Go 结构体和结构体指针调用有什么区别&lt;/strong&gt;》，希望对大家有所帮助，带来一些思考。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;请在此处默念自己心目中的答案&lt;/strong&gt;，再和煎鱼一同研讨一波 Go 的技术哲学。&lt;/p&gt;</description>
    </item>
    <item>
      <title>再见 Go 面试官：单核 CPU，开两个 Goroutine，其中一个死循环，会怎么样</title>
      <link>http://shanks.link/blog/2021/04/17/%E5%86%8D%E8%A7%81-go-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8D%95%E6%A0%B8-cpu%E5%BC%80%E4%B8%A4%E4%B8%AA-goroutine%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/</link>
      <pubDate>Sat, 17 Apr 2021 23:45:39 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/17/%E5%86%8D%E8%A7%81-go-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8D%95%E6%A0%B8-cpu%E5%BC%80%E4%B8%A4%E4%B8%AA-goroutine%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/h27GXmfGYVLHRG3Mu_8axw&#34;&gt;以下转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;最近金三银四，是面试的季节。在我的 Go 读者交流群里出现了许多小伙伴在讨论自己面试过程中所遇到的一些 Go 面试题。若大家有兴趣，欢迎加我的微信进群一同交流。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 内存泄露之痛，这篇把 Go timer.After 问题根因讲透了！</title>
      <link>http://shanks.link/blog/2021/04/17/go-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8B%E7%97%9B%E8%BF%99%E7%AF%87%E6%8A%8A-go-timer.after-%E9%97%AE%E9%A2%98%E6%A0%B9%E5%9B%A0%E8%AE%B2%E9%80%8F%E4%BA%86/</link>
      <pubDate>Sat, 17 Apr 2021 23:33:30 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/17/go-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8B%E7%97%9B%E8%BF%99%E7%AF%87%E6%8A%8A-go-timer.after-%E9%97%AE%E9%A2%98%E6%A0%B9%E5%9B%A0%E8%AE%B2%E9%80%8F%E4%BA%86/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/KSBdPkkvonSES9Z9iggElg&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前几天在公众号分享了一篇 Go timer 源码解析的文章《难以驾驭的 Go timer，一文带你参透计时器的奥秘》。&lt;/p&gt;&#xA;&lt;p&gt;如果大家也有兴趣共同交流，欢迎关注煎鱼的公众号，加我微信后拉你进群。&lt;/p&gt;</description>
    </item>
    <item>
      <title>手撕 Go 面试官：Go 结构体是否可以比较，为什么？</title>
      <link>http://shanks.link/blog/2021/04/16/%E6%89%8B%E6%92%95-go-%E9%9D%A2%E8%AF%95%E5%AE%98go-%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E4%B8%BA%E4%BB%80%E4%B9%88/</link>
      <pubDate>Fri, 16 Apr 2021 18:58:13 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/%E6%89%8B%E6%92%95-go-%E9%9D%A2%E8%AF%95%E5%AE%98go-%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E4%B8%BA%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/HScH6nm3xf4POXVk774jUA&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;今天的男主角，是 Go 工程师的必修技能，也是极容易踩坑的地方，就是 “&lt;strong&gt;Go 面试题：Go 结构体（struct）是否可以比较？&lt;/strong&gt;”&lt;/p&gt;&#xA;&lt;p&gt;如果可以比较，是为什么？如果不可以比较，又是为什么？&lt;/p&gt;</description>
    </item>
    <item>
      <title>难以驾驭的 Go timer，一文带你参透计时器的奥秘</title>
      <link>http://shanks.link/blog/2021/04/16/%E9%9A%BE%E4%BB%A5%E9%A9%BE%E9%A9%AD%E7%9A%84-go-timer%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%8F%82%E9%80%8F%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E5%A5%A5%E7%A7%98/</link>
      <pubDate>Fri, 16 Apr 2021 18:40:40 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/%E9%9A%BE%E4%BB%A5%E9%A9%BE%E9%A9%AD%E7%9A%84-go-timer%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%8F%82%E9%80%8F%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E5%A5%A5%E7%A7%98/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/gxX-q2EvgWZEWe-deRITSw&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;#Go进阶之旅1&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。久违的源码剖析系列，让我们一起努力，看看谁能坚持到最后，因为学习一定是给能够坚持重复啃和热衷于&lt;strong&gt;三连&lt;/strong&gt;的人。&lt;/p&gt;&#xA;&lt;p&gt;接下来正式开始今天的内容讲解，今天的男主角是计时器 timer。&lt;/p&gt;</description>
    </item>
    <item>
      <title>再见 Go 面试官：GMP 模型，为什么要有 P？</title>
      <link>http://shanks.link/blog/2021/04/16/%E5%86%8D%E8%A7%81-go-%E9%9D%A2%E8%AF%95%E5%AE%98gmp-%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-p/</link>
      <pubDate>Fri, 16 Apr 2021 18:20:16 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/%E5%86%8D%E8%A7%81-go-%E9%9D%A2%E8%AF%95%E5%AE%98gmp-%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-p/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;最近金三银四，是面试的季节。在我的 Go 读者交流群里出现了许多小伙伴在讨论自己面试过程中所遇到的一些 Go 面试题。&lt;/p&gt;&#xA;&lt;p&gt;今天的主角，是 Go 面试的万能题 GMP 模型的延伸题（疑问），那就是 ”&lt;strong&gt;GMP 模型，为什么要有 P&lt;/strong&gt;？“&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 群友提问：进程、线程都有 ID，为什么 Goroutine 没有 ID？</title>
      <link>http://shanks.link/blog/2021/04/16/go-%E7%BE%A4%E5%8F%8B%E6%8F%90%E9%97%AE%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%9C%89-id%E4%B8%BA%E4%BB%80%E4%B9%88-goroutine-%E6%B2%A1%E6%9C%89-id/</link>
      <pubDate>Fri, 16 Apr 2021 17:32:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go-%E7%BE%A4%E5%8F%8B%E6%8F%90%E9%97%AE%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%9C%89-id%E4%B8%BA%E4%BB%80%E4%B9%88-goroutine-%E6%B2%A1%E6%9C%89-id/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/qFAtgpbAsHSPVLuo3PYIhg&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;今天的主角，是大家在既有语言基础的情况下，学 Goroutine 时会容易纠结的一点。就是 “&lt;strong&gt;进程、线程都有 ID，为什么 Goroutine 没有 GoroutineID？&lt;/strong&gt;”。&lt;/p&gt;&#xA;&lt;p&gt;这是为什么呢，怎么做那些跨协程处理呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 语言中的一等公民：看似普通的函数，凭什么？</title>
      <link>http://shanks.link/blog/2021/04/16/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E7%9C%8B%E4%BC%BC%E6%99%AE%E9%80%9A%E7%9A%84%E5%87%BD%E6%95%B0%E5%87%AD%E4%BB%80%E4%B9%88/</link>
      <pubDate>Fri, 16 Apr 2021 17:19:05 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E7%9C%8B%E4%BC%BC%E6%99%AE%E9%80%9A%E7%9A%84%E5%87%BD%E6%95%B0%E5%87%AD%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/NPPzcfp7I50XcDMnR5bU9w&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 Go 语言中，一提函数，大家提的最多的就是 “Go 语言的函数是一等公民”。这个定义来的非常突然，我们先了解一下什么是一等公民，他又凭什么？&lt;/p&gt;&#xA;&lt;p&gt;根据维基百科的一等公民（First-class citizen）的定义：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 面试题：Go interface 的一个 坑 及原理分析</title>
      <link>http://shanks.link/blog/2021/04/16/go-%E9%9D%A2%E8%AF%95%E9%A2%98go-interface-%E7%9A%84%E4%B8%80%E4%B8%AA-%E5%9D%91-%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 16 Apr 2021 17:10:27 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go-%E9%9D%A2%E8%AF%95%E9%A2%98go-interface-%E7%9A%84%E4%B8%80%E4%B8%AA-%E5%9D%91-%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/vNACbdSDxC9S0LOAr7ngLQ&#34;&gt;以下内容转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;go-面试题go-interface-的一个-坑-及原理分析&#34;&gt;Go 面试题：Go interface 的一个 “坑” 及原理分析&lt;/h2&gt;&#xA;&lt;p&gt;原创 陈煎鱼 &lt;a href=&#34;javascript:void(0);&#34;&gt;脑子进煎鱼了&lt;/a&gt; &lt;em&gt;3月16日&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;收录于话题&lt;/p&gt;&#xA;&lt;p&gt;#Go45&lt;/p&gt;&#xA;&lt;p&gt;#面试题13&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。&lt;/p&gt;&#xA;&lt;p&gt;前几天在读者交流群里看到一位小伙伴，针对 interface 的使用有了比较大的疑惑。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 群友提问：学习 defer 时很懵逼，这道不会做！</title>
      <link>http://shanks.link/blog/2021/04/16/go-%E7%BE%A4%E5%8F%8B%E6%8F%90%E9%97%AE%E5%AD%A6%E4%B9%A0-defer-%E6%97%B6%E5%BE%88%E6%87%B5%E9%80%BC%E8%BF%99%E9%81%93%E4%B8%8D%E4%BC%9A%E5%81%9A/</link>
      <pubDate>Fri, 16 Apr 2021 17:00:42 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go-%E7%BE%A4%E5%8F%8B%E6%8F%90%E9%97%AE%E5%AD%A6%E4%B9%A0-defer-%E6%97%B6%E5%BE%88%E6%87%B5%E9%80%BC%E8%BF%99%E9%81%93%E4%B8%8D%E4%BC%9A%E5%81%9A/</guid>
      <description>&lt;h2 id=&#34;go-群友提问学习-defer-时很懵逼这道不会做&#34;&gt;Go 群友提问：学习 defer 时很懵逼，这道不会做！&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/lELMqKho003h0gfKkZxhHQ&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前几天在读者交流群里看到一位小伙伴，在向大家咨询 Go 相关的技术问题。疑问是：“&lt;strong&gt;各位大佬，我在学习 defer 遇到闭包的时候很懵逼，谁比较明白，能指点？&lt;/strong&gt;”&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 群友提问：Goroutine 数量控制在多少合适，会影响 GC 和调度？</title>
      <link>http://shanks.link/blog/2021/04/16/go-%E7%BE%A4%E5%8F%8B%E6%8F%90%E9%97%AEgoroutine-%E6%95%B0%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9C%A8%E5%A4%9A%E5%B0%91%E5%90%88%E9%80%82%E4%BC%9A%E5%BD%B1%E5%93%8D-gc-%E5%92%8C%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Fri, 16 Apr 2021 15:53:17 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go-%E7%BE%A4%E5%8F%8B%E6%8F%90%E9%97%AEgoroutine-%E6%95%B0%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9C%A8%E5%A4%9A%E5%B0%91%E5%90%88%E9%80%82%E4%BC%9A%E5%BD%B1%E5%93%8D-gc-%E5%92%8C%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw&#34;&gt;以下内容转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前几天在读者交流群里看到一位小伙伴，发出了一个致命提问，那就是：“&lt;strong&gt;单机的 goroutine 数量控制在多少比较合适？&lt;/strong&gt;”。&lt;/p&gt;&#xA;&lt;p&gt;也许你和群内小伙伴第一反应一样，会答复 “控制多少，我觉得没有定论”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 面试题： new 和 make 是什么，差异在哪？</title>
      <link>http://shanks.link/blog/2021/04/16/go-%E9%9D%A2%E8%AF%95%E9%A2%98-new-%E5%92%8C-make-%E6%98%AF%E4%BB%80%E4%B9%88%E5%B7%AE%E5%BC%82%E5%9C%A8%E5%93%AA/</link>
      <pubDate>Fri, 16 Apr 2021 14:49:39 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go-%E9%9D%A2%E8%AF%95%E9%A2%98-new-%E5%92%8C-make-%E6%98%AF%E4%BB%80%E4%B9%88%E5%B7%AE%E5%BC%82%E5%9C%A8%E5%93%AA/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/tZg3zmESlLmefAWdTR96Tg&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;go-面试题-new-和-make-是什么差异在哪&#34;&gt;Go 面试题： new 和 make 是什么，差异在哪？&lt;/h2&gt;&#xA;&lt;p&gt;在 Go 语言中，有两个比较雷同的内置函数，分别是 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 方法，其主要用途都是用于分配相应类型的内存空间。&lt;/p&gt;&#xA;&lt;p&gt;看上去 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt; 都是分配内存的，那他们有什么区别呢？这个细节点也成为了不少 Go 语言工程师的面试题之一，值得大家一看。&lt;/p&gt;</description>
    </item>
    <item>
      <title>灵魂拷问 Go 语言：这个变量到底分配到哪里了？</title>
      <link>http://shanks.link/blog/2021/04/16/%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-go-%E8%AF%AD%E8%A8%80%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%88%B0%E5%BA%95%E5%88%86%E9%85%8D%E5%88%B0%E5%93%AA%E9%87%8C%E4%BA%86/</link>
      <pubDate>Fri, 16 Apr 2021 11:18:05 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE-go-%E8%AF%AD%E8%A8%80%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%88%B0%E5%BA%95%E5%88%86%E9%85%8D%E5%88%B0%E5%93%AA%E9%87%8C%E4%BA%86/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/mFfza7DayFqsiS93Ep15BA&#34;&gt;以下内容转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们在写代码的时候，有时候会想这个变量到底分配到哪里了？这时候可能会有人说，在栈上，在堆上。信我准没错&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/1.jpg&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;但从结果上来讲你还是一知半解，这可不行，万一被人懵了呢。今天我们一起来深挖下 Go 在这块的奥妙，自己动手丰衣足食！&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go1.16 新特性：Go mod 的后悔药，仅需这一招</title>
      <link>http://shanks.link/blog/2021/04/16/go1.16-%E6%96%B0%E7%89%B9%E6%80%A7go-mod-%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF%E4%BB%85%E9%9C%80%E8%BF%99%E4%B8%80%E6%8B%9B/</link>
      <pubDate>Fri, 16 Apr 2021 11:07:00 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go1.16-%E6%96%B0%E7%89%B9%E6%80%A7go-mod-%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF%E4%BB%85%E9%9C%80%E8%BF%99%E4%B8%80%E6%8B%9B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/0g89yj9sc1oIz9kS9ZIAEA&#34;&gt;以下内容转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前几天 Go 官方正式发布了 1.16 版本。&lt;strong&gt;从这个版本起，环境变量 GO111MODULE 的默认值正式修改为 on&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;http://shanks.link/img/Go116%E6%96%B0%E7%89%B9%E6%80%A7Gomod%E7%9A%84%E5%90%8E%E6%82%94%E8%8D%AF/1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这也意味着 Go modules 将更进一步推进其业务覆盖面，有新老项目共存的小伙伴建议手动将 GO111MODULE 调整为 auto。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go1.16 新特性：详解内存管理机制的变更</title>
      <link>http://shanks.link/blog/2021/04/16/go1.16-%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8F%98%E6%9B%B4/</link>
      <pubDate>Fri, 16 Apr 2021 10:55:29 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/16/go1.16-%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8F%98%E6%9B%B4/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/l4oEJdskbWpff1E3tTNUxQ&#34;&gt;以下内容转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在上一篇 Go1.16 特性介绍的文章中我们有提到，从 v1.16 起，Go 在 Linux 下的默认内存管理策略会从&lt;code&gt;MADV_FREE&lt;/code&gt; 改回 &lt;code&gt;MADV_DONTNEED&lt;/code&gt; 策略。&lt;/p&gt;&#xA;&lt;p&gt;这时候可能至少分两拨小伙伴，分别是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go116新特性Goembed</title>
      <link>http://shanks.link/blog/2021/04/15/go116%E6%96%B0%E7%89%B9%E6%80%A7goembed/</link>
      <pubDate>Thu, 15 Apr 2021 19:32:27 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/15/go116%E6%96%B0%E7%89%B9%E6%80%A7goembed/</guid>
      <description>&lt;p&gt;Go1.16 新特性：一文快速上手 Go embed&#xA;&lt;a href=&#34;https://mp.weixin.qq.com/s/aBPrBHl9BpbvbJyatB3Vww&#34;&gt;以下内容转载自煎鱼的blog&lt;/a&gt;&#xA;大家好，我是正在沉迷学习煎鱼的煎鱼。&#xA;在以前，很多从其他语言转过来 Go 语言的同学会问到，或是踩到一个坑。就是以为 Go 语言所打包的二进制文件中会包含配置文件的联同编译和打包。&#xA;&lt;img src=&#34;1.png&#34; alt=&#34;&#34;&gt;&#xA;结果往往一把二进制文件挪来挪去，就无法把应用程序运行起来了。因为无法读取到静态文件的资源。&#xA;无法将静态资源编译打包进二进制文件的话，通常会有两种解决方法：&#xA;第一种是识别这类静态资源，是否需要跟着程序走。&#xA;第二种就是考虑将其打包进二进制文件中。&#xA;第二种情况的话，Go 以前是不支持的，大家就会去借助各种花式的开源库，例如：go-bindata/go-bindata 来实现。&#xA;但从在 Go1.16 起，Go 语言自身正式支持了该项特性，今天我们将通过这篇文章快速了解和学习这项特性。&#xA;基本使用&lt;/p&gt;</description>
    </item>
    <item>
      <title>上下文Context</title>
      <link>http://shanks.link/blog/2021/04/15/%E4%B8%8A%E4%B8%8B%E6%96%87context/</link>
      <pubDate>Thu, 15 Apr 2021 18:19:18 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/15/%E4%B8%8A%E4%B8%8B%E6%96%87context/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/&#34;&gt;以下内容转载自面向信仰编程&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;61-上下文-context-&#34;&gt;6.1 上下文 Context #&lt;/h1&gt;&#xA;&lt;p&gt;上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一文吃透 Go 语言解密之上下文 context</title>
      <link>http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-go-%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%AF%86%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87-context/</link>
      <pubDate>Thu, 15 Apr 2021 16:08:31 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-go-%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%AF%86%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87-context/</guid>
      <description>&lt;h2 id=&#34;一文吃透-go-语言解密之上下文-context&#34;&gt;一文吃透 Go 语言解密之上下文 context&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/A03G3_kCvVFN3TxB-92GVw&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;上下文（Context）是 Go 语言中非常有特色的一个特性， 在 Go 1.7 版本中正式引入新标准库 context。&lt;/p&gt;&#xA;&lt;p&gt;其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一文吃透 Go 语言解密之接口 interface</title>
      <link>http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-go-%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%AF%86%E4%B9%8B%E6%8E%A5%E5%8F%A3-interface/</link>
      <pubDate>Thu, 15 Apr 2021 15:34:27 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-go-%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%AF%86%E4%B9%8B%E6%8E%A5%E5%8F%A3-interface/</guid>
      <description>&lt;h2 id=&#34;一文吃透-go-语言解密之接口-interface&#34;&gt;一文吃透 Go 语言解密之接口 interface&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/vSgV_9bfoifnh2LEX0Y7cQ&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;自古流传着一个传言&amp;hellip;在 Go 语言面试的时候必有人会问接口（interface）的实现原理。这又是为什么？为何对接口如此执着？&lt;/p&gt;</description>
    </item>
    <item>
      <title>一文带你解密 Go 语言之通道 channel</title>
      <link>http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E8%A7%A3%E5%AF%86-go-%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%80%9A%E9%81%93-channel/</link>
      <pubDate>Thu, 15 Apr 2021 11:42:26 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E8%A7%A3%E5%AF%86-go-%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%80%9A%E9%81%93-channel/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/ZXYpfLNGyej0df2zXqfnHQ&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;今天这篇文章主要是针对 Go channel 的重点分析，一开始写的时候以为范围不会太大，但洋洋洒洒还是写破了万字，成为了一篇覆盖面较广和有一定深度的长文分析。&lt;/p&gt;</description>
    </item>
    <item>
      <title>解密 Go 语言之反射 reflect</title>
      <link>http://shanks.link/blog/2021/04/15/%E8%A7%A3%E5%AF%86-go-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8F%8D%E5%B0%84-reflect/</link>
      <pubDate>Thu, 15 Apr 2021 11:32:37 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/15/%E8%A7%A3%E5%AF%86-go-%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%8F%8D%E5%B0%84-reflect/</guid>
      <description>&lt;h2 id=&#34;解密-go-语言之反射-reflect&#34;&gt;解密 Go 语言之反射 reflect&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/onl3sBCSNs8l42uihi_p4A&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。今天是 2020 年的最后一天，让我们一起继续愉快的学习吧 ：）。&lt;/p&gt;&#xA;&lt;p&gt;在所有的语言中，反射这一功能基本属于必不可少的模块。&lt;/p&gt;&#xA;&lt;p&gt;虽说 “反射” 这个词让人根深蒂固，但更多的还是 WHY。反射到底是什么，反射又是基于什么法则实现的？&lt;/p&gt;</description>
    </item>
    <item>
      <title>干货满满的 Go Modules 知识分享</title>
      <link>http://shanks.link/blog/2021/04/14/%E5%B9%B2%E8%B4%A7%E6%BB%A1%E6%BB%A1%E7%9A%84-go-modules-%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 14 Apr 2021 23:57:17 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/14/%E5%B9%B2%E8%B4%A7%E6%BB%A1%E6%BB%A1%E7%9A%84-go-modules-%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/uUNTH06_s6yzy5urtjPMsg&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。&lt;/p&gt;&#xA;&lt;p&gt;马上 2021 年了，Go 也即将在明年发布 Go1.16。但 Go Modules 仍然是大家关注的话题之一。早期汇总过傲飞分享的 《Go Modules、Go Module Proxy 和 goproxy.cn》。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 错误处理：用 panic 取代 err != nil 的模式</title>
      <link>http://shanks.link/blog/2021/04/14/go-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%94%A8-panic-%E5%8F%96%E4%BB%A3-err-nil-%E7%9A%84%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 14 Apr 2021 14:33:59 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/14/go-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%94%A8-panic-%E5%8F%96%E4%BB%A3-err-nil-%E7%9A%84%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;go-错误处理用-panic-取代-err--nil-的模式&#34;&gt;Go 错误处理：用 panic 取代 err != nil 的模式&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/p77V3_LkREuXPVLdebmmmQ&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前段时间我分享了文章 《先睹为快，Go2 Error 的挣扎之路》后，和一位朋友进行了一次深度交流，他给我分享了他们项目组对于 Go 错误处理的方式调整。&lt;/p&gt;</description>
    </item>
    <item>
      <title>先睹为快，Go2 Error 的挣扎之路</title>
      <link>http://shanks.link/blog/2021/04/14/%E5%85%88%E7%9D%B9%E4%B8%BA%E5%BF%ABgo2-error-%E7%9A%84%E6%8C%A3%E6%89%8E%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Wed, 14 Apr 2021 11:42:13 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/14/%E5%85%88%E7%9D%B9%E4%B8%BA%E5%BF%ABgo2-error-%E7%9A%84%E6%8C%A3%E6%89%8E%E4%B9%8B%E8%B7%AF/</guid>
      <description>&lt;h2 id=&#34;先睹为快go2-error-的挣扎之路&#34;&gt;先睹为快，Go2 Error 的挣扎之路&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/XILveKzh07BOQnqxYDKQsA&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;自从 Go 语言在国内火热以来，除去泛型，其次最具槽点的就是 Go 对错误的处理方式，一句经典的 &lt;code&gt;if err != nil&lt;/code&gt; 暗号就能认出你是一个 Go 语言爱好者。&lt;/p&gt;</description>
    </item>
    <item>
      <title>万字长文 | 从实践到原理，带你参透 gRPC</title>
      <link>http://shanks.link/blog/2021/04/13/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87-%E4%BB%8E%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86%E5%B8%A6%E4%BD%A0%E5%8F%82%E9%80%8F-grpc/</link>
      <pubDate>Tue, 13 Apr 2021 18:51:13 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/13/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87-%E4%BB%8E%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86%E5%B8%A6%E4%BD%A0%E5%8F%82%E9%80%8F-grpc/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/o-K7G9ywCdmW7et6Q4WMeA&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;万字长文--从实践到原理带你参透-grpc&#34;&gt;万字长文 | 从实践到原理，带你参透 gRPC&lt;/h2&gt;&#xA;&lt;p&gt;原创 陈煎鱼 &lt;a href=&#34;javascript:void(0);&#34;&gt;脑子进煎鱼了&lt;/a&gt; &lt;em&gt;2020-12-14&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。&lt;/p&gt;&#xA;&lt;p&gt;gRPC 在 Go 语言中大放异彩，越来越多的小伙伴在使用，最近也在公司安利了一波，希望这一篇文章能带你一览 gRPC 的巧妙之处，本文篇幅比较长，请做好阅读准备。&lt;/p&gt;</description>
    </item>
    <item>
      <title>必须要学的 Go 进程诊断工具 gops</title>
      <link>http://shanks.link/blog/2021/04/13/%E5%BF%85%E9%A1%BB%E8%A6%81%E5%AD%A6%E7%9A%84-go-%E8%BF%9B%E7%A8%8B%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-gops/</link>
      <pubDate>Tue, 13 Apr 2021 18:27:04 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/13/%E5%BF%85%E9%A1%BB%E8%A6%81%E5%AD%A6%E7%9A%84-go-%E8%BF%9B%E7%A8%8B%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-gops/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247484471&amp;amp;idx=1&amp;amp;sn=f61bd753ddc80e475b71a846bba799fa&amp;amp;chksm=f904116ace73987c48312fe6c01dfab3c7705d8e3b172986ccf1efe00d4bff630a366cfb766f&amp;amp;scene=178&amp;amp;cur_album_id=1515516076481101825#rd&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;必须要学的-go-进程诊断工具-gops&#34;&gt;必须要学的 Go 进程诊断工具 gops&lt;/h2&gt;&#xA;&lt;p&gt;在类 Unix 系统中，我们常常会使用 ps 命令来查看系统当前所运行的进程信息，该命令为我们提供了较大的帮助，能够快速的定位到某些进程的运行情况和状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>为什么 Go 占用那么多的虚拟内存？</title>
      <link>http://shanks.link/blog/2021/04/13/%E4%B8%BA%E4%BB%80%E4%B9%88-go-%E5%8D%A0%E7%94%A8%E9%82%A3%E4%B9%88%E5%A4%9A%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 13 Apr 2021 17:48:57 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/13/%E4%B8%BA%E4%BB%80%E4%B9%88-go-%E5%8D%A0%E7%94%A8%E9%82%A3%E4%B9%88%E5%A4%9A%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247484139&amp;amp;idx=1&amp;amp;sn=f1bd1793d2ae3d9ead1277807596b0b9&amp;amp;chksm=f90417b6ce739ea0e3d6bbb969708e92e2e958b721908791706c452fccd119c4add3c44292d4&amp;amp;scene=178&amp;amp;cur_album_id=1515516076481101825#rd&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。&lt;/p&gt;&#xA;&lt;p&gt;我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。&lt;/p&gt;</description>
    </item>
    <item>
      <title>详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？</title>
      <link>http://shanks.link/blog/2021/04/13/%E8%AF%A6%E8%A7%A3-go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%BD%A0%E7%9F%A5%E9%81%93-g0m0-%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97/</link>
      <pubDate>Tue, 13 Apr 2021 16:52:04 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/13/%E8%AF%A6%E8%A7%A3-go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%BD%A0%E7%9F%A5%E9%81%93-g0m0-%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/YK-TD3bZGEgqC0j-8U6VkQ&#34;&gt;转载自煎鱼的blog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;详解-go-程序的启动流程你知道-g0m0-是什么吗&#34;&gt;详解 Go 程序的启动流程，你知道 g0，m0 是什么吗？&lt;/h2&gt;&#xA;&lt;p&gt;大家好，我是煎鱼。&lt;/p&gt;&#xA;&lt;p&gt;自古应用程序均从 Hello World 开始，你我所写的 Go 语言亦然：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;import &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; main() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; fmt.Println(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;hello world.&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段程序的输出结果为 &lt;code&gt;hello world.&lt;/code&gt;，就是这么的简单又直接。但这时候又不禁思考了起来，这个 &lt;code&gt;hello world.&lt;/code&gt; 是怎么输出来，经历了什么过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go单例模式</title>
      <link>http://shanks.link/blog/2021/04/05/go%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 05 Apr 2021 12:09:42 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/05/go%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/JAlt0JQt8hkPCxYbmOMFJw&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Go语言中的单例模式&lt;/strong&gt;&#xA;在过去的几年中，Go语言的发展是惊人的，并且吸引了很多由其他语言（Python、PHP、Ruby）转向Go语言的跨语言学习者。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 切片与函数参数陷阱</title>
      <link>http://shanks.link/blog/2021/04/05/golang-%E5%88%87%E7%89%87%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%99%B7%E9%98%B1/</link>
      <pubDate>Mon, 05 Apr 2021 12:03:39 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/05/golang-%E5%88%87%E7%89%87%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%99%B7%E9%98%B1/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://studygolang.com/articles/9876&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;线性结构是计算机最常用的数据结构之一。无论是数组（arrary）还是链表（list），在编程中不可或缺。golang也有数组，不同于别的语言，golang还提供了切片（slice）。切片比数组有更好的灵活性，具有某些动态特性。然而切片又不像动态语言的列表（Python list）。不明白切片的基本实现，写程序的时候容易掉“坑”里。&#xA;&lt;strong&gt;slice参数&lt;/strong&gt;&#xA;本来写一个堆排序，使用了golang的slice来做堆，可是发现在pop数据的时候，切片不改变。进而引发了golang函数切片的参数，是传值还是传引用呢？我们知道slice相比array是引用类型。那么直觉上告诉我们如果函数修改了参数的切片，那么外层的切片变量也会变啦。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go 汇编入门 如何学习Golang？万字详文教你Go语言入门</title>
      <link>http://shanks.link/blog/2021/04/04/go-%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0golang%E4%B8%87%E5%AD%97%E8%AF%A6%E6%96%87%E6%95%99%E4%BD%A0go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 04 Apr 2021 21:15:18 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/go-%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0golang%E4%B8%87%E5%AD%97%E8%AF%A6%E6%96%87%E6%95%99%E4%BD%A0go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;p&gt;作者：&lt;a href=&#34;https://www.toutiao.com/i6882641627349778955/&#34;&gt;ivansli&lt;/a&gt;，腾讯开发工程师&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在深入学习 Golang 的 runtime 和标准库实现的时候发现，如果对 Golang 汇编没有一定了解的话，很难深入了解其底层实现机制。在这里整理总结了一份基础的 Golang 汇编入门知识，通过学习之后能够对其底层实现有一定的认识。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入浅出Go Runtime</title>
      <link>http://shanks.link/blog/2021/04/04/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAgo-runtime/</link>
      <pubDate>Sun, 04 Apr 2021 20:53:10 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAgo-runtime/</guid>
      <description>&lt;p&gt;以下内容转载自 &lt;a href=&#34;https://mp.weixin.qq.com/s/ivO-USpxiyrL-9BzgE8Vcg&#34;&gt;yifhao&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;介绍&lt;/p&gt;&#xA;&lt;p&gt;基于2019.02发布的go 1.12 linux amd64版本, 主要介绍了Runtime一些原理和实现的一些细节, 对大家容易不容易理解或者网络上很多错误的地方做一些梳理:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goroutine 的切换过程涉及了什么</title>
      <link>http://shanks.link/blog/2021/04/04/goroutine-%E7%9A%84%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%B6%89%E5%8F%8A%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sun, 04 Apr 2021 17:56:52 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/goroutine-%E7%9A%84%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%B6%89%E5%8F%8A%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;p&gt;GCTT:anxk Go语言中文网 &lt;a href=&#34;https://mp.weixin.qq.com/s/r0y4Fweq-YGo1FZrsNsl3A&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;点击上方蓝色“Go语言中文网”关注，每天一起学 Go&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/e0dda0b377c4e8f6c613e523208ae875.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Illustration created for “A Journey With Go”, made from the original Go Gopher, created by Renee French.&lt;/p&gt;&#xA;&lt;p&gt;本文基于 Go 1.13 版本。&lt;/p&gt;&#xA;&lt;p&gt;Goroutine 很轻，它只需要 2Kb 的内存堆栈即可运行。另外，它们运行起来也很廉价，将一个 Goroutine 切换到另一个的过程不牵涉到很多的操作。在深入 Goroutine 切换过程之前，让我们回顾一下 Goroutine 的切换在更高的层次上是如何进行的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go：Goroutine, OS线程 以及 CPU管理</title>
      <link>http://shanks.link/blog/2021/04/04/gogoroutine-os%E7%BA%BF%E7%A8%8B-%E4%BB%A5%E5%8F%8A-cpu%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 04 Apr 2021 17:22:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/gogoroutine-os%E7%BA%BF%E7%A8%8B-%E4%BB%A5%E5%8F%8A-cpu%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://studygolang.com/articles/24986?fr=sidebar&#34;&gt;中文翻译&lt;/a&gt; &lt;a href=&#34;https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a&#34;&gt;英文原文&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/ee06766dac7ef695b03463d38ad1b32f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;操作系统的线程创建以及切换是需要开销的，会影响程序的性能。Go致力于尽可能地从内核中获取优势，所以从最开始的时候设计就考虑到了并发性。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;M，P，G 编排&lt;/strong&gt;&#xA;为了解决这个问题，Go有他自己的调度者，负责在线程上分配goroutines。这个协调者由3个概念组成，如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>go g0,特殊的Goroutinue</title>
      <link>http://shanks.link/blog/2021/04/04/go-g0%E7%89%B9%E6%AE%8A%E7%9A%84goroutinue/</link>
      <pubDate>Sun, 04 Apr 2021 17:14:06 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/go-g0%E7%89%B9%E6%AE%8A%E7%9A%84goroutinue/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://studygolang.com/articles/28443&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;ℹ️ 这篇文章基于 Go 1.13。&lt;/p&gt;&#xA;&lt;p&gt;在 Go 中创建的所有 Goroutine 都会被一个内部的调度器所管理。Go 调度器尝试为所有的 Goroutine 分配运行时间，并且在当前的 Goroutine 阻塞或者终止的时候，Go 调度器会通过运行 Goroutine 的方式使所有 CPU 保持忙碌状态。这个调度器实际上是作为一个特殊的 Goroutine 运行的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Goroutine 数量控制在多少合适，会影响 GC 和调度？</title>
      <link>http://shanks.link/blog/2021/04/04/goroutine-%E6%95%B0%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9C%A8%E5%A4%9A%E5%B0%91%E5%90%88%E9%80%82%E4%BC%9A%E5%BD%B1%E5%93%8D-gc-%E5%92%8C%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Sun, 04 Apr 2021 17:02:42 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/goroutine-%E6%95%B0%E9%87%8F%E6%8E%A7%E5%88%B6%E5%9C%A8%E5%A4%9A%E5%B0%91%E5%90%88%E9%80%82%E4%BC%9A%E5%BD%B1%E5%93%8D-gc-%E5%92%8C%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;p&gt;大家好，我是煎鱼&lt;a href=&#34;https://mp.weixin.qq.com/s/uWP2X6iFu7BtwjIv5H55vw&#34;&gt;&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;前几天在读者交流群里看到一位小伙伴，发出了一个致命提问，那就是：“单机的 goroutine 数量控制在多少比较合适？”。&lt;/p&gt;&#xA;&lt;p&gt;也许你和群内小伙伴第一反应一样，会答复 “控制多少，我觉得没有定论”。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go高效内存分配</title>
      <link>http://shanks.link/blog/2021/04/04/go%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Sun, 04 Apr 2021 16:38:51 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/go%E9%AB%98%E6%95%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;手动内存管理真的很坑爹(如C C++)，好在我们有强大的自动化系统能够管理内存分配和生命周期，从而解放我们的双手。&lt;/p&gt;&#xA;&lt;p&gt;但是呢，如果你想通过调整JVM垃圾回收器参数或者是优化go代码的内存分配模式话来解决问题的话，这是远远不够的。自动化的内存管理帮我们规避了大部分的错误，但这只是故事的一半。我们必须要合理有效构建我们的软件，这样垃圾回收系统可以有效工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>详解Go逃逸分析</title>
      <link>http://shanks.link/blog/2021/04/04/%E8%AF%A6%E8%A7%A3go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 04 Apr 2021 16:15:00 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/%E8%AF%A6%E8%A7%A3go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;原文链接&lt;a href=&#34;https://juejin.cn/post/6917201712029630478&#34;&gt;机器铃砍菜刀&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Go是一门带有垃圾回收的现代语言，它抛弃了传统C/C++的开发者需要手动管理内存的方式，实现了内存的主动申请和释放的管理。Go的垃圾回收，让堆和栈的概念对程序员保持透明，它增加的逃逸分析与GC，使得程序员的双手真正地得到了解放，给了开发者更多的精力去关注软件设计本身。&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解golang调度之三：并发</title>
      <link>http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%89%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sun, 04 Apr 2021 00:42:03 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%89%E5%B9%B6%E5%8F%91/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;当我在解决一个问题尤其是新问题的时候，我开始不会去考虑并发(concurrency)是否合适。我首先会去找一系列的解决方式然后确保它有效。然后在可读性和技术方案评估之后，我会开始去考虑并发是否实际合理。有些时候并发的好处是显而易见的，但是有时候并不是很明显。&#xA;第一篇文章，我解释了OS调度器的相关内容，我觉得这部分对于你写多线程代码很重要。第二篇里，我讲解了一些Go调度器的一些内容，这部分对于你理解和写go的并发代码很有帮助。在这篇文章里，我会在OS和Go调度器层面让你去深层次的理解并发到底是什么。&#xA;这部分内容的目标是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解golang调度之二 ：Go调度器</title>
      <link>http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%BA%8C-go%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Sun, 04 Apr 2021 00:32:10 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%BA%8C-go%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;&lt;a href=&#34;https://juejin.cn/post/6844903846825705485&#34;&gt;原文链接&lt;/a&gt;&#xA;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;从一个程序开始&#34;&gt;第一篇文章解释了关于操作系统层级的调度，这对于理解Go的调度是很重要的。这一部分我会在语义层级解释Go调度器是如何工作的，并且着重关注它的一些高级特性。Go 调度器是一个十分复杂的系统，特别细节的地方不重要，重要的是对于它的工作模式有一个好的理解，这会让你做出更好的工程方面的决定。&#xA;&lt;strong&gt;从一个程序开始&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;当你的go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，如果你的处理器上每个物理内核有多个硬件线程（超线程），每个硬件线程对于你的go程序来说就是一个虚拟内核。为了理解这个事情，看一下我的MacBook Pro的系统配置。&#xA;图2.1&#xA;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/5/19/16acf54c9af604f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;&#34;&gt;&#xA;你可以看到一个单独处理器有4个物理核心。配置表上没说每个物理核心有多少个硬件线程。Intel Core i7 处理器有自己的超线程，也就是每个物理内核上有两个硬件线程。因此Go程序知道并行执行操作系统线程的时候，会有8个虚拟内核可以用&#xA;验证一下，看一下下面的程序&#xA;&lt;strong&gt;L1&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解golang调度之一 ：操作系统调度</title>
      <link>http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Sun, 04 Apr 2021 00:23:24 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;&lt;a href=&#34;https://juejin.im/post/6844903846284787719&#34;&gt;原文链接&lt;/a&gt;&#xA;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;操作系统调度器&#34;&gt;golang调度器的设计行为能够使你的多线程go程序更有效率、性能更好，这要归功于golang调度器对于操作系统调度器的支持。对于一个golang开发者来说，同时深刻理解操作系统调度和golang调度器工作原理，能够让你的golang程序设计和开发走到正确道路上。&#xA;&lt;strong&gt;操作系统调度器&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;执行指令&#34;&gt;操作系统调度器十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。&#xA;程序其实就是一系列按顺序执行的机器指令。为了能让其正常干活，操作系统使用了线程的概念。线程会处理和执行分配给它的一系列的机器指令。线程会一直执行这些机器指令，直到没有指令再去执行了。这也是为什么把线程称作&amp;quot;a path of execution&amp;quot;。&#xA;每个运行程序都会创建一个进程，每个进程都会有一个初始线程。线程能够创建更多的线程。这些不同的线程独立运行并且调度行为是线程级别决定的，而不是在进程级别。线程能够并发的执行(单独内核上每个线程会轮询占用一段cpu时间),而不是并行执行(在不同内核上同时执行)。线程同时会维持它自己的状态，并且能够在本地安全、独立地执行他自己的指令。这也说明了为什么线程是cpu调度的最小单位。&#xA;操作系统调度器，它负责确保在有线程能够运行的时候内核不会空闲下来。它会制造一种假象——所有能够跑的线程此时都在同时执行。为此，调度器需要优先执行高优先级的线程，但是它也必须保证低优先级的线程不会饿死。调度器也必须尽可能将调度延时压倒最少，。&#xA;好在许多算法的应用使得调度器更加高效。下面解释一些重要的概念。&#xA;&lt;strong&gt;执行指令&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;程序计数器(PC)，有时候也叫做指令指针(IP)，能够让你找到下一个要执行的指令。大部分的处理器里，PC指向下一个指令。&#xA;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/5/17/16ac61a45164982f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;&#34;&gt;&#xA;如果你曾经注意到go程序的追踪栈，你会注意到这些每一行末尾的16进制数字。例如Listing 1里的+0x39和+0x72&#xA;Listing 1&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 中的垃圾回收（一）</title>
      <link>http://shanks.link/blog/2021/04/03/golang-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%80/</link>
      <pubDate>Sat, 03 Apr 2021 23:41:35 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/golang-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903888177332237&#34;&gt;原文链接&lt;/a&gt;&#xA;垃圾回收器负责追踪堆内存的分配，释放掉不需要的空间，追踪那些还在使用的分配空间。不同编程语言对这个机制的实现都很复杂，但是开发人员开发软件时候并不需要了解垃圾回收太细节的东西就能进行构建。另外，不同发布版本编程语言的VM和runtime也总是在改变和进化。对于应用开发人员来说，重要的是保持一个良好的work模型，了解编程语言里垃圾回收器的行为并且它们是怎么样支持这种行为的。&#xA;对于go 1.12版本来说，go语言使用了非分代，并发的三色标记和清扫的回收器。如果想了解如何进行标记和清扫的工作，请参考这篇文章。golang的垃圾回收器的实现每个版本都在更新和进化。因此一旦下个版本发布，讲任何细节的实现都不再准确。&#xA;总而言之，这篇文章不会去讲实际的实现细节。我会为你分享回收器的一些行为并且去解释怎样面对这些行为，不考虑实现细节以及未来的改变。这将会使你成为一个更好的golang开发者&#xA;&lt;strong&gt;堆不是一个容器&lt;/strong&gt;&#xA;我不会把堆看做是一个可以存储或者是释放值的容器。理解这件事情很重要，内存里并没有明确定义了“堆”的一个分界线。任何应用程序预留的内存空间，在堆内存分配上是可用的。给定任何堆内存分配空间，它实际在虚拟内存还是物理内存上的存储位置和我们的模型并没有关联。理解这件事情会帮助你更好的理解垃圾回收模型的工作方式。&#xA;&lt;strong&gt;回收器行为&lt;/strong&gt;&#xA;当回收开始，回收器会完成三个阶段的工作。这其中两个阶段会产生Stop The World(STW) 延迟，并且另一个阶段也会产生延迟，并且会导致降低应用程序的吞吐量。这三个阶段是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>go 垃圾回收：三色算法</title>
      <link>http://shanks.link/blog/2021/04/03/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%89%E8%89%B2%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 03 Apr 2021 23:36:19 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%89%E8%89%B2%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903897253806088&#34;&gt;原文链接&lt;/a&gt;&#xA;三色算法&#xA;go垃圾回收器的操作都是基于三色算法，这篇文章主要来说明此算法。&lt;/p&gt;&#xA;&lt;p&gt;注意：三色算法并不是go独有的，它也会在其它编程语言中使用到&lt;/p&gt;&#xA;&lt;p&gt;严格来说，在Go中这个算法的官方名称是叫做&lt;strong&gt;三色标记清除算法&lt;/strong&gt;（tricolor mark-and-sweep algorithm）。它可以和程序一起并发工作并且使用&lt;strong&gt;写屏障&lt;/strong&gt;（write barrier）。这就意味着，当Go程序员运行起来，go调度器去负责应用程序的调度，而垃圾回收器会像调度器处理常规应用程序一样，去使用多个goroutines去进行工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入 Go Golang 内存分配超级棒的文章：Go 内存分配器可视化指南</title>
      <link>http://shanks.link/blog/2021/04/03/%E6%B7%B1%E5%85%A5-go-golang-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%B6%85%E7%BA%A7%E6%A3%92%E7%9A%84%E6%96%87%E7%AB%A0go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 03 Apr 2021 23:18:12 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/%E6%B7%B1%E5%85%A5-go-golang-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%B6%85%E7%BA%A7%E6%A3%92%E7%9A%84%E6%96%87%E7%AB%A0go-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.toutiao.com/i6777555732402274830/&#34;&gt;翻译地址&lt;/a&gt; &lt;a href=&#34;https://github.com/coldnight/go-memory-allocator-visual-guide&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;当我第一次开始尝试理解 Go 语言的内存分配器时，整个过程让我抓狂。一切看起来都像一个神秘的黑盒子。因为几乎所有技术魔法（technical wizardry）都隐藏在抽象之下，所以你需要一层一层的剥离才能去理解它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go 定时器 ticker和timer</title>
      <link>http://shanks.link/blog/2021/04/03/go-%E5%AE%9A%E6%97%B6%E5%99%A8-ticker%E5%92%8Ctimer/</link>
      <pubDate>Sat, 03 Apr 2021 23:13:19 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go-%E5%AE%9A%E6%97%B6%E5%99%A8-ticker%E5%92%8Ctimer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/lanyang123456/article/details/79794183&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;两种类型的定时器：ticker和timer。两者有什么区别呢？请看如下代码：&lt;/p&gt;&#xA;&lt;p&gt;ticker&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;package&lt;/span&gt; main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        d := time.&lt;span style=&#34;color:#c34e00&#34;&gt;Duration&lt;/span&gt;(time.Second*2)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        t := time.&lt;span style=&#34;color:#c34e00&#34;&gt;NewTicker&lt;/span&gt;(d)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;defer&lt;/span&gt; t.&lt;span style=&#34;color:#c34e00&#34;&gt;Stop&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#00f&#34;&gt;for&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &amp;lt;- t.C&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;timeout...&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;timeout…&#xA;timeout…&#xA;timeout…&lt;/p&gt;</description>
    </item>
    <item>
      <title>go 使用protobuf</title>
      <link>http://shanks.link/blog/2021/04/03/go-%E4%BD%BF%E7%94%A8protobuf/</link>
      <pubDate>Sat, 03 Apr 2021 23:03:31 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go-%E4%BD%BF%E7%94%A8protobuf/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000009277748&#34;&gt;原文链接&lt;/a&gt;发布于 2017-05-03&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;为什么要使用protobuf&lt;/strong&gt;&#xA;最近的项目中，一直使用Json做数据传输。Json用起来的确很方便。但相对于protobuf数据量更大些。做一个移动端应用，为用户省点流量还是很有必要的。正好也可以学习一下protobuf的使用&lt;/p&gt;</description>
    </item>
    <item>
      <title>How to Use Websockets in go</title>
      <link>http://shanks.link/blog/2021/04/03/how-to-use-websockets-in-go/</link>
      <pubDate>Sat, 03 Apr 2021 22:54:19 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/how-to-use-websockets-in-go/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://yalantis.com/blog/how-to-build-websockets-in-go/&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Sending a message and getting an instant response without refreshing the page is something we take for granted. But in the past, enabling real-time functionality was a real challenge for developers. The developer community has come a long way from HTTP long polling and AJAX and has finally found a solution for building truly real-time apps.&lt;/p&gt;&#xA;&lt;p&gt;This solution comes in the form of WebSockets, which make it possible to open an interactive session between a user’s browser and a server. WebSockets allow a browser to send messages to a server and receive event-driven responses without having to poll the server for a reply.&lt;/p&gt;</description>
    </item>
    <item>
      <title>go系统学习推荐书籍</title>
      <link>http://shanks.link/blog/2021/04/03/go%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%B1%8D/</link>
      <pubDate>Sat, 03 Apr 2021 22:36:26 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%B1%8D/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://tonybai.com/2020/11/04/the-recommend-books-list-for-learning-go/&#34;&gt;Tony Bai&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;一个程序员的心路历程&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Go语言的发展现状&#xA;如果从2007年9月20日那个下午三个“程序员大佬”在谷歌总部的一间办公室里进行的一次有关设计一门新编程语言的讨论算起，那么Go语言已经度过了自己的13个年头了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/2d81729a32d793d6a63a5a0ed77b953f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>go post请求常用的几种方式</title>
      <link>http://shanks.link/blog/2021/04/03/go-post%E8%AF%B7%E6%B1%82%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sat, 03 Apr 2021 22:31:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go-post%E8%AF%B7%E6%B1%82%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mofiu/article/details/79925994&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;post请求常用的几种方式，记录一下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;httpPost&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    resp, err := http.&lt;span style=&#34;color:#c34e00&#34;&gt;Post&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;https://www.abcd123.top/api/v1/login&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;application/x-www-form-urlencoded&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        strings.&lt;span style=&#34;color:#c34e00&#34;&gt;NewReader&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;username=test&amp;amp;password=ab123123&amp;#34;&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;defer&lt;/span&gt; resp.Body.&lt;span style=&#34;color:#c34e00&#34;&gt;Close&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    body, err := ioutil.&lt;span style=&#34;color:#c34e00&#34;&gt;ReadAll&lt;/span&gt;(resp.Body)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;// handle error&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(string(body))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;httpPostForm&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    resp, err := http.&lt;span style=&#34;color:#c34e00&#34;&gt;PostForm&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;https://www.denlery.top/api/v1/login&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        url.Values{&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;: {&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;}, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;: {&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;auto123123&amp;#34;&lt;/span&gt;}})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;// handle error&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;defer&lt;/span&gt; resp.Body.&lt;span style=&#34;color:#c34e00&#34;&gt;Close&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    body, err := ioutil.&lt;span style=&#34;color:#c34e00&#34;&gt;ReadAll&lt;/span&gt;(resp.Body)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;// handle error&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(string(body))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;httpPostJson&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    jsonStr :=[]byte(&lt;span style=&#34;color:#009c00&#34;&gt;`{ &amp;#34;username&amp;#34;: &amp;#34;auto&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;auto123123&amp;#34; }`&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    url:= &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;https://www.denlery.top/api/v1/login&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    req, err := http.&lt;span style=&#34;color:#c34e00&#34;&gt;NewRequest&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;POST&amp;#34;&lt;/span&gt;, url, bytes.&lt;span style=&#34;color:#c34e00&#34;&gt;NewBuffer&lt;/span&gt;(jsonStr))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    req.Header.&lt;span style=&#34;color:#c34e00&#34;&gt;Set&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;Content-Type&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;application/json&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    client := &amp;amp;http.Client{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    resp, err := client.&lt;span style=&#34;color:#c34e00&#34;&gt;Do&lt;/span&gt;(req)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;if&lt;/span&gt; err != &lt;span style=&#34;color:#00f&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f00;font-style:italic&#34;&gt;// handle error&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;defer&lt;/span&gt; resp.Body.&lt;span style=&#34;color:#c34e00&#34;&gt;Close&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    statuscode := resp.StatusCode&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    hea := resp.Header&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    body, _ := ioutil.&lt;span style=&#34;color:#c34e00&#34;&gt;ReadAll&lt;/span&gt;(resp.Body)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(string(body))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(statuscode)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(hea)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>go中的init函数以及main函数</title>
      <link>http://shanks.link/blog/2021/04/03/go%E4%B8%AD%E7%9A%84init%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8Amain%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 03 Apr 2021 22:27:14 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E4%B8%AD%E7%9A%84init%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8Amain%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/TimLiuDream/p/9929934.html&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;首先我们看一个例子：init函数：&lt;/p&gt;&#xA;&lt;p&gt;init 函数可在package main中，可在其他package中，可在同一个package中出现多次。&lt;/p&gt;&#xA;&lt;p&gt;main函数&lt;/p&gt;</description>
    </item>
    <item>
      <title>go 语言中关于包导入必学的8个知识点</title>
      <link>http://shanks.link/blog/2021/04/03/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%8C%85%E5%AF%BC%E5%85%A5%E5%BF%85%E5%AD%A6%E7%9A%848%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sat, 03 Apr 2021 22:21:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%8C%85%E5%AF%BC%E5%85%A5%E5%BF%85%E5%AD%A6%E7%9A%848%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>&lt;p&gt;Hi，大家好，我是明哥&lt;a href=&#34;https://juejin.im/post/6844904167073382408&#34;&gt;&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;在自己学习 Golang 的这段时间里，我写了详细的学习笔记放在我的个人微信公众号 《Go编程时光》，对于 Go 语言，我也算是个初学者，因此写的东西应该会比较适合刚接触的同学，如果你也是刚学习 Go 语言，不防关注一下，一起学习，一起成长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go struct详解</title>
      <link>http://shanks.link/blog/2021/04/03/go-struct%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 03 Apr 2021 22:15:06 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go-struct%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;Go Struct超详细讲解&#xA;原创作者，&lt;a href=&#34;https://juejin.im/post/6844903814168838151&#34;&gt;程序员读书&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;Go语言中提供了对struct的支持,struct,中文翻译称为结构体，与数组一样，属于复合类型，并非引用类型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 中的垃圾回收（三)</title>
      <link>http://shanks.link/blog/2021/04/04/golang-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%89/</link>
      <pubDate>Sun, 04 Apr 2021 00:07:15 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/04/04/golang-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903902924521485&#34;&gt;原文链接&lt;/a&gt;&#xA;通过前两节的说明，我们得出这样一个结论：如果降低堆内存的分配压力就会相应的减少延迟，从而提升程序性能。这一节来讲一下，给一种类型的工作负载，GC的pacing算法是怎么来确定最佳回收速率的。&#xA;&lt;strong&gt;并发代码实例&lt;/strong&gt;&#xA;本节给出的代码在这里可以找到：&#xA;&lt;a href=&#34;https://github.com/ardanlabs/gotraining/tree/master/topics/go/profiling/trace&#34;&gt;github.com/ardanlabs/g…&lt;/a&gt;&#xA;程序是做了这样一件事情，给一个特定topic，要确定它在文档集中出现的频率。程序包含了不用版本的寻找算法，它们使用了不同的并发模式。这里我们只看freq，freqConcurrent和freqNumCPU这三种版本的算法。&#xA;首先看freq，它是非并发顺序执行的程序版本，代码如下。&#xA;L1&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 中的垃圾回收（二)</title>
      <link>http://shanks.link/blog/2021/04/03/golang-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BA%8C/</link>
      <pubDate>Sat, 03 Apr 2021 23:57:23 +0800</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/golang-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903892212269064&#34;&gt;原文链接&lt;/a&gt;&#xA;第一部分，我花了时间去描述了golang 垃圾收集器的行为，并说明了程序运行时候收集器所产生的延迟。我分享了怎么样去产生以及去解释GC traces。并展示了堆内内存如何改变，并且解释了GC不同阶段对延迟代价的影响。&#xA;最后的结论是，如果你减少了堆的压力，你就会减少延迟代价并提高了程序性能。我也指出了，降低收集速率，推迟收集，设法增加两次收集的时间间隔并不是很好的策略。即使是收集速率很快，但是以一致的速度进行，也能保持程序以最佳性能运行。&#xA;这部分里，我会带你通过一个实际的web应用并向你展示怎么样生成GC traces和程序状态。然后我会解释这些工具的输出内容，这样你可以找到方法去提高应用程序的性能。&#xA;&lt;strong&gt;运行应用&lt;/strong&gt;&#xA;看一下go training的web应用程序&#xA;图1.1&#xA;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/7/18/16c03b402f24c06a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;&#34;&gt;&#xA;&lt;a href=&#34;https://github.com/ardanlabs/gotraining/tree/master/topics/go/profiling/project&#34;&gt;github.com/ardanlabs/g…&lt;/a&gt;&#xA;图一是应用程序的样子。这个程序从不同的地方下载三个rss 订阅集合，并且允许用户去进行搜索。build之后，启动程序&#xA;&lt;strong&gt;L1&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言panic,recover的实现</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80panicrecover%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 03 Apr 2021 14:26:05 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80panicrecover%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw&#34;&gt;源码游记&lt;/a&gt; 2019-07-02&lt;/p&gt;&#xA;&lt;p&gt;本文主要分析Go语言的panic/recover在AMD64 Linux平台下的实现，包括：&lt;/p&gt;&#xA;&lt;p&gt;主动调用 panic() 函数所引发的panic的处理流程，比如go代码中直接调用panic()函数或编译器插入的对panic()的调用；&lt;/p&gt;</description>
    </item>
    <item>
      <title>go深入理解defer（下）defer实现机制</title>
      <link>http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Bdefer%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 03 Apr 2021 11:33:30 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Bdefer%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g&#34;&gt;源码游记&lt;/a&gt; 2019-06-17&lt;/p&gt;&#xA;&lt;p&gt;上一篇文章我们主要从使用的角度介绍了 defer 的基础知识，本文我们来分析一下 defer 的实现机制。&lt;/p&gt;&#xA;&lt;p&gt;还是从一个例子程序开始。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;package&lt;/span&gt; main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;sum&lt;/span&gt;(a, b &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c := a + b&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;sum:&amp;#34;&lt;/span&gt; , c)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;f&lt;/span&gt;(a, b &lt;span style=&#34;color:#00f&#34;&gt;int&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00f&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;sum&lt;/span&gt;(a, b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    fmt.&lt;span style=&#34;color:#c34e00&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#009c00&#34;&gt;&amp;#34;a: %d, b: %d\n&amp;#34;&lt;/span&gt;, a, b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#00f&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#c34e00&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a, b := 1, 2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#c34e00&#34;&gt;f&lt;/span&gt;(a, b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从前一篇文章我们得知，编译器会把 defer 语句翻译成对 deferproc 函数的调用，同时，编译器也会在使用了 defer 语句的 go 函数的末尾插入对 deferreturn 函数的调用，下面我们来看一下这两个函数的实现代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go深入理解defer（上）defer基础</title>
      <link>http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Adefer%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 03 Apr 2021 11:04:11 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Adefer%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/QmeQTONUuWlr_sRNP8b5Tw&#34;&gt;源码游记&lt;/a&gt; 2019-06-11&lt;/p&gt;&#xA;&lt;p&gt;深入理解 defer 分上下两篇文章，本文为上篇，主要介绍如下内容：&lt;/p&gt;&#xA;&lt;p&gt;为什么需要 defer；&lt;/p&gt;&#xA;&lt;p&gt;defer 语法及语义；&lt;/p&gt;&#xA;&lt;p&gt;defer 使用要点；&lt;/p&gt;&#xA;&lt;p&gt;defer 语句中的函数到底是在 return 语句之后被调用还是 return 语句之前被调用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>抢占系统调用执行时间过长的goroutine（22）</title>
      <link>http://shanks.link/blog/2021/04/03/%E6%8A%A2%E5%8D%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E7%9A%84goroutine22/</link>
      <pubDate>Sat, 03 Apr 2021 10:37:43 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/%E6%8A%A2%E5%8D%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E7%9A%84goroutine22/</guid>
      <description>&lt;p&gt;​​​​​​​​​原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/If0-35Pt8dN7G1gD4L9-hw&#34;&gt;源码游记&lt;/a&gt; 2019-06-01&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第22篇，也是第六章《抢占调度》的第2小节。&lt;/p&gt;&#xA;&lt;p&gt;上一节我们分析了因运行时间过长而导致的抢占调度，这一节我们来分析因进入系统调用时间过长而发生的抢占调度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>因goroutine运行时间过长而发生的抢占调度（21）</title>
      <link>http://shanks.link/blog/2021/04/03/%E5%9B%A0goroutine%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E8%80%8C%E5%8F%91%E7%94%9F%E7%9A%84%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A621/</link>
      <pubDate>Sat, 03 Apr 2021 10:34:06 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/%E5%9B%A0goroutine%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E8%80%8C%E5%8F%91%E7%94%9F%E7%9A%84%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A621/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/i8DQ0HrO5Bt-qE5cX7c1ng&#34;&gt;源码游记&lt;/a&gt; 2019-05-28&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第21篇，也是第六章《抢占调度》的第1小节。&lt;/p&gt;&#xA;&lt;p&gt;前面几节我们分析了Goroutine因读写channel等阻塞而导致的被动调度以及通过调用Gosched函数发起的主动调度，现在还剩下最后一种调度方式即抢占调度未讨论，从本节开始，我们就来对它进行分析。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器之主动调度(20)</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A620/</link>
      <pubDate>Sat, 03 Apr 2021 10:29:25 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A620/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/zA7KY_25NGjip9pP38RIvg&#34;&gt;源码游记&lt;/a&gt; 2019-05-24&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第20篇，也是第五章《主动调度》的第1小节。&lt;/p&gt;&#xA;&lt;p&gt;Goroutine的主动调度是指当前正在运行的goroutine通过直接调用runtime.Gosched()函数暂时放弃运行而发生的调度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>工作线程的唤醒及创建(19)</title>
      <link>http://shanks.link/blog/2021/04/03/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92%E5%8F%8A%E5%88%9B%E5%BB%BA19/</link>
      <pubDate>Sat, 03 Apr 2021 10:24:35 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92%E5%8F%8A%E5%88%9B%E5%BB%BA19/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/T9CDaNF5KUFjE_Z6YW7mRw&#34;&gt;源码游记&lt;/a&gt; 2019-05-23&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第19篇，也是第四章《Goroutine被动调度》的第2小节。&lt;/p&gt;&#xA;&lt;p&gt;本文需要重点关注：&lt;/p&gt;</description>
    </item>
    <item>
      <title>goroutine被动调度之一（18）</title>
      <link>http://shanks.link/blog/2021/04/03/goroutine%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%8018/</link>
      <pubDate>Sat, 03 Apr 2021 10:21:58 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/goroutine%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%8018/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/w3i5hVKmYW_M06nLaMlwvQ&#34;&gt;源码游记&lt;/a&gt; 2019-05-22&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第18篇，也是第四章《Goroutine被动调度》的第1小节。&lt;/p&gt;&#xA;&lt;p&gt;前一章我们详细分析了调度器的调度策略，即调度器如何选取下一个进入运行的goroutine，但我们还不清楚什么时候以及什么情况下会发生调度，从这一章开始我们就来讨论这个问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器之盗取goroutine(17)</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E7%9B%97%E5%8F%96goroutine17/</link>
      <pubDate>Sat, 03 Apr 2021 10:14:00 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E7%9B%97%E5%8F%96goroutine17/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/o2UmxmFFOwUAkgE-Ao9MsA&#34;&gt;源码游记&lt;/a&gt; 2019-05-17&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第17篇，也是第三章《Goroutine调度策略》的第2小节。&lt;/p&gt;&#xA;&lt;p&gt;上一小节我们分析了从全局运行队列与工作线程的本地运行队列获取goroutine的过程，这一小节我们继续分析因无法从上述两个队列中拿到需要运行的goroutine而导致的从其它工作线程的本地运行队列中盗取goroutine的过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>第三章 goroutine调度策略（16）</title>
      <link>http://shanks.link/blog/2021/04/03/%E7%AC%AC%E4%B8%89%E7%AB%A0-goroutine%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A516/</link>
      <pubDate>Sat, 03 Apr 2021 10:12:03 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/%E7%AC%AC%E4%B8%89%E7%AB%A0-goroutine%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A516/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/2objs5JrlnKnwFbF4a2z2g&#34;&gt;源码游记&lt;/a&gt; 2019-05-14&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第16篇，也是第三章《Goroutine调度策略》的第1小节。&lt;/p&gt;&#xA;&lt;p&gt;在调度器概述一节我们提到过，所谓的goroutine调度，是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到CPU上去运行的过程。这句话揭示了调度系统需要解决的三大核心问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>非main goroutine的退出及调度循环（15）</title>
      <link>http://shanks.link/blog/2021/04/03/%E9%9D%9Emain-goroutine%E7%9A%84%E9%80%80%E5%87%BA%E5%8F%8A%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF15/</link>
      <pubDate>Sat, 03 Apr 2021 10:07:03 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/%E9%9D%9Emain-goroutine%E7%9A%84%E9%80%80%E5%87%BA%E5%8F%8A%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF15/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/XttP9q7-PO7VXhskaBzGqA&#34;&gt;源码游记&lt;/a&gt; 2019-05-12&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第15篇，也是第二章的第5小节。&lt;/p&gt;&#xA;&lt;p&gt;上一节我们说过main goroutine退出时会直接执行exit系统调用退出整个进程，而非main goroutine退出时则会进入goexit函数完成最后的清理工作，本小节我们首先就来验证一下非main goroutine执行完成后是否真的会去执行goexit，然后再对非main goroutine的退出流程做个梳理。这一节我们需要重点理解以下内容：&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器之调度main goroutine（14)</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E8%B0%83%E5%BA%A6main-goroutine14/</link>
      <pubDate>Sat, 03 Apr 2021 10:01:28 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E8%B0%83%E5%BA%A6main-goroutine14/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/8eJm5hjwKXya85VnT4y8Cw&#34;&gt;源码游记&lt;/a&gt; 2019-05-09&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第14篇，也是第二章的第4小节&lt;/p&gt;&#xA;&lt;p&gt;上一节我们通过分析main goroutine的创建详细讨论了goroutine的创建及初始化流程，这一节我们接着来分析调度器如何把main goroutine调度到CPU上去运行。本节需要重点关注的问题有：&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器之创建main goroutine(13)</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E5%88%9B%E5%BB%BAmain-goroutine13/</link>
      <pubDate>Sat, 03 Apr 2021 09:53:43 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E5%88%9B%E5%BB%BAmain-goroutine13/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/FF8YU8nXP9TKt0qvSuzmtw&#34;&gt;源码游记&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第13篇，也是第二章的第3小节。&lt;/p&gt;&#xA;&lt;p&gt;上一节我们分析了调度器的初始化，这一节我们来看程序中的第一个goroutine是如何创建的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言goroutine调度器初始化 十二</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%81%E4%BA%8C/</link>
      <pubDate>Sat, 03 Apr 2021 00:23:53 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%81%E4%BA%8C/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/W9D4Sl-6jYfcpczzdPfByQ&#34;&gt;源码游记&lt;/a&gt; 2019-05-05&lt;/p&gt;&#xA;&lt;h2 id=&#34;本文是go语言调度器源代码情景分析系列的第12篇也是第二章的第2小节&#34;&gt;本文是《Go语言调度器源代码情景分析》系列的第12篇，也是第二章的第2小节。&lt;/h2&gt;&#xA;&lt;p&gt;本章将以下面这个简单的Hello World程序为例，通过跟踪其从启动到退出这一完整的运行流程来分析Go语言调度器的初始化、goroutine的创建与退出、工作线程的调度循环以及goroutine的切换等重要内容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>goroutine调度器概述(11)</title>
      <link>http://shanks.link/blog/2021/04/03/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E6%A6%82%E8%BF%B011/</link>
      <pubDate>Sat, 03 Apr 2021 00:13:50 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E6%A6%82%E8%BF%B011/</guid>
      <description>&lt;p&gt;原创 &lt;strong&gt;爱写程序的阿波张&lt;/strong&gt; &lt;a href=&#34;https://mp.weixin.qq.com/s/2wkZyOFAyhHgvNkEkXamkQ&#34;&gt;源码游记&lt;/a&gt; 2019-05-01&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;本文是《go调度器源代码情景分析》系列的第11篇，也是第二章的第1小节。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;goroutine简介&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;goroutine是Go语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题，所谓的太重，主要表现在以下两个方面：&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之十：线程本地存储</title>
      <link>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%8D%81%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sat, 03 Apr 2021 00:09:46 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%8D%81%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</guid>
      <description>&lt;p&gt;原创 &lt;strong&gt;爱写程序的阿波张&lt;/strong&gt; &lt;a href=&#34;https://mp.weixin.qq.com/s/-tiXJpH0IrJw-RH4x5SRdQ&#34;&gt;源码游记&lt;/a&gt; 2019-04-27&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;本文是《go调度器源代码情景分析》系列 第一章 预备知识的第十小节，也是预备知识的最后一小节。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;线程本地存储又叫线程局部存储，其英文为Thread Local Storage，简称TLS，看似一个很高大上的东西，其实就是线程私有的全局变量而已。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之八：系统调用</title>
      <link>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%85%AB%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Fri, 02 Apr 2021 13:13:55 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%85%AB%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>&lt;h1 id=&#34;原创-爱写程序的阿波张-源码游记-2019-04-24&#34;&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/CXhc71UZtbdbAo15xbJ6_Q&#34;&gt;源码游记&lt;/a&gt; 2019-04-24&lt;/h1&gt;&#xA;&lt;p&gt;我们将在最后一章讨论有关系统调用方面的抢占调度，所以这里有必要对系统调用有个基本的了解。&lt;/p&gt;&#xA;&lt;p&gt;系统调用是指使用类似函数调用的方式调用操作系统提供的API。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之七：函数调用过程</title>
      <link>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%83%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 02 Apr 2021 13:00:41 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%83%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/3RUjui-q6bgRnUW7TgOjmA&#34;&gt;源码游记&lt;/a&gt; 2019-04-22&lt;/p&gt;&#xA;&lt;p&gt;前面几节我们介绍了CPU寄存器、内存、汇编指令以及栈等基础知识，为了达到融会贯通加深理解的目的，这一节我们来综合运用一下所学知识，看看函数的执行和调用过程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之六：go汇编语言</title>
      <link>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%85%ADgo%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Fri, 02 Apr 2021 12:54:48 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%85%ADgo%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/dNzLMtn1X7dBvtkfX7Ifag&#34;&gt;源码游记&lt;/a&gt; 2019-04-21&lt;/p&gt;&#xA;&lt;p&gt;go语言runtime（包括调度器）源代码中有部分代码是用汇编语言编写的，不过这些汇编代码并非针对特定体系结构的汇编代码，而是go语言引入的一种伪汇编，它同样也需要经过汇编器转换成机器指令才能被CPU执行。需要注意的是，用go汇编语言编写的代码一旦经过汇编器转换成机器指令之后，再用调试工具反汇编出来的代码已经不是go语言汇编代码了，而是跟平台相关的汇编代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之五：汇编指令</title>
      <link>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%94%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Fri, 02 Apr 2021 12:47:46 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/02/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%94%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</guid>
      <description>&lt;p&gt;原创 爱写程序的阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/fuox6st_iXg_rpklxWXXRA&#34; title=&#34;源码游记&#34;&gt;源码游记&lt;/a&gt; 2019-04-20&lt;/p&gt;&#xA;&lt;p&gt;汇编语言是每位后端程序员都应该掌握的一门语言，因为学会了汇编语言，不管是对我们调试程序还是研究与理解计算机底层的一些运行原理都具有非常重要的作用，所以建议有兴趣的读者可以多花点时间把它学好。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之四：函数调用栈</title>
      <link>http://shanks.link/blog/2021/04/01/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%9B%9B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</link>
      <pubDate>Thu, 01 Apr 2021 23:52:57 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/01/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E5%9B%9B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</guid>
      <description>&lt;p&gt;原创 阿波张 &lt;a href=&#34;https://mp.weixin.qq.com/s/EY1acVrkUnmFQ0E1IwLzUQ&#34; title=&#34;源码游记&#34;&gt;源码游记&lt;/a&gt; 2019-04-19&lt;/p&gt;&#xA;&lt;p&gt;什么是栈&lt;/p&gt;&#xA;&lt;p&gt;栈是一种“后进先出”的数据结构，它相当于一个容器，当需要往容器里面添加元素时只能放在最上面的一个元素之上，需要取出元素时也只能从最上面开始取，通常我们称添加元素为入栈(push)，取出元素为出栈(pop)。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之三：内存</title>
      <link>http://shanks.link/blog/2021/04/01/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%89%E5%86%85%E5%AD%98/</link>
      <pubDate>Thu, 01 Apr 2021 23:32:28 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/01/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%89%E5%86%85%E5%AD%98/</guid>
      <description>&lt;p&gt;原创 张方波 &lt;a href=&#34;https://mp.weixin.qq.com/s/iZxfTL34NFKsJNyLvREZPQ&#34; title=&#34;源码游记&#34;&gt;源码游记&lt;/a&gt; 2019-04-18&lt;/p&gt;&#xA;&lt;p&gt;内存是计算机系统的存储设备，其主要作用是协助CPU在执行程序时存储数据和指令。&lt;/p&gt;&#xA;&lt;p&gt;内存由大量内存单元组成，内存单元大小为1个字节（1字节包含8个二进制位）， 每个内存单元都有一个编号，更专业的说法是每一个内存单元都有一个地址，我们在编写汇编代码或编译器把用高级语言所写的程序编译成汇编指令时，如果要读写内存，就必须在指令中指定内存地址，这样CPU才知道它要存取哪个或哪些内存单元。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析之二：CPU寄存器</title>
      <link>http://shanks.link/blog/2021/04/01/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8Ccpu%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Thu, 01 Apr 2021 23:26:01 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/04/01/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E4%B9%8B%E4%BA%8Ccpu%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description>&lt;p&gt;原创 张方波 &lt;a href=&#34;https://mp.weixin.qq.com/s/wTfbFfBfTJNGsgIJ_71nAg&#34; title=&#34;源码游记&#34;&gt;源码游记&lt;/a&gt; 2019-04-17&lt;/p&gt;&#xA;&lt;p&gt;寄存器是CPU内部的存储单元，用于存放从内存读取而来的数据（包括指令）和CPU运算的中间结果，之所以要使用寄存器来临时存放数据而不是直接操作内存，一是因为CPU的工作原理决定了有些操作运算只能在CPU内部进行，二是因为CPU读写寄存器的速度比读写内存的速度快得多。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言调度器源代码情景分析1</title>
      <link>http://shanks.link/blog/2021/03/31/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%901/</link>
      <pubDate>Wed, 31 Mar 2021 14:18:56 +0000</pubDate>
      <guid>http://shanks.link/blog/2021/03/31/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%901/</guid>
      <description>&lt;p&gt;原创 张方波  源码游记  2019-04-16&#xA;专栏简介&lt;/p&gt;&#xA;&lt;p&gt;本专栏以精心设计的情景为线索，结合go语言最新1.12版源代码深入细致的分析了goroutine调度器实现原理。&lt;/p&gt;&#xA;&lt;p&gt;适宜读者&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
