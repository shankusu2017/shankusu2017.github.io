<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 愿星光伴随你左右</title>
    <link>http://shanks.link/categories/linux/</link>
    <description>Recent content in Linux on 愿星光伴随你左右</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 16 Apr 2024 14:28:20 +0800</lastBuildDate>
    <atom:link href="http://shanks.link/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux进程间通信7：数据报套接字 socket()、bind()、sendto()、recvfrom()、close()</title>
      <link>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A17%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97-socketbindsendtorecvfromclose/</link>
      <pubDate>Tue, 16 Apr 2024 14:28:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A17%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97-socketbindsendtorecvfromclose/</guid>
      <description>&lt;p&gt;前一篇文章，&lt;a href=&#34;http://shanks.link/blog/2024/04/16/linux%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a16-%e6%b5%81%e5%a5%97%e6%8e%a5%e5%ad%97-socketbindlistenacceptconnectreadwriteclose/&#34;&gt;Linux进程间通信——使用流套接字&lt;/a&gt;介绍了一些有关socket（套接字）的一些基本内容，并讲解了流套接字的使用，这篇文章将会给大家讲讲，数据报套接字的使用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一简单回顾什么是数据报套接字&#34;&gt;一、简单回顾——什么是数据报套接字&lt;/h3&gt;&#xA;&lt;p&gt;socket，即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux进程间通信6 流套接字 socket bind listen accept connect read write close</title>
      <link>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A16-%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97-socket-bind-listen-accept-connect-read-write-close/</link>
      <pubDate>Tue, 16 Apr 2024 11:53:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A16-%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97-socket-bind-listen-accept-connect-read-write-close/</guid>
      <description>&lt;p&gt;前面说到的进程间的通信，所通信的进程都是在同一台计算机上的，而使用socket进行通信的进程可以是同一台计算机的进程，也是可以是通过网络连接起来的不同计算机上的进程。通常我们使用socket进行网络编程，这里将会简单地讲述如何使用socket进行简单的网络编程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信5 消息队列 msgget、msgsend、msgrcv、msgctl</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A15-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-msggetmsgsendmsgrcvmsgctl/</link>
      <pubDate>Tue, 16 Apr 2024 11:41:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A15-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-msggetmsgsendmsgrcvmsgctl/</guid>
      <description>&lt;p&gt;下面来说说如何用不用消息队列来进行进程间的通信，消息队列与命名管道有很多相似之处。有关命名管道的更多内容可以参阅我的另一篇文章：&lt;a href=&#34;http://shanks.link/blog/2024/04/16/%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a12-%e6%9c%89%e5%90%8d%e7%ae%a1%e9%81%93/&#34;&gt;Linux进程间通信 &amp;ndash; 使用命名管道&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信4 共享内存 shmget shmat shmdt shmctl</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A14-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shmget-shmat-shmdt-shmctl/</link>
      <pubDate>Tue, 16 Apr 2024 11:19:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A14-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shmget-shmat-shmdt-shmctl/</guid>
      <description>&lt;p&gt;下面将讲解进程间通信的另一种方式，使用共享内存。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一什么是共享内存&#34;&gt;一、什么是共享内存&lt;/h3&gt;&#xA;&lt;p&gt;顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc()分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信3 信号量 semget、semop、semctl</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A13-%E4%BF%A1%E5%8F%B7%E9%87%8F-semgetsemopsemctl/</link>
      <pubDate>Tue, 16 Apr 2024 10:49:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A13-%E4%BF%A1%E5%8F%B7%E9%87%8F-semgetsemopsemctl/</guid>
      <description>&lt;p&gt;这篇文章将讲述别一种进程间通信的机制——信号量。注意请不要把它与之前所说的信号混淆起来，信号与信号量是不同的两种事物。有关信号的更多内容，可以阅读我的另一篇文章：&lt;a href=&#34;http://www.cnblogs.com/52php/p/5813867.html&#34;&gt;Linux进程间通信 &amp;ndash; 信号&lt;/a&gt;。下面就进入信号量的讲解。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信2 有名管道 mkfifo、open、read、close</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-mkfifoopenreadclose/</link>
      <pubDate>Tue, 16 Apr 2024 09:56:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-mkfifoopenreadclose/</guid>
      <description>&lt;p&gt;在前一篇文章—— &lt;a href=&#34;http://shanks.link/blog/2024/04/15/%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a12-%e5%8c%bf%e5%90%8d%e7%ae%a1%e9%81%93/&#34;&gt;Linux进程间通信 &amp;ndash; 使用匿名管道&lt;/a&gt; 中，我们看到了如何使用匿名管道来在进程之间传递数据，同时也看到了这个方式的一个缺陷，就是这些进程都由一个共同的祖先进程启动，这给我们在不相关的的进程之间交换数据带来了不方便。这里将会介绍进程的另一种通信方式——命名管道，来解决不相关进程间的通信问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信2 匿名管道 popen、pclose、pipe、close、dup、dup2</title>
      <link>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-popenpclosepipeclosedupdup2/</link>
      <pubDate>Mon, 15 Apr 2024 17:17:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-popenpclosepipeclosedupdup2/</guid>
      <description>&lt;p&gt;在前面，介绍了一种进程间的通信方式：使用信号，我们创建通知事件，并通过它引起响应，但传递的信息只是一个信号值。这里将介绍另一种进程间通信的方式——匿名管道，通过它进程间可以交换更多有用的数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信1 信号  signal、sigaction</title>
      <link>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7-signalsigaction/</link>
      <pubDate>Mon, 15 Apr 2024 16:51:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7-signalsigaction/</guid>
      <description>&lt;h3 id=&#34;一什么是信号&#34;&gt;一、什么是信号&lt;/h3&gt;&#xA;&lt;p&gt;用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的功能在Linux上是通过生成信号和捕获信号来实现的，运行中的进程捕获到这个信号然后作出一定的操作并最终被终止。&lt;/p&gt;</description>
    </item>
    <item>
      <title>进程间通信1 信号之信号集函数 sigemptyset()、sigprocmask()、sigpending()、sigsuspend()</title>
      <link>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0-sigemptysetsigprocmasksigpendingsigsuspend/</link>
      <pubDate>Mon, 15 Apr 2024 16:51:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0-sigemptysetsigprocmasksigpendingsigsuspend/</guid>
      <description>&lt;p&gt;我们已经知道，我们可以通过信号来终止进程，也可以通过信号来在进程间进行通信，程序也可以通过指定信号的关联处理函数来改变信号的默认处理方式，也可以屏蔽某些信号，使其不能传递给进程。那么我们应该如何设定我们需要处理的信号，我们不需要处理哪些信号等问题呢？信号集函数就是帮助我们解决这些问题的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux线程与信号</title>
      <link>http://shanks.link/blog/2023/09/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Fri, 22 Sep 2023 10:13:44 +0800</pubDate>
      <guid>http://shanks.link/blog/2023/09/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7/</guid>
      <description>&lt;h3 id=&#34;信号与线程的关系&#34;&gt;&lt;strong&gt;信号与线程的关系&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;POSIX标准对&lt;a href=&#34;https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;amp;spm=1001.2101.3001.7020&#34;&gt;多线程&lt;/a&gt;情况下的信号机制提出了一些要求：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;信号处理函数必须在多线程进程的&lt;strong&gt;所有线程之间共享&lt;/strong&gt;， 但是每个线程要有自己的挂起信号集合和阻塞信号掩码。&lt;/li&gt;&#xA;&lt;li&gt;POSIX函数kill/sigqueue必须面向进程， 而不是进程下的某个特定的线程。&lt;/li&gt;&#xA;&lt;li&gt;每个发给多线程应用的信号仅递送给一个线程， 这个线程是由内核从不会阻塞该信号的线程中****随意选出来****的。&lt;/li&gt;&#xA;&lt;li&gt;如果发送一个致命信号到多线程， 那么内核将杀死该应用的所有线程， 而不仅仅是接收信号的那个线程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这些就是POSIX标准提出的要求， Linux也要遵循这些要求， 那它是怎么做到的呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux共享库、静态库、动态库详解</title>
      <link>http://shanks.link/blog/2022/12/02/linux%E5%85%B1%E4%BA%AB%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 02 Dec 2022 15:39:20 +0800</pubDate>
      <guid>http://shanks.link/blog/2022/12/02/linux%E5%85%B1%E4%BA%AB%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;​        使用GNU的工具我们如何在Linux下创建自己的程序函数库?一个“程序函数库”简单的说就是一个文件包含了一些编译好的代码和数据，这些编译好的代码和数据可以在事后供其他的程序使用。程序函数库可以使整个程序更加模块化，更容易重新编译，而且更方便升级。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
