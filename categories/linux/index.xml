<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Golang编程语言知识介绍</title>
    <link>http://shanks.link/categories/linux/</link>
    <description>Recent content in linux on Golang编程语言知识介绍</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 16 Apr 2024 14:28:20 +0800</lastBuildDate><atom:link href="http://shanks.link/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux进程间通信7：数据报套接字 socket()、bind()、sendto()、recvfrom()、close()</title>
      <link>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A17%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97-socketbindsendtorecvfromclose/</link>
      <pubDate>Tue, 16 Apr 2024 14:28:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A17%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97-socketbindsendtorecvfromclose/</guid>
      <description>前一篇文章，Linux进程间通信——使用流套接字介绍了一些有关socket（套接字）的一些基本内容，并讲解了流套接字的使用，这篇文章将会给大</description>
    </item>
    
    <item>
      <title>Linux进程间通信6 流套接字 socket()、bind()、listen()、accept()、connect()、read()、write()、close()</title>
      <link>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A16-%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97-socketbindlistenacceptconnectreadwriteclose/</link>
      <pubDate>Tue, 16 Apr 2024 11:53:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/16/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A16-%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97-socketbindlistenacceptconnectreadwriteclose/</guid>
      <description>前面说到的进程间的通信，所通信的进程都是在同一台计算机上的，而使用socket进行通信的进程可以是同一台计算机的进程，也是可以是通过网络连接</description>
    </item>
    
    <item>
      <title>进程间通信5 消息队列 msgget、msgsend、msgrcv、msgctl</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A15-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-msggetmsgsendmsgrcvmsgctl/</link>
      <pubDate>Tue, 16 Apr 2024 11:41:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A15-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-msggetmsgsendmsgrcvmsgctl/</guid>
      <description>下面来说说如何用不用消息队列来进行进程间的通信，消息队列与命名管道有很多相似之处。有关命名管道的更多内容可以参阅我的另一篇文章：Linux进</description>
    </item>
    
    <item>
      <title>进程间通信4 共享内存</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A14-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 16 Apr 2024 11:19:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A14-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid>
      <description>下面将讲解进程间通信的另一种方式，使用共享内存。 一、什么是共享内存 顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在</description>
    </item>
    
    <item>
      <title>进程间通信3 信号量</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A13-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link>
      <pubDate>Tue, 16 Apr 2024 10:49:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A13-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid>
      <description>这篇文章将讲述别一种进程间通信的机制——信号量。注意请不要把它与之前所说的信号混淆起来，信号与信号量是不同的两种事物。有关信号的更多内容，可</description>
    </item>
    
    <item>
      <title>进程间通信2 有名管道</title>
      <link>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/</link>
      <pubDate>Tue, 16 Apr 2024 09:56:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/16/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/</guid>
      <description>在前一篇文章—— Linux进程间通信 &amp;ndash; 使用匿名管道 中，我们看到了如何使用匿名管道来在进程之间传递数据，同时也看到了这个方式的一个缺陷，就是这</description>
    </item>
    
    <item>
      <title>进程间通信2 匿名管道</title>
      <link>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/</link>
      <pubDate>Mon, 15 Apr 2024 17:17:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A12-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/</guid>
      <description>在前面，介绍了一种进程间的通信方式：使用信号，我们创建通知事件，并通过它引起响应，但传递的信息只是一个信号值。这里将介绍另一种进程间通信的方</description>
    </item>
    
    <item>
      <title>进程间通信1 信号</title>
      <link>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Mon, 15 Apr 2024 16:51:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7/</guid>
      <description>一、什么是信号 用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的</description>
    </item>
    
    <item>
      <title>进程间通信1 信号之信号集函数</title>
      <link>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 15 Apr 2024 16:51:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2024/04/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A11-%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0/</guid>
      <description>我们已经知道，我们可以通过信号来终止进程，也可以通过信号来在进程间进行通信，程序也可以通过指定信号的关联处理函数来改变信号的默认处理方式，也</description>
    </item>
    
    <item>
      <title>Linux线程与信号</title>
      <link>http://shanks.link/blog/2023/09/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Fri, 22 Sep 2023 10:13:44 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2023/09/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7/</guid>
      <description>信号与线程的关系 POSIX标准对多线程情况下的信号机制提出了一些要求： 信号处理函数必须在多线程进程的所有线程之间共享， 但是每个线程要有自己的</description>
    </item>
    
    <item>
      <title>Linux共享库、静态库、动态库详解</title>
      <link>http://shanks.link/blog/2022/12/02/linux%E5%85%B1%E4%BA%AB%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 02 Dec 2022 15:39:20 +0800</pubDate>
      
      <guid>http://shanks.link/blog/2022/12/02/linux%E5%85%B1%E4%BA%AB%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93%E8%AF%A6%E8%A7%A3/</guid>
      <description>介绍 ​ 使用GNU的工具我们如何在Linux下创建自己的程序函数库?一个“程序函数库”简单的说就是一个文件包含了一些编译好的代码和数据，这些编</description>
    </item>
    
  </channel>
</rss>
