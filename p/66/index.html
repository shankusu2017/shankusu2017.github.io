<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
	<meta name="generator" content="Hugo 0.147.3">
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>愿星光伴随你左右 - 愿星光伴随你左右</title>
    <meta name="keywords" content="Golang,golang,go,git,Git,Lua,lua">
    
    <meta property="og:title" content="愿星光伴随你左右">
    <meta property="og:site_name" content="愿星光伴随你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="愿星光伴随你左右 - 愿星光伴随你左右" />
    <meta name="description" content="愿星光伴随你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: false, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴随你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/food/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />food
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/finance/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />投资
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
    
 <section id="posts" class="posts-expand">

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/31/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-llex.c/" itemprop="url">
        lua源码注释-llex.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-31">
    2021-05-31
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">2470 字 ~5分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: llex.c,v 2.20.1.2 2009/11/23 14:58:22 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Lexical Analyzer
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;ctype.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;locale.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define llex_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;llex.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lparser.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstring.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lzio.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define next(ls) (ls-&gt;current = zgetc(ls-&gt;z))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define currIsNewline(ls)	(ls-&gt;current == &#39;\n&#39; || ls-&gt;current == &#39;\r&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* ORDER RESERVED */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#00f">char</span> *<span style="color:#00f">const</span> luaX_tokens [] = {
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;and&#34;</span>, <span style="color:#009c00">&#34;break&#34;</span>, <span style="color:#009c00">&#34;do&#34;</span>, <span style="color:#009c00">&#34;else&#34;</span>, <span style="color:#009c00">&#34;elseif&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;end&#34;</span>, <span style="color:#009c00">&#34;false&#34;</span>, <span style="color:#009c00">&#34;for&#34;</span>, <span style="color:#009c00">&#34;function&#34;</span>, <span style="color:#009c00">&#34;if&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;in&#34;</span>, <span style="color:#009c00">&#34;local&#34;</span>, <span style="color:#009c00">&#34;nil&#34;</span>, <span style="color:#009c00">&#34;not&#34;</span>, <span style="color:#009c00">&#34;or&#34;</span>, <span style="color:#009c00">&#34;repeat&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;return&#34;</span>, <span style="color:#009c00">&#34;then&#34;</span>, <span style="color:#009c00">&#34;true&#34;</span>, <span style="color:#009c00">&#34;until&#34;</span>, <span style="color:#009c00">&#34;while&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;..&#34;</span>, <span style="color:#009c00">&#34;...&#34;</span>, <span style="color:#009c00">&#34;==&#34;</span>, <span style="color:#009c00">&#34;&gt;=&#34;</span>, <span style="color:#009c00">&#34;&lt;=&#34;</span>, <span style="color:#009c00">&#34;~=&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;&lt;number&gt;&#34;</span>, <span style="color:#009c00">&#34;&lt;name&gt;&#34;</span>, <span style="color:#009c00">&#34;&lt;string&gt;&#34;</span>, <span style="color:#009c00">&#34;&lt;eof&gt;&#34;</span>,
</span></span><span style="display:flex;"><span>    NULL
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define save_and_next(ls) (save(ls, ls-&gt;current), next(ls))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将c存到ls-&gt;buff中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">save</span> (LexState *ls, <span style="color:#00f">int</span> c) {
</span></span><span style="display:flex;"><span>  Mbuffer *b = ls-&gt;buff;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (b-&gt;n + 1 &gt; b-&gt;buffsize) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">size_t</span> newsize;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (b-&gt;buffsize &gt;= MAX_SIZET/2)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;lexical element too long&#34;</span>, 0);
</span></span><span style="display:flex;"><span>    newsize = b-&gt;buffsize * 2;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaZ_resizebuffer</span>(ls-&gt;L, b, newsize);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  b-&gt;buffer[b-&gt;n++] = <span style="color:#c34e00">cast</span>(<span style="color:#00f">char</span>, c);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 构建出关键字 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaX_init</span> (lua_State *L) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=0; i&lt;NUM_RESERVED; i++) {
</span></span><span style="display:flex;"><span>    TString *ts = <span style="color:#c34e00">luaS_new</span>(L, luaX_tokens[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaS_fix</span>(ts);  <span style="color:#f00;font-style:italic">/* reserved words are never collected */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">strlen</span>(luaX_tokens[i])+1 &lt;= TOKEN_LEN);
</span></span><span style="display:flex;"><span>    ts-&gt;tsv.reserved = <span style="color:#c34e00">cast_byte</span>(i+1);  <span style="color:#f00;font-style:italic">/* reserved word */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define MAXSRC          80
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> <span style="color:#00f">char</span> *<span style="color:#c34e00">luaX_token2str</span> (LexState *ls, <span style="color:#00f">int</span> token) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (token &lt; FIRST_RESERVED) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(token == <span style="color:#c34e00">cast</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>, token));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> (<span style="color:#c34e00">iscntrl</span>(token)) ? <span style="color:#c34e00">luaO_pushfstring</span>(ls-&gt;L, <span style="color:#009c00">&#34;char(%d)&#34;</span>, token) :
</span></span><span style="display:flex;"><span>                              <span style="color:#c34e00">luaO_pushfstring</span>(ls-&gt;L, <span style="color:#009c00">&#34;%c&#34;</span>, token);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> luaX_tokens[token-FIRST_RESERVED];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">const</span> <span style="color:#00f">char</span> *<span style="color:#c34e00">txtToken</span> (LexState *ls, <span style="color:#00f">int</span> token) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (token) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NAME:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_STRING:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NUMBER:
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">save</span>(ls, <span style="color:#009c00">&#39;\0&#39;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">luaX_token2str</span>(ls, token);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaX_lexerror</span> (LexState *ls, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *msg, <span style="color:#00f">int</span> token) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">char</span> buff[MAXSRC];
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaO_chunkid</span>(buff, <span style="color:#c34e00">getstr</span>(ls-&gt;source), MAXSRC);
</span></span><span style="display:flex;"><span>  msg = <span style="color:#c34e00">luaO_pushfstring</span>(ls-&gt;L, <span style="color:#009c00">&#34;%s:%d: %s&#34;</span>, buff, ls-&gt;linenumber, msg);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (token)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaO_pushfstring</span>(ls-&gt;L, <span style="color:#009c00">&#34;%s near &#34;</span> LUA_QS, msg, <span style="color:#c34e00">txtToken</span>(ls, token));
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_throw</span>(ls-&gt;L, LUA_ERRSYNTAX);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaX_syntaxerror</span> (LexState *ls, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *msg) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_lexerror</span>(ls, msg, ls-&gt;t.token);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TString *<span style="color:#c34e00">luaX_newstring</span> (LexState *ls, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *str, <span style="color:#00f">size_t</span> l) {
</span></span><span style="display:flex;"><span>  lua_State *L = ls-&gt;L;
</span></span><span style="display:flex;"><span>  TString *ts = <span style="color:#c34e00">luaS_newlstr</span>(L, str, l);
</span></span><span style="display:flex;"><span>  TValue *o = <span style="color:#c34e00">luaH_setstr</span>(L, ls-&gt;fs-&gt;h, ts);  <span style="color:#f00;font-style:italic">/* entry for `str&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(o)) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setbvalue</span>(o, 1);  <span style="color:#f00;font-style:italic">/* make sure `str&#39; will not be collected */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaC_checkGC</span>(L);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> ts;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 读到单个换行符\n，\r，再多读一个字符，看是否是双字符的换行\n\r,\r\n */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">inclinenumber</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> old = ls-&gt;current;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">currIsNewline</span>(ls));	<span style="color:#f00;font-style:italic">/* 当前是换行符 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 往后再读一个字符，看看不是不是\n\r和\r\n这种双字符的换行符（仅算一次换行） */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip `\n&#39; or `\r&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">currIsNewline</span>(ls) &amp;&amp; ls-&gt;current != old)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip `\n\r&#39; or `\r\n&#39; */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (++ls-&gt;linenumber &gt;= MAX_INT)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#009c00">&#34;chunk has too many lines&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 初始化LexState，初始化ls-&gt;buf,从ZIO读取第一个字符 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaX_setinput</span> (lua_State *L, LexState *ls, ZIO *z, TString *source) {
</span></span><span style="display:flex;"><span>  ls-&gt;decpoint = <span style="color:#009c00">&#39;.&#39;</span>;
</span></span><span style="display:flex;"><span>  ls-&gt;L = L;
</span></span><span style="display:flex;"><span>  ls-&gt;lookahead.token = TK_EOS;  <span style="color:#f00;font-style:italic">/* no look-ahead token */</span>
</span></span><span style="display:flex;"><span>  ls-&gt;z = z;
</span></span><span style="display:flex;"><span>  ls-&gt;fs = NULL;	<span style="color:#f00;font-style:italic">/* 尚未开始编译函数，这里置NULL */</span>
</span></span><span style="display:flex;"><span>  ls-&gt;linenumber = 1;	<span style="color:#f00;font-style:italic">/* 当前在第一行，亲 */</span>
</span></span><span style="display:flex;"><span>  ls-&gt;lastline = 1;
</span></span><span style="display:flex;"><span>  ls-&gt;source = source;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 申请属于ls-&gt;buff的私有buff */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaZ_resizebuffer</span>(ls-&gt;L, ls-&gt;buff, LUA_MINBUFFER);  <span style="color:#f00;font-style:italic">/* initialize buffer */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">next</span>(ls);  <span style="color:#f00;font-style:italic">/* read first char */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** =======================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** LEXICAL ANALYZER
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** =======================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* ls-&gt;current和set字符集中的某个字符匹配吗 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">check_next</span> (LexState *ls, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *set) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">strchr</span>(set, ls-&gt;current))	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将ls-&gt;buff中的from字符替换层to字符 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">buffreplace</span> (LexState *ls, <span style="color:#00f">char</span> from, <span style="color:#00f">char</span> to) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">size_t</span> n = <span style="color:#c34e00">luaZ_bufflen</span>(ls-&gt;buff);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">char</span> *p = <span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (n--)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (p[n] == from) p[n] = to;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 数字字符串转换为数字时失败，尝试更换成本地区的数字字符小数点后再次尝试转换 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">trydecpoint</span> (LexState *ls, SemInfo *seminfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* format error: try to update decimal point separator */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> lconv *cv = <span style="color:#c34e00">localeconv</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#00f">char</span> old = ls-&gt;decpoint;
</span></span><span style="display:flex;"><span>  ls-&gt;decpoint = (cv ? cv-&gt;decimal_point[0] : <span style="color:#009c00">&#39;.&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">buffreplace</span>(ls, old, ls-&gt;decpoint);  <span style="color:#f00;font-style:italic">/* try updated decimal separator */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">luaO_str2d</span>(<span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff), &amp;seminfo-&gt;r)) {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* format error with correct decimal point: no more options */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">buffreplace</span>(ls, ls-&gt;decpoint, <span style="color:#009c00">&#39;.&#39;</span>);  <span style="color:#f00;font-style:italic">/* undo change (for error message) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;malformed number&#34;</span>, TK_NUMBER);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* LUA_NUMBER 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** .123这种  123或者科学计数法形式(1.99714E+13)的数字
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">read_numeral</span> (LexState *ls, SemInfo *seminfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">isdigit</span>(ls-&gt;current));	<span style="color:#f00;font-style:italic">/* 属于 [0,9] 集合？*/</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 读取第一部分 1.99714 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">while</span> (<span style="color:#c34e00">isdigit</span>(ls-&gt;current) || ls-&gt;current == <span style="color:#009c00">&#39;.&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 读取第二部分 E+ */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">check_next</span>(ls, <span style="color:#009c00">&#34;Ee&#34;</span>))  <span style="color:#f00;font-style:italic">/* `E&#39;? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">check_next</span>(ls, <span style="color:#009c00">&#34;+-&#34;</span>);  <span style="color:#f00;font-style:italic">/* optional exponent sign */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 读取第三部分 13 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (<span style="color:#c34e00">isalnum</span>(ls-&gt;current) || ls-&gt;current == <span style="color:#009c00">&#39;_&#39;</span>)	<span style="color:#f00;font-style:italic">/* 这里的_不太明白其含义 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 主动补\0,关闭字符串 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">save</span>(ls, <span style="color:#009c00">&#39;\0&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 不同国家不同的小数点 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">buffreplace</span>(ls, <span style="color:#009c00">&#39;.&#39;</span>, ls-&gt;decpoint);  <span style="color:#f00;font-style:italic">/* follow locale for decimal point */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">luaO_str2d</span>(<span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff), &amp;seminfo-&gt;r))  <span style="color:#f00;font-style:italic">/* format error? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">trydecpoint</span>(ls, seminfo); <span style="color:#f00;font-style:italic">/* try to update decimal point separator */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 尝试读取多行字符串的开头或结尾 --[{=}[ 或者 ]{=}] */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">skip_sep</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> count = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> s = ls-&gt;current;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(s == <span style="color:#009c00">&#39;[&#39;</span> || s == <span style="color:#009c00">&#39;]&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (ls-&gt;current == <span style="color:#009c00">&#39;=&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>    count++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> (ls-&gt;current == s) ? count : (-count) - 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 读取一个长字符串和&#34;结尾控制符&#34;(长注释或String的token)(同时更新linenumber) */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">read_long_string</span> (LexState *ls, SemInfo *seminfo, <span style="color:#00f">int</span> sep) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> cont = 0;
</span></span><span style="display:flex;"><span>  (<span style="color:#00f">void</span>)(cont);  <span style="color:#f00;font-style:italic">/* avoid warnings when `cont&#39; is not used */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">save_and_next</span>(ls);  		<span style="color:#f00;font-style:italic">/* skip 2nd `[&#39; */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">currIsNewline</span>(ls))  	<span style="color:#f00;font-style:italic">/* string starts with a newline? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">inclinenumber</span>(ls);  <span style="color:#f00;font-style:italic">/* skip it */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> (ls-&gt;current) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> EOZ:
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaX_lexerror</span>(ls, (seminfo) ? <span style="color:#009c00">&#34;unfinished long string&#34;</span> :
</span></span><span style="display:flex;"><span>                                   <span style="color:#009c00">&#34;unfinished long comment&#34;</span>, TK_EOS);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* to avoid warnings */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if defined(LUA_COMPAT_LSTR)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;[&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">skip_sep</span>(ls) == sep) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">save_and_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip 2nd `[&#39; */</span>
</span></span><span style="display:flex;"><span>          cont++;
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if LUA_COMPAT_LSTR == 1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">if</span> (sep == 0)
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;nesting of [[...]] is deprecated&#34;</span>, <span style="color:#009c00">&#39;[&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;]&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">skip_sep</span>(ls) == sep) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">save_and_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip 2nd `]&#39; */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if defined(LUA_COMPAT_LSTR) &amp;&amp; LUA_COMPAT_LSTR == 2
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          cont--;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (sep == 0 &amp;&amp; cont &gt;= 0) <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">goto</span> endloop;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\n&#39;</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\r&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">save</span>(ls, <span style="color:#009c00">&#39;\n&#39;</span>);	
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">inclinenumber</span>(ls);	<span style="color:#f00;font-style:italic">/* 注释的业务中也不能忘了linenumber */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (!seminfo) <span style="color:#c34e00">luaZ_resetbuffer</span>(ls-&gt;buff);  <span style="color:#f00;font-style:italic">/* avoid wasting space */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (seminfo) <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } endloop:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* seminfo为null是注释逻辑，注释不用管里面的具体String，否则是一个正常的String的token，需将String保存 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (seminfo) {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 2+sep:[{=}[ */</span>
</span></span><span style="display:flex;"><span>    seminfo-&gt;ts = <span style="color:#c34e00">luaX_newstring</span>(ls, <span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff) + (2 + sep),	
</span></span><span style="display:flex;"><span>                                     <span style="color:#c34e00">luaZ_bufflen</span>(ls-&gt;buff) - 2*(2 + sep));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 读一个&#34;字符串&#34;或&#39;字符串&#39;格式的字符串 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">read_string</span> (LexState *ls, <span style="color:#00f">int</span> del, SemInfo *seminfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (ls-&gt;current != del) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> (ls-&gt;current) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> EOZ:
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;unfinished string&#34;</span>, TK_EOS);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;  <span style="color:#f00;font-style:italic">/* to avoid warnings */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\n&#39;</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\r&#39;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;unfinished string&#34;</span>, TK_STRING);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;  <span style="color:#f00;font-style:italic">/* to avoid warnings */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\\&#39;</span>: {	<span style="color:#f00;font-style:italic">/* 可能的转移序列 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> c;
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);  <span style="color:#f00;font-style:italic">/* do not save the `\&#39; */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">switch</span> (ls-&gt;current) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;a&#39;</span>: c = <span style="color:#009c00">&#39;\a&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;b&#39;</span>: c = <span style="color:#009c00">&#39;\b&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;f&#39;</span>: c = <span style="color:#009c00">&#39;\f&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;n&#39;</span>: c = <span style="color:#009c00">&#39;\n&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;r&#39;</span>: c = <span style="color:#009c00">&#39;\r&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;t&#39;</span>: c = <span style="color:#009c00">&#39;\t&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;v&#39;</span>: c = <span style="color:#009c00">&#39;\v&#39;</span>; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		  <span style="color:#f00;font-style:italic">/* 本身就是一个换行符 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\n&#39;</span>:  <span style="color:#f00;font-style:italic">/* go through */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\r&#39;</span>: <span style="color:#c34e00">save</span>(ls, <span style="color:#009c00">&#39;\n&#39;</span>); <span style="color:#c34e00">inclinenumber</span>(ls); <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>		  
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> EOZ: <span style="color:#00f">continue</span>;  <span style="color:#f00;font-style:italic">/* will raise an error next loop */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (!<span style="color:#c34e00">isdigit</span>(ls-&gt;current))
</span></span><span style="display:flex;"><span>              <span style="color:#c34e00">save_and_next</span>(ls);  <span style="color:#f00;font-style:italic">/* handles \\, \&#34;, \&#39;, and \? */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* \xxx */</span>
</span></span><span style="display:flex;"><span>              <span style="color:#00f">int</span> i = 0;
</span></span><span style="display:flex;"><span>              c = 0;
</span></span><span style="display:flex;"><span>              <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>                c = 10*c + (ls-&gt;current-<span style="color:#009c00">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>              } <span style="color:#00f">while</span> (++i&lt;3 &amp;&amp; <span style="color:#c34e00">isdigit</span>(ls-&gt;current));
</span></span><span style="display:flex;"><span>              <span style="color:#00f">if</span> (c &gt; UCHAR_MAX)
</span></span><span style="display:flex;"><span>                <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;escape sequence too large&#34;</span>, TK_STRING);
</span></span><span style="display:flex;"><span>              <span style="color:#c34e00">save</span>(ls, c);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">save</span>(ls, c);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">save_and_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip delimiter(分隔符) */</span>
</span></span><span style="display:flex;"><span>  seminfo-&gt;ts = <span style="color:#c34e00">luaX_newstring</span>(ls, <span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff) + 1,
</span></span><span style="display:flex;"><span>                                   <span style="color:#c34e00">luaZ_bufflen</span>(ls-&gt;buff) - 2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 从读取下一个字符token 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 从ZIO读取下一个token到seminfo,并返回TokenType(中途可能用到lx-&gt;buff)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">llex</span> (LexState *ls, SemInfo *seminfo) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaZ_resetbuffer</span>(ls-&gt;buff);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> (ls-&gt;current) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\n&#39;</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\r&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">inclinenumber</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;-&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>		<span style="color:#f00;font-style:italic">/* 单独的 - */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;current != <span style="color:#009c00">&#39;-&#39;</span>) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;-&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">/* else is a comment */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);	<span style="color:#f00;font-style:italic">/* 单行OR多行注释? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;current == <span style="color:#009c00">&#39;[&#39;</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">int</span> sep = <span style="color:#c34e00">skip_sep</span>(ls);
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaZ_resetbuffer</span>(ls-&gt;buff);  <span style="color:#f00;font-style:italic">/* `skip_sep&#39; may dirty the buffer */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (sep &gt;= 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">read_long_string</span>(ls, NULL, sep);  <span style="color:#f00;font-style:italic">/* long comment */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">luaZ_resetbuffer</span>(ls-&gt;buff);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">/* else short comment */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (!<span style="color:#c34e00">currIsNewline</span>(ls) &amp;&amp; ls-&gt;current != EOZ)
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;[&#39;</span>: {	<span style="color:#f00;font-style:italic">/* 长字符串: [{=}[ String ]{=}] */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> sep = <span style="color:#c34e00">skip_sep</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (sep &gt;= 0) {	<span style="color:#f00;font-style:italic">/* 多行字符串开头 [{=}[ */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">read_long_string</span>(ls, seminfo, sep);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span> TK_STRING;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (sep == -1) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;[&#39;</span>;	<span style="color:#f00;font-style:italic">/* [,others这样的开头 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;invalid long string delimiter&#34;</span>, TK_STRING);		<span style="color:#f00;font-style:italic">/* [={=},others这样的开头 */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;=&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;current != <span style="color:#009c00">&#39;=&#39;</span>) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;=&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> { <span style="color:#c34e00">next</span>(ls); <span style="color:#00f">return</span> TK_EQ; }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&lt;&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;current != <span style="color:#009c00">&#39;=&#39;</span>) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;&lt;&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> { <span style="color:#c34e00">next</span>(ls); <span style="color:#00f">return</span> TK_LE; }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&gt;&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;current != <span style="color:#009c00">&#39;=&#39;</span>) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;&gt;&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> { <span style="color:#c34e00">next</span>(ls); <span style="color:#00f">return</span> TK_GE; }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;~&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;current != <span style="color:#009c00">&#39;=&#39;</span>) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;~&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> { <span style="color:#c34e00">next</span>(ls); <span style="color:#00f">return</span> TK_NE; }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 短字符串 */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&#34;&#39;</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;\&#39;&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">read_string</span>(ls, ls-&gt;current, seminfo);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> TK_STRING;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 看这个符号的解析，是一个深度优先的解析示例 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;.&#39;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">check_next</span>(ls, <span style="color:#009c00">&#34;.&#34;</span>)) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (<span style="color:#c34e00">check_next</span>(ls, <span style="color:#009c00">&#34;.&#34;</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> TK_DOTS;   <span style="color:#f00;font-style:italic">/* ... */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">else</span> <span style="color:#00f">return</span> TK_CONCAT;   <span style="color:#f00;font-style:italic">/* .. */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!<span style="color:#c34e00">isdigit</span>(ls-&gt;current)) <span style="color:#00f">return</span> <span style="color:#009c00">&#39;.&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">read_numeral</span>(ls, seminfo);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span> TK_NUMBER;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> EOZ: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> TK_EOS;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">isspace</span>(ls-&gt;current)) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">lua_assert</span>(!<span style="color:#c34e00">currIsNewline</span>(ls));	<span style="color:#f00;font-style:italic">/* 换行符在前面就被解析掉了，这里不能再是换行符了,否则就重复了 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">isdigit</span>(ls-&gt;current)) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">read_numeral</span>(ls, seminfo);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span> TK_NUMBER;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">isalpha</span>(ls-&gt;current) || ls-&gt;current == <span style="color:#009c00">&#39;_&#39;</span>) {	<span style="color:#f00;font-style:italic">/* 标识符 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">/* identifier or reserved word */</span>
</span></span><span style="display:flex;"><span>          TString *ts;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">save_and_next</span>(ls);
</span></span><span style="display:flex;"><span>          } <span style="color:#00f">while</span> (<span style="color:#c34e00">isalnum</span>(ls-&gt;current) || ls-&gt;current == <span style="color:#009c00">&#39;_&#39;</span>);	<span style="color:#f00;font-style:italic">/* 这里和上面的有一点差别 */</span>
</span></span><span style="display:flex;"><span>		  
</span></span><span style="display:flex;"><span>          ts = <span style="color:#c34e00">luaX_newstring</span>(ls, <span style="color:#c34e00">luaZ_buffer</span>(ls-&gt;buff),
</span></span><span style="display:flex;"><span>                                  <span style="color:#c34e00">luaZ_bufflen</span>(ls-&gt;buff));
</span></span><span style="display:flex;"><span>		  <span style="color:#f00;font-style:italic">/* 关键或保留字符串 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (ts-&gt;tsv.reserved &gt; 0)  <span style="color:#f00;font-style:italic">/* reserved word? */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> ts-&gt;tsv.reserved - 1 + FIRST_RESERVED;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            seminfo-&gt;ts = ts;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> TK_NAME;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">int</span> c = ls-&gt;current;
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">next</span>(ls);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span> c;  <span style="color:#f00;font-style:italic">/* single-char tokens (+ - / ...) */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaX_next</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  ls-&gt;lastline = ls-&gt;linenumber
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 已有一个准备好的lookhead&#39;token,则取出来用 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;lookahead.token != TK_EOS) {  <span style="color:#f00;font-style:italic">/* is there a look-ahead token? */</span>
</span></span><span style="display:flex;"><span>    ls-&gt;t = ls-&gt;lookahead;  <span style="color:#f00;font-style:italic">/* use this one */</span>
</span></span><span style="display:flex;"><span>    ls-&gt;lookahead.token = TK_EOS;  <span style="color:#f00;font-style:italic">/* and discharge it */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#f00;font-style:italic">/* 读取一个token */</span>
</span></span><span style="display:flex;"><span>    ls-&gt;t.token = <span style="color:#c34e00">llex</span>(ls, &amp;ls-&gt;t.seminfo);  <span style="color:#f00;font-style:italic">/* read next token */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 当前lookhead&#39;token已过期，重新准备lookhead&#39;token */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaX_lookahead</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(ls-&gt;lookahead.token == TK_EOS);
</span></span><span style="display:flex;"><span>  ls-&gt;lookahead.token = <span style="color:#c34e00">llex</span>(ls, &amp;ls-&gt;lookahead.seminfo);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/28/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-ldo.c/" itemprop="url">
        lua源码注释-ldo.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-28">
    2021-05-28
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4661 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: ldo.c,v 2.38.1.4 2012/01/18 02:27:10 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Stack and Call structure of Lua
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;setjmp.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define ldo_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lfunc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lgc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lmem.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lparser.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstring.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltm.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lundump.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lvm.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lzio.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** {======================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Error-recovery functions
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** =======================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* chain list of long jump buffers */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> lua_longjmp {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> lua_longjmp *previous;
</span></span><span style="display:flex;"><span>  luai_jmpbuf b;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">volatile</span> <span style="color:#00f">int</span> status;  <span style="color:#f00;font-style:italic">/* error code */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_seterrorobj</span> (lua_State *L, <span style="color:#00f">int</span> errcode, StkId oldtop) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (errcode) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_ERRMEM: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setsvalue2s</span>(L, oldtop, <span style="color:#c34e00">luaS_newliteral</span>(L, MEMERRMSG));
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_ERRERR: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setsvalue2s</span>(L, oldtop, <span style="color:#c34e00">luaS_newliteral</span>(L, <span style="color:#009c00">&#34;error in error handling&#34;</span>));
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_ERRSYNTAX:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_ERRRUN: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setobjs2s</span>(L, oldtop, L-&gt;top - 1);  <span style="color:#f00;font-style:italic">/* error message on current top */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里结合 luaD_pcall 来一起来看 */</span>
</span></span><span style="display:flex;"><span>  L-&gt;top = oldtop + 1;	<span style="color:#f00;font-style:italic">/* correct top */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 空闲的callInfo过多时，尝试压缩其空间 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">restore_stack_limit</span> (lua_State *L) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(L-&gt;stack_last - L-&gt;stack == L-&gt;stacksize - EXTRA_STACK - 1);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;size_ci &gt; LUAI_MAXCALLS) {  <span style="color:#f00;font-style:italic">/* there was an overflow? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> inuse = <span style="color:#c34e00">cast_int</span>(L-&gt;ci - L-&gt;base_ci);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (inuse + 1 &lt; LUAI_MAXCALLS)  <span style="color:#f00;font-style:italic">/* can `undo&#39; overflow? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_reallocCI</span>(L, LUAI_MAXCALLS);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 回滚stack到初始状态！！！！ */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">resetstack</span> (lua_State *L, <span style="color:#00f">int</span> status) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这一下彻底回滚了 */</span>
</span></span><span style="display:flex;"><span>  L-&gt;ci = L-&gt;base_ci;
</span></span><span style="display:flex;"><span>  L-&gt;base = L-&gt;ci-&gt;base;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaF_close</span>(L, L-&gt;base);  <span style="color:#f00;font-style:italic">/* close eventual pending closures */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_seterrorobj</span>(L, status, L-&gt;base);
</span></span><span style="display:flex;"><span>  L-&gt;nCcalls = L-&gt;baseCcalls;
</span></span><span style="display:flex;"><span>  L-&gt;allowhook = 1;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">restore_stack_limit</span>(L);
</span></span><span style="display:flex;"><span>  L-&gt;errfunc = 0;
</span></span><span style="display:flex;"><span>  L-&gt;errorJmp = NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 尝试调用异常处理函数 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 主要在luaG_errormsg中被间接调用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_throw</span> (lua_State *L, <span style="color:#00f">int</span> errcode) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;errorJmp) {
</span></span><span style="display:flex;"><span>    L-&gt;errorJmp-&gt;status = errcode;  <span style="color:#f00;font-style:italic">/* !!! 跳出去之前设置status */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">LUAI_THROW</span>(L, L-&gt;errorJmp); 	<span style="color:#f00;font-style:italic">/* 正式跳出 */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {	<span style="color:#f00;font-style:italic">/* 没有设置errHdl，调用panic后退出进程 */</span>
</span></span><span style="display:flex;"><span>    L-&gt;status = <span style="color:#c34e00">cast_byte</span>(errcode);	<span style="color:#f00;font-style:italic">/* 无jump点了，在这里设置L的状态，有则由上层业务处理 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">G</span>(L)-&gt;panic) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">resetstack</span>(L, errcode);	<span style="color:#f00;font-style:italic">/* 这里对stack进行收尾 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_unlock</span>(L);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">G</span>(L)-&gt;<span style="color:#c34e00">panic</span>(L);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">exit</span>(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 保护模式下(longjump)调用C函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 但发生错误，则调用了L-&gt;errfunc后(若设置了)，后走到这里而不是直接退出进程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** RETURN：执行流的执行结果，没有同步到L-&gt;status中(由上层调用决定是否同步)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaD_rawrunprotected</span> (lua_State *L, Pfunc f, <span style="color:#00f">void</span> *ud) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> lua_longjmp lj;
</span></span><span style="display:flex;"><span>  lj.status = 0;
</span></span><span style="display:flex;"><span>  lj.previous = L-&gt;errorJmp;  <span style="color:#f00;font-style:italic">/* chain new error handler */</span>
</span></span><span style="display:flex;"><span>  L-&gt;errorJmp = &amp;lj;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">LUAI_TRY</span>(L, &amp;lj,
</span></span><span style="display:flex;"><span>    (*f)(L, ud);
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  L-&gt;errorJmp = lj.previous;  <span style="color:#f00;font-style:italic">/* restore old error handler */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> lj.status;	<span style="color:#f00;font-style:italic">/* luaD_throw()中更新了status */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* }====================================================== */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* stack移动后更新upvalues,ci-list和L-&gt;base */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">correctstack</span> (lua_State *L, TValue *oldstack) {
</span></span><span style="display:flex;"><span>  CallInfo *ci;
</span></span><span style="display:flex;"><span>  GCObject *up;
</span></span><span style="display:flex;"><span>  L-&gt;top = (L-&gt;top - oldstack) + L-&gt;stack;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (up = L-&gt;openupval; up != NULL; up = up-&gt;gch.next)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">gco2uv</span>(up)-&gt;v = (<span style="color:#c34e00">gco2uv</span>(up)-&gt;v - oldstack) + L-&gt;stack;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (ci = L-&gt;base_ci; ci &lt;= L-&gt;ci; ci++) {
</span></span><span style="display:flex;"><span>    ci-&gt;top = (ci-&gt;top - oldstack) + L-&gt;stack;
</span></span><span style="display:flex;"><span>    ci-&gt;base = (ci-&gt;base - oldstack) + L-&gt;stack;
</span></span><span style="display:flex;"><span>    ci-&gt;func = (ci-&gt;func - oldstack) + L-&gt;stack;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* L-&gt;ci不用调整哈 */</span>
</span></span><span style="display:flex;"><span>  L-&gt;base = (L-&gt;base - oldstack) + L-&gt;stack;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 重新调整stack的大小 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_reallocstack</span> (lua_State *L, <span style="color:#00f">int</span> newsize) {
</span></span><span style="display:flex;"><span>  TValue *oldstack = L-&gt;stack;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> realsize = newsize + 1 + EXTRA_STACK;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(L-&gt;stack_last - L-&gt;stack == L-&gt;stacksize - EXTRA_STACK - 1);	<span style="color:#f00;font-style:italic">/* 和stack_init()函数对应 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, L-&gt;stack, L-&gt;stacksize, realsize, TValue);
</span></span><span style="display:flex;"><span>  L-&gt;stacksize = realsize;
</span></span><span style="display:flex;"><span>  L-&gt;stack_last = L-&gt;stack+newsize;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">correctstack</span>(L, oldstack);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 调整callInfo链的大小 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_reallocCI</span> (lua_State *L, <span style="color:#00f">int</span> newsize) {
</span></span><span style="display:flex;"><span>  CallInfo *oldci = L-&gt;base_ci;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, L-&gt;base_ci, L-&gt;size_ci, newsize, CallInfo);
</span></span><span style="display:flex;"><span>  L-&gt;size_ci = newsize;
</span></span><span style="display:flex;"><span>  L-&gt;ci = (L-&gt;ci - oldci) + L-&gt;base_ci;
</span></span><span style="display:flex;"><span>  L-&gt;end_ci = L-&gt;base_ci + L-&gt;size_ci - 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_growstack</span> (lua_State *L, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (n &lt;= L-&gt;stacksize)  <span style="color:#f00;font-style:italic">/* double size is enough? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_reallocstack</span>(L, 2*L-&gt;stacksize);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_reallocstack</span>(L, L-&gt;stacksize + n);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> CallInfo *<span style="color:#c34e00">growCI</span> (lua_State *L) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;size_ci &gt; LUAI_MAXCALLS)  <span style="color:#f00;font-style:italic">/* overflow while handling overflow? 嵌套调用层次太深了，直接报错，方便用户检查调用情况 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_throw</span>(L, LUA_ERRERR);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_reallocCI</span>(L, 2*L-&gt;size_ci);	<span style="color:#f00;font-style:italic">/* 简单粗暴，直接扩大一倍 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (L-&gt;size_ci &gt; LUAI_MAXCALLS)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;stack overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> ++L-&gt;ci;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">static</span> StkId <span style="color:#c34e00">callrethooks</span> (lua_State *L, StkId firstResult) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">ptrdiff_t</span> fr = <span style="color:#c34e00">savestack</span>(L, firstResult);  <span style="color:#f00;font-style:italic">/* next call may change stack */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_callhook</span>(L, LUA_HOOKRET, -1);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">f_isLua</span>(L-&gt;ci)) {  <span style="color:#f00;font-style:italic">/* Lua function? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> ((L-&gt;hookmask &amp; LUA_MASKRET) &amp;&amp; L-&gt;ci-&gt;tailcalls--) <span style="color:#f00;font-style:italic">/* tail calls */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_callhook</span>(L, LUA_HOOKTAILRET, -1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">restorestack</span>(L, fr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 调用钩子函数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_callhook</span> (lua_State *L, <span style="color:#00f">int</span> event, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  lua_Hook hook = L-&gt;hook;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (hook &amp;&amp; L-&gt;allowhook) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">ptrdiff_t</span> top = <span style="color:#c34e00">savestack</span>(L, L-&gt;top);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">ptrdiff_t</span> ci_top = <span style="color:#c34e00">savestack</span>(L, L-&gt;ci-&gt;top);
</span></span><span style="display:flex;"><span>    lua_Debug ar;
</span></span><span style="display:flex;"><span>    ar.event = event;
</span></span><span style="display:flex;"><span>    ar.currentline = line;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (event == LUA_HOOKTAILRET)
</span></span><span style="display:flex;"><span>      ar.i_ci = 0;  <span style="color:#f00;font-style:italic">/* tail call; no debug information about it */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>      ar.i_ci = <span style="color:#c34e00">cast_int</span>(L-&gt;ci - L-&gt;base_ci);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_checkstack</span>(L, LUA_MINSTACK);  <span style="color:#f00;font-style:italic">/* ensure minimum stack size */</span>
</span></span><span style="display:flex;"><span>    L-&gt;ci-&gt;top = L-&gt;top + LUA_MINSTACK;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(L-&gt;ci-&gt;top &lt;= L-&gt;stack_last);
</span></span><span style="display:flex;"><span>    L-&gt;allowhook = 0;  <span style="color:#f00;font-style:italic">/* cannot call hooks inside a hook */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_unlock</span>(L);
</span></span><span style="display:flex;"><span>    (*hook)(L, &amp;ar);	<span style="color:#f00;font-style:italic">/* 正式调用钩子函数 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_lock</span>(L);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(!L-&gt;allowhook);
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* !!!! 现场需恢复，别忘了，亲 */</span>
</span></span><span style="display:flex;"><span>    L-&gt;allowhook = 1;
</span></span><span style="display:flex;"><span>    L-&gt;ci-&gt;top = <span style="color:#c34e00">restorestack</span>(L, ci_top);
</span></span><span style="display:flex;"><span>    L-&gt;top = <span style="color:#c34e00">restorestack</span>(L, top);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**补齐固定形参(若实际传入的参数不够)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**将传给固定形参的值mv到top之上且纠正top
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**将剩下(若还有剩下)的参数留给变参...
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> StkId <span style="color:#c34e00">adjust_varargs</span> (lua_State *L, Proto *p, <span style="color:#00f">int</span> actual) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nfixargs = p-&gt;numparams;
</span></span><span style="display:flex;"><span>  Table *htab = NULL;
</span></span><span style="display:flex;"><span>  StkId base, fixed;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 传入的参数数量不够填补fixed参数的，直接补nil：至少得把fixed形参需要的个数补齐 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; actual &lt; nfixargs; ++actual)	
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnilvalue</span>(L-&gt;top++);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if defined(LUA_COMPAT_VARARG)	</span><span style="color:#f00;font-style:italic">/* 将留给...的参数信息打包到额外的arg表中 */</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  <span style="color:#00f">if</span> (p-&gt;is_vararg &amp; VARARG_NEEDSARG) { <span style="color:#f00;font-style:italic">/* compat. with old-style vararg? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> nvar = actual - nfixargs;  <span style="color:#f00;font-style:italic">/* number of extra arguments */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(p-&gt;is_vararg &amp; VARARG_HASARG);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaC_checkGC</span>(L);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_checkstack</span>(L, p-&gt;maxstacksize);
</span></span><span style="display:flex;"><span>    htab = <span style="color:#c34e00">luaH_new</span>(L, nvar, 1);  <span style="color:#f00;font-style:italic">/* create `arg&#39; table */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (i=0; i&lt;nvar; i++)  <span style="color:#f00;font-style:italic">/* put extra arguments into `arg&#39; table */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setobj2n</span>(L, <span style="color:#c34e00">luaH_setnum</span>(L, htab, i+1), L-&gt;top - nvar + i);
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* store counter in field `n&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnvalue</span>(<span style="color:#c34e00">luaH_setstr</span>(L, htab, <span style="color:#c34e00">luaS_newliteral</span>(L, <span style="color:#009c00">&#34;n&#34;</span>)), <span style="color:#c34e00">cast_num</span>(nvar));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  <span style="color:#f00;font-style:italic">/* move fixed parameters to final position */</span>
</span></span><span style="display:flex;"><span>  fixed = L-&gt;top - actual;  <span style="color:#f00;font-style:italic">/* first fixed argument */</span>
</span></span><span style="display:flex;"><span>  base = L-&gt;top;  <span style="color:#f00;font-style:italic">/* final position of first argument */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 从第一个参数开始移动其值到被调函数的fixed‘arg域,直到给所有的fixed&#39;arg赋值为止
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 如果还剩下多余的参数，则直接保留下来(留给变参...)，无需移动
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=0; i&lt;nfixargs; i++) {	
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setobjs2s</span>(L, L-&gt;top++, fixed+i);	<span style="color:#f00;font-style:italic">/* !!!!这里移动了top指针 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnilvalue</span>(fixed+i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* add `arg&#39; parameter */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (htab) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">sethvalue</span>(L, L-&gt;top++, htab);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">iswhite</span>(<span style="color:#c34e00">obj2gco</span>(htab)));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> base;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 直接看代码 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> StkId <span style="color:#c34e00">tryfuncTM</span> (lua_State *L, StkId func) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, func, TM_CALL);
</span></span><span style="display:flex;"><span>  StkId p;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">ptrdiff_t</span> funcr = <span style="color:#c34e00">savestack</span>(L, func);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisfunction</span>(tm))
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaG_typeerror</span>(L, func, <span style="color:#009c00">&#34;call&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* Open a hole inside the stack at `func&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (p = L-&gt;top; p &gt; func; p--) <span style="color:#c34e00">setobjs2s</span>(L, p, p-1);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">incr_top</span>(L);
</span></span><span style="display:flex;"><span>  func = <span style="color:#c34e00">restorestack</span>(L, funcr);  <span style="color:#f00;font-style:italic">/* previous call may change stack */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, func, tm);  <span style="color:#f00;font-style:italic">/* tag method is the new function to be called */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> func;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define inc_ci(L) \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ((L-&gt;ci == L-&gt;end_ci) ? growCI(L) : \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">   (condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci)), ++L-&gt;ci))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 先做调用前的准备工作，后进入函数调用(for C,not Lua)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nresults:-1返回所有的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 0：不要返回值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 1：期待一个返回值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaD_precall</span> (lua_State *L, StkId func, <span style="color:#00f">int</span> nresults) {
</span></span><span style="display:flex;"><span>  LClosure *cl;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">ptrdiff_t</span> funcr;	<span style="color:#f00;font-style:italic">/* 当前调用函数的pc距离stack栈底的偏移量 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisfunction</span>(func)) <span style="color:#f00;font-style:italic">/* `func&#39; is not a function? */</span>
</span></span><span style="display:flex;"><span>    func = <span style="color:#c34e00">tryfuncTM</span>(L, func);  <span style="color:#f00;font-style:italic">/* check the `function&#39; tag method */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 随着新的调用产生,ci链/stack可能因为增长而移动位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 故不能记住绝地位置而记住相对位置，后面根据此值最终确定ci-&gt;func 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  funcr = <span style="color:#c34e00">savestack</span>(L, func);	
</span></span><span style="display:flex;"><span>  cl = &amp;<span style="color:#c34e00">clvalue</span>(func)-&gt;l;
</span></span><span style="display:flex;"><span>  L-&gt;ci-&gt;savedpc = L-&gt;savedpc;	<span style="color:#f00;font-style:italic">/* 正式调用前，存档L-&gt;savedpc至L-&gt;ci-&gt;savedpc */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!cl-&gt;isC) {  <span style="color:#f00;font-style:italic">/* Lua function? prepare its call */</span>
</span></span><span style="display:flex;"><span>    CallInfo *ci;
</span></span><span style="display:flex;"><span>    StkId st, base;
</span></span><span style="display:flex;"><span>    Proto *p = cl-&gt;p;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_checkstack</span>(L, p-&gt;maxstacksize);
</span></span><span style="display:flex;"><span>    func = <span style="color:#c34e00">restorestack</span>(L, funcr);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!p-&gt;is_vararg) {  <span style="color:#f00;font-style:italic">/* no varargs?(不是变参函数?即函数参数数量固定) */</span>
</span></span><span style="display:flex;"><span>      base = func + 1;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (L-&gt;top &gt; base + p-&gt;numparams)	<span style="color:#f00;font-style:italic">/* 删除栈上多余的传入参数 */</span>
</span></span><span style="display:flex;"><span>        L-&gt;top = base + p-&gt;numparams;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* vararg function */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> nargs = <span style="color:#c34e00">cast_int</span>(L-&gt;top - func) - 1;	<span style="color:#f00;font-style:italic">/* 计算实际传入的参数个数 */</span>
</span></span><span style="display:flex;"><span>      base = <span style="color:#c34e00">adjust_varargs</span>(L, p, nargs);
</span></span><span style="display:flex;"><span>      func = <span style="color:#c34e00">restorestack</span>(L, funcr);  <span style="color:#f00;font-style:italic">/* previous call may change the stack */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ci = <span style="color:#c34e00">inc_ci</span>(L);  <span style="color:#f00;font-style:italic">/* now `enter&#39; new function */</span>
</span></span><span style="display:flex;"><span>    ci-&gt;func = func;
</span></span><span style="display:flex;"><span>    L-&gt;base = ci-&gt;base = base;
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 这里可以推导出L-&gt;base----&gt;L-&gt;top之间的区域都是ci的私有栈空间(lua,c均如此) */</span>
</span></span><span style="display:flex;"><span>    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(ci-&gt;top &lt;= L-&gt;stack_last);
</span></span><span style="display:flex;"><span>    L-&gt;savedpc = p-&gt;code;  <span style="color:#f00;font-style:italic">/* starting point */</span>
</span></span><span style="display:flex;"><span>    ci-&gt;tailcalls = 0;
</span></span><span style="display:flex;"><span>    ci-&gt;nresults = nresults;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 新的函数的私有栈空间直接补nil(参数的区域除外) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (st = L-&gt;top; st &lt; ci-&gt;top; st++)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setnilvalue</span>(st);	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 最后调整L-&gt;top使其指向本次ci的栈顶,对于Lua函数而言L-&gt;Base----&gt;(L-&gt;Base+L-&gt;maxstacksize)之间都是我私有的了，且是有效的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	** C由于L-&gt;top是动态变化的，故而L-&gt;top的值被设置为传入参数后栈顶的位置，后面会因为push等函数而动态变化-
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	*/</span>
</span></span><span style="display:flex;"><span>    L-&gt;top = ci-&gt;top;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL) {
</span></span><span style="display:flex;"><span>      L-&gt;savedpc++;  <span style="color:#f00;font-style:italic">/* hooks assume &#39;pc&#39; is already incremented */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_callhook</span>(L, LUA_HOOKCALL, -1);
</span></span><span style="display:flex;"><span>      L-&gt;savedpc--;  <span style="color:#f00;font-style:italic">/* correct &#39;pc&#39; */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> PCRLUA;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* if is a C function, call it */</span>
</span></span><span style="display:flex;"><span>    CallInfo *ci;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_checkstack</span>(L, LUA_MINSTACK);  <span style="color:#f00;font-style:italic">/* ensure minimum stack size */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 填充新的CallInfo */</span>
</span></span><span style="display:flex;"><span>    ci = <span style="color:#c34e00">inc_ci</span>(L);  <span style="color:#f00;font-style:italic">/* now `enter&#39; new function */</span>
</span></span><span style="display:flex;"><span>    ci-&gt;func = <span style="color:#c34e00">restorestack</span>(L, funcr);
</span></span><span style="display:flex;"><span>    L-&gt;base = ci-&gt;base = ci-&gt;func + 1;	<span style="color:#f00;font-style:italic">/* C函数没有Lua函数的变参问题，所以这里无需adjust_varargs() */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* &#34;OP_CALL指令&#34;已经将L-&gt;top指向了最后一个传入参数的上方 */</span>
</span></span><span style="display:flex;"><span>    ci-&gt;top = L-&gt;top + LUA_MINSTACK;	<span style="color:#f00;font-style:italic">/* 这里和上面luaD_checkstack呼应 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(ci-&gt;top &lt;= L-&gt;stack_last);
</span></span><span style="display:flex;"><span>    ci-&gt;nresults = nresults;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_callhook</span>(L, LUA_HOOKCALL, -1);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_unlock</span>(L);
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">// L-&gt;top已经在lvm中准备好了(call和vararg指令)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    n = (*<span style="color:#c34e00">curr_func</span>(L)-&gt;c.f)(L);  <span style="color:#f00;font-style:italic">/* do the actual call */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_lock</span>(L);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n &lt; 0)  <span style="color:#f00;font-style:italic">/* yielding, co调用yield，co.yeild运行完毕了,co.yeild还不能释放ci-list信息，需等到母thread调用resume，将控制权转移到co，再在co.resume中luaD_poscall()才释放 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> PCRYIELD;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_poscall</span>(L, L-&gt;top - n);	<span style="color:#f00;font-style:italic">/* 调整子C函数的返回值到指定位置并适配母函数的wanted(results) */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> PCRC;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 函数调用结束后，处理实际返回值和期待返回值的匹配问题
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 也处理ci链的嵌套逻辑（本层ci结束往后退一层)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 即处理C函数调用,也处理Lua函数执行结束即将返回这两种情况
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 没有检测C函数说返回了n个参数，当实际上没有返回那么多参数的情况
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** RETURNS: wanted.cnt: 0:返回多个参数，1：返回0个，2：返回1个。。。
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaD_poscall</span> (lua_State *L, StkId firstResult) {
</span></span><span style="display:flex;"><span>  StkId res;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> wanted, i;
</span></span><span style="display:flex;"><span>  CallInfo *ci;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;hookmask &amp; LUA_MASKRET)
</span></span><span style="display:flex;"><span>    firstResult = <span style="color:#c34e00">callrethooks</span>(L, firstResult);
</span></span><span style="display:flex;"><span>  ci = L-&gt;ci--;
</span></span><span style="display:flex;"><span>  res = ci-&gt;func;  <span style="color:#f00;font-style:italic">/* res == final position of 1st result */</span>
</span></span><span style="display:flex;"><span>  wanted = ci-&gt;nresults;
</span></span><span style="display:flex;"><span>  L-&gt;base = (ci - 1)-&gt;base;  <span style="color:#f00;font-style:italic">/* restore base */</span>
</span></span><span style="display:flex;"><span>  L-&gt;savedpc = (ci - 1)-&gt;savedpc;  <span style="color:#f00;font-style:italic">/* restore savedpc */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* move results to correct place */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i = wanted; i != 0 &amp;&amp; firstResult &lt; L-&gt;top; i--)	<span style="color:#f00;font-style:italic">/* 这个判断即处理非尾调用，又处理了尾调用 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setobjs2s</span>(L, res++, firstResult++);	<span style="color:#f00;font-style:italic">/* wanted根据实际返回数量赋值 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (i-- &gt; 0)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnilvalue</span>(res++);	<span style="color:#f00;font-style:italic">/* local a, b, c = funcA(...), 针对 funcA的返回值不够则补nil */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** L-&gt;top恢复到最后一个返回参数在stack的位置，这里和调用函数之前，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 将L-&gt;top设置到最后一个传入参数在stack的位置相呼应了！！！
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 最终将L-&gt;top恢复到ci-&gt;top是由“OP_CALL”指令负责
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  L-&gt;top = res;	
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> (wanted - LUA_MULTRET);  <span style="color:#f00;font-style:italic">/* 0 iff wanted == LUA_MULTRET */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Call a function (C or Lua). The function to be called is at *func.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** The arguments are on the stack, right after the function.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** When returns, all the results are on the stack, starting at the original
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** function position.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span> 
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaD_call</span> (lua_State *L, StkId func, <span style="color:#00f">int</span> nResults) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (++L-&gt;nCcalls &gt;= LUAI_MAXCCALLS) {	<span style="color:#f00;font-style:italic">/* 调用层次太深，进入抛出异常 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (L-&gt;nCcalls == LUAI_MAXCCALLS)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;C stack overflow&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (L-&gt;nCcalls &gt;= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS&gt;&gt;3)))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_throw</span>(L, LUA_ERRERR);  <span style="color:#f00;font-style:italic">/* error while handing stack error */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">luaD_precall</span>(L, func, nResults) == PCRLUA)  <span style="color:#f00;font-style:italic">/* is a Lua function? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaV_execute</span>(L, 1);  <span style="color:#f00;font-style:italic">/* call it, 这里的1是真的妙啊 */</span>
</span></span><span style="display:flex;"><span>  L-&gt;nCcalls--;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_checkGC</span>(L);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 协程co开始执行co.resume 母thread在lbaselib.auxresume()中交出CPU，等待子co返回 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">resume</span> (lua_State *L, <span style="color:#00f">void</span> *ud) {
</span></span><span style="display:flex;"><span>  StkId firstArg = <span style="color:#c34e00">cast</span>(StkId, ud);	<span style="color:#f00;font-style:italic">/* 没有传参时firstArg指向top,下面的firstArg&gt;L-&gt;base还是成立 */</span>
</span></span><span style="display:flex;"><span>  CallInfo *ci = L-&gt;ci;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;status == 0) {  <span style="color:#f00;font-style:italic">/* start coroutine? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(ci == L-&gt;base_ci);	<span style="color:#f00;font-style:italic">/* 尚未有任何调用链ci生成(或co已运行完毕) */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#c34e00">lua_assert</span>(firstArg &gt; L-&gt;base);	<span style="color:#f00;font-style:italic">/* 至少还有个参数(是co.fun),意味着不是co运行完毕的状态，运行完毕后不能调用本函数了，co.fun都没有了，ci也是空的，ro不知道该怎么运行了不是 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* 若是崭新的co第一次开始运行resume,则会生成相应的ci（co.initFun),再运行起来和普通的c.main中构建一个thread后第一次运行是一样的 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">luaD_precall</span>(L, firstArg - 1, LUA_MULTRET) != PCRLUA)
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* resuming from previous yield */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(L-&gt;status == LUA_YIELD);	<span style="color:#f00;font-style:italic">/* 非YEILD状态，不能调用resume */</span>
</span></span><span style="display:flex;"><span>    L-&gt;status = 0;	<span style="color:#f00;font-style:italic">/* switch back status */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!<span style="color:#c34e00">f_isLua</span>(ci)) {  <span style="color:#f00;font-style:italic">/* `common&#39; yield? ci这里指向的是baselib.yield */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* finish interrupted execution of `OP_CALL&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">GET_OPCODE</span>(*((ci-1)-&gt;savedpc - 1)) == OP_CALL ||
</span></span><span style="display:flex;"><span>                 <span style="color:#c34e00">GET_OPCODE</span>(*((ci-1)-&gt;savedpc - 1)) == OP_TAILCALL);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">luaD_poscall</span>(L, firstArg))  <span style="color:#f00;font-style:italic">/* complete it... 结束上述说的baselib.yield的调用流程 */</span>
</span></span><span style="display:flex;"><span>        L-&gt;top = L-&gt;ci-&gt;top;  <span style="color:#f00;font-style:italic">/* and correct top if not multiple results,如果是 multiple results则由跟在后面的vararg或者setlist来调整L-&gt;top(他们还需要用到L-&gt;top来确定传入参数的个数呢,所以这里不能将其恢复到L-&gt;ci-&gt;top，) */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>  <span style="color:#f00;font-style:italic">/* yielded inside a hook: just continue its execution */</span>
</span></span><span style="display:flex;"><span>      L-&gt;base = L-&gt;ci-&gt;base;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaV_execute</span>(L, <span style="color:#c34e00">cast_int</span>(L-&gt;ci - L-&gt;base_ci));	<span style="color:#f00;font-style:italic">/* 这里的nexeccalls值得好好推导一下 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">resume_error</span> (lua_State *L, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *msg) {
</span></span><span style="display:flex;"><span>  L-&gt;top = L-&gt;ci-&gt;base;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setsvalue2s</span>(L, L-&gt;top, <span style="color:#c34e00">luaS_new</span>(L, msg));
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">incr_top</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_unlock</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> LUA_ERRRUN;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LUA_API <span style="color:#00f">int</span> <span style="color:#c34e00">lua_resume</span> (lua_State *L, <span style="color:#00f">int</span> nargs) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> status;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_lock</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;status != LUA_YIELD &amp;&amp; (L-&gt;status != 0 || L-&gt;ci != L-&gt;base_ci))
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">resume_error</span>(L, <span style="color:#009c00">&#34;cannot resume non-suspended coroutine&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;nCcalls &gt;= LUAI_MAXCCALLS)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">resume_error</span>(L, <span style="color:#009c00">&#34;C stack overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luai_userstateresume</span>(L, nargs);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(L-&gt;errfunc == 0);
</span></span><span style="display:flex;"><span>  L-&gt;baseCcalls = ++L-&gt;nCcalls;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 必须protected状态下call，不然协程出错，整个进程都会被关闭 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 本函数还没有为co生成ci链,resume中会生成co的ci调用链（如果是第一次resume）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  status = <span style="color:#c34e00">luaD_rawrunprotected</span>(L, resume, L-&gt;top - nargs);	
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (status != 0) {  <span style="color:#f00;font-style:italic">/* error? */</span>
</span></span><span style="display:flex;"><span>    L-&gt;status = <span style="color:#c34e00">cast_byte</span>(status);  <span style="color:#f00;font-style:italic">/* mark thread as `dead&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_seterrorobj</span>(L, status, L-&gt;top);
</span></span><span style="display:flex;"><span>    L-&gt;ci-&gt;top = L-&gt;top;	<span style="color:#f00;font-style:italic">/* 上面压入了errMsg这里更新下top */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(L-&gt;nCcalls == L-&gt;baseCcalls);
</span></span><span style="display:flex;"><span>    status = L-&gt;status;	<span style="color:#f00;font-style:italic">/* coroutinue运行中出让则为 LUA_YIELD */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  --L-&gt;nCcalls;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_unlock</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LUA_API <span style="color:#00f">int</span> <span style="color:#c34e00">lua_yield</span> (lua_State *L, <span style="color:#00f">int</span> nresults) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luai_userstateyield</span>(L, nresults);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_lock</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (L-&gt;nCcalls &gt; L-&gt;baseCcalls)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;attempt to yield across metamethod/C-call boundary&#34;</span>);
</span></span><span style="display:flex;"><span>  L-&gt;base = L-&gt;top - nresults;  <span style="color:#f00;font-style:italic">/* protect stack slots below */</span>
</span></span><span style="display:flex;"><span>  L-&gt;status = LUA_YIELD;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_unlock</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> -1;	<span style="color:#f00;font-style:italic">/* note:这是一个特殊的值，用于标识从yield返回 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* old_top 指向被调用函数slot 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** KEYCODE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaD_pcall</span> (lua_State *L, Pfunc func, <span style="color:#00f">void</span> *u,
</span></span><span style="display:flex;"><span>                <span style="color:#00f">ptrdiff_t</span> old_top, <span style="color:#00f">ptrdiff_t</span> ef) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> status;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">unsigned</span> <span style="color:#00f">short</span> oldnCcalls = L-&gt;nCcalls;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 存档当前的ci,以便发生错误恢复时使用 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">ptrdiff_t</span> old_ci = <span style="color:#c34e00">saveci</span>(L, L-&gt;ci);	<span style="color:#f00;font-style:italic">/* 这里只能记住offset而不是绝对地址(call过程中ci可能会调整!) */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  lu_byte old_allowhooks = L-&gt;allowhook;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">ptrdiff_t</span> old_errfunc = L-&gt;errfunc;
</span></span><span style="display:flex;"><span>  L-&gt;errfunc = ef;
</span></span><span style="display:flex;"><span>  status = <span style="color:#c34e00">luaD_rawrunprotected</span>(L, func, u);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 发生了错误，回滚到存档时刻 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (status != 0) {  <span style="color:#f00;font-style:italic">/* an error occurred? */</span>
</span></span><span style="display:flex;"><span>    StkId oldtop = <span style="color:#c34e00">restorestack</span>(L, old_top);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaF_close</span>(L, oldtop);  <span style="color:#f00;font-style:italic">/* close eventual pending closures */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_seterrorobj</span>(L, status, oldtop);	<span style="color:#f00;font-style:italic">/* 顺带correct了top */</span>
</span></span><span style="display:flex;"><span>    L-&gt;nCcalls = oldnCcalls;
</span></span><span style="display:flex;"><span>    L-&gt;ci = <span style="color:#c34e00">restoreci</span>(L, old_ci);
</span></span><span style="display:flex;"><span>    L-&gt;base = L-&gt;ci-&gt;base;
</span></span><span style="display:flex;"><span>    L-&gt;savedpc = L-&gt;ci-&gt;savedpc;
</span></span><span style="display:flex;"><span>    L-&gt;allowhook = old_allowhooks;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">restore_stack_limit</span>(L);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  L-&gt;errfunc = old_errfunc;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Execute a protected parser.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> SParser {  <span style="color:#f00;font-style:italic">/* data to `f_parser&#39; */</span>
</span></span><span style="display:flex;"><span>  ZIO *z;
</span></span><span style="display:flex;"><span>  Mbuffer buff;  <span style="color:#f00;font-style:italic">/* buffer to be used by the scanner */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *name;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">f_parser</span> (lua_State *L, <span style="color:#00f">void</span> *ud) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  Proto *tf;
</span></span><span style="display:flex;"><span>  Closure *cl;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> SParser *p = <span style="color:#c34e00">cast</span>(<span style="color:#00f">struct</span> SParser *, ud);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> c = <span style="color:#c34e00">luaZ_lookahead</span>(p-&gt;z);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_checkGC</span>(L);
</span></span><span style="display:flex;"><span>  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p-&gt;z,
</span></span><span style="display:flex;"><span>                                                             &amp;p-&gt;buff, p-&gt;name);
</span></span><span style="display:flex;"><span>  cl = <span style="color:#c34e00">luaF_newLclosure</span>(L, tf-&gt;nups, <span style="color:#c34e00">hvalue</span>(<span style="color:#c34e00">gt</span>(L)));	<span style="color:#f00;font-style:italic">/* 新生成的clouse的env直接来自gobal&#39;table而不是上层函数的env */</span>
</span></span><span style="display:flex;"><span>  cl-&gt;l.p = tf;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i = 0; i &lt; tf-&gt;nups; i++)  <span style="color:#f00;font-style:italic">/* initialize eventual upvalues */</span>
</span></span><span style="display:flex;"><span>    cl-&gt;l.upvals[i] = <span style="color:#c34e00">luaF_newupval</span>(L);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setclvalue</span>(L, L-&gt;top, cl);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">incr_top</span>(L);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaD_protectedparser</span> (lua_State *L, ZIO *z, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *name) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> SParser p;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> status;
</span></span><span style="display:flex;"><span>  p.z = z; p.name = name;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaZ_initbuffer</span>(L, &amp;p.buff);
</span></span><span style="display:flex;"><span>  status = <span style="color:#c34e00">luaD_pcall</span>(L, f_parser, &amp;p, <span style="color:#c34e00">savestack</span>(L, L-&gt;top), L-&gt;errfunc);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaZ_freebuffer</span>(L, &amp;p.buff);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> status;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/26/lua-5.1-reference-manual/" itemprop="url">
        Lua 5.1 Reference Manual
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-26">
    2021-05-26
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">29874 字 ~141分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>Lua 5.1 Reference Manual
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</p>
<p>Copyright © 2006–2012 Lua.org, PUC-Rio. Freely available under the terms of the Lua license.</p>
<p>contents · index · other versions · english · português · español · deutsch
1 – Introduction
Lua is an extension programming language designed to support general procedural programming with data description facilities. It also offers good support for object-oriented programming, functional programming, and data-driven programming. Lua is intended to be used as a powerful, light-weight scripting language for any program that needs one. Lua is implemented as a library, written in clean C (that is, in the common subset of ANSI C and C++).</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/05/26/lua-5.1-reference-manual/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/23/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lvm.c/" itemprop="url">
        lua源码注释-lvm.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-23">
    2021-05-23
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6104 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://github.com/shankusu2017/lua">github链接</a> lua515子域</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Lua virtual machine
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define lvm_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lfunc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lgc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstring.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltm.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lvm.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* limit for table tag-method chains (to avoid loops) */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define MAXTAGLOOP	100
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* number,string--&gt;number */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> TValue *<span style="color:#c34e00">luaV_tonumber</span> (<span style="color:#00f">const</span> TValue *obj, TValue *n) {
</span></span><span style="display:flex;"><span>  lua_Number num;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(obj)) <span style="color:#00f">return</span> obj;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisstring</span>(obj) &amp;&amp; <span style="color:#c34e00">luaO_str2d</span>(<span style="color:#c34e00">svalue</span>(obj), &amp;num)) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnvalue</span>(n, num);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> n;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* number-&gt;string */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaV_tostring</span> (lua_State *L, StkId obj) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnumber</span>(obj))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">char</span> s[LUAI_MAXNUMBER2STR];
</span></span><span style="display:flex;"><span>    lua_Number n = <span style="color:#c34e00">nvalue</span>(obj);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_number2str</span>(s, n);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setsvalue2s</span>(L, obj, <span style="color:#c34e00">luaS_new</span>(L, s));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 判断调试MASK是否设置，以及相关条件是否已满足，满足则进入钩子函数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">traceexec</span> (lua_State *L, <span style="color:#00f">const</span> Instruction *pc) {
</span></span><span style="display:flex;"><span>  lu_byte mask = L-&gt;hookmask;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> Instruction *oldpc = L-&gt;savedpc;
</span></span><span style="display:flex;"><span>  L-&gt;savedpc = pc;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> ((mask &amp; LUA_MASKCOUNT) &amp;&amp; L-&gt;hookcount == 0) {	<span style="color:#f00;font-style:italic">/* 执行了指定数量的pc，调用指定的钩子函数 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">resethookcount</span>(L);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaD_callhook</span>(L, LUA_HOOKCOUNT, -1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (mask &amp; LUA_MASKLINE) {	<span style="color:#f00;font-style:italic">/* LUA_MASKLINE不是说执行到了某一行，具体的意思看下面的代码 */</span>
</span></span><span style="display:flex;"><span>    Proto *p = <span style="color:#c34e00">ci_func</span>(L-&gt;ci)-&gt;l.p;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> npc = <span style="color:#c34e00">pcRel</span>(pc, p);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> newline = <span style="color:#c34e00">getline</span>(p, npc);
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* call linehook when enter a new function, when jump back (loop),
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       or when enter a new line */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (npc == 0 || pc &lt;= oldpc || newline != <span style="color:#c34e00">getline</span>(p, <span style="color:#c34e00">pcRel</span>(oldpc, p)))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaD_callhook</span>(L, LUA_HOOKLINE, newline);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 调用元方法，将结果返回给res */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">callTMres</span> (lua_State *L, StkId res, <span style="color:#00f">const</span> TValue *f,
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">const</span> TValue *p1, <span style="color:#00f">const</span> TValue *p2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">ptrdiff_t</span> result = <span style="color:#c34e00">savestack</span>(L, res);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top, f);  <span style="color:#f00;font-style:italic">/* push function */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top+1, p1);  <span style="color:#f00;font-style:italic">/* 1st argument */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top+2, p2);  <span style="color:#f00;font-style:italic">/* 2nd argument */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_checkstack</span>(L, 3);
</span></span><span style="display:flex;"><span>  L-&gt;top += 3;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_call</span>(L, L-&gt;top - 3, 1);
</span></span><span style="display:flex;"><span>  res = <span style="color:#c34e00">restorestack</span>(L, result);
</span></span><span style="display:flex;"><span>  L-&gt;top--;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobjs2s</span>(L, res, L-&gt;top);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">callTM</span> (lua_State *L, <span style="color:#00f">const</span> TValue *f, <span style="color:#00f">const</span> TValue *p1,
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">const</span> TValue *p2, <span style="color:#00f">const</span> TValue *p3) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top, f);  <span style="color:#f00;font-style:italic">/* push function */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top+1, p1);  <span style="color:#f00;font-style:italic">/* 1st argument */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top+2, p2);  <span style="color:#f00;font-style:italic">/* 2nd argument */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setobj2s</span>(L, L-&gt;top+3, p3);  <span style="color:#f00;font-style:italic">/* 3th argument */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_checkstack</span>(L, 4);
</span></span><span style="display:flex;"><span>  L-&gt;top += 4;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaD_call</span>(L, L-&gt;top - 4, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaV_gettable</span> (lua_State *L, <span style="color:#00f">const</span> TValue *t, TValue *key, StkId val) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> loop;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> TValue *tm;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttistable</span>(t)) {  <span style="color:#f00;font-style:italic">/* `t&#39; is a table? */</span>
</span></span><span style="display:flex;"><span>      Table *h = <span style="color:#c34e00">hvalue</span>(t);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">const</span> TValue *res = <span style="color:#c34e00">luaH_get</span>(h, key); <span style="color:#f00;font-style:italic">/* do a primitive get */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(res) ||  <span style="color:#f00;font-style:italic">/* result is no nil? */</span>
</span></span><span style="display:flex;"><span>          (tm = <span style="color:#c34e00">fasttm</span>(L, h-&gt;metatable, TM_INDEX)) == NULL) { <span style="color:#f00;font-style:italic">/* or no TM? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobj2s</span>(L, val, res);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* else will try the tag method */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(tm = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, t, TM_INDEX)))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaG_typeerror</span>(L, t, <span style="color:#009c00">&#34;index&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisfunction</span>(tm)) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">callTMres</span>(L, val, tm, t, key);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    t = tm;  <span style="color:#f00;font-style:italic">/* else repeat with `tm&#39; */</span> 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;loop in gettable&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaV_settable</span> (lua_State *L, <span style="color:#00f">const</span> TValue *t, TValue *key, StkId val) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> loop;
</span></span><span style="display:flex;"><span>  TValue temp;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> TValue *tm;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttistable</span>(t)) {  <span style="color:#f00;font-style:italic">/* `t&#39; is a table? */</span>
</span></span><span style="display:flex;"><span>      Table *h = <span style="color:#c34e00">hvalue</span>(t);
</span></span><span style="display:flex;"><span>      TValue *oldval = <span style="color:#c34e00">luaH_set</span>(L, h, key); <span style="color:#f00;font-style:italic">/* do a primitive set */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(oldval) ||  <span style="color:#f00;font-style:italic">/* result is no nil? */</span>
</span></span><span style="display:flex;"><span>          (tm = <span style="color:#c34e00">fasttm</span>(L, h-&gt;metatable, TM_NEWINDEX)) == NULL) { <span style="color:#f00;font-style:italic">/* or no TM? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobj2t</span>(L, oldval, val);
</span></span><span style="display:flex;"><span>        h-&gt;flags = 0;	<span style="color:#f00;font-style:italic">/* 更新flags:假设所有的tm都存在 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaC_barriert</span>(L, h, val);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* else will try the tag method */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(tm = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, t, TM_NEWINDEX)))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaG_typeerror</span>(L, t, <span style="color:#009c00">&#34;index&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisfunction</span>(tm)) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">callTM</span>(L, tm, t, key, val);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* else repeat with `tm&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setobj</span>(L, &amp;temp, tm);  <span style="color:#f00;font-style:italic">/* avoid pointing inside table (may rehash) */</span>
</span></span><span style="display:flex;"><span>    t = &amp;temp;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;loop in settable&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 同上callTM，针对tblA+tblB这种两个操作数的，尝试调用特定元方法 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">call_binTM</span> (lua_State *L, <span style="color:#00f">const</span> TValue *p1, <span style="color:#00f">const</span> TValue *p2,
</span></span><span style="display:flex;"><span>                       StkId res, TMS event) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, p1, event);  <span style="color:#f00;font-style:italic">/* try first operand */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(tm))
</span></span><span style="display:flex;"><span>    tm = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, p2, event);  <span style="color:#f00;font-style:italic">/* try second operand */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(tm)) <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">callTMres</span>(L, res, tm, p1, p2);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* only for userdata */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">const</span> TValue *<span style="color:#c34e00">get_compTM</span> (lua_State *L, Table *mt1, Table *mt2,
</span></span><span style="display:flex;"><span>                                  TMS event) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm1 = <span style="color:#c34e00">fasttm</span>(L, mt1, event);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm2;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (tm1 == NULL) <span style="color:#00f">return</span> NULL;  <span style="color:#f00;font-style:italic">/* no metamethod */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (mt1 == mt2) <span style="color:#00f">return</span> tm1;  <span style="color:#f00;font-style:italic">/* same metatables =&gt; same metamethods */</span>
</span></span><span style="display:flex;"><span>  tm2 = <span style="color:#c34e00">fasttm</span>(L, mt2, event);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (tm2 == NULL) <span style="color:#00f">return</span> NULL;  <span style="color:#f00;font-style:italic">/* no metamethod */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">luaO_rawequalObj</span>(tm1, tm2))  <span style="color:#f00;font-style:italic">/* same metamethods? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> tm1;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> NULL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 元方法：比较操作 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">call_orderTM</span> (lua_State *L, <span style="color:#00f">const</span> TValue *p1, <span style="color:#00f">const</span> TValue *p2,
</span></span><span style="display:flex;"><span>                         TMS event) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm1 = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, p1, event);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm2;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(tm1)) <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* no metamethod? */</span>
</span></span><span style="display:flex;"><span>  tm2 = <span style="color:#c34e00">luaT_gettmbyobj</span>(L, p2, event);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">luaO_rawequalObj</span>(tm1, tm2))  <span style="color:#f00;font-style:italic">/* different metamethods? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> -1;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">callTMres</span>(L, L-&gt;top, tm1, p1, p2);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> !<span style="color:#c34e00">l_isfalse</span>(L-&gt;top);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">l_strcmp</span> (<span style="color:#00f">const</span> TString *ls, <span style="color:#00f">const</span> TString *rs) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *l = <span style="color:#c34e00">getstr</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">size_t</span> ll = ls-&gt;tsv.len;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *r = <span style="color:#c34e00">getstr</span>(rs);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">size_t</span> lr = rs-&gt;tsv.len;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> temp = <span style="color:#c34e00">strcoll</span>(l, r);	<span style="color:#f00;font-style:italic">/* 依环境变量 LC_COLLATE 所指定的文字排列次序来比较 s1 和 s2 字符串 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (temp != 0) <span style="color:#00f">return</span> temp;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* strings are equal up to a `\0&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">size_t</span> len = <span style="color:#c34e00">strlen</span>(l);  <span style="color:#f00;font-style:italic">/* index of first `\0&#39; in both strings */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (len == lr)  <span style="color:#f00;font-style:italic">/* r is finished? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> (len == ll) ? 0 : 1;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> <span style="color:#00f">if</span> (len == ll)  <span style="color:#f00;font-style:italic">/* l is finished? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* l is smaller than r (because r is not finished) */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* both strings longer than `len&#39;; go on comparing (after the `\0&#39;) */</span>
</span></span><span style="display:flex;"><span>      len++;
</span></span><span style="display:flex;"><span>      l += len; ll -= len; r += len; lr -= len;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 比较指令 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaV_lessthan</span> (lua_State *L, <span style="color:#00f">const</span> TValue *l, <span style="color:#00f">const</span> TValue *r) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> res;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttype</span>(l) != <span style="color:#c34e00">ttype</span>(r))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">luaG_ordererror</span>(L, l, r);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(l))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">luai_numlt</span>(<span style="color:#c34e00">nvalue</span>(l), <span style="color:#c34e00">nvalue</span>(r));
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisstring</span>(l))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">l_strcmp</span>(<span style="color:#c34e00">rawtsvalue</span>(l), <span style="color:#c34e00">rawtsvalue</span>(r)) &lt; 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> ((res = <span style="color:#c34e00">call_orderTM</span>(L, l, r, TM_LT)) != -1)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> res;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaG_ordererror</span>(L, l, r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">lessequal</span> (lua_State *L, <span style="color:#00f">const</span> TValue *l, <span style="color:#00f">const</span> TValue *r) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> res;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttype</span>(l) != <span style="color:#c34e00">ttype</span>(r))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">luaG_ordererror</span>(L, l, r);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(l))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">luai_numle</span>(<span style="color:#c34e00">nvalue</span>(l), <span style="color:#c34e00">nvalue</span>(r));
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisstring</span>(l))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">l_strcmp</span>(<span style="color:#c34e00">rawtsvalue</span>(l), <span style="color:#c34e00">rawtsvalue</span>(r)) &lt;= 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> ((res = <span style="color:#c34e00">call_orderTM</span>(L, l, r, TM_LE)) != -1)  <span style="color:#f00;font-style:italic">/* first try `le&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> res;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> ((res = <span style="color:#c34e00">call_orderTM</span>(L, r, l, TM_LT)) != -1)  <span style="color:#f00;font-style:italic">/* else try `lt&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> !res;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaG_ordererror</span>(L, l, r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaV_equalval</span> (lua_State *L, <span style="color:#00f">const</span> TValue *t1, <span style="color:#00f">const</span> TValue *t2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *tm;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">ttype</span>(t1) == <span style="color:#c34e00">ttype</span>(t2));
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (<span style="color:#c34e00">ttype</span>(t1)) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TNIL: <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TNUMBER: <span style="color:#00f">return</span> <span style="color:#c34e00">luai_numeq</span>(<span style="color:#c34e00">nvalue</span>(t1), <span style="color:#c34e00">nvalue</span>(t2));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TBOOLEAN: <span style="color:#00f">return</span> <span style="color:#c34e00">bvalue</span>(t1) == <span style="color:#c34e00">bvalue</span>(t2);  <span style="color:#f00;font-style:italic">/* true must be 1 !! */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TLIGHTUSERDATA: <span style="color:#00f">return</span> <span style="color:#c34e00">pvalue</span>(t1) == <span style="color:#c34e00">pvalue</span>(t2);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TUSERDATA: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">uvalue</span>(t1) == <span style="color:#c34e00">uvalue</span>(t2)) <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>      tm = <span style="color:#c34e00">get_compTM</span>(L, <span style="color:#c34e00">uvalue</span>(t1)-&gt;metatable, <span style="color:#c34e00">uvalue</span>(t2)-&gt;metatable,
</span></span><span style="display:flex;"><span>                         TM_EQ);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* will try TM */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TTABLE: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">hvalue</span>(t1) == <span style="color:#c34e00">hvalue</span>(t2)) <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>      tm = <span style="color:#c34e00">get_compTM</span>(L, <span style="color:#c34e00">hvalue</span>(t1)-&gt;metatable, <span style="color:#c34e00">hvalue</span>(t2)-&gt;metatable, TM_EQ);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* will try TM */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> <span style="color:#c34e00">gcvalue</span>(t1) == <span style="color:#c34e00">gcvalue</span>(t2);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (tm == NULL) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* no TM? */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">callTMres</span>(L, L-&gt;top, tm, t1, t2);  <span style="color:#f00;font-style:italic">/* call TM */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> !<span style="color:#c34e00">l_isfalse</span>(L-&gt;top);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 从last开始，一共链接total个slot          */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaV_concat</span> (lua_State *L, <span style="color:#00f">int</span> total, <span style="color:#00f">int</span> last) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>    StkId top = L-&gt;base + last + 1;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> n = 2;  <span style="color:#f00;font-style:italic">/* number of elements handled in this pass (at least 2) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!(<span style="color:#c34e00">ttisstring</span>(top-2) || <span style="color:#c34e00">ttisnumber</span>(top-2)) || !<span style="color:#c34e00">tostring</span>(L, top-1)) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">call_binTM</span>(L, top-2, top-1, top-2, TM_CONCAT))
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaG_concaterror</span>(L, top-2, top-1);
</span></span><span style="display:flex;"><span>    } <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">tsvalue</span>(top-1)-&gt;len == 0)  <span style="color:#f00;font-style:italic">/* second op is empty? */</span>
</span></span><span style="display:flex;"><span>      (<span style="color:#00f">void</span>)<span style="color:#c34e00">tostring</span>(L, top - 2);  <span style="color:#f00;font-style:italic">/* result is first op (as string) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* at least two string values; get as many as possible */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">size_t</span> tl = <span style="color:#c34e00">tsvalue</span>(top-1)-&gt;len;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">char</span> *buffer;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* collect total length */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">for</span> (n = 1; n &lt; total &amp;&amp; <span style="color:#c34e00">tostring</span>(L, top-n-1); n++) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">size_t</span> l = <span style="color:#c34e00">tsvalue</span>(top-n-1)-&gt;len;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (l &gt;= MAX_SIZET - tl) <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;string length overflow&#34;</span>);
</span></span><span style="display:flex;"><span>        tl += l;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      buffer = <span style="color:#c34e00">luaZ_openspace</span>(L, &amp;<span style="color:#c34e00">G</span>(L)-&gt;buff, tl);
</span></span><span style="display:flex;"><span>      tl = 0;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">for</span> (i=n; i&gt;0; i--) {  <span style="color:#f00;font-style:italic">/* concat all strings */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">size_t</span> l = <span style="color:#c34e00">tsvalue</span>(top-i)-&gt;len;
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">memcpy</span>(buffer+tl, <span style="color:#c34e00">svalue</span>(top-i), l);
</span></span><span style="display:flex;"><span>        tl += l;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setsvalue2s</span>(L, top-n, <span style="color:#c34e00">luaS_newlstr</span>(L, buffer, tl));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    total -= n-1;  <span style="color:#f00;font-style:italic">/* got `n&#39; strings to create 1 new */</span>
</span></span><span style="display:flex;"><span>    last -= n-1;
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">while</span> (total &gt; 1);  <span style="color:#f00;font-style:italic">/* repeat until only 1 result left */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">Arith</span> (lua_State *L, StkId ra, <span style="color:#00f">const</span> TValue *rb,
</span></span><span style="display:flex;"><span>                   <span style="color:#00f">const</span> TValue *rc, TMS op) {
</span></span><span style="display:flex;"><span>  TValue tempb, tempc;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *b, *c;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> ((b = <span style="color:#c34e00">luaV_tonumber</span>(rb, &amp;tempb)) != NULL &amp;&amp;
</span></span><span style="display:flex;"><span>      (c = <span style="color:#c34e00">luaV_tonumber</span>(rc, &amp;tempc)) != NULL) {
</span></span><span style="display:flex;"><span>    lua_Number nb = <span style="color:#c34e00">nvalue</span>(b), nc = <span style="color:#c34e00">nvalue</span>(c);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_ADD: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numadd</span>(nb, nc)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_SUB: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numsub</span>(nb, nc)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_MUL: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_nummul</span>(nb, nc)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_DIV: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numdiv</span>(nb, nc)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_MOD: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_nummod</span>(nb, nc)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_POW: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numpow</span>(nb, nc)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TM_UNM: <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numunm</span>(nb)); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">default</span>: <span style="color:#c34e00">lua_assert</span>(0); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!<span style="color:#c34e00">call_binTM</span>(L, rb, rc, ra, op))
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaG_aritherror</span>(L, rb, rc);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** some macros for common tasks in `luaV_execute&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define runtime_check(L, c)	{ if (!(c)) break; }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 提取指令中A,B,C的值 */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define RA(i)	(base+GETARG_A(i))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#f00;font-style:italic">/* to be used after possible stack reallocation */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* x可能触发新的frame，这里保存和恢复“部分现场”配合下面的execute一起看 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** pc:为何要存档呢？这是一个局部变量，且是相对frame有效，若切换execute则pc作为上一个execute的局部变量保存起来了，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**    所以为啥要保存这个变量呢？
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** base: {x}可能修改stack,造成base记录的本frame的base失效，故而这里要刷新base
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define Protect(x)	{ L-&gt;savedpc = pc; {x;}; base = L-&gt;base; }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 这个宏有意思哈 */</span> 
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define arith_op(op,tm) { \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        TValue *rb = RKB(i); \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        TValue *rc = RKC(i); \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) { \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">          setnvalue(ra, op(nb, nc)); \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        } \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        else \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">          Protect(Arith(L, ra, rb, rc, tm)); \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** KEYCODE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nexeccalls:Lua连续调用的层次
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** eg: c(0)-&gt;Lua(1)-&gt;Lua(2)-&gt;c()-&gt;Lua(1)-&gt;Lua(2)-&gt;Lua(3)-&gt;c(0)-&gt;Lua(1)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 某次Lua调用结束，--nexeccalls，如果nexeccalls==0，表示当前lua调用链结束了，需要跳出luaV_execute函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 大于0表示本Lua调用结束后，上一层必然还是Lua函数，需要进入reentry点
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaV_execute</span> (lua_State *L, <span style="color:#00f">int</span> nexeccalls) {
</span></span><span style="display:flex;"><span>  LClosure *cl;
</span></span><span style="display:flex;"><span>  StkId base;
</span></span><span style="display:flex;"><span>  TValue *k;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> Instruction *pc;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span> reentry:  <span style="color:#f00;font-style:italic">/* entry point for new (callInfo,frame) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">isLua</span>(L-&gt;ci));	<span style="color:#f00;font-style:italic">/* C函数frame的执行不在这里，亲! */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* KEYCODE vm执行的关键参数:base,top,pc,savedpc, closure,k, L-&gt;ci,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 后续因为call和return等切换调用栈时，必须正确处理上述参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** !!!!!!!! L-&gt;top没有在这里更新，这点要有印象，resason:类似funA(funB())一个函数(frame)运行完毕时的某些状态eg:L-&gt;top
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 对上下文的frame可能有影响，所以这里没有更新L-&gt;top，而是让有关业务(return,call...)自行处理
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  pc = L-&gt;savedpc;
</span></span><span style="display:flex;"><span>  cl = &amp;<span style="color:#c34e00">clvalue</span>(L-&gt;ci-&gt;func)-&gt;l;
</span></span><span style="display:flex;"><span>  base = L-&gt;base;
</span></span><span style="display:flex;"><span>  k = cl-&gt;p-&gt;k;	<span style="color:#f00;font-style:italic">/* locvars 仅在编译阶段/调试库中有效，虚拟机运行阶段无效(已编码到pc中) */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* main loop of interpreter */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">const</span> Instruction i = *pc++;	<span style="color:#f00;font-style:italic">/* 等效：*(pc++) */</span>
</span></span><span style="display:flex;"><span>    StkId ra;
</span></span><span style="display:flex;"><span>   <span style="color:#f00;font-style:italic">/* 运行钩子逻辑 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;
</span></span><span style="display:flex;"><span>        (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">traceexec</span>(L, pc);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (L-&gt;status == LUA_YIELD) {  <span style="color:#f00;font-style:italic">/* did hook yield? */</span>
</span></span><span style="display:flex;"><span>        L-&gt;savedpc = pc - 1;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      base = L-&gt;base;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* warning!! several(某些) calls may realloc the stack and invalidate `ra&#39; */</span>
</span></span><span style="display:flex;"><span>    ra = <span style="color:#c34e00">RA</span>(i);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(base == L-&gt;base &amp;&amp; L-&gt;base == L-&gt;ci-&gt;base);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt;= L-&gt;stack + L-&gt;stacksize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* luaG_checkopenop的用途对照上面L-&gt;top的注释看就明白了 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(L-&gt;top == L-&gt;ci-&gt;top || <span style="color:#c34e00">luaG_checkopenop</span>(i));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> (<span style="color:#c34e00">GET_OPCODE</span>(i)) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_MOVE: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjs2s</span>(L, ra, <span style="color:#c34e00">RB</span>(i));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_LOADK: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobj2s</span>(L, ra, <span style="color:#c34e00">KBx</span>(i));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_LOADBOOL: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setbvalue</span>(ra, <span style="color:#c34e00">GETARG_B</span>(i));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">GETARG_C</span>(i)) pc++;  <span style="color:#f00;font-style:italic">/* skip next instruction (if C) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_LOADNIL: {
</span></span><span style="display:flex;"><span>        TValue *rb = <span style="color:#c34e00">RB</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setnilvalue</span>(rb--);
</span></span><span style="display:flex;"><span>        } <span style="color:#00f">while</span> (rb &gt;= ra);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_GETUPVAL: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobj2s</span>(L, ra, cl-&gt;upvals[b]-&gt;v);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_GETGLOBAL: {
</span></span><span style="display:flex;"><span>        TValue g;
</span></span><span style="display:flex;"><span>        TValue *rb = <span style="color:#c34e00">KBx</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">sethvalue</span>(L, &amp;g, cl-&gt;env);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">ttisstring</span>(rb));	<span style="color:#f00;font-style:italic">/* 全局变量名类型必须是TString */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaV_gettable</span>(L, &amp;g, rb, ra));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_GETTABLE: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaV_gettable</span>(L, <span style="color:#c34e00">RB</span>(i), <span style="color:#c34e00">RKC</span>(i), ra));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_SETGLOBAL: {
</span></span><span style="display:flex;"><span>        TValue g;
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">sethvalue</span>(L, &amp;g, cl-&gt;env);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">ttisstring</span>(<span style="color:#c34e00">KBx</span>(i)));
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaV_settable</span>(L, &amp;g, <span style="color:#c34e00">KBx</span>(i), ra));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_SETUPVAL: {
</span></span><span style="display:flex;"><span>        UpVal *uv = cl-&gt;upvals[<span style="color:#c34e00">GETARG_B</span>(i)];
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobj</span>(L, uv-&gt;v, ra);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaC_barrier</span>(L, uv, ra);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_SETTABLE: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaV_settable</span>(L, ra, <span style="color:#c34e00">RKB</span>(i), <span style="color:#c34e00">RKC</span>(i)));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_NEWTABLE: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> c = <span style="color:#c34e00">GETARG_C</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">sethvalue</span>(L, ra, <span style="color:#c34e00">luaH_new</span>(L, <span style="color:#c34e00">luaO_fb2int</span>(b), <span style="color:#c34e00">luaO_fb2int</span>(c)));
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaC_checkGC</span>(L));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_SELF: {
</span></span><span style="display:flex;"><span>        StkId rb = <span style="color:#c34e00">RB</span>(i);	<span style="color:#f00;font-style:italic">/* 拿到self.sub中的self指代的表 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjs2s</span>(L, ra+1, rb);	<span style="color:#f00;font-style:italic">/* 将上述表self存起来 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaV_gettable</span>(L, rb, <span style="color:#c34e00">RKC</span>(i), ra)); <span style="color:#f00;font-style:italic">/* 计算self.sub的值 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_ADD: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">arith_op</span>(luai_numadd, TM_ADD);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_SUB: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">arith_op</span>(luai_numsub, TM_SUB);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_MUL: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">arith_op</span>(luai_nummul, TM_MUL);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_DIV: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">arith_op</span>(luai_numdiv, TM_DIV);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_MOD: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">arith_op</span>(luai_nummod, TM_MOD);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_POW: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">arith_op</span>(luai_numpow, TM_POW);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_UNM: {
</span></span><span style="display:flex;"><span>        TValue *rb = <span style="color:#c34e00">RB</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(rb)) {
</span></span><span style="display:flex;"><span>          lua_Number nb = <span style="color:#c34e00">nvalue</span>(rb);
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numunm</span>(nb));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">Arith</span>(L, ra, rb, rb, TM_UNM));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_NOT: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> res = <span style="color:#c34e00">l_isfalse</span>(<span style="color:#c34e00">RB</span>(i));  <span style="color:#f00;font-style:italic">/* next assignment may change this value */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setbvalue</span>(ra, res);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_LEN: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> TValue *rb = <span style="color:#c34e00">RB</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">switch</span> (<span style="color:#c34e00">ttype</span>(rb)) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> LUA_TTABLE: {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">cast_num</span>(<span style="color:#c34e00">luaH_getn</span>(<span style="color:#c34e00">hvalue</span>(rb))));
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> LUA_TSTRING: {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">cast_num</span>(<span style="color:#c34e00">tsvalue</span>(rb)-&gt;len));
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">default</span>: {  <span style="color:#f00;font-style:italic">/* try metamethod */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">Protect</span>(
</span></span><span style="display:flex;"><span>              <span style="color:#00f">if</span> (!<span style="color:#c34e00">call_binTM</span>(L, rb, luaO_nilobject, ra, TM_LEN))
</span></span><span style="display:flex;"><span>                <span style="color:#c34e00">luaG_typeerror</span>(L, rb, <span style="color:#009c00">&#34;get length of&#34;</span>);
</span></span><span style="display:flex;"><span>            )
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_CONCAT: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> c = <span style="color:#c34e00">GETARG_C</span>(i);
</span></span><span style="display:flex;"><span>		<span style="color:#f00;font-style:italic">/* */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaV_concat</span>(L, c-b+1, c); <span style="color:#c34e00">luaC_checkGC</span>(L));
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjs2s</span>(L, <span style="color:#c34e00">RA</span>(i), base+b);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_JMP: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(i));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* KEYCODE 重点，难点，代表性的指令 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	** if ((RK(B) == RK(C)) ~= A) then pc++
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	** OP_EQ后面紧跟着是跳转指令，这里猜测，跳转的值Bx应该短1，因为后面又进行了pc++
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	*/</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_EQ: {
</span></span><span style="display:flex;"><span>        TValue *rb = <span style="color:#c34e00">RKB</span>(i);
</span></span><span style="display:flex;"><span>        TValue *rc = <span style="color:#c34e00">RKC</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (<span style="color:#c34e00">equalobj</span>(L, rb, rc) == <span style="color:#c34e00">GETARG_A</span>(i))
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(*pc));
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        pc++;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_LT: {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (<span style="color:#c34e00">luaV_lessthan</span>(L, <span style="color:#c34e00">RKB</span>(i), <span style="color:#c34e00">RKC</span>(i)) == <span style="color:#c34e00">GETARG_A</span>(i))
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(*pc));
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        pc++;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_LE: {	
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (<span style="color:#c34e00">lessequal</span>(L, <span style="color:#c34e00">RKB</span>(i), <span style="color:#c34e00">RKC</span>(i)) == <span style="color:#c34e00">GETARG_A</span>(i))
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(*pc));
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        pc++;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_TEST: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">l_isfalse</span>(ra) != <span style="color:#c34e00">GETARG_C</span>(i))
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(*pc));
</span></span><span style="display:flex;"><span>        pc++;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_TESTSET: {
</span></span><span style="display:flex;"><span>        TValue *rb = <span style="color:#c34e00">RB</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">l_isfalse</span>(rb) != <span style="color:#c34e00">GETARG_C</span>(i)) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setobjs2s</span>(L, ra, rb);
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(*pc));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pc++;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_CALL: {	<span style="color:#f00;font-style:italic">/* R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i);			<span style="color:#f00;font-style:italic">/* 传入参数个数，          B:0：...  1：0个，2：1个，3：2个依次类推 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> nresults = <span style="color:#c34e00">GETARG_C</span>(i) - 1;	<span style="color:#f00;font-style:italic">/* 期待的返回值个数 C:0(...), 1:(期待返回0个)，2:(期待返回1个) */</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">/* 注解99: 当传入的参数数量明确时，设置L-&gt;top告知被调用函数确切的传入参数数量,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        ** 不明确时，OP_VARARG(fun(...))/	RETURN.B(funA(funB())等指令中已确定了top的位置，这里不能也不用再更改设置(否则L-&gt;top!=实际传入的参数位置)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        ** L-&gt;top都是指向了最后一个参数的&#34;位置&#34;,也是告知被调用函数，我已经准备好了你要的参数且top指针已指到相应的位置了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (b != 0) 
</span></span><span style="display:flex;"><span>			L-&gt;top = ra+b;  <span style="color:#f00;font-style:italic">/* else previous instruction set top */</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        L-&gt;savedpc = pc;	<span style="color:#f00;font-style:italic">/* 记下原本接下来要执行的下一条指令，等待new&#39;frame运行结束后，继续运行本frame */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">switch</span> (<span style="color:#c34e00">luaD_precall</span>(L, ra, nresults)) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> PCRLUA: {
</span></span><span style="display:flex;"><span>            nexeccalls++;
</span></span><span style="display:flex;"><span>			<span style="color:#f00;font-style:italic">/* 若子函数(frame)是Lua，这里continue才真正开始执行子函数(frame)的opcode */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> reentry;  <span style="color:#f00;font-style:italic">/* restart luaV_execute over new Lua function */</span>
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> PCRC: {
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">/* it was a C function (`precall&#39; called it); adjust results */</span>
</span></span><span style="display:flex;"><span>		  
</span></span><span style="display:flex;"><span>		    <span style="color:#f00;font-style:italic">/* 注解100: C调用结束时luaD_poscall已经将所有的返回值填充到RA开头的addr上,L-&gt;top指向最后一个返回值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		    ** 期待返回值个数确定时eg:local a,b = fun()，luaD_poscall函数自动赋值了a,b，L-&gt;top已经完成了使命
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		    **     故而这里将其复原。
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		    ** 期待返回个数不确定时eg:local t = {fun()}或funA(funB())，这种情况下L-&gt;top指向的最后一个返回值地址，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		    **     将被下一条指令setlist(B=0)或callA(B=0)用于计算传入参数的个数，所以不能复原(下一条指令要用到)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		    */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (nresults &gt;= 0)
</span></span><span style="display:flex;"><span>				L-&gt;top = L-&gt;ci-&gt;top;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>            base = L-&gt;base;	<span style="color:#f00;font-style:italic">/* 调用过程中stack可能变化而移动，故而重新获取最新的(L-&gt;ci-&gt;base==L-&gt;base)的base，下同 */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f00;font-style:italic">/* 子函数(frame)为c,luaD_precall的返回意味着子函数(frame)已运行完毕，相关参数也调整完毕
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">			** 这里接着运行母函数(frame)的紧跟着OP_CALL后面的下一条指令 */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">continue</span>;	
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* yield,交出lua的执行权 */</span>
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_TAILCALL: {
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* A B C return R(A)(R(A+1), ... ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (b != 0) {
</span></span><span style="display:flex;"><span>			L-&gt;top = ra+b;  <span style="color:#f00;font-style:italic">/* else previous instruction set top */</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        	<span style="color:#f00;font-style:italic">/* return fun(...) 前面的OP_VARARG指令设置好了L-&gt;top */</span> 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        L-&gt;savedpc = pc;
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">GETARG_C</span>(i) - 1 == LUA_MULTRET);	<span style="color:#f00;font-style:italic">/* 尾调用的定义中：必须返回其调用返回的所有值，所以这里C必须为0 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">switch</span> (<span style="color:#c34e00">luaD_precall</span>(L, ra, LUA_MULTRET)) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> PCRLUA: {	<span style="color:#f00;font-style:italic">/* 画图，代码不难，看懂它们 */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">/* tail call: put new frame in place of previous one */</span>
</span></span><span style="display:flex;"><span>            CallInfo *ci = L-&gt;ci - 1;  <span style="color:#f00;font-style:italic">/* previous frame */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> aux;
</span></span><span style="display:flex;"><span>            StkId func = ci-&gt;func;
</span></span><span style="display:flex;"><span>            StkId pfunc = (ci+1)-&gt;func;  <span style="color:#f00;font-style:italic">/* previous function index */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (L-&gt;openupval) <span style="color:#c34e00">luaF_close</span>(L, ci-&gt;base);
</span></span><span style="display:flex;"><span>            L-&gt;base = ci-&gt;base = ci-&gt;func + ((ci+1)-&gt;base - pfunc);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#f00;font-style:italic">/* ！！！！移动后func指向的地址不变，但值改变了（由母函数变成了被尾调用的子函数) */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (aux = 0; pfunc+aux &lt; L-&gt;top; aux++)  <span style="color:#f00;font-style:italic">/* move frame down */</span>
</span></span><span style="display:flex;"><span>              <span style="color:#c34e00">setobjs2s</span>(L, func+aux, pfunc+aux);
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>            ci-&gt;top = L-&gt;top = func+aux;  <span style="color:#f00;font-style:italic">/* correct top */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">lua_assert</span>(L-&gt;top == L-&gt;base + <span style="color:#c34e00">clvalue</span>(func)-&gt;l.p-&gt;maxstacksize);
</span></span><span style="display:flex;"><span>            ci-&gt;savedpc = L-&gt;savedpc;	<span style="color:#f00;font-style:italic">/* 这里也要更新 */</span>
</span></span><span style="display:flex;"><span>            ci-&gt;tailcalls++;  <span style="color:#f00;font-style:italic">/* one more call lost */</span>
</span></span><span style="display:flex;"><span>            L-&gt;ci--;  <span style="color:#f00;font-style:italic">/* remove new frame */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> reentry;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">case</span> PCRC: {  <span style="color:#f00;font-style:italic">/* it was a C function (`precall&#39; called it) */</span>
</span></span><span style="display:flex;"><span>            base = L-&gt;base;	<span style="color:#f00;font-style:italic">/* restore base */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* yield */</span>
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_RETURN: {
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* return R(A), ... ,R(A+B-2) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i);	<span style="color:#f00;font-style:italic">/* 0：返回所有值，1：返回0个值，2：返回1个值 ... */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (b != 0) <span style="color:#f00;font-style:italic">/* b==0其它的指令argvar等已处理好top,eg:(return ...)或者return(a, fun()) */</span>
</span></span><span style="display:flex;"><span>			L-&gt;top = ra+b-1;	<span style="color:#f00;font-style:italic">/* 以便确定返回值的确切个数 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (L-&gt;openupval) <span style="color:#c34e00">luaF_close</span>(L, base);
</span></span><span style="display:flex;"><span>        L-&gt;savedpc = pc;
</span></span><span style="display:flex;"><span>        b = <span style="color:#c34e00">luaD_poscall</span>(L, ra);	<span style="color:#f00;font-style:italic">/* 将子函数的返回值移到指定地方，并适配母函数的result要求 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#f00;font-style:italic">/* lua调用结束，返回值已经按照移动到指定的位置(本fun的addr)，且L-&gt;top指向了最后一个返回值的位置(可以用来计算返回值的个数)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		   这里直接return，将CPU交换到母C函数 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (--nexeccalls == 0)  <span style="color:#f00;font-style:italic">/* was previous function running `here&#39;? Lua层面的调用结束了，结束lua的execute的执行，返回到C */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* no: return */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* yes: continue its execution */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (b) <span style="color:#f00;font-style:italic">/* 同上注解100，请往上翻阅 */</span>
</span></span><span style="display:flex;"><span>		  	L-&gt;top = L-&gt;ci-&gt;top;	<span style="color:#f00;font-style:italic">/*  */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">isLua</span>(L-&gt;ci)); <span style="color:#f00;font-style:italic">/* return后，lua连续调用链还没结束，那么上一层必然是个lua函数 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">GET_OPCODE</span>(*((L-&gt;ci)-&gt;savedpc - 1)) == OP_CALL);	<span style="color:#f00;font-style:italic">/* 上一个指令必然是call */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">goto</span> reentry;	<span style="color:#f00;font-style:italic">/* 切回到母lua的execute的frame */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_FORLOOP: {	<span style="color:#f00;font-style:italic">/* 先看 OP_FORPREP 指令 */</span>
</span></span><span style="display:flex;"><span>        lua_Number step = <span style="color:#c34e00">nvalue</span>(ra+2);
</span></span><span style="display:flex;"><span>        lua_Number idx = <span style="color:#c34e00">luai_numadd</span>(<span style="color:#c34e00">nvalue</span>(ra), step); <span style="color:#f00;font-style:italic">/* increment index */</span>
</span></span><span style="display:flex;"><span>        lua_Number limit = <span style="color:#c34e00">nvalue</span>(ra+1);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">luai_numlt</span>(0, step) ? <span style="color:#c34e00">luai_numle</span>(idx, limit)
</span></span><span style="display:flex;"><span>                                : <span style="color:#c34e00">luai_numle</span>(limit, idx)) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(i));  <span style="color:#f00;font-style:italic">/* jump back */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setnvalue</span>(ra, idx);  <span style="color:#f00;font-style:italic">/* update internal index... */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setnvalue</span>(ra+3, idx);  <span style="color:#f00;font-style:italic">/* ...and external index 这个idx才是暴露给for循环里面的i(for i = 0; 10; 1) */</span> 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_FORPREP: {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> TValue *init = ra;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> TValue *plimit = ra+1;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">const</span> TValue *pstep = ra+2;
</span></span><span style="display:flex;"><span>        L-&gt;savedpc = pc;  <span style="color:#f00;font-style:italic">/* next steps may throw errors */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (!<span style="color:#c34e00">tonumber</span>(init, ra))
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;for&#34;</span>) <span style="color:#009c00">&#34; initial value must be a number&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!<span style="color:#c34e00">tonumber</span>(plimit, ra+1))
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;for&#34;</span>) <span style="color:#009c00">&#34; limit must be a number&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!<span style="color:#c34e00">tonumber</span>(pstep, ra+2))
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;for&#34;</span>) <span style="color:#009c00">&#34; step must be a number&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setnvalue</span>(ra, <span style="color:#c34e00">luai_numsub</span>(<span style="color:#c34e00">nvalue</span>(ra), <span style="color:#c34e00">nvalue</span>(pstep)));	<span style="color:#f00;font-style:italic">/* 这里提前-=step */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(i));	<span style="color:#f00;font-style:italic">/* 跳到cond判断那里 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_TFORLOOP: {
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* 编译模块保证了ra+3是个有意义的参数 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	** next函数会吃掉传入的参数，所以这里CP了一份
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	    */</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#f00;font-style:italic">/* 结合 http://shankusu.me/lua/ANo-FrillsIntroductiontoLua51VMInstructions/ 文档来看，更容易理解 */</span>
</span></span><span style="display:flex;"><span>        StkId cb = ra + 3;  <span style="color:#f00;font-style:italic">/* call base */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjs2s</span>(L, cb+2, ra+2);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjs2s</span>(L, cb+1, ra+1);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjs2s</span>(L, cb, ra);
</span></span><span style="display:flex;"><span>        L-&gt;top = cb+3;  <span style="color:#f00;font-style:italic">/* func. + 2 args (state and index) */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaD_call</span>(L, cb, <span style="color:#c34e00">GETARG_C</span>(i)));
</span></span><span style="display:flex;"><span>        L-&gt;top = L-&gt;ci-&gt;top;
</span></span><span style="display:flex;"><span>        cb = <span style="color:#c34e00">RA</span>(i) + 3;  <span style="color:#f00;font-style:italic">/* previous call may change the stack */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(cb)) {  <span style="color:#f00;font-style:italic">/* continue loop? */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setobjs2s</span>(L, cb-1, cb);  <span style="color:#f00;font-style:italic">/* save control variable */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">dojump</span>(L, pc, <span style="color:#c34e00">GETARG_sBx</span>(*pc));  <span style="color:#f00;font-style:italic">/* jump back */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pc++;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_SETLIST: {	<span style="color:#f00;font-style:italic">/* local t = {...} 本指令之前可能会有一条vararg或local t2={fun(...)}产生的OP_CALL，所以结合vararg来理解本block的代码 */</span>
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> n = <span style="color:#c34e00">GETARG_B</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> c = <span style="color:#c34e00">GETARG_C</span>(i);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> last;
</span></span><span style="display:flex;"><span>        Table *h;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (n == 0) {	
</span></span><span style="display:flex;"><span>          n = <span style="color:#c34e00">cast_int</span>(L-&gt;top - ra) - 1;	<span style="color:#f00;font-style:italic">/* 计算确切的参数个数 */</span>
</span></span><span style="display:flex;"><span>          L-&gt;top = L-&gt;ci-&gt;top;	<span style="color:#f00;font-style:italic">/* OP_VARARG指令L-&gt;top已经指向了{...}不定参数的最后一个slot的位置以便求n,这里将其复原 */</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (c == 0) c = <span style="color:#c34e00">cast_int</span>(*pc++);	<span style="color:#f00;font-style:italic">/* 这行代码最好有个印象 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">runtime_check</span>(L, <span style="color:#c34e00">ttistable</span>(ra));	<span style="color:#f00;font-style:italic">/* 编译模块出错了 */</span>
</span></span><span style="display:flex;"><span>        h = <span style="color:#c34e00">hvalue</span>(ra);
</span></span><span style="display:flex;"><span>        last = ((c-1)*LFIELDS_PER_FLUSH) + n;	<span style="color:#f00;font-style:italic">/* 计算当前能确定的数组下标的最大值 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (last &gt; h-&gt;sizearray)  <span style="color:#f00;font-style:italic">/* needs more space?  数组区域大小不够，需扩展*/</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaH_resizearray</span>(L, h, last);  <span style="color:#f00;font-style:italic">/* pre-alloc it at once */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (; n &gt; 0; n--) {
</span></span><span style="display:flex;"><span>          TValue *val = ra+n;
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">setobj2t</span>(L, <span style="color:#c34e00">luaH_setnum</span>(L, h, last--), val);
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaC_barriert</span>(L, h, val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_CLOSE: {
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* close all variables in the stack up to (&gt;=) R(A) 编译模块如何确定参数A？*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaF_close</span>(L, ra);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_CLOSURE: {
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n)) */</span>
</span></span><span style="display:flex;"><span>        Proto *p;
</span></span><span style="display:flex;"><span>        Closure *ncl;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> nup, j;
</span></span><span style="display:flex;"><span>        p = cl-&gt;p-&gt;p[<span style="color:#c34e00">GETARG_Bx</span>(i)];	<span style="color:#f00;font-style:italic">/* 找到对应的proto */</span>
</span></span><span style="display:flex;"><span>        nup = p-&gt;nups;
</span></span><span style="display:flex;"><span>        ncl = <span style="color:#c34e00">luaF_newLclosure</span>(L, nup, cl-&gt;env);
</span></span><span style="display:flex;"><span>        ncl-&gt;l.p = p;
</span></span><span style="display:flex;"><span>		<span style="color:#f00;font-style:italic">/* 下面的block尚未完全看懂 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (j=0; j&lt;nup; j++, pc++) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (<span style="color:#c34e00">GET_OPCODE</span>(*pc) == OP_GETUPVAL)
</span></span><span style="display:flex;"><span>            ncl-&gt;l.upvals[j] = cl-&gt;upvals[<span style="color:#c34e00">GETARG_B</span>(*pc)];
</span></span><span style="display:flex;"><span>          <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">GET_OPCODE</span>(*pc) == OP_MOVE);
</span></span><span style="display:flex;"><span>            ncl-&gt;l.upvals[j] = <span style="color:#c34e00">luaF_findupval</span>(L, base + <span style="color:#c34e00">GETARG_B</span>(*pc));
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setclvalue</span>(L, ra, ncl);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaC_checkGC</span>(L));
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> OP_VARARG: {
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/* A B	R(A), R(A+1), ..., R(A+B-1) = vararg */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> b = <span style="color:#c34e00">GETARG_B</span>(i) - 1;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> j;
</span></span><span style="display:flex;"><span>        CallInfo *ci = L-&gt;ci;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> n = <span style="color:#c34e00">cast_int</span>(ci-&gt;base - ci-&gt;func) - cl-&gt;p-&gt;numparams - 1;	<span style="color:#f00;font-style:italic">/* 本次函数调用传入的不定参数的个数eg: funA(a,b, ...) funA */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (b == LUA_MULTRET) {
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">Protect</span>(<span style="color:#c34e00">luaD_checkstack</span>(L, n));
</span></span><span style="display:flex;"><span>          ra = <span style="color:#c34e00">RA</span>(i);  <span style="color:#f00;font-style:italic">/* previous call may change the stack */</span>
</span></span><span style="display:flex;"><span>          b = n;	<span style="color:#f00;font-style:italic">/* 出现在 local tbl = {...} 或者 funA(...) 需要拷贝所有的不定参数的地方 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		  <span style="color:#f00;font-style:italic">/* 为可能即将到来的C/lua函数调用做准备，(L-&gt;top-func可知即将发生的函数调用实际上有多少个传入参数) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		  ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		  ** local tbl={...} OP_SETLIST指令也用到了L-&gt;top，故而可以推断出，这里L-&gt;top标记了实际上...携带的参数个数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		  ** 以便其它指令能准确的执行(主要是获取..参数个数)，这里将实际传入的参数个数通过L-&gt;top计算好，避免其它指令再去计算一遍
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		  ** 其它指令用完L-&gt;top后需将其复原
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		  */</span>
</span></span><span style="display:flex;"><span>          L-&gt;top = ra + n; 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>		<span style="color:#f00;font-style:italic">/* 将不定参数赋值给指定的对象？？？
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		** local a, b = ...
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		** 不定参数数量不足则补nil
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">		*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (j = 0; j &lt; b; j++) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (j &lt; n) {	<span style="color:#f00;font-style:italic">/* 本函数的不定参数的个数还能满足ra+j代表的dst寄存器 */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">setobjs2s</span>(L, ra + j, ci-&gt;base - n + j);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">setnilvalue</span>(ra + j);	<span style="color:#f00;font-style:italic">/* local a, b = ... 本函数实际上只收到了一个不定参数，那么不足的部分(b)就要补nil值了 */</span>
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/20/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-ltable.c/" itemprop="url">
        lua源码注释-ltable.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-20">
    2021-05-20
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4801 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://github.com/shankusu2017/lua">github链接</a> lua515子域</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: ltable.c,v 2.32.1.2 2007/12/28 15:32:23 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Lua tables (hash)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Implementation of tables (aka(又名) arrays, objects, or hash tables).
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Tables keep its elements in two parts: an array part and a hash part.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Non-negative integer keys are all candidates(考虑) to be kept in the array
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** part. The actual size of the array is the largest `n&#39; such that at
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** least half the slots between 0 and n are in use.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Hash uses a mix of chained scatter（分散） table with Brent&#39;s variation.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** A main invariant(不变的) of these tables is that, if an element is not
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** in its main position (i.e. the `original&#39; position that its hash gives
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** to it), then the colliding(碰撞的) element is in its own main position.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Hence even when the load factor reaches 100%, performance remains good.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 和lstring的闭散列不同，这里采用的是开散列算法                    https://blog.csdn.net/Boring_Wednesday/article/details/80316884
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 结合gc流程和table&#39;insert的流程来看
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** tbl[k]=nil,若k仅被此表引用,则此k会被gc回收,for中进行tbl[k]=nil的操作，并不会修改影响表遍历的完整性
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** next函数有对此进行了专门的处理(deadkey)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** tbl[k]=nil后，node经过gc后被标记为deadkey,在此之前resize之前，此node是个&#34;正常的node&#34;，可以被复用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** gc被标记为deadkey后，进入了dead流程，是一个deadkey了。没作用了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;math.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define ltable_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lgc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lmem.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** max size of array part is 2^MAXBITS
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if LUAI_BITSINT &gt; 26
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define MAXBITS		26
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#else
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define MAXBITS		(LUAI_BITSINT-2)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define MAXASIZE	(1 &lt;&lt; MAXBITS)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hashstr(t,str)  hashpow2(t, (str)-&gt;tsv.hash)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hashboolean(t,p)        hashpow2(t, p)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** for some types, it is better to avoid modulus by power of 2, as
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** they tend to have many 2 factors.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hashpointer(t,p)	hashmod(t, IntPoint(p))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** number of ints inside a lua_Number
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define numints		cast_int(sizeof(lua_Number)/sizeof(int))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define dummynode		(&amp;dummynode_)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">const</span> Node dummynode_ = {
</span></span><span style="display:flex;"><span>  {{NULL}, LUA_TNIL},  <span style="color:#f00;font-style:italic">/* value */</span>
</span></span><span style="display:flex;"><span>  {{{NULL}, LUA_TNIL, NULL}}  <span style="color:#f00;font-style:italic">/* key */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** hash for lua_Numbers
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> Node *<span style="color:#c34e00">hashnum</span> (<span style="color:#00f">const</span> Table *t, lua_Number n) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> a[numints];
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">luai_numeq</span>(n, 0))  <span style="color:#f00;font-style:italic">/* avoid problems with -0 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">gnode</span>(t, 0);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">memcpy</span>(a, &amp;n, <span style="color:#00f">sizeof</span>(a));
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i = 1; i &lt; numints; i++) a[0] += a[i];
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">hashmod</span>(t, a[0]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** returns the `main&#39; position of an element in a table (that is, the index
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** of its hash value)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> Node *<span style="color:#c34e00">mainposition</span> (<span style="color:#00f">const</span> Table *t, <span style="color:#00f">const</span> TValue *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (<span style="color:#c34e00">ttype</span>(key)) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TNUMBER:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">hashnum</span>(t, <span style="color:#c34e00">nvalue</span>(key));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TSTRING:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">hashstr</span>(t, <span style="color:#c34e00">rawtsvalue</span>(key));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TBOOLEAN:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">hashboolean</span>(t, <span style="color:#c34e00">bvalue</span>(key));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TLIGHTUSERDATA:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">hashpointer</span>(t, <span style="color:#c34e00">pvalue</span>(key));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">hashpointer</span>(t, <span style="color:#c34e00">gcvalue</span>(key));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** returns the index for `key&#39; if `key&#39; is an appropriate(合适的) key to live in
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** the array part of the table, -1 otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">arrayindex</span> (<span style="color:#00f">const</span> TValue *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(key)) {
</span></span><span style="display:flex;"><span>    lua_Number n = <span style="color:#c34e00">nvalue</span>(key);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> k;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_number2int</span>(k, n);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">luai_numeq</span>(<span style="color:#c34e00">cast_num</span>(k), n))
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> k;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* `key&#39; did not match some condition */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** returns the index of a `key&#39; for table traversals(遍历). First goes all
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** elements in the array part, then elements in the hash part. The
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** beginning of a traversal is signalled by -1.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">findindex</span> (lua_State *L, Table *t, StkId key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(key)) { <span style="color:#f00;font-style:italic">/* 下面i++后，开始从数组的第一个slot开始匹配 */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* first iteration */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  i = <span style="color:#c34e00">arrayindex</span>(key);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (0 &lt; i &amp;&amp; i &lt;= t-&gt;sizearray)  <span style="color:#f00;font-style:italic">/* is `key&#39; inside array part? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> i-1;  <span style="color:#f00;font-style:italic">/* yes; that&#39;s the index (corrected to C) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    Node *n = <span style="color:#c34e00">mainposition</span>(t, key);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">do</span> {  <span style="color:#f00;font-style:italic">/* check whether `key&#39; is somewhere in the chain */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* key may be dead already, but it is ok to use it in `next&#39; 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** for k,v pair(tbl) do
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      **      tbl[k] = nil
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      **      可能的gc导致出现DEADKEY
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** LUA_TDEADKEY的key对应的mem可能被释放了，所以这里可能gcvalue(gkey(n) == gcvalue(key)) 这个判断不准确，要使其准确的前提是mem不释放，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** 上面for循环中k保持了对其引用所以不会导致mem释放，其它环境下调用tbl.next(deadKey)因为不确定mem是否被释放所以结果是未定义的，我的妈妈咪耶，搞明白了吗
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** 不管是lua还是C调用,tbl[k]=nil导致deadkey，但k的存在使key对应的gc内存不被释放(k还引用着它呢)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** C中调用tbl[k]=nil导致死键后，top-=2,key也被抛弃，如果stack还有其它的slot引用key则key对应的内存
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** 不会被释放，也可以再次利用key调用next,如果statck中没有其它的slot引用该key，则对应的内存可能会被释放
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** 但key也不存在了，故而gcvalue(gkey(n)==gcvalue(key))中的key也不存在了，该判断就不可能成立了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">luaO_rawequalObj</span>(<span style="color:#c34e00">key2tval</span>(n), key) ||
</span></span><span style="display:flex;"><span>	  		<span style="color:#f00;font-style:italic">/* 支持lua中的在next中tbl[k]=nil的操作后，k-&gt;k.next */</span>
</span></span><span style="display:flex;"><span>            (<span style="color:#c34e00">ttype</span>(<span style="color:#c34e00">gkey</span>(n)) == LUA_TDEADKEY &amp;&amp; <span style="color:#c34e00">iscollectable</span>(key) &amp;&amp; <span style="color:#c34e00">gcvalue</span>(<span style="color:#c34e00">gkey</span>(n)) == <span style="color:#c34e00">gcvalue</span>(key))) {
</span></span><span style="display:flex;"><span>        i = <span style="color:#c34e00">cast_int</span>(n - <span style="color:#c34e00">gnode</span>(t, 0));  <span style="color:#f00;font-style:italic">/* key index in hash table */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">/* hash elements are numbered after array ones */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> i + t-&gt;sizearray;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> n = <span style="color:#c34e00">gnext</span>(n);
</span></span><span style="display:flex;"><span>    } <span style="color:#00f">while</span> (n);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;invalid key to &#34;</span> <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;next&#34;</span>));  <span style="color:#f00;font-style:italic">/* key not found */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* to avoid warnings */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaH_next</span> (lua_State *L, Table *t, StkId key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i = <span style="color:#c34e00">findindex</span>(L, t, key);  <span style="color:#f00;font-style:italic">/* find original element */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里先来个i++,配合着上面的findindex，就形成了如果传入的是nil，则从数组第一个slot开始查找
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 如果传入的是前面找到的oldKey，则在oldKey的下一个slot开始匹配,符合next函数定义
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i++; i &lt; t-&gt;sizearray; i++) {  <span style="color:#f00;font-style:italic">/* try first array part */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(&amp;t-&gt;array[i])) {  <span style="color:#f00;font-style:italic">/* a non-nil value? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setnvalue</span>(key, <span style="color:#c34e00">cast_num</span>(i+1));	<span style="color:#f00;font-style:italic">/* c下表从0开始，lua从1开始，所以这里要补1 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setobj2s</span>(L, key+1, &amp;t-&gt;array[i]);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i -= t-&gt;sizearray; i &lt; <span style="color:#c34e00">sizenode</span>(t); i++) {  <span style="color:#f00;font-style:italic">/* then hash part */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">gval</span>(<span style="color:#c34e00">gnode</span>(t, i)))) {  <span style="color:#f00;font-style:italic">/* a non-nil value? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setobj2s</span>(L, key, <span style="color:#c34e00">key2tval</span>(<span style="color:#c34e00">gnode</span>(t, i)));
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setobj2s</span>(L, key+1, <span style="color:#c34e00">gval</span>(<span style="color:#c34e00">gnode</span>(t, i)));
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* no more elements */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** {=============================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Rehash
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** ==============================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">computesizes</span> (<span style="color:#00f">int</span> nums[], <span style="color:#00f">int</span> *narray) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> twotoi;  <span style="color:#f00;font-style:italic">/* 2^i */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> a = 0;  <span style="color:#f00;font-style:italic">/* number of elements smaller than 2^i */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> na = 0;  <span style="color:#f00;font-style:italic">/* number of elements to go to array part */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> n = 0;  <span style="color:#f00;font-style:italic">/* optimal size for array part */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i = 0, twotoi = 1; twotoi/2 &lt; *narray; i++, twotoi *= 2) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (nums[i] &gt; 0) {
</span></span><span style="display:flex;"><span>      a += nums[i];	<span style="color:#f00;font-style:italic">/* 加上当前区间 */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 截至到当前区间.left，利用率超过了1/2，存个档 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (a &gt; twotoi/2) {  <span style="color:#f00;font-style:italic">/* more than half elements present? */</span>
</span></span><span style="display:flex;"><span>        n = twotoi;  <span style="color:#f00;font-style:italic">/* optimal size (till now) */</span>
</span></span><span style="display:flex;"><span>        na = a;  <span style="color:#f00;font-style:italic">/* all elements smaller than n will go to array part */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 所有已存在的元素都已统计完毕，无需再往后面统计了(nums[i+]及后面都是0了)，这里提前跳出 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (a == *narray) 
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* all elements already counted */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  *narray = n;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(*narray/2 &lt;= na &amp;&amp; na &lt;= *narray);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> na;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">countint</span> (<span style="color:#00f">const</span> TValue *key, <span style="color:#00f">int</span> *nums) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> k = <span style="color:#c34e00">arrayindex</span>(key);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (0 &lt; k &amp;&amp; k &lt;= MAXASIZE) {  <span style="color:#f00;font-style:italic">/* is `key&#39; an appropriate array index? */</span>
</span></span><span style="display:flex;"><span>    nums[<span style="color:#c34e00">ceillog2</span>(k)]++;  <span style="color:#f00;font-style:italic">/* count as such */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">numusearray</span> (<span style="color:#00f">const</span> Table *t, <span style="color:#00f">int</span> *nums) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> lg;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> ttlg;  <span style="color:#f00;font-style:italic">/* 2^lg */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> ause = 0;  <span style="color:#f00;font-style:italic">/* summation of `nums&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i = 1;  <span style="color:#f00;font-style:italic">/* count to traverse all array keys */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (lg=0, ttlg=1; lg&lt;=MAXBITS; lg++, ttlg*=2) {  <span style="color:#f00;font-style:italic">/* for each slice */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> lc = 0;  <span style="color:#f00;font-style:italic">/* counter */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> lim = ttlg;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (lim &gt; t-&gt;sizearray) {
</span></span><span style="display:flex;"><span>      lim = t-&gt;sizearray;  <span style="color:#f00;font-style:italic">/* adjust upper limit */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (i &gt; lim)	<span style="color:#f00;font-style:italic">/* 下面的for循环中i提前++了。所以这里要对其评估 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* no more elements to count */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* count elements in range (2^(lg-1), 2^lg] */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (; i &lt;= lim; i++) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(&amp;t-&gt;array[i-1]))	<span style="color:#f00;font-style:italic">/* 这里要-1,因为C的下标从0开始 */</span>
</span></span><span style="display:flex;"><span>        lc++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    nums[lg] += lc;	<span style="color:#f00;font-style:italic">/* 更新区间内used的数量 */</span>
</span></span><span style="display:flex;"><span>    ause += lc;		<span style="color:#f00;font-style:italic">/* 更新总的used数量 */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> ause;	<span style="color:#f00;font-style:italic">/* 返回 array中used的总数 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 更新node中int的key到nums和pnasize中，返回node中key的总数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">numusehash</span> (<span style="color:#00f">const</span> Table *t, <span style="color:#00f">int</span> *nums, <span style="color:#00f">int</span> *pnasize) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> totaluse = 0;  <span style="color:#f00;font-style:italic">/* total number of elements */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> ause = 0;  <span style="color:#f00;font-style:italic">/* summation of `nums&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i = <span style="color:#c34e00">sizenode</span>(t);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (i--) {
</span></span><span style="display:flex;"><span>    Node *n = &amp;t-&gt;node[i];
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">gval</span>(n))) {	<span style="color:#f00;font-style:italic">/* 这里没有判断gkey而是gval!!! */</span>
</span></span><span style="display:flex;"><span>      ause += <span style="color:#c34e00">countint</span>(<span style="color:#c34e00">key2tval</span>(n), nums);
</span></span><span style="display:flex;"><span>      totaluse++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  *pnasize += ause;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> totaluse;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">setarrayvector</span> (lua_State *L, Table *t, <span style="color:#00f">int</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, t-&gt;array, t-&gt;sizearray, size, TValue);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=t-&gt;sizearray; i&lt;size; i++)	<span style="color:#f00;font-style:italic">/* 多出来的数组部分填nil */</span>
</span></span><span style="display:flex;"><span>     <span style="color:#c34e00">setnilvalue</span>(&amp;t-&gt;array[i]);
</span></span><span style="display:flex;"><span>  t-&gt;sizearray = size;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 按照新的node区大小size，申请新内存且将其全部set-nil */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">setnodevector</span> (lua_State *L, Table *t, <span style="color:#00f">int</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> lsize;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (size == 0) {  <span style="color:#f00;font-style:italic">/* no elements to hash part? */</span>
</span></span><span style="display:flex;"><span>    t-&gt;node = <span style="color:#c34e00">cast</span>(Node *, dummynode);  <span style="color:#f00;font-style:italic">/* use common `dummynode&#39; */</span>
</span></span><span style="display:flex;"><span>    lsize = 0;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>    lsize = <span style="color:#c34e00">ceillog2</span>(size);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (lsize &gt; MAXBITS)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;table overflow&#34;</span>);
</span></span><span style="display:flex;"><span>    size = <span style="color:#c34e00">twoto</span>(lsize);
</span></span><span style="display:flex;"><span>    t-&gt;node = <span style="color:#c34e00">luaM_newvector</span>(L, size, Node);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (i=0; i&lt;size; i++) {
</span></span><span style="display:flex;"><span>      Node *n = <span style="color:#c34e00">gnode</span>(t, i);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">gnext</span>(n) = NULL;
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setnilvalue</span>(<span style="color:#c34e00">gkey</span>(n));
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setnilvalue</span>(<span style="color:#c34e00">gval</span>(n));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  t-&gt;lsizenode = <span style="color:#c34e00">cast_byte</span>(lsize);
</span></span><span style="display:flex;"><span>  t-&gt;lastfree = <span style="color:#c34e00">gnode</span>(t, size);  <span style="color:#f00;font-style:italic">/* all positions are free */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* nasize:调整后的数组大小
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nhsize:调整后node部分的元素个数 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">resize</span> (lua_State *L, Table *t, <span style="color:#00f">int</span> nasize, <span style="color:#00f">int</span> nhsize) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldasize = t-&gt;sizearray;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldhsize = t-&gt;lsizenode;
</span></span><span style="display:flex;"><span>  Node *nold = t-&gt;node;  <span style="color:#f00;font-style:italic">/* save old hash ... */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (nasize &gt; oldasize)  <span style="color:#f00;font-style:italic">/* array part must grow? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setarrayvector</span>(L, t, nasize);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* create new hash part with appropriate size 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 准备好全新的node，以便下面调整array时，接收array中溢出的slot
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setnodevector</span>(L, t, nhsize);  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (nasize &lt; oldasize) {  <span style="color:#f00;font-style:italic">/* array part must shrink? */</span>
</span></span><span style="display:flex;"><span>    t-&gt;sizearray = nasize;
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* re-insert elements from vanishing slice */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (i=nasize; i&lt;oldasize; i++) {	<span style="color:#f00;font-style:italic">/* new的array-size下将数组溢出的slot移动到node区域去 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(&amp;t-&gt;array[i]))
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">setobjt2t</span>(L, <span style="color:#c34e00">luaH_setnum</span>(L, t, i+1), &amp;t-&gt;array[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* shrink array */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaM_reallocvector</span>(L, t-&gt;array, oldasize, nasize, TValue);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* re-insert elements from hash part */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i = <span style="color:#c34e00">twoto</span>(oldhsize) - 1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>    Node *old = nold+i;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">gval</span>(old)))	<span style="color:#f00;font-style:italic">/* 这里没拿gkey判断!!       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setobjt2t</span>(L, <span style="color:#c34e00">luaH_set</span>(L, t, <span style="color:#c34e00">key2tval</span>(old)), <span style="color:#c34e00">gval</span>(old));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (nold != dummynode)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaM_freearray</span>(L, nold, <span style="color:#c34e00">twoto</span>(oldhsize), Node);  <span style="color:#f00;font-style:italic">/* free old array */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 供lvm调用，一次到位申请对应的array区域的内存 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaH_resizearray</span> (lua_State *L, Table *t, <span style="color:#00f">int</span> nasize) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nsize = (t-&gt;node == dummynode) ? 0 : <span style="color:#c34e00">sizenode</span>(t);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">resize</span>(L, t, nasize, nsize);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 尝试插入新的key(ek时发现空间不足，从而rehash) */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">rehash</span> (lua_State *L, Table *t, <span style="color:#00f">const</span> TValue *ek) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nasize, na;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nums[MAXBITS+1];  <span style="color:#f00;font-style:italic">/* nums[i] = number of keys between 2^(i-1) and 2^i */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> totaluse;	<span style="color:#f00;font-style:italic">/* 所有元素总和 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=0; i&lt;=MAXBITS; i++) nums[i] = 0;  <span style="color:#f00;font-style:italic">/* reset counts */</span>
</span></span><span style="display:flex;"><span>  nasize = <span style="color:#c34e00">numusearray</span>(t, nums);  <span style="color:#f00;font-style:italic">/* count keys in array part */</span>
</span></span><span style="display:flex;"><span>  totaluse = nasize;  <span style="color:#f00;font-style:italic">/* all those keys are integer keys */</span>
</span></span><span style="display:flex;"><span>  totaluse += <span style="color:#c34e00">numusehash</span>(t, nums, &amp;nasize);  <span style="color:#f00;font-style:italic">/* count keys in hash part */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* count extra key */</span>
</span></span><span style="display:flex;"><span>  nasize += <span style="color:#c34e00">countint</span>(ek, nums);
</span></span><span style="display:flex;"><span>  totaluse++;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* compute new size for array part */</span>
</span></span><span style="display:flex;"><span>  na = <span style="color:#c34e00">computesizes</span>(nums, &amp;nasize);	<span style="color:#f00;font-style:italic">/* 计算下最优解下的nasize，以及即将落在array中的数量(na) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* resize the table to new computed sizes */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">resize</span>(L, t, nasize, totaluse - na);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** }=============================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Table *<span style="color:#c34e00">luaH_new</span> (lua_State *L, <span style="color:#00f">int</span> narray, <span style="color:#00f">int</span> nhash) {
</span></span><span style="display:flex;"><span>  Table *t = <span style="color:#c34e00">luaM_new</span>(L, Table);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_link</span>(L, <span style="color:#c34e00">obj2gco</span>(t), LUA_TTABLE);
</span></span><span style="display:flex;"><span>  t-&gt;metatable = NULL;
</span></span><span style="display:flex;"><span>  t-&gt;flags = <span style="color:#c34e00">cast_byte</span>(~0);	<span style="color:#f00;font-style:italic">/* 新表，tag&#39;method都不存在 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* temporary values (kept only if some malloc fails) */</span>
</span></span><span style="display:flex;"><span>  t-&gt;array = NULL;
</span></span><span style="display:flex;"><span>  t-&gt;sizearray = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* n的0次幂==1，这里不能简单的t-&gt;node==NULL */</span>
</span></span><span style="display:flex;"><span>  t-&gt;lsizenode = 0;
</span></span><span style="display:flex;"><span>  t-&gt;node = <span style="color:#c34e00">cast</span>(Node *, dummynode);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setarrayvector</span>(L, t, narray);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setnodevector</span>(L, t, nhash);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> t;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaH_free</span> (lua_State *L, Table *t) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (t-&gt;node != dummynode)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaM_freearray</span>(L, t-&gt;node, <span style="color:#c34e00">sizenode</span>(t), Node);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_freearray</span>(L, t-&gt;array, t-&gt;sizearray, TValue);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_free</span>(L, t);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> Node *<span style="color:#c34e00">getfreepos</span> (Table *t) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (t-&gt;lastfree-- &gt; t-&gt;node) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">gkey</span>(t-&gt;lastfree)))
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> t-&gt;lastfree;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> NULL;  <span style="color:#f00;font-style:italic">/* could not find a free place */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** inserts a new key into a hash table; first, check whether key&#39;s main 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** position is free. If not, check whether colliding node is in its main 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** position or not: if it is not, move colliding node to an empty place and 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** put new key in its main position; otherwise (colliding node is in its main 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** position), new key goes to an empty position. 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> TValue *<span style="color:#c34e00">newkey</span> (lua_State *L, Table *t, <span style="color:#00f">const</span> TValue *key) {
</span></span><span style="display:flex;"><span>  Node *mp = <span style="color:#c34e00">mainposition</span>(t, key);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">gval</span>(mp)) || mp == dummynode) {
</span></span><span style="display:flex;"><span>    Node *othern;
</span></span><span style="display:flex;"><span>    Node *n = <span style="color:#c34e00">getfreepos</span>(t);  <span style="color:#f00;font-style:italic">/* get a free place */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n == NULL) {  <span style="color:#f00;font-style:italic">/* cannot find a free place? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">rehash</span>(L, t, key);  <span style="color:#f00;font-style:italic">/* grow table */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">luaH_set</span>(L, t, key);  <span style="color:#f00;font-style:italic">/* re-insert key into grown table */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(n != dummynode);	<span style="color:#f00;font-style:italic">/* mp==dummynode时，getfreepos必然返回NULL,不应该走到这里 */</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    othern = <span style="color:#c34e00">mainposition</span>(t, <span style="color:#c34e00">key2tval</span>(mp));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (othern != mp) {  <span style="color:#f00;font-style:italic">/* is colliding node out of its main position? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* yes; move colliding node into free position */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">while</span> (<span style="color:#c34e00">gnext</span>(othern) != mp) othern = <span style="color:#c34e00">gnext</span>(othern);  <span style="color:#f00;font-style:italic">/* find previous */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 更新下链表 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">gnext</span>(othern) = n;  <span style="color:#f00;font-style:italic">/* redo the chain with `n&#39; in place of `mp&#39; */</span>
</span></span><span style="display:flex;"><span>      *n = *mp;  <span style="color:#f00;font-style:italic">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">gnext</span>(mp) = NULL;  <span style="color:#f00;font-style:italic">/* now `mp&#39; is free */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">setnilvalue</span>(<span style="color:#c34e00">gval</span>(mp));	<span style="color:#f00;font-style:italic">/* key在下面设置 */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* colliding node is in its own main position */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* new node will go into free position */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">gnext</span>(n) = <span style="color:#c34e00">gnext</span>(mp);  <span style="color:#f00;font-style:italic">/* chain new position */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">gnext</span>(mp) = n;
</span></span><span style="display:flex;"><span>      mp = n;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">gkey</span>(mp)-&gt;value = key-&gt;value; <span style="color:#c34e00">gkey</span>(mp)-&gt;tt = key-&gt;tt;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_barriert</span>(L, t, key);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">gval</span>(mp)));	<span style="color:#f00;font-style:italic">/* new的node，其val必然是一个崭新的，必须为nil */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">gval</span>(mp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** search function for integers
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> TValue *<span style="color:#c34e00">luaH_getnum</span> (Table *t, <span style="color:#00f">int</span> key) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 如果key为负数，按照C的int-&gt;uint规则，转换的结果将是一个巨大的数，故而下面判断为false */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">cast</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">int</span>, key-1) &lt; <span style="color:#c34e00">cast</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">int</span>, t-&gt;sizearray))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> &amp;t-&gt;array[key-1];
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    lua_Number nk = <span style="color:#c34e00">cast_num</span>(key);
</span></span><span style="display:flex;"><span>    Node *n = <span style="color:#c34e00">hashnum</span>(t, nk);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">do</span> {  <span style="color:#f00;font-style:italic">/* check whether `key&#39; is somewhere in the chain */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 由于Value是union,故而可能n=nk但！！！！！ n对应的value的type和nk.对应的value不相等的情况
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	   ** 所以这里必须要有个ttisnumber的判断 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	   */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(<span style="color:#c34e00">gkey</span>(n)) &amp;&amp; <span style="color:#c34e00">luai_numeq</span>(<span style="color:#c34e00">nvalue</span>(<span style="color:#c34e00">gkey</span>(n)), nk))
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#c34e00">gval</span>(n);  <span style="color:#f00;font-style:italic">/* that&#39;s it */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> <span style="color:#f00;font-style:italic">/* 如果key已存在于tbl，则必然在mp&#39;link上，故而这里可以遍历列表来查找，下同 */</span>
</span></span><span style="display:flex;"><span>	  	n = <span style="color:#c34e00">gnext</span>(n);
</span></span><span style="display:flex;"><span>    } <span style="color:#00f">while</span> (n);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> luaO_nilobject;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** search function for strings
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> TValue *<span style="color:#c34e00">luaH_getstr</span> (Table *t, TString *key) {
</span></span><span style="display:flex;"><span>  Node *n = <span style="color:#c34e00">hashstr</span>(t, key);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">do</span> {  <span style="color:#f00;font-style:italic">/* check whether `key&#39; is somewhere in the chain */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 这里ttisstring(gkey(n))的判断排除掉已经被gc标记为deadkey的key,和上面的value相等但type不相等的情况
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	** 如果运行了tbl[key]=nil，再到调用本函数之前，gc还没来得及将其node标记为deadkey,且还没调用resize
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	** 则是复用该node
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisstring</span>(<span style="color:#c34e00">gkey</span>(n)) &amp;&amp; <span style="color:#c34e00">rawtsvalue</span>(<span style="color:#c34e00">gkey</span>(n)) == key)
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">gval</span>(n);  <span style="color:#f00;font-style:italic">/* that&#39;s it */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> 
</span></span><span style="display:flex;"><span>		n = <span style="color:#c34e00">gnext</span>(n);	
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">while</span> (n);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> luaO_nilobject;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** main search function
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">const</span> TValue *<span style="color:#c34e00">luaH_get</span> (Table *t, <span style="color:#00f">const</span> TValue *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (<span style="color:#c34e00">ttype</span>(key)) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TNIL: <span style="color:#00f">return</span> luaO_nilobject;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TSTRING: <span style="color:#00f">return</span> <span style="color:#c34e00">luaH_getstr</span>(t, <span style="color:#c34e00">rawtsvalue</span>(key));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> LUA_TNUMBER: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> k;
</span></span><span style="display:flex;"><span>      lua_Number n = <span style="color:#c34e00">nvalue</span>(key);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_number2int</span>(k, n);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">luai_numeq</span>(<span style="color:#c34e00">cast_num</span>(k), <span style="color:#c34e00">nvalue</span>(key))) <span style="color:#f00;font-style:italic">/* index is int? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#c34e00">luaH_getnum</span>(t, k);  <span style="color:#f00;font-style:italic">/* use specialized version */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* else go through */</span>  <span style="color:#f00;font-style:italic">/* 所以这里没有break,看懂了吗？ 非int的，走到default分支去了 */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      Node *n = <span style="color:#c34e00">mainposition</span>(t, key);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">do</span> {  <span style="color:#f00;font-style:italic">/* check whether `key&#39; is somewhere in the chain */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (<span style="color:#c34e00">luaO_rawequalObj</span>(<span style="color:#c34e00">key2tval</span>(n), key))		<span style="color:#f00;font-style:italic">/* 这里必须rawequlObj进行type==type的判断，以忽略掉deadKey的Node,以及union带来的影响 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span> <span style="color:#c34e00">gval</span>(n);  <span style="color:#f00;font-style:italic">/* that&#39;s it */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span> n = <span style="color:#c34e00">gnext</span>(n);
</span></span><span style="display:flex;"><span>      } <span style="color:#00f">while</span> (n);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> luaO_nilobject;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TValue *<span style="color:#c34e00">luaH_set</span> (lua_State *L, Table *t, <span style="color:#00f">const</span> TValue *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *p = <span style="color:#c34e00">luaH_get</span>(t, key);
</span></span><span style="display:flex;"><span>  t-&gt;flags = 0;	<span style="color:#f00;font-style:italic">/* 如果本tbl当作meta，那么set后可能其tag有更新，这里索性假设所有的tag&#39;methods都更新了，假设所有的tag&#39;methaod都有了 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (p != luaO_nilobject)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">cast</span>(TValue *, p);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(key)) <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;table index is nil&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(key) &amp;&amp; <span style="color:#c34e00">luai_numisnan</span>(<span style="color:#c34e00">nvalue</span>(key)))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaG_runerror</span>(L, <span style="color:#009c00">&#34;table index is NaN&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">newkey</span>(L, t, key);	<span style="color:#f00;font-style:italic">/* 构造新的slot */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TValue *<span style="color:#c34e00">luaH_setnum</span> (lua_State *L, Table *t, <span style="color:#00f">int</span> key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *p = <span style="color:#c34e00">luaH_getnum</span>(t, key);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (p != luaO_nilobject)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">cast</span>(TValue *, p);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    TValue k;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnvalue</span>(&amp;k, <span style="color:#c34e00">cast_num</span>(key));
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">newkey</span>(L, t, &amp;k);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TValue *<span style="color:#c34e00">luaH_setstr</span> (lua_State *L, Table *t, TString *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> TValue *p = <span style="color:#c34e00">luaH_getstr</span>(t, key);	<span style="color:#f00;font-style:italic">/* key现存，则直接返回node&#39;key */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (p != luaO_nilobject)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">cast</span>(TValue *, p);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    TValue k;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setsvalue</span>(L, &amp;k, key);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">newkey</span>(L, t, &amp;k);	<span style="color:#f00;font-style:italic">/* 没有则构造一个new&#39;node出来，其中node.key=key,并返回其node.val */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">unbound_search</span> (Table *t, <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> j) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> i = j;  <span style="color:#f00;font-style:italic">/* i is zero or a present index */</span>
</span></span><span style="display:flex;"><span>  j++;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* find `i&#39; and `j&#39; such that i is present and j is not */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (!<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">luaH_getnum</span>(t, j))) {
</span></span><span style="display:flex;"><span>    i = j;
</span></span><span style="display:flex;"><span>    j *= 2;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (j &gt; <span style="color:#c34e00">cast</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">int</span>, MAX_INT)) {  <span style="color:#f00;font-style:italic">/* overflow? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* table was built with bad purposes: resort to linear search */</span>
</span></span><span style="display:flex;"><span>      i = 1;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">while</span> (!<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">luaH_getnum</span>(t, i))) i++;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> i - 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* now do a binary search between them */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (j - i &gt; 1) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> m = (i+j)/2;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(<span style="color:#c34e00">luaH_getnum</span>(t, m))) j = m;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> i = m;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> i;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Try to find a boundary in table `t&#39;. A `boundary&#39; is an integer index
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaH_getn</span> (Table *t) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> j = t-&gt;sizearray;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (j &gt; 0 &amp;&amp; <span style="color:#c34e00">ttisnil</span>(&amp;t-&gt;array[j - 1])) {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* there is a boundary in the array part: (binary) search for it */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> i = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (j - i &gt; 1) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> m = (i+j)/2;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnil</span>(&amp;t-&gt;array[m - 1])) j = m;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> i = m;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> i;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* else must find a boundary in hash part */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (t-&gt;node == dummynode)  <span style="color:#f00;font-style:italic">/* hash part is empty? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> j;  <span style="color:#f00;font-style:italic">/* that is easy... */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">return</span> <span style="color:#c34e00">unbound_search</span>(t, j);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if defined(LUA_DEBUG)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>Node *<span style="color:#c34e00">luaH_mainposition</span> (<span style="color:#00f">const</span> Table *t, <span style="color:#00f">const</span> TValue *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">mainposition</span>(t, key);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaH_isdummy</span> (Node *n) { <span style="color:#00f">return</span> n == dummynode; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/19/too-many-open-files/" itemprop="url">
        too many open files
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-19">
    2021-05-19
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4" itemprop="url" rel="index">
        <span itemprop="name">运维</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">2589 字 ~6分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="原因">原因</h2>
<p>​	程序打开的文件/socket 数量超过系统设定值。</p>
<h2 id="查看程序已打开的fd">查看程序已打开的fd</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -l /proc/pid/fd     详情
</span></span><span style="display:flex;"><span>lsof -p pid | wc -l    数量
</span></span><span style="display:flex;"><span>lsof -n | awk <span style="color:#009c00">&#39;{print $2}&#39;</span> | sort | uniq -c | sort -nr | more 			输出fd数量和进程ID
</span></span></code></pre></div><h2 id="限制级别">限制级别</h2>
<p>最大文件描述符数的限制可以分为3种：</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/05/19/too-many-open-files/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/19/the-complete-syntax-of-lua51/" itemprop="url">
        The Complete Syntax of Lua51
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-19">
    2021-05-19
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">271 字 ~2分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>Here is the complete syntax of Lua in extended BNF. (It does not describe operator precedences.)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bnf" data-lang="bnf"><span style="display:flex;"><span>	chunk ::= {stat [`;´]} [laststat [`;´]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	block ::= chunk
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	stat ::=  varlist `=´ explist | 
</span></span><span style="display:flex;"><span>		 functioncall | 
</span></span><span style="display:flex;"><span>		 do block end | 
</span></span><span style="display:flex;"><span>		 while exp do block end | 
</span></span><span style="display:flex;"><span>		 repeat block until exp | 
</span></span><span style="display:flex;"><span>		 if exp then block {elseif exp then block} [else block] end | 
</span></span><span style="display:flex;"><span>		 for Name `=´ exp `,´ exp [`,´ exp] do block end | 
</span></span><span style="display:flex;"><span>		 for namelist in explist do block end | 
</span></span><span style="display:flex;"><span>		 function funcname funcbody | 
</span></span><span style="display:flex;"><span>		 local function Name funcbody | 
</span></span><span style="display:flex;"><span>		 local namelist [`=´ explist] 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	laststat ::= return [explist] | break
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	funcname ::= Name {`.´ Name} [`:´ Name]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	varlist ::= var {`,´ var}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	namelist ::= Name {`,´ Name}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	explist ::= {exp `,´} exp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	exp ::=  nil | false | true | Number | String | `...´ | function | 
</span></span><span style="display:flex;"><span>		 prefixexp | tableconstructor | exp binop exp | unop exp 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	prefixexp ::= var | functioncall | `(´ exp `)´
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	functioncall ::=  prefixexp args | prefixexp `:´ Name args 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	args ::=  `(´ [explist] `)´ | tableconstructor | String 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	function ::= function funcbody
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	funcbody ::= `(´ [parlist] `)´ block end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	parlist ::= namelist [`,´ `...´] | `...´
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	tableconstructor ::= `{´ [fieldlist] `}´
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fieldlist ::= field {fieldsep field} [fieldsep]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fieldsep ::= `,´ | `;´
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | 
</span></span><span style="display:flex;"><span>		 `&lt;´ | `&lt;=´ | `&gt;´ | `&gt;=´ | `==´ | `~=´ | 
</span></span><span style="display:flex;"><span>		 and | or
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	unop ::= `-´ | not | `#´
</span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/19/a-no-frills-introduction-to-lua-5.1-vm-instructions/" itemprop="url">
        A No-Frills Introduction to Lua 5.1 VM Instructions
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-19">
    2021-05-19
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">23471 字 ~47分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <hr>
<h2 id="a-no-frills-introduction-to-lua-51-vm-instructions">A No-Frills Introduction to Lua 5.1 VM Instructions</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>by Kein-Hong Man, esq. &lt;khman AT users.sf.net&gt;
</span></span></code></pre></div><p>Version 0.1, 20060313</p>
<p>​		为了检索指令描述，本人额外做了添加特定的前缀OP_处理，eg: MOVE&mdash;-&gt;OP_MOVE，以便在阅读lvm.c中的源码时能快速在本文档中找到相关注解。</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/05/19/a-no-frills-introduction-to-lua-5.1-vm-instructions/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

</section>
















<nav class="pagination">
    <a class="extend prev" rel="prev" href="http://shanks.link/p/65/"><i class="fa fa-angle-left"></i></a>
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/62/">62</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/63/">63</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/64/">64</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/65/">65</a>
        
        
    
        
        
          <span class="page-number current">66</span>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/67/">67</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/68/">68</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/69/">69</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/70/">70</a>
        
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
    <a class="extend next" rel="next" href="http://shanks.link/p/67/"><i class="fa fa-angle-right"></i></a>
</nav>




          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
<div class="feed-link motion-element">
<a href="http://shanks.link/index.xml" rel="alternate" type="application/rss+xml" target="_blank">
    <i class="fa fa-rss"></i>
    RSS 订阅
</a>
</div>

      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2025</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" id="motion.page.archive">
  $('.archive-year').velocity('transition.slideLeftIn');
</script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>