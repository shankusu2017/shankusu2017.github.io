<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
	<meta name="generator" content="Hugo 0.147.3">
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>愿星光伴随你左右 - 愿星光伴随你左右</title>
    <meta name="keywords" content="Golang,golang,go,git,Git,Lua,lua">
    
    <meta property="og:title" content="愿星光伴随你左右">
    <meta property="og:site_name" content="愿星光伴随你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="愿星光伴随你左右 - 愿星光伴随你左右" />
    <meta name="description" content="愿星光伴随你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: false, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴随你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/food/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />food
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/finance/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />投资
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
    
 <section id="posts" class="posts-expand">

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8Alcode.c/" itemprop="url">
        lua源码注释lcode.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-08">
    2021-06-08
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6252 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Code generator for Lua
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define lcode_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lcode.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lgc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;llex.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lmem.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lparser.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* e的类型 expdesc */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">isnumeral</span>(expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> (e-&gt;k == VKNUM &amp;&amp;	<span style="color:#f00;font-style:italic">/* 仅仅e-&gt;k == VKNUM 不够么？ */</span>
</span></span><span style="display:flex;"><span>		  	e-&gt;t == NO_JUMP &amp;&amp;
</span></span><span style="display:flex;"><span>		  	e-&gt;f == NO_JUMP);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 给连续的变量赋nil
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** OP_LOADNIL A B R(A) := ... := R(B) := nil
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 当可以合并前一条OP_LOADNIL时则尝试合并，可以利用fun&#39;stack的默认NIL时，直接用NIL
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_nil</span> (FuncState *fs, <span style="color:#00f">int</span> from, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  Instruction *previous;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (fs-&gt;pc &gt; fs-&gt;lasttarget) {  <span style="color:#f00;font-style:italic">/* no jumps to current position? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (fs-&gt;pc == 0) {  <span style="color:#f00;font-style:italic">/* function start? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (from &gt;= fs-&gt;nactvar)  <span style="color:#f00;font-style:italic">/* 新调用一个fun时，其私有stack默认会被置NULL，这种情况直接使用默认的NULL即可 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* positions are already clean */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">GET_OPCODE</span>(*previous) == OP_LOADNIL) {	<span style="color:#f00;font-style:italic">/* 尝试合并前后连续的OP_LOADNIL指令 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> pfrom = <span style="color:#c34e00">GETARG_A</span>(*previous);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> pto = <span style="color:#c34e00">GETARG_B</span>(*previous);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  <span style="color:#f00;font-style:italic">/* can connect both? */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (from+n-1 &gt; pto)
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">SETARG_B</span>(*previous, from+n-1);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_LOADNIL, from, from+n-1, 0);  <span style="color:#f00;font-style:italic">/* else no optimization */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** OP_JMP sBx PC += sBx
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 待回填的跳转链表指向我，而我又指向其它pc，那么将上述链表和我串联在一起即可
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_jump</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> jpc = fs-&gt;jpc;  <span style="color:#f00;font-style:italic">/* save list of jumps to here */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> j;
</span></span><span style="display:flex;"><span>  fs-&gt;jpc = NO_JUMP;
</span></span><span style="display:flex;"><span>  j = <span style="color:#c34e00">luaK_codeAsBx</span>(fs, OP_JMP, 0, NO_JUMP);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_concat</span>(fs, &amp;j, jpc);  <span style="color:#f00;font-style:italic">/* keep them on hold */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> j;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 从函数返回
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** OP_RETURN A B return R(A), ... ,R(A+B-2)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_ret</span> (FuncState *fs, <span style="color:#00f">int</span> first, <span style="color:#00f">int</span> nret) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_RETURN, first, nret+1, 0);	<span style="color:#f00;font-style:italic">/* 这里可以反推OP_RETURNS中A,B,C的含义了 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 有条件跳转 OP_TEST, OP_TESTSET */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">condjump</span> (FuncState *fs, OpCode op, <span style="color:#00f">int</span> A, <span style="color:#00f">int</span> B, <span style="color:#00f">int</span> C) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_codeABC</span>(fs, op, A, B, C);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaK_jump</span>(fs);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将待回填的跳转指令pc指向dest */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">fixjump</span> (FuncState *fs, <span style="color:#00f">int</span> pc, <span style="color:#00f">int</span> dest) {
</span></span><span style="display:flex;"><span>  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 下面计算跳转指令的跳转目标绝对值时也加了1，和这里是一致的 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> offset = dest-(pc+1);		
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(dest != NO_JUMP);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">abs</span>(offset) &gt; MAXARG_sBx)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_syntaxerror</span>(fs-&gt;ls, <span style="color:#009c00">&#34;control structure too long&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">SETARG_sBx</span>(*jmp, offset);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** returns current `pc&#39; and marks it as a jump target (to avoid wrong
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** optimizations(优化) with consecutive(连续) instructions not in the same basic block).
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_getlabel</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  fs-&gt;lasttarget = fs-&gt;pc;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> fs-&gt;pc;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 获取跳转指令指向的绝对位置 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">getjump</span> (FuncState *fs, <span style="color:#00f">int</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> offset = <span style="color:#c34e00">GETARG_sBx</span>(fs-&gt;f-&gt;code[pc]);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (offset == NO_JUMP)  <span style="color:#f00;font-style:italic">/* point to itself represents end of list */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> NO_JUMP;  <span style="color:#f00;font-style:italic">/* end of list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> (pc+1)+offset;  <span style="color:#f00;font-style:italic">/* turn offset into absolute position */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> Instruction *<span style="color:#c34e00">getjumpcontrol</span> (FuncState *fs, <span style="color:#00f">int</span> pc) {
</span></span><span style="display:flex;"><span>  Instruction *pi = &amp;fs-&gt;f-&gt;code[pc];
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (pc &gt;= 1 &amp;&amp; <span style="color:#c34e00">testTMode</span>(<span style="color:#c34e00">GET_OPCODE</span>(*(pi-1))))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> pi-1;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> pi;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** check whether list has any jump that do not produce a value
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** (or produce an inverted(颠,倒) value)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">need_value</span> (FuncState *fs, <span style="color:#00f">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; list != NO_JUMP; list = <span style="color:#c34e00">getjump</span>(fs, list)) {
</span></span><span style="display:flex;"><span>    Instruction i = *<span style="color:#c34e00">getjumpcontrol</span>(fs, list);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">GET_OPCODE</span>(i) != OP_TESTSET) <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* not found */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">patchtestreg</span> (FuncState *fs, <span style="color:#00f">int</span> node, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  Instruction *i = <span style="color:#c34e00">getjumpcontrol</span>(fs, node);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">GET_OPCODE</span>(*i) != OP_TESTSET)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* cannot patch other instructions */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (reg != NO_REG &amp;&amp; reg != <span style="color:#c34e00">GETARG_B</span>(*i))
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">SETARG_A</span>(*i, reg);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>  <span style="color:#f00;font-style:italic">/* no register to put value or register already has the value */</span>
</span></span><span style="display:flex;"><span>    *i = <span style="color:#c34e00">CREATE_ABC</span>(OP_TEST, <span style="color:#c34e00">GETARG_B</span>(*i), 0, <span style="color:#c34e00">GETARG_C</span>(*i));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">removevalues</span> (FuncState *fs, <span style="color:#00f">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; list != NO_JUMP; list = <span style="color:#c34e00">getjump</span>(fs, list))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">patchtestreg</span>(fs, list, NO_REG);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 回填跳转指令链表上的指令到指定目标
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将待回填跳转指令列表list上指令的跳转参数sBx更新到target上 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">patchlistaux</span> (FuncState *fs, <span style="color:#00f">int</span> list, <span style="color:#00f">int</span> vtarget, <span style="color:#00f">int</span> reg,
</span></span><span style="display:flex;"><span>                          <span style="color:#00f">int</span> dtarget) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (list != NO_JUMP) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> next = <span style="color:#c34e00">getjump</span>(fs, list);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">patchtestreg</span>(fs, list, reg))
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">fixjump</span>(fs, list, vtarget);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">fixjump</span>(fs, list, dtarget);  <span style="color:#f00;font-style:italic">/* jump to default target */</span>
</span></span><span style="display:flex;"><span>    list = next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将待回填的跳转到当前指令的跳转链表上的跳转指令的sBx更新为fs-&gt;pc */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">dischargejpc</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">patchlistaux</span>(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc);
</span></span><span style="display:flex;"><span>  fs-&gt;jpc = NO_JUMP;	<span style="color:#f00;font-style:italic">/* 置空 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_patchlist</span> (FuncState *fs, <span style="color:#00f">int</span> list, <span style="color:#00f">int</span> target) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (target == fs-&gt;pc)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_patchtohere</span>(fs, list);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(target &lt; fs-&gt;pc);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">patchlistaux</span>(fs, list, target, NO_REG, target);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将待回填的跳转指令链表list挂到fs-&gt;jpc,等生成下一条指令时回填sBx */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_patchtohere</span> (FuncState *fs, <span style="color:#00f">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_getlabel</span>(fs);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_concat</span>(fs, &amp;fs-&gt;jpc, list);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*  l1.sBx = l2 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将l2指向的待回填跳转指令/指令链表挂到l1的跳转链表上
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_concat</span> (FuncState *fs, <span style="color:#00f">int</span> *l1, <span style="color:#00f">int</span> l2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (l2 == NO_JUMP) <span style="color:#f00;font-style:italic">/* l2不是一条跳转指令，直接返回 */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (*l1 == NO_JUMP)	<span style="color:#f00;font-style:italic">/* 当前跳转列表为空 */</span>
</span></span><span style="display:flex;"><span>    *l1 = l2;	<span style="color:#f00;font-style:italic">/* l1尚未初始化，直接赋值即可 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> list = *l1;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> next;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> ((next = <span style="color:#c34e00">getjump</span>(fs, list)) != NO_JUMP)  <span style="color:#f00;font-style:italic">/* find last element */</span>
</span></span><span style="display:flex;"><span>      list = next;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">fixjump</span>(fs, list, l2);	<span style="color:#f00;font-style:italic">/* 将待回填的跳转指令链表l2挂到l1的末尾 */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 调整maxstacksize以便匹配locvar的数量 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_checkstack</span> (FuncState *fs, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> newstack = fs-&gt;freereg + n;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (newstack &gt; fs-&gt;f-&gt;maxstacksize) {	<span style="color:#f00;font-style:italic">/* 这个判断是必须的 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (newstack &gt;= MAXSTACK)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_syntaxerror</span>(fs-&gt;ls, <span style="color:#009c00">&#34;function or expression too complex&#34;</span>);
</span></span><span style="display:flex;"><span>    fs-&gt;f-&gt;maxstacksize = <span style="color:#c34e00">cast_byte</span>(newstack);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* reserve reg:预定 寄存器 实际上是占用n个寄存器的意思
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_reserveregs</span> (FuncState *fs, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_checkstack</span>(fs, n);
</span></span><span style="display:flex;"><span>  fs-&gt;freereg += n;	<span style="color:#f00;font-style:italic">/* 占用n个locvar,释放则n为负值或在其它函数中实现 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 重点函数，需要细读 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">freereg</span> (FuncState *fs, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">ISK</span>(reg) &amp;&amp;            <span style="color:#f00;font-style:italic">/* 常量的就不用释放了，压根没占用reg */</span>
</span></span><span style="display:flex;"><span>      reg &gt;= fs-&gt;nactvar) {   <span style="color:#f00;font-style:italic">/* reg从0开始，nactvar从1开始，所以这里reg&gt;=fs-&gt;nactvar是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	/* 释放一个reg后,reg==fs-&gt;freereg:确保只能释放最新一个被激活的reg(作为exp的临时reg占用？) */</span>
</span></span><span style="display:flex;"><span>    fs-&gt;freereg--;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(reg == fs-&gt;freereg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 释放被临时占用的reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">freeexp</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VNONRELOC)		<span style="color:#f00;font-style:italic">/* 表达式的值已被CP_XXX到reg中的，才释放 (还没加载到reg，那压根没占用reg，释放个锤子*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">freereg</span>(fs, e-&gt;u.s.info);	<span style="color:#f00;font-style:italic">/* VNONRELOC info = result register */</span> 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将常量加载到fs-&gt;f的常量表中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** local var = &#34;hello
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">&#34; 则本函数的k,v=&#34;hello&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">addk</span> (FuncState *fs, TValue *k, TValue *v) {
</span></span><span style="display:flex;"><span>  lua_State *L = fs-&gt;L;
</span></span><span style="display:flex;"><span>  TValue *idx = <span style="color:#c34e00">luaH_set</span>(L, fs-&gt;h, k);
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldsize = f-&gt;sizek;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">ttisnumber</span>(idx)) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">luaO_rawequalObj</span>(&amp;fs-&gt;f-&gt;k[<span style="color:#c34e00">cast_int</span>(<span style="color:#c34e00">nvalue</span>(idx))], v));	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#c34e00">cast_int</span>(<span style="color:#c34e00">nvalue</span>(idx));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* constant not found; create a new entry */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setnvalue</span>(idx, <span style="color:#c34e00">cast_num</span>(fs-&gt;nk));
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaM_growvector</span>(L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TValue,
</span></span><span style="display:flex;"><span>                    MAXARG_Bx, <span style="color:#009c00">&#34;constant table overflow&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizek) <span style="color:#c34e00">setnilvalue</span>(&amp;f-&gt;k[oldsize++]);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">setobj</span>(L, &amp;f-&gt;k[fs-&gt;nk], v);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaC_barrier</span>(L, f, v);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> fs-&gt;nk++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将字符串常量加载到fs-&gt;f的常量表中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_stringK</span> (FuncState *fs, TString *s) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setsvalue</span>(fs-&gt;L, &amp;o, s);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">addk</span>(fs, &amp;o, &amp;o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_numberK</span> (FuncState *fs, lua_Number r) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setnvalue</span>(&amp;o, r);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">addk</span>(fs, &amp;o, &amp;o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">boolK</span> (FuncState *fs, <span style="color:#00f">int</span> b) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setbvalue</span>(&amp;o, b);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">addk</span>(fs, &amp;o, &amp;o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">nilK</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  TValue k, v;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setnilvalue</span>(&amp;v);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* cannot use nil as key; instead use table itself to represent nil */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">sethvalue</span>(fs-&gt;L, &amp;k, fs-&gt;h);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">addk</span>(fs, &amp;k, &amp;v);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* nresults:-1, C=0，表示希望返回变参
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nresults: 0, C=1, 表示希望返回0个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nresults: 2, C=2, 表示希望返回1个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_setreturns</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> nresults) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* OP_CALL A B C 		R(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VCALL) {  <span style="color:#f00;font-style:italic">/* expression is an open function call? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">SETARG_C</span>(<span style="color:#c34e00">getcode</span>(fs, e), nresults+1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (e-&gt;k == VVARARG) {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* OP_VARARG A B 	R(A), R(A+1), ..., R(A+B-1) = vararg 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	** 将变参拷贝到RA指定的寄存器开始的地方，拷贝B个元素，这里仅使用了一个寄存器的编码?
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">SETARG_B</span>(<span style="color:#c34e00">getcode</span>(fs, e), nresults+1);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">SETARG_A</span>(<span style="color:#c34e00">getcode</span>(fs, e), fs-&gt;freereg);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_reserveregs</span>(fs, 1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 对于可能返回变参的表达式，强制其仅返回一个值 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_setoneret</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VCALL) {  <span style="color:#f00;font-style:italic">/* expression is an open function call? */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* A B C R(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 函数调用返回的第一个值占用的reg就是函数指针本身占用的reg,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	** 不能返回到其它地方，故而这里是VNONRELOC
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	*/</span>
</span></span><span style="display:flex;"><span>    e-&gt;k = VNONRELOC;	
</span></span><span style="display:flex;"><span>    e-&gt;u.s.info = <span style="color:#c34e00">GETARG_A</span>(<span style="color:#c34e00">getcode</span>(fs, e));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (e-&gt;k == VVARARG) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">SETARG_B</span>(<span style="color:#c34e00">getcode</span>(fs, e), 2);	<span style="color:#f00;font-style:italic">/* 2:期待返回一个返回值 */</span>
</span></span><span style="display:flex;"><span>    e-&gt;k = VRELOCABLE;  <span style="color:#f00;font-style:italic">/* can relocate its simple result */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 生成LOAD_XXX(加载)系列指令，（为后续加载间接表达式的值到reg做准备）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 对需间接读取src.val的表达式生成对应的读值指令(eg:OP_GETTABLE),以便下一步的dst=src
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 需要间接求表达式src.val的：
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 生成求表达式src.val的指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** e-&gt;u.s.info----&gt;pc.addr方便后面确定dst后进行指令回填
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** e.k        ----&gt;VNONRELOC 表达式的src.val对应读值指令已生成，但不在reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式的src.val已经在reg中的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** src.val已在reg中的表达式(VLOCAL,VCALL)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**   e.k      ----&gt; e.k=VNONRELOC
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式的src.val是直接值的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** src.val是直接值的表达式，无需处理
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** discharge:释放
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_dischargevars</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VLOCAL: {	<span style="color:#f00;font-style:italic">/* exp.src已在reg中，故而这里是VNONRELOC */</span>
</span></span><span style="display:flex;"><span>      e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VUPVAL: {
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_GETUPVAL, 0, e-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VGLOBAL: {
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = <span style="color:#c34e00">luaK_codeABx</span>(fs, OP_GETGLOBAL, 0, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VINDEXED: {	<span style="color:#f00;font-style:italic">/* OP_GETTABLE A B C R(A) := R(B)[RK(C)] */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* !!这里是依次释放的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  ** a.b.c.d.e... 释放a.b.c.d之前占用的reg,以便重利用reg
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freereg</span>(fs, e-&gt;u.s.aux);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freereg</span>(fs, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* A填 0，配合下面的可重定位VRELOCALBLE */</span>
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_GETTABLE, 0, e-&gt;u.s.info, e-&gt;u.s.aux);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VVARARG:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VCALL: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_setoneret</span>(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* !!!!常量，常量，常量 不需要用到reg，无需更新reg的信息e-&gt;k了 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VNIL:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VTRUE:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VFALSE:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VKNUM:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VK: {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 还没遇到过，不太理解 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VJMP:
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* e-&gt;k已经确定了寄存器的信息了，直接返回 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VRELOCABLE:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VNONRELOC:
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* there is one value available (somewhere) */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">code_label</span> (FuncState *fs, <span style="color:#00f">int</span> A, <span style="color:#00f">int</span> b, <span style="color:#00f">int</span> jump) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_getlabel</span>(fs);  <span style="color:#f00;font-style:italic">/* those instructions may be jump targets */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_LOADBOOL, A, b, jump);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** CP_XXX拷贝指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 拷贝表达式的值到指定的目的寄存器(reg(dst) = exp(src)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.1 生成表达式的src.val的加载指令(R(B))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.2 回填表达式的目标寄存器(RA),对VNONRELOC的则生成MV指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 参考init_exp 和 luaK_dischargevars函数来理解本函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">discharge2reg</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** step1. 对&#34;间接表达式&#34;生成求值指令 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** step2. 对&#34;直接表达式&#34;生成求值指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** step3. 对&#34;上述表达式&#34;进行回填处理(确定目标寄存器(R(A)))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 表达式的值是常值, 这里生成指令并回填R(A) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_nil</span>(fs, reg, 1);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VFALSE:  <span style="color:#00f">case</span> VTRUE: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_LOADBOOL, reg, e-&gt;k == VTRUE, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 表达式的值在e-&gt;u.s.info：常量表中，这里提出来，生成指令并回填R(A)                       */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: {
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* reg：指令的目标寄存器RA, e-&gt;u.s.info:指令中常量exp在常量表中的索引 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_codeABx</span>(fs, OP_LOADK, reg, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 同上VK，只是nval在常量中的索引延迟到这里确定 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VKNUM: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_codeABx</span>(fs, OP_LOADK, reg, <span style="color:#c34e00">luaK_numberK</span>(fs, e-&gt;u.nval));
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 指令，表达式的值都已确定，这里回填指令的目的地R(A)即可 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VRELOCABLE: {
</span></span><span style="display:flex;"><span>      Instruction *pc = &amp;<span style="color:#c34e00">getcode</span>(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">SETARG_A</span>(*pc, reg);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 表达式的值已确定，生成OP_MOVE指令，回填R(A)=R(B)中的即可 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNONRELOC: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (reg != e-&gt;u.s.info)
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_MOVE, reg, e-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* VJMP尚不理解 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(e-&gt;k == VVOID || e-&gt;k == VJMP);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* nothing to do... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 表达式的目的寄存器R(A)已确定 */</span>
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = reg;
</span></span><span style="display:flex;"><span>  e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">discharge2anyreg</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k != VNONRELOC) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_reserveregs</span>(fs, 1);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">discharge2reg</span>(fs, e, fs-&gt;freereg-1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* dst=src CP_XXX指令，将表达式的值赋值给指定的寄存器reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">exp2reg</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 将表达式的src.val赋值给dst(reg) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">discharge2reg</span>(fs, e, reg);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VJMP)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_concat</span>(fs, &amp;e-&gt;t, e-&gt;u.s.info);  <span style="color:#f00;font-style:italic">/* put this jump in `t&#39; list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">hasjumps</span>(e)) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> final;  <span style="color:#f00;font-style:italic">/* position after whole expression */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> p_f = NO_JUMP;  <span style="color:#f00;font-style:italic">/* position of an eventual LOAD false */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> <span style="color:#00f">p_t</span> = NO_JUMP;  <span style="color:#f00;font-style:italic">/* position of an eventual LOAD true */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">need_value</span>(fs, e-&gt;t) || <span style="color:#c34e00">need_value</span>(fs, e-&gt;f)) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> fj = (e-&gt;k == VJMP) ? NO_JUMP : <span style="color:#c34e00">luaK_jump</span>(fs);
</span></span><span style="display:flex;"><span>      p_f = <span style="color:#c34e00">code_label</span>(fs, reg, 0, 1);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">p_t</span> = <span style="color:#c34e00">code_label</span>(fs, reg, 1, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_patchtohere</span>(fs, fj);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    final = <span style="color:#c34e00">luaK_getlabel</span>(fs);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">patchlistaux</span>(fs, e-&gt;f, final, reg, p_f);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">patchlistaux</span>(fs, e-&gt;t, final, reg, <span style="color:#00f">p_t</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  e-&gt;f = e-&gt;t = NO_JUMP;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 经过dst.(reg) = src.val 后，表达式的目标地址已确定,且已在reg中 */</span>
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = reg;
</span></span><span style="display:flex;"><span>  e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** CP_XXX 拷贝指令 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** reg(var) = exp： 将表达式的src.val拷贝给next&#39;free.reg
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_exp2nextreg</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 更新exp的reg或者op信息
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 不能确定exp对应指令的则e-&gt;u.info中填入指令地址，方便回填,同时e-&gt;k:更新为VRELOCABLE，表示需要回填RA?
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 释放被临时占用的reg */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, e);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 申请一个reg，并将exp赋值到reg上 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_reserveregs</span>(fs, 1);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">exp2reg</span>(fs, e, fs-&gt;freereg - 1);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** LOAD_XXX 加载指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将表达式的值加载到寄存器中(eg:VGLOBAL, VINDEXED)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 已加载到reg中的则无需此步骤(VNONRELOC)),
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** RETURNS:寄存器地址 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_exp2anyreg</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 对表达式生成估值指令 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VNONRELOC) {	<span style="color:#f00;font-style:italic">/* e的src.val已在reg中，则直接返回对应的reg */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!<span style="color:#c34e00">hasjumps</span>(e)) <span style="color:#00f">return</span> e-&gt;u.s.info;  <span style="color:#f00;font-style:italic">/* exp is already in a register */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (e-&gt;u.s.info &gt;= fs-&gt;nactvar) {  <span style="color:#f00;font-style:italic">/* reg. is not a local? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">exp2reg</span>(fs, e, e-&gt;u.s.info);  <span style="color:#f00;font-style:italic">/* put value on it */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* e的src值还不在reg则将其存入reg */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, e);  <span style="color:#f00;font-style:italic">/* default */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 类似 LOAD_XXX 生成表达式的加载指令(！！！！不是CP_XXX拷贝一份e的值到reg的拷贝指令) */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_exp2val</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">hasjumps</span>(e))
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, e);	<span style="color:#f00;font-style:italic">/* 求解表达式的src.val后，将表达式的值放到下一个free.reg中 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);	<span style="color:#f00;font-style:italic">/* 对间接表达式（原值不在reg中或不是直接值的）生成求值指令 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** LOAD_XXX 加载指令 将表达式的值加载到next’free’reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** VNONRELOC这种表达式的值已被加载到reg上的就无需处理了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.1 表达式的值不在reg中的非VNONRELOC,生成对应的加载指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.2 回填上述加载指令，正式将表达式加载到reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** RETURNS: 加载的reg的地址
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_exp2RK</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 对[间接]表达式e生成求值指令 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2val</span>(fs, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* e是常量表达式，无需生成求值指令，直接返回常量表中对应的索引即可 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VKNUM:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VTRUE:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VFALSE:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (fs-&gt;nk &lt;= MAXINDEXRK) {  <span style="color:#f00;font-style:italic">/* constant fit in RK operand? */</span>
</span></span><span style="display:flex;"><span>        e-&gt;u.s.info = (e-&gt;k == VNIL)  ? <span style="color:#c34e00">nilK</span>(fs) :
</span></span><span style="display:flex;"><span>                      (e-&gt;k == VKNUM) ? <span style="color:#c34e00">luaK_numberK</span>(fs, e-&gt;u.nval) :
</span></span><span style="display:flex;"><span>                                        <span style="color:#c34e00">boolK</span>(fs, (e-&gt;k == VTRUE));
</span></span><span style="display:flex;"><span>        e-&gt;k = VK;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#c34e00">RKASK</span>(e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (e-&gt;u.s.info &lt;= MAXINDEXRK)  <span style="color:#f00;font-style:italic">/* constant fit in argC? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> <span style="color:#c34e00">RKASK</span>(e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* not a constant in the right range: put it in a register 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 间接表达式(非常量表达式)，将其src.val赋值到下一个free.reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* var = ex
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 先 LOAD_XXX (ex) 后 SET_XXX(var=ex) 的&#34;赋值组合业务&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_storevar</span> (FuncState *fs, expdesc *var, expdesc *ex) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (var-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VLOCAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freeexp</span>(fs, ex);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">exp2reg</span>(fs, ex, var-&gt;u.s.info);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VUPVAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> e = <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, ex);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_SETUPVAL, e, var-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VGLOBAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> e = <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, ex);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_codeABx</span>(fs, OP_SETGLOBAL, e, var-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VINDEXED: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> e = <span style="color:#c34e00">luaK_exp2RK</span>(fs, ex);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_SETTABLE, var-&gt;u.s.info, var-&gt;u.s.aux, e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(0);  <span style="color:#f00;font-style:italic">/* invalid var kind to store */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, ex);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* OP_SELF A B C R(A+1) := R(B); R(A) := R(B)[RK(C)] */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_self</span> (FuncState *fs, expdesc *e, expdesc *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> func;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, e);
</span></span><span style="display:flex;"><span>  func = fs-&gt;freereg;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_reserveregs</span>(fs, 2);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_SELF, func, e-&gt;u.s.info, <span style="color:#c34e00">luaK_exp2RK</span>(fs, key));
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, key);
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = func;
</span></span><span style="display:flex;"><span>  e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* invert:颠倒 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">invertjump</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  Instruction *pc = <span style="color:#c34e00">getjumpcontrol</span>(fs, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">testTMode</span>(<span style="color:#c34e00">GET_OPCODE</span>(*pc)) &amp;&amp; <span style="color:#c34e00">GET_OPCODE</span>(*pc) != OP_TESTSET &amp;&amp;
</span></span><span style="display:flex;"><span>                                           <span style="color:#c34e00">GET_OPCODE</span>(*pc) != OP_TEST);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">SETARG_A</span>(*pc, !(<span style="color:#c34e00">GETARG_A</span>(*pc)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">jumponcond</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> cond) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VRELOCABLE) {
</span></span><span style="display:flex;"><span>    Instruction ie = <span style="color:#c34e00">getcode</span>(fs, e);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">GET_OPCODE</span>(ie) == OP_NOT) {
</span></span><span style="display:flex;"><span>      fs-&gt;pc--;  <span style="color:#f00;font-style:italic">/* remove previous OP_NOT */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> <span style="color:#c34e00">condjump</span>(fs, OP_TEST, <span style="color:#c34e00">GETARG_B</span>(ie), 0, !cond);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* else go through */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">discharge2anyreg</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">condjump</span>(fs, OP_TESTSET, NO_REG, e-&gt;u.s.info, cond);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* and */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_goiftrue</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> pc;  <span style="color:#f00;font-style:italic">/* pc of last jump */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: <span style="color:#00f">case</span> VKNUM: <span style="color:#00f">case</span> VTRUE: {	
</span></span><span style="display:flex;"><span>      pc = NO_JUMP;  <span style="color:#f00;font-style:italic">/* always true; do nothing， keep go throught? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">invertjump</span>(fs, e);
</span></span><span style="display:flex;"><span>      pc = e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      pc = <span style="color:#c34e00">jumponcond</span>(fs, e, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_concat</span>(fs, &amp;e-&gt;f, pc);  <span style="color:#f00;font-style:italic">/* insert last jump in `f&#39; list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchtohere</span>(fs, e-&gt;t);
</span></span><span style="display:flex;"><span>  e-&gt;t = NO_JUMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* or */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">luaK_goiffalse</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> pc;  <span style="color:#f00;font-style:italic">/* pc of last jump */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: <span style="color:#00f">case</span> VFALSE: {
</span></span><span style="display:flex;"><span>      pc = NO_JUMP;  <span style="color:#f00;font-style:italic">/* always false; do nothing */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      pc = e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      pc = <span style="color:#c34e00">jumponcond</span>(fs, e, 1);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_concat</span>(fs, &amp;e-&gt;t, pc);  <span style="color:#f00;font-style:italic">/* insert last jump in `t&#39; list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchtohere</span>(fs, e-&gt;f);
</span></span><span style="display:flex;"><span>  e-&gt;f = NO_JUMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* not  A B R(A) := not R(B) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** not的stat的左边必须有左值,否则就是语法错误
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codenot</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_dischargevars</span>(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: <span style="color:#00f">case</span> VFALSE: {
</span></span><span style="display:flex;"><span>      e-&gt;k = VTRUE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: <span style="color:#00f">case</span> VKNUM: <span style="color:#00f">case</span> VTRUE: {
</span></span><span style="display:flex;"><span>      e-&gt;k = VFALSE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">invertjump</span>(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VRELOCABLE:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNONRELOC: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">discharge2anyreg</span>(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freeexp</span>(fs, e);
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_NOT, 0, e-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(0);  <span style="color:#f00;font-style:italic">/* cannot happen */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* interchange true and false lists */</span>
</span></span><span style="display:flex;"><span>  { <span style="color:#00f">int</span> temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">removevalues</span>(fs, e-&gt;f);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">removevalues</span>(fs, e-&gt;t);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 索引表达式t.k 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** info = table register; aux = index register (or `k&#39;) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** eg: tbl(info).aux(aux) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_indexed</span> (FuncState *fs, expdesc *t, expdesc *k) {
</span></span><span style="display:flex;"><span>  t-&gt;u.s.aux = <span style="color:#c34e00">luaK_exp2RK</span>(fs, k);
</span></span><span style="display:flex;"><span>  t-&gt;k = VINDEXED;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 尝试合并二元操作符以及左右两边的表达式(编译优化) */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">constfolding</span> (OpCode op, expdesc *e1, expdesc *e2) {
</span></span><span style="display:flex;"><span>  lua_Number v1, v2, r;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 两个操作数都得是numeral */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">isnumeral</span>(e1) || !<span style="color:#c34e00">isnumeral</span>(e2)) <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  v1 = e1-&gt;u.nval;
</span></span><span style="display:flex;"><span>  v2 = e2-&gt;u.nval;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_ADD: r = <span style="color:#c34e00">luai_numadd</span>(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_SUB: r = <span style="color:#c34e00">luai_numsub</span>(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_MUL: r = <span style="color:#c34e00">luai_nummul</span>(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_DIV:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (v2 == 0) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* do not attempt to divide by 0 */</span>
</span></span><span style="display:flex;"><span>      r = <span style="color:#c34e00">luai_numdiv</span>(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_MOD:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (v2 == 0) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* do not attempt to divide by 0 */</span>
</span></span><span style="display:flex;"><span>      r = <span style="color:#c34e00">luai_nummod</span>(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_POW: r = <span style="color:#c34e00">luai_numpow</span>(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_UNM: r = <span style="color:#c34e00">luai_numunm</span>(v1); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_LEN: <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* no constant folding for &#39;len&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#c34e00">lua_assert</span>(0); r = 0; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">luai_numisnan</span>(r)) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* do not attempt to produce NaN */</span>
</span></span><span style="display:flex;"><span>  e1-&gt;u.nval = r;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** local a = b + c 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式运行完毕后，b,c占用的临时的reg就可以被释放了，故而这一行编译完成后b,c占用的reg也可以释放了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codearith</span> (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">constfolding</span>(op, e1, e2))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> o2 = (op != OP_UNM &amp;&amp; op != OP_LEN) ? <span style="color:#c34e00">luaK_exp2RK</span>(fs, e2) : 0;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> o1 = <span style="color:#c34e00">luaK_exp2RK</span>(fs, e1);
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* 释放exp的规则是从后往前free */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (o1 &gt; o2) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freeexp</span>(fs, e1);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freeexp</span>(fs, e2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freeexp</span>(fs, e2);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">freeexp</span>(fs, e1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 这里R(A)的值尚未确定，e-&gt;=VRELOCABLE:表示需要重定位？ */</span>
</span></span><span style="display:flex;"><span>    e1-&gt;u.s.info = <span style="color:#c34e00">luaK_codeABC</span>(fs, op, 0, o1, o2);
</span></span><span style="display:flex;"><span>    e1-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 关系表达式 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codecomp</span> (FuncState *fs, OpCode op, <span style="color:#00f">int</span> cond, expdesc *e1,
</span></span><span style="display:flex;"><span>                                                          expdesc *e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> o1 = <span style="color:#c34e00">luaK_exp2RK</span>(fs, e1);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> o2 = <span style="color:#c34e00">luaK_exp2RK</span>(fs, e2);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, e2);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">freeexp</span>(fs, e1);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (cond == 0 &amp;&amp; op != OP_EQ) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> temp;  <span style="color:#f00;font-style:italic">/* exchange args to replace by `&lt;&#39; or `&lt;=&#39; */</span>
</span></span><span style="display:flex;"><span>    temp = o1; o1 = o2; o2 = temp;  <span style="color:#f00;font-style:italic">/* o1 &lt;==&gt; o2 */</span>
</span></span><span style="display:flex;"><span>    cond = 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  e1-&gt;u.s.info = <span style="color:#c34e00">condjump</span>(fs, op, cond, o1, o2);
</span></span><span style="display:flex;"><span>  e1-&gt;k = VJMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_prefix</span> (FuncState *fs, UnOpr op, expdesc *e) {
</span></span><span style="display:flex;"><span>  expdesc e2;
</span></span><span style="display:flex;"><span>  e2.t = e2.f = NO_JUMP;
</span></span><span style="display:flex;"><span>  e2.k = VKNUM; e2.u.nval = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MINUS: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">isnumeral</span>(e))
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, e);  <span style="color:#f00;font-style:italic">/* cannot operate on non-numeric constants */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">codearith</span>(fs, OP_UNM, e, &amp;e2);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_NOT: <span style="color:#c34e00">codenot</span>(fs, e); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_LEN: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, e);  <span style="color:#f00;font-style:italic">/* cannot operate on constants */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">codearith</span>(fs, OP_LEN, e, &amp;e2);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#c34e00">lua_assert</span>(0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_infix</span> (FuncState *fs, BinOpr op, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_AND: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_goiftrue</span>(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_OR: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_goiffalse</span>(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_CONCAT: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, v);  <span style="color:#f00;font-style:italic">/* operand must be on the `stack&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_ADD: <span style="color:#00f">case</span> OPR_SUB: <span style="color:#00f">case</span> OPR_MUL: <span style="color:#00f">case</span> OPR_DIV:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MOD: <span style="color:#00f">case</span> OPR_POW: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!<span style="color:#c34e00">isnumeral</span>(v)) <span style="color:#c34e00">luaK_exp2RK</span>(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_exp2RK</span>(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_posfix</span> (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_AND: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(e1-&gt;t == NO_JUMP);  <span style="color:#f00;font-style:italic">/* list must be closed */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_dischargevars</span>(fs, e2);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_concat</span>(fs, &amp;e2-&gt;f, e1-&gt;f);
</span></span><span style="display:flex;"><span>      *e1 = *e2;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_OR: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(e1-&gt;f == NO_JUMP);  <span style="color:#f00;font-style:italic">/* list must be closed */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_dischargevars</span>(fs, e2);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_concat</span>(fs, &amp;e2-&gt;t, e1-&gt;t);
</span></span><span style="display:flex;"><span>      *e1 = *e2;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_CONCAT: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_exp2val</span>(fs, e2);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (e2-&gt;k == VRELOCABLE &amp;&amp; <span style="color:#c34e00">GET_OPCODE</span>(<span style="color:#c34e00">getcode</span>(fs, e2)) == OP_CONCAT) {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">lua_assert</span>(e1-&gt;u.s.info == <span style="color:#c34e00">GETARG_B</span>(<span style="color:#c34e00">getcode</span>(fs, e2))-1);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">freeexp</span>(fs, e1);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">SETARG_B</span>(<span style="color:#c34e00">getcode</span>(fs, e2), e1-&gt;u.s.info);
</span></span><span style="display:flex;"><span>        e1-&gt;k = VRELOCABLE; e1-&gt;u.s.info = e2-&gt;u.s.info;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, e2);  <span style="color:#f00;font-style:italic">/* operand must be on the &#39;stack&#39; */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">codearith</span>(fs, OP_CONCAT, e1, e2);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_ADD: <span style="color:#c34e00">codearith</span>(fs, OP_ADD, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_SUB: <span style="color:#c34e00">codearith</span>(fs, OP_SUB, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MUL: <span style="color:#c34e00">codearith</span>(fs, OP_MUL, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_DIV: <span style="color:#c34e00">codearith</span>(fs, OP_DIV, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MOD: <span style="color:#c34e00">codearith</span>(fs, OP_MOD, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_POW: <span style="color:#c34e00">codearith</span>(fs, OP_POW, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_EQ: <span style="color:#c34e00">codecomp</span>(fs, OP_EQ, 1, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_NE: <span style="color:#c34e00">codecomp</span>(fs, OP_EQ, 0, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_LT: <span style="color:#c34e00">codecomp</span>(fs, OP_LT, 1, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_LE: <span style="color:#c34e00">codecomp</span>(fs, OP_LE, 1, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_GT: <span style="color:#c34e00">codecomp</span>(fs, OP_LT, 0, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_GE: <span style="color:#c34e00">codecomp</span>(fs, OP_LE, 0, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#c34e00">lua_assert</span>(0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 更新上一个生成的pc对应的行信息 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_fixline</span> (FuncState *fs, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">luaK_code</span> (FuncState *fs, Instruction i, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">dischargejpc</span>(fs);  <span style="color:#f00;font-style:italic">/* `pc&#39; will change */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* put new instruction in code array */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_growvector</span>(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,
</span></span><span style="display:flex;"><span>                  MAX_INT, <span style="color:#009c00">&#34;code size overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  f-&gt;code[fs-&gt;pc] = i;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* save corresponding line information */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_growvector</span>(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, <span style="color:#00f">int</span>,
</span></span><span style="display:flex;"><span>                  MAX_INT, <span style="color:#009c00">&#34;code size overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  f-&gt;lineinfo[fs-&gt;pc] = line;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> fs-&gt;pc++;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_codeABC</span> (FuncState *fs, OpCode o, <span style="color:#00f">int</span> a, <span style="color:#00f">int</span> b, <span style="color:#00f">int</span> c) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">getOpMode</span>(o) == iABC);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">getBMode</span>(o) != OpArgN || b == 0);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">getCMode</span>(o) != OpArgN || c == 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaK_code</span>(fs, <span style="color:#c34e00">CREATE_ABC</span>(o, a, b, c), fs-&gt;ls-&gt;lastline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_codeABx</span> (FuncState *fs, OpCode o, <span style="color:#00f">int</span> a, <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> bc) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">getOpMode</span>(o) == iABx || <span style="color:#c34e00">getOpMode</span>(o) == iAsBx);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">getCMode</span>(o) == OpArgN);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> <span style="color:#c34e00">luaK_code</span>(fs, <span style="color:#c34e00">CREATE_ABx</span>(o, a, bc), fs-&gt;ls-&gt;lastline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_setlist</span> (FuncState *fs, <span style="color:#00f">int</span> base, <span style="color:#00f">int</span> nelems, <span style="color:#00f">int</span> tostore) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> b = (tostore == LUA_MULTRET) ? 0 : tostore;	<span style="color:#f00;font-style:italic">/* tostore中最后一个是变参，则tostore==LUA_MULTRET */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(tostore != 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (c &lt;= MAXARG_C)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_SETLIST, base, b, c);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* c过大，将其放到下一条指令中 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_SETLIST, base, b, 0);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_code</span>(fs, <span style="color:#c34e00">cast</span>(Instruction, c), fs-&gt;ls-&gt;lastline);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里可以回收空闲出来的寄存器了，有意思吧 */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;freereg = base + 1;  <span style="color:#f00;font-style:italic">/* free registers with list values */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lparse.c/" itemprop="url">
        lua源码注释 lparse.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-08">
    2021-06-08
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">9731 字 ~20分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 参考的BNF地址 shankusu.me/lua/TheCompleteSyntaxOfLua51/ */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: lparser.c,v 2.42.1.4 2011/10/21 19:31:42 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Lua Parser
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define lparser_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lcode.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lfunc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;llex.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lmem.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lparser.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstring.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 也只有函数调用或变参操作符这两种TOKEN能返回 ... */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* i:当前活跃的locvar的索引 */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define getlocvar(fs, i)	((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 检查value是否超过了limit限制,超过则报错msg */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define luaY_checklimit(fs,v,l,m)	if ((v)&gt;(l)) errorlimit(fs,l,m)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nodes for block list (list of active blocks)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** previous:往前跳(eg:查找变量时从now-block往前一级一级的block找)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> BlockCnt {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> BlockCnt *previous;  <span style="color:#f00;font-style:italic">/* chain */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> breaklist;  <span style="color:#f00;font-style:italic">/* list of jumps out of this loop */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** ！！！！在进入本block的瞬间，外面已经激活的var的数量， ！！！！
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 意味着本块内激活的locvar的reg.idx不会低于整个值，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 用于按照便变量的生存期检索变量 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 退出本block后，将fs-&gt;reg重置到本次即可清掉本block内激活的actvar
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  lu_byte nactvar;  <span style="color:#f00;font-style:italic">/* # active locals outside the breakable structure */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  lu_byte upval;  <span style="color:#f00;font-style:italic">/* true if some variable in the block is an upvalue(本块中存在某些变量是其它块的upvalues：本块关闭时要做善后处理？) */</span>
</span></span><span style="display:flex;"><span>  lu_byte isbreakable;  <span style="color:#f00;font-style:italic">/* true if `block&#39; is a loop, 语法规则：break仅能用于loop的block中 */</span>
</span></span><span style="display:flex;"><span>} BlockCnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** prototypes for recursive non-terminal functions
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">chunk</span> (LexState *ls);
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">expr</span> (LexState *ls, expdesc *v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* anchor:锚 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">anchor_token</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token == TK_NAME || ls-&gt;t.token == TK_STRING) {
</span></span><span style="display:flex;"><span>    TString *ts = ls-&gt;t.seminfo.ts;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_newstring</span>(ls, <span style="color:#c34e00">getstr</span>(ts), ts-&gt;tsv.len);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">error_expected</span> (LexState *ls, <span style="color:#00f">int</span> token) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_syntaxerror</span>(ls,
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaO_pushfstring</span>(ls-&gt;L, LUA_QS <span style="color:#009c00">&#34; expected&#34;</span>, <span style="color:#c34e00">luaX_token2str</span>(ls, token)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">errorlimit</span> (FuncState *fs, <span style="color:#00f">int</span> limit, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *what) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *msg = (fs-&gt;f-&gt;linedefined == 0) ?
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaO_pushfstring</span>(fs-&gt;L, <span style="color:#009c00">&#34;main function has more than %d %s&#34;</span>, limit, what) :
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaO_pushfstring</span>(fs-&gt;L, <span style="color:#009c00">&#34;function at line %d has more than %d %s&#34;</span>,
</span></span><span style="display:flex;"><span>                            fs-&gt;f-&gt;linedefined, limit, what);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_lexerror</span>(fs-&gt;ls, msg, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">testnext</span> (LexState *ls, <span style="color:#00f">int</span> c) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token == c) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 检查当前c是否为特定的token&#39;Type */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">check</span> (LexState *ls, <span style="color:#00f">int</span> c) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token != c)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">error_expected</span>(ls, c);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">checknext</span> (LexState *ls, <span style="color:#00f">int</span> c) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check</span>(ls, c);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 在where(line)这里，who(TK.1)需要一个what(TK.2)匹配
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** eg: function 需要一个end来结束函数定义
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">check_match</span> (LexState *ls, <span style="color:#00f">int</span> what, <span style="color:#00f">int</span> who, <span style="color:#00f">int</span> where) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!<span style="color:#c34e00">testnext</span>(ls, what)) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (where == ls-&gt;linenumber)	<span style="color:#f00;font-style:italic">/* 当前行，那就不需要打印line信息了？ */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">error_expected</span>(ls, what);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#f00;font-style:italic">/* 输出连带line信息的错误信息 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#c34e00">luaO_pushfstring</span>(ls-&gt;L,
</span></span><span style="display:flex;"><span>             LUA_QS <span style="color:#009c00">&#34; expected (to close &#34;</span> LUA_QS <span style="color:#009c00">&#34; at line %d)&#34;</span>,
</span></span><span style="display:flex;"><span>              <span style="color:#c34e00">luaX_token2str</span>(ls, what), <span style="color:#c34e00">luaX_token2str</span>(ls, who), where));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 强制检查并当前token的type为TK_NAME，返回当前token，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 读取下一个token 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> TString *<span style="color:#c34e00">str_checkname</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  TString *ts;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check</span>(ls, TK_NAME);		<span style="color:#f00;font-style:italic">/* 当前token&#39;type必须是TK_NAME的类型 */</span>
</span></span><span style="display:flex;"><span>  ts = ls-&gt;t.seminfo.ts;	<span style="color:#f00;font-style:italic">/* 提取token的值 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);			<span style="color:#f00;font-style:italic">/* 继续读下一个token */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> ts;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*  KEYCODE: 关键函数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">init_exp</span> (expdesc *e, expkind k, <span style="color:#00f">int</span> i) {
</span></span><span style="display:flex;"><span>  e-&gt;f = e-&gt;t = NO_JUMP;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ************************************exp对应的reg已定或是一个参数无需reg*********************************
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VVOID, VKNUM, VNIL, VTRUE, VFALSE,   	i:0 值直接被包含在表达式expdesc中，无需寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VK   								    i:常量表中的索引
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VLOCAL									i:locvar占用的reg索引
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VGLOBAL							    i:NO_REG-&gt;全局变量名的NAME在常量表中的索引
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ***********************************需回填指令的RA?**********************************
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VRELOCABLE								i:？对应指令OP在指令数组中的下标（方便回填指令中的RA？)？
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VCALL, VVARARG							i:对应指令OP在指令数组中的下标（方便回填指令中的RA？)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** VNONRELOC								i:对应指令OP在指令数组的下标(方便回填指令中的RA?)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  e-&gt;k = k;
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = i;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 用字符串(TK_NAME)s初始化expdesc的e表达式 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codestring</span> (LexState *ls, expdesc *e, TString *s) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(e, VK, <span style="color:#c34e00">luaK_stringK</span>(ls-&gt;fs, s));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 先检查当前t的类型为NAME，后将其携带的string赋值给expdesc, 内部读取一次luaX_next() */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">checkname</span>(LexState *ls, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">codestring</span>(ls, e, <span style="color:#c34e00">str_checkname</span>(ls));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 填充一个全新的 Locvar信息到 Proto.locvars (供调试用)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">registerlocalvar</span> (LexState *ls, TString *varname) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldsize = f-&gt;sizelocvars;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 原来的总数组f-&gt;sizelocvars空间不足则扩大 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_growvector</span>(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
</span></span><span style="display:flex;"><span>                  LocVar, SHRT_MAX, <span style="color:#009c00">&#34;too many local variables&#34;</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizelocvars)	<span style="color:#f00;font-style:italic">/* locvars数组扩大则将新增的slot填NULL */</span>
</span></span><span style="display:flex;"><span>  	f-&gt;locvars[oldsize++].varname = NULL;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新locvar信息, startPC,endPC暂时还不确定 */</span>
</span></span><span style="display:flex;"><span>  f-&gt;locvars[fs-&gt;nlocvars].varname = varname; 
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* printf(&#34;registerlocalvar: idx(%d), name(%p)\n&#34;, fs-&gt;nlocvars, varname); */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_objbarrier</span>(ls-&gt;L, f, varname);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> fs-&gt;nlocvars++;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 如果v是不变的string则此宏定义可以利用宏处理阶段提高程序速度 */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define new_localvarliteral(ls,v,n) \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  new_localvar(ls, luaX_newstring(ls, &#34;&#34; v, (sizeof(v)/sizeof(char))-1), n)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* KEYCODE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 注册一个本地变量信息到 Proto.locvars ,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 填充变量名, startpc,endpc稍后再处理
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">new_localvar</span> (LexState *ls, TString *name, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaY_checklimit</span>(fs, fs-&gt;nactvar+n+1, LUAI_MAXVARS, <span style="color:#009c00">&#34;local variables&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 设置actvar 到 Proto.nlocvars 的映射 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里仅设置了变量的name, 尚未设置startpc,endpc */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;actvar[fs-&gt;nactvar+n] = <span style="color:#c34e00">cast</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">short</span>, <span style="color:#c34e00">registerlocalvar</span>(ls, name));
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">//printf(&#34;......... %d-&gt;%d&#34;, fs-&gt;nactvar+n, fs-&gt;actvar[fs-&gt;nactvar+n]);
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 更新!!! FunState.nactvar 数量，更新 Proto.locvars.startpc 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 一次性生成多个locvar时，nvars可以告诉本函数方便一次性调整到位
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">adjustlocalvars</span> (LexState *ls, <span style="color:#00f">int</span> nvars) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新fs中当前激活的locvar数量 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新fs中当前激活的locvar数量 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新fs中当前激活的locvar数量 */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;nactvar = <span style="color:#c34e00">cast_byte</span>(fs-&gt;nactvar + nvars);	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新localvar的startpc */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; nvars; nvars--) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">getlocvar</span>(fs, fs-&gt;nactvar - nvars).startpc = fs-&gt;pc;
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 对应的chunk结束时，再更新endpc信息，也只有那个时候才能确切的知道endpc */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 确定一批actvar的endpc 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 仔细看这个函数，很有意思哈（结合 new_localvar adjustlocalvars 一起看 ）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">removevars</span> (LexState *ls, <span style="color:#00f">int</span> tolevel) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (fs-&gt;nactvar &gt; tolevel)	<span style="color:#f00;font-style:italic">/* 这里tolevel是指block结束时对应的pc.idx */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">getlocvar</span>(fs, --fs-&gt;nactvar).endpc = fs-&gt;pc;	<span style="color:#f00;font-style:italic">/* 离开block时,关闭block内actvar */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 查找一个upvalue,返回其在upval数组中的索引，没有则构建 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">indexupvalue</span> (FuncState *fs, TString *name, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldsize = f-&gt;sizeupvalues;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 当前存在的upvalue中已存在吗? */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=0; i&lt;f-&gt;nups; i++) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp;			<span style="color:#f00;font-style:italic">/* 类型为VUPVAL */</span>
</span></span><span style="display:flex;"><span>		fs-&gt;upvalues[i].info == v-&gt;u.s.info) {	<span style="color:#f00;font-style:italic">/* 在proto中的索引一致 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">lua_assert</span>(f-&gt;upvalues[i] == name);		<span style="color:#f00;font-style:italic">/* 名字就必须一致了 */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* new one */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 数组容量不够则扩大 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaY_checklimit</span>(fs, f-&gt;nups + 1, LUAI_MAXUPVALUES, <span style="color:#009c00">&#34;upvalues&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_growvector</span>(fs-&gt;L, f-&gt;upvalues, f-&gt;nups, f-&gt;sizeupvalues,
</span></span><span style="display:flex;"><span>                  TString *, MAX_INT, <span style="color:#009c00">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizeupvalues)
</span></span><span style="display:flex;"><span>  	f-&gt;upvalues[oldsize++] = NULL;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  f-&gt;upvalues[f-&gt;nups] = name;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_objbarrier</span>(fs-&gt;L, f, name);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(v-&gt;k == VLOCAL || v-&gt;k == VUPVAL);	<span style="color:#f00;font-style:italic">/* 这里的v-&gt;k==VLOCAL ? */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新到fs */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;upvalues[f-&gt;nups].k = <span style="color:#c34e00">cast_byte</span>(v-&gt;k);
</span></span><span style="display:flex;"><span>  fs-&gt;upvalues[f-&gt;nups].info = <span style="color:#c34e00">cast_byte</span>(v-&gt;u.s.info);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> f-&gt;nups++;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 尝试在当前fs中匹配激活状态的locvar */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">searchvar</span> (FuncState *fs, TString *n) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=fs-&gt;nactvar-1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n == <span style="color:#c34e00">getlocvar</span>(fs, i).varname)
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> i;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* not found */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* fs中的locvar在其它函数中被当作upval引用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 标记fs中对应的block，你有变量是其它fs的upval
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** level:actvar在reg数组中的索引
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">markupval</span> (FuncState *fs, <span style="color:#00f">int</span> level) {
</span></span><span style="display:flex;"><span>  BlockCnt *bl = fs-&gt;bl;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这个标记过程的逻辑蛮有意思的 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (bl &amp;&amp; bl-&gt;nactvar &gt; level)
</span></span><span style="display:flex;"><span>  	bl = bl-&gt;previous;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (bl)
</span></span><span style="display:flex;"><span>  	bl-&gt;upval = 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 查找变量名对应的表达式类型的值类型(VLOCAL还是?)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 仔细看这个函数的逻辑，搞明白关于变量的查找过程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step1:先在本地fs6激活中的locvar查找，找到则返回VLOCAL
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step2:往前一个fs5中的激活中的locvar查找，找不到，继续下一步step3
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step3:继续往前一个fs1中的激活的locvar查找，一直到fs1-&gt;pre为空，则
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**     可以确定var是一个VGLOBAL
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step4:在某一个fs3中的激活中的locvar被找到，则标记此fs3中的bl表示你的某个var被其它fsX当作upval了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**        往前退，在fs4中的upval中新增一条信息(此upval在父fs3中是VLOCAL,且在fs3的actvar中的索引是多少)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**        再往前退，在fs5中的upval中新增一条信息(此upval在父fs4中是UPVAL，且在fs4的upvalues的索引是多少)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**        再往前退，直到初始的fs6，在fs6中的upval中新增一条信息（此upval在父fs5中是UPVAL,且在fs5的upvalues的索引是多少)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 理论上可以优化下：在本地locvar找不到时，先不要在父fs中找，而是在本fs的upvales中找下
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">singlevaraux</span> (FuncState *fs, TString *n, expdesc *var, <span style="color:#00f">int</span> base) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (fs == NULL) {  <span style="color:#f00;font-style:italic">/* no more levels? */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* default is global variable, NO_REG:表示此全局变量尚未决定其寄存器的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	** 全局变量对应的NAME在p中常量表的索引由singlevar()函数来处理
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">init_exp</span>(var, VGLOBAL, NO_REG);  
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> VGLOBAL;	<span style="color:#f00;font-style:italic">/* 往外一层一层都找不到时，则认为它是全局变量 */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 在激活的locvar中找到了，则是本地变量 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> v = <span style="color:#c34e00">searchvar</span>(fs, n);  <span style="color:#f00;font-style:italic">/* look up at current level */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (v &gt;= 0) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">init_exp</span>(var, VLOCAL, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!base)
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">markupval</span>(fs, v);  <span style="color:#f00;font-style:italic">/* local will be used as an upval */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> VLOCAL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* not found at current level; try upper one */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">singlevaraux</span>(fs-&gt;prev, n, var, 0) == VGLOBAL)	<span style="color:#f00;font-style:italic">/* 都没找到，则是全局变量 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> VGLOBAL;
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 父func中找到，在自己的fun中算upval */</span>
</span></span><span style="display:flex;"><span>      var-&gt;u.s.info = <span style="color:#c34e00">indexupvalue</span>(fs, n, var);  <span style="color:#f00;font-style:italic">/* else was LOCAL or UPVAL */</span>
</span></span><span style="display:flex;"><span>      var-&gt;k = VUPVAL;  <span style="color:#f00;font-style:italic">/* upvalue in this level */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> VUPVAL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step1: 检查ls-&gt;t.token的类型为TK_NAME，读取下一个TOKEN
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step2: 根据上一个token的NAME，确定其变量(VLOCAL,VGLOBAL还是VUPVAL？)类型，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**            后填充expdesc.u.s.info信息
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">singlevar</span> (LexState *ls, expdesc *var) {
</span></span><span style="display:flex;"><span>  TString *varname = <span style="color:#c34e00">str_checkname</span>(ls);
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** OP_GETGLOBAL A Bx R(A) := Gbl[Kst(Bx)]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** OP_SETGLOBAL A Bx Gbl[Kst(Bx)] := R(A)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 全局变量的指令需要知道表示全局变量的NAME在常量表中的idx，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **     理解这一点就明白了下面var-&gt;u.s.info的赋值的意义
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">singlevaraux</span>(fs, varname, var, 1) == VGLOBAL) {	<span style="color:#f00;font-style:italic">/* VLOCVAR,VUPVAL在singlevaraux中已被init_exp初始化 */</span>
</span></span><span style="display:flex;"><span>    var-&gt;u.s.info = <span style="color:#c34e00">luaK_stringK</span>(fs, varname);  <span style="color:#f00;font-style:italic">/* info points to global name */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 针对 nvars = nexps 赋值进行调整
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 如果右边少了则给左边赋NIL
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 如果右边有call,...则确定期待的返回值个数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** ！！！ 如果右边多了，本函数未处理！！！
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">adjust_assign</span> (LexState *ls, <span style="color:#00f">int</span> nvars, <span style="color:#00f">int</span> nexps, expdesc *e) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* extra: 右边除掉fun和...外，表达式的数量少于左边的val的数量的情况下，缺失的数量? */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> extra = nvars - nexps;	
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">hasmultret</span>(e-&gt;k)) {	<span style="color:#f00;font-style:italic">/* exp的类型为VARARG或CALL */</span>
</span></span><span style="display:flex;"><span>    extra++;  <span style="color:#f00;font-style:italic">/* includes call itself：除开VARARG和CALL本身 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 如果右边exp多了，那就不用补偿左边了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	** OP_VARARG A B R(A), R(A+1), ..., R(A+B-1) = vararg
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	** 看上面的指令的含义，猜测这里是在确定B的值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	*/</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (extra &lt; 0) extra = 0;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_setreturns</span>(fs, e, extra);  <span style="color:#f00;font-style:italic">/* last exp. provides the difference */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (extra &gt; 1) <span style="color:#c34e00">luaK_reserveregs</span>(fs, extra-1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (e-&gt;k != VVOID) <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, e);  <span style="color:#f00;font-style:italic">/* close last expression */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (extra &gt; 0) {	<span style="color:#f00;font-style:italic">/* nexps：包含右边最后一个exp */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> reg = fs-&gt;freereg;
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* 为左边多出来的var申请reg,然后填NIL */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_reserveregs</span>(fs, extra);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_nil</span>(fs, reg, extra);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 进入一个新的block */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">enterlevel</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (++ls-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS)
</span></span><span style="display:flex;"><span>	<span style="color:#c34e00">luaX_lexerror</span>(ls, <span style="color:#009c00">&#34;chunk has too many syntax levels&#34;</span>, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define leavelevel(ls)	((ls)-&gt;L-&gt;nCcalls--)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 进入块时，初始化block信息 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">enterblock</span> (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
</span></span><span style="display:flex;"><span>  bl-&gt;breaklist = NO_JUMP;
</span></span><span style="display:flex;"><span>  bl-&gt;isbreakable = isbreakable;
</span></span><span style="display:flex;"><span>  bl-&gt;nactvar = fs-&gt;nactvar;
</span></span><span style="display:flex;"><span>  bl-&gt;upval = 0;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里有个印象 */</span>
</span></span><span style="display:flex;"><span>  bl-&gt;previous = fs-&gt;bl;
</span></span><span style="display:flex;"><span>  fs-&gt;bl = bl;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(fs-&gt;freereg == fs-&gt;nactvar);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">leaveblock</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  BlockCnt *bl = fs-&gt;bl;
</span></span><span style="display:flex;"><span>  fs-&gt;bl = bl-&gt;previous;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 确定本block内激活的var的生存周期的endpc */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">removevars</span>(fs-&gt;ls, bl-&gt;nactvar);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* OP_CLOSE A close all variables in the stack up to (&gt;=) R(A) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (bl-&gt;upval) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* a block either controls scope or breaks (never both) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(!bl-&gt;isbreakable || !bl-&gt;upval);	<span style="color:#f00;font-style:italic">/* TODOLOOK 还不是太理解 */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(bl-&gt;nactvar == fs-&gt;nactvar);	<span style="color:#f00;font-style:italic">/* 这个必须保证 */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;freereg = fs-&gt;nactvar;  <span style="color:#f00;font-style:italic">/* free registers */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchtohere</span>(fs, bl-&gt;breaklist);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">pushclosure</span> (LexState *ls, FuncState *func, expdesc *v) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldsize = f-&gt;sizep;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_growvector</span>(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,
</span></span><span style="display:flex;"><span>                  MAXARG_Bx, <span style="color:#009c00">&#34;constant table overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;
</span></span><span style="display:flex;"><span>  f-&gt;p[fs-&gt;np++] = func-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaC_objbarrier</span>(ls-&gt;L, f, func-&gt;f);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(v, VRELOCABLE, <span style="color:#c34e00">luaK_codeABx</span>(fs, OP_CLOSURE, 0, fs-&gt;np-1));
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (i=0; i&lt;func-&gt;f-&gt;nups; i++) {
</span></span><span style="display:flex;"><span>    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;	<span style="color:#f00;font-style:italic">/* TODOLOOK 这里不是明白 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABC</span>(fs, o, 0, func-&gt;upvalues[i].info, 0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 开始编译函数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">open_func</span> (LexState *ls, FuncState *fs) {
</span></span><span style="display:flex;"><span>  lua_State *L = ls-&gt;L;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  fs-&gt;L = L;	
</span></span><span style="display:flex;"><span>  Proto *f = <span style="color:#c34e00">luaF_newproto</span>(L);
</span></span><span style="display:flex;"><span>  fs-&gt;ls = ls;
</span></span><span style="display:flex;"><span>  fs-&gt;f = f;	<span style="color:#f00;font-style:italic">/* funState 在编译哪个Proto */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* ls指向最新的一个FuncState,这里可以猜测，只有先编译完了子函数才有可能编译父函数 */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;prev = ls-&gt;fs;  <span style="color:#f00;font-style:italic">/* linked list of funcstates */</span>
</span></span><span style="display:flex;"><span>  ls-&gt;fs = fs;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  fs-&gt;pc = 0;
</span></span><span style="display:flex;"><span>  fs-&gt;lasttarget = -1;
</span></span><span style="display:flex;"><span>  fs-&gt;jpc = NO_JUMP;
</span></span><span style="display:flex;"><span>  fs-&gt;freereg = 0;
</span></span><span style="display:flex;"><span>  fs-&gt;nk = 0;
</span></span><span style="display:flex;"><span>  fs-&gt;np = 0;
</span></span><span style="display:flex;"><span>  fs-&gt;nlocvars = 0;
</span></span><span style="display:flex;"><span>  fs-&gt;nactvar = 0;
</span></span><span style="display:flex;"><span>  fs-&gt;bl = NULL;	<span style="color:#f00;font-style:italic">/* 这里是NULL */</span>
</span></span><span style="display:flex;"><span>  f-&gt;source = ls-&gt;source;
</span></span><span style="display:flex;"><span>  f-&gt;maxstacksize = 2;  <span style="color:#f00;font-style:italic">/* registers 0/1 are always valid */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;h = <span style="color:#c34e00">luaH_new</span>(L, 0, 0);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* anchor table of constants and prototype (to avoid being collected)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 常量和原型的锚表（避免被收集）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">sethvalue2s</span>(L, L-&gt;top, fs-&gt;h);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">incr_top</span>(L);	<span style="color:#f00;font-style:italic">/* 放到堆栈上可避免被gc,如果编译失败stack回缩，则可自动被gc（没有被其它obj引用的话 ） */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">setptvalue2s</span>(L, L-&gt;top, f);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">incr_top</span>(L);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">close_func</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  lua_State *L = ls-&gt;L;
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 关闭还处于激活状态的actvar(设置endpc) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">removevars</span>(ls, 0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 自动补一个 OP_RETURN 指令 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_ret</span>(fs, 0, 0);  <span style="color:#f00;font-style:italic">/* final return */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 释放多余的mem */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
</span></span><span style="display:flex;"><span>  f-&gt;sizecode = fs-&gt;pc;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, <span style="color:#00f">int</span>);
</span></span><span style="display:flex;"><span>  f-&gt;sizelineinfo = fs-&gt;pc;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TValue);
</span></span><span style="display:flex;"><span>  f-&gt;sizek = fs-&gt;nk;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, Proto *);
</span></span><span style="display:flex;"><span>  f-&gt;sizep = fs-&gt;np;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
</span></span><span style="display:flex;"><span>  f-&gt;sizelocvars = fs-&gt;nlocvars;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaM_reallocvector</span>(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, TString *);
</span></span><span style="display:flex;"><span>  f-&gt;sizeupvalues = f-&gt;nups;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">luaG_checkcode</span>(f));	<span style="color:#f00;font-style:italic">/* 检查生成的字节码是否有明显的问题 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(fs-&gt;bl == NULL);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 本子函数编译完毕，切换到母函数中去 */</span>
</span></span><span style="display:flex;"><span>  ls-&gt;fs = fs-&gt;prev;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* last token read was anchored(锚定) in defunct function; must reanchor(锚) it */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (fs) <span style="color:#c34e00">anchor_token</span>(ls);
</span></span><span style="display:flex;"><span>  L-&gt;top -= 2;  <span style="color:#f00;font-style:italic">/* remove table and prototype from the stack */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Proto *<span style="color:#c34e00">luaY_parser</span> (lua_State *L, ZIO *z, Mbuffer *buff, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *name) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> LexState lexstate;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> FuncState funcstate;	<span style="color:#f00;font-style:italic">/* mainFunc */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  lexstate.buff = buff;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 设置input信息，但，buff在上面就设置了，有点意思吧，z和buff对于lexState是有点不同的 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_setinput</span>(L, &amp;lexstate, z, <span style="color:#c34e00">luaS_new</span>(L, name));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 一个lua文件，编译模块将其当做一个函数来看待
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 函数原型 function (...)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **          end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** BNF funcbody ::= `(´ [parlist] `)´ block end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">open_func</span>(&amp;lexstate, &amp;funcstate);
</span></span><span style="display:flex;"><span>  funcstate.f-&gt;is_vararg = VARARG_ISVARARG;  <span style="color:#f00;font-style:italic">/* main func. is always vararg，哈哈知道lua文件一般开头的local modName=...的语法支撑了吧 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(&amp;lexstate);  <span style="color:#f00;font-style:italic">/* read first token */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">chunk</span>(&amp;lexstate);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check</span>(&amp;lexstate, TK_EOS);	<span style="color:#f00;font-style:italic">/* 直到编译到文件EOF才结束编译流程 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">close_func</span>(&amp;lexstate);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(lexstate.fs == NULL);		<span style="color:#f00;font-style:italic">/* lexstate下不应该还有未编译完的funState了 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(funcstate.prev == NULL);	<span style="color:#f00;font-style:italic">/* 已编译完的主函数上面还有其它函数，不可能的嘛 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(funcstate.f-&gt;nups == 0);	<span style="color:#f00;font-style:italic">/* 编译结束，主函数不应该有nups了 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> funcstate.f;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*============================================================*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* GRAMMAR RULES */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*============================================================*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* A.B, A:B 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 对前缀生成必要的估值指令，放入free&#39;reg(若有必要)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 用上述值作为A,再和B一起生成新的VINDEXED表达式
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">field</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* field -&gt; [&#39;.&#39; | &#39;:&#39;] NAME */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  expdesc key;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **将前缀(a.b.c中的a.b)加载到reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **若前缀已在寄存器中则无需处理(A=VLOCAL(a))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, v);	
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls); 		<span style="color:#f00;font-style:italic">/* skip the dot or colon */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checkname</span>(ls, &amp;key);	<span style="color:#f00;font-style:italic">/* 读取NAME这个域的常量exp并返回给key */</span>		
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 生成新的VINDEXED表达式（求值指令，指令的目标寄存器尚未处理） */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_indexed</span>(fs, v, &amp;key);	
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">yindex</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* index -&gt; &#39;[&#39; expr &#39;]&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip the &#39;[&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">expr</span>(ls, v);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2val</span>(ls-&gt;fs, v);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;]&#39;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** {======================================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Rules for Constructors
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** =======================================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 构造表   tbl {a, b, c=val, d.e} */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> ConsControl {
</span></span><span style="display:flex;"><span>  expdesc *t;  <span style="color:#f00;font-style:italic">/* table descriptor 指代本表的expdesc */</span>
</span></span><span style="display:flex;"><span>  expdesc v;  <span style="color:#f00;font-style:italic">/* last list item read: 指代正在分析到的哪一个元素eg(b),对于c=val用不上v */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nh;  <span style="color:#f00;font-style:italic">/* total number of `record&#39; elements */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> na;  <span style="color:#f00;font-style:italic">/* total number of array elements */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> tostore;  <span style="color:#f00;font-style:italic">/* number of array elements pending to be stored */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 形如 local tbl = { x = y, [a] = b,}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 中的x=1,这种指定tbl[k]=v的表达式
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">recfield</span> (LexState *ls, <span style="color:#00f">struct</span> ConsControl *cc) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* recfield -&gt; (NAME | `[&#39;exp1`]&#39;) = exp1 */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> reg = ls-&gt;fs-&gt;freereg;
</span></span><span style="display:flex;"><span>  expdesc key, val;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> rkkey;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 对key生成加载指令 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token == TK_NAME) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaY_checklimit</span>(fs, cc-&gt;nh, MAX_INT, <span style="color:#009c00">&#34;items in a constructor&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">checkname</span>(ls, &amp;key);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>  <span style="color:#f00;font-style:italic">/* ls-&gt;t.token == &#39;[&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">yindex</span>(ls, &amp;key);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  cc-&gt;nh++;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;=&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 回填上述k的加载指令,将表达式的值SET到next&#39;free&#39;reg上 */</span>
</span></span><span style="display:flex;"><span>  rkkey = <span style="color:#c34e00">luaK_exp2RK</span>(fs, &amp;key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 初始化表达式val */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">expr</span>(ls, &amp;val);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 先生成对val的LOAD_XXX加载指令，后生成OP_SETTABLE */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_SETTABLE, cc-&gt;t-&gt;u.s.info, rkkey, <span style="color:#c34e00">luaK_exp2RK</span>(fs, &amp;val));
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  fs-&gt;freereg = reg;  <span style="color:#f00;font-style:italic">/* free registers 释放表达式占用的临时寄存器 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* local tbl = {a,b,c,d}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 解析完毕b,关闭对b的解析
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">closelistfield</span> (FuncState *fs, <span style="color:#00f">struct</span> ConsControl *cc) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (cc-&gt;v.k == VVOID) <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* there is no list item */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, &amp;cc-&gt;v);
</span></span><span style="display:flex;"><span>  cc-&gt;v.k = VVOID;	<span style="color:#f00;font-style:italic">/* 释放表达式 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (cc-&gt;tostore == LFIELDS_PER_FLUSH) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_setlist</span>(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);  <span style="color:#f00;font-style:italic">/* flush */</span>
</span></span><span style="display:flex;"><span>    cc-&gt;tostore = 0;  <span style="color:#f00;font-style:italic">/* no more items pending */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* local tbl = {a, b, c, d}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 结束d的解析后，调到这里 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 逻辑独立出来是因为函数调用作为表的最后一个元素和非最后一个元素，其期望对其返回值的个数是不一样的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">lastlistfield</span> (FuncState *fs, <span style="color:#00f">struct</span> ConsControl *cc) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (cc-&gt;tostore == 0) <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">hasmultret</span>(cc-&gt;v.k)) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_setmultret</span>(fs, &amp;cc-&gt;v);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_setlist</span>(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, LUA_MULTRET);
</span></span><span style="display:flex;"><span>    cc-&gt;na--;  <span style="color:#f00;font-style:italic">/* do not count last expression (unknown number of elements) */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (cc-&gt;v.k != VVOID)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, &amp;cc-&gt;v);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_setlist</span>(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* tbl = {a,b, c = 100} 数组中单个field eg:a
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">listfield</span> (LexState *ls, <span style="color:#00f">struct</span> ConsControl *cc) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">expr</span>(ls, &amp;cc-&gt;v);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaY_checklimit</span>(ls-&gt;fs, cc-&gt;na, MAX_INT, <span style="color:#009c00">&#34;items in a constructor&#34;</span>);
</span></span><span style="display:flex;"><span>  cc-&gt;na++;
</span></span><span style="display:flex;"><span>  cc-&gt;tostore++;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">constructor</span> (LexState *ls, expdesc *t) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* constructor -&gt; ?? */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> line = ls-&gt;linenumber;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> pc = <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_NEWTABLE, 0, 0, 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> ConsControl cc;
</span></span><span style="display:flex;"><span>  cc.na = cc.nh = cc.tostore = 0;
</span></span><span style="display:flex;"><span>  cc.t = t;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 初始化table的exp */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(t, VRELOCABLE, pc);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(&amp;cc.v, VVOID, 0);  <span style="color:#f00;font-style:italic">/* no value (yet) */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2nextreg</span>(ls-&gt;fs, t);  <span style="color:#f00;font-style:italic">/* fix it at stack top (for gc) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;{&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(cc.v.k == VVOID || cc.tostore &gt; 0);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;}&#39;</span>) <span style="color:#00f">break</span>;	<span style="color:#f00;font-style:italic">/* 表被遍历完毕 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">closelistfield</span>(fs, &amp;cc);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span>(ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> TK_NAME: {  <span style="color:#f00;font-style:italic">/* may be listfields or recfields */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaX_lookahead</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (ls-&gt;lookahead.token != <span style="color:#009c00">&#39;=&#39;</span>)  <span style="color:#f00;font-style:italic">/* expression? */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">listfield</span>(ls, &amp;cc);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">recfield</span>(ls, &amp;cc);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;[&#39;</span>: {  <span style="color:#f00;font-style:italic">/* constructor_item -&gt; recfield */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">recfield</span>(ls, &amp;cc);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">default</span>: {  <span style="color:#f00;font-style:italic">/* constructor_part -&gt; listfield */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">listfield</span>(ls, &amp;cc);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">while</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>) || <span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;;&#39;</span>));
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_match</span>(ls, <span style="color:#009c00">&#39;}&#39;</span>, <span style="color:#009c00">&#39;{&#39;</span>, line);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lastlistfield</span>(fs, &amp;cc);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">SETARG_B</span>(fs-&gt;f-&gt;code[pc], <span style="color:#c34e00">luaO_int2fb</span>(cc.na)); <span style="color:#f00;font-style:italic">/* set initial array size */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">SETARG_C</span>(fs-&gt;f-&gt;code[pc], <span style="color:#c34e00">luaO_int2fb</span>(cc.nh));  <span style="color:#f00;font-style:italic">/* set initial table size */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* }====================================================================== */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 解析函数的显式形参列表（对于modName:sub(x,y) 这种隐含的第一个self参数，在外面已被解析完毕
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">parlist</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* parlist -&gt; [ param { `,&#39; param } ] */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nparams = 0;
</span></span><span style="display:flex;"><span>  f-&gt;is_vararg = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token != <span style="color:#009c00">&#39;)&#39;</span>) {  <span style="color:#f00;font-style:italic">/* is `parlist&#39; not empty? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">do</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> TK_NAME: {  <span style="color:#f00;font-style:italic">/* param -&gt; NAME */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">new_localvar</span>(ls, <span style="color:#c34e00">str_checkname</span>(ls), nparams++);
</span></span><span style="display:flex;"><span>		  <span style="color:#f00;font-style:italic">/* adjustlocalvars 在下面调用：一次性调整到位 */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">case</span> TK_DOTS: {  <span style="color:#f00;font-style:italic">/* param -&gt; `...&#39; */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#if defined(LUA_COMPAT_VARARG)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#f00;font-style:italic">/* use `arg&#39; as default name */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;arg&#34;</span>, nparams++);
</span></span><span style="display:flex;"><span>          f-&gt;is_vararg = VARARG_HASARG | VARARG_NEEDSARG;
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          f-&gt;is_vararg |= VARARG_ISVARARG;
</span></span><span style="display:flex;"><span>          <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">default</span>: <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#009c00">&#34;&lt;name&gt; or &#34;</span> <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;...&#34;</span>) <span style="color:#009c00">&#34; expected&#34;</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#00f">while</span> (!f-&gt;is_vararg &amp;&amp; <span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>));	<span style="color:#f00;font-style:italic">/* 这里看得出来 ... 只能是最后一个形参 */</span>
</span></span><span style="display:flex;"><span>  }<span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">// function name() body end 显式形参为空
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjustlocalvars</span>(ls, nparams);
</span></span><span style="display:flex;"><span>  f-&gt;numparams = <span style="color:#c34e00">cast_byte</span>(fs-&gt;nactvar - (f-&gt;is_vararg &amp; VARARG_HASARG));
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_reserveregs</span>(fs, fs-&gt;nactvar);  <span style="color:#f00;font-style:italic">/* reserve register for parameters */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 解析函数形参和函数体 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">body</span> (LexState *ls, expdesc *e, <span style="color:#00f">int</span> needself, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* body -&gt;  `(&#39; parlist `)&#39; chunk END */</span>
</span></span><span style="display:flex;"><span>  FuncState new_fs;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新ls中的fs变量，完成编译对象的切换 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">open_func</span>(ls, &amp;new_fs);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 新函数从哪一方开始定义 */</span>
</span></span><span style="display:flex;"><span>  new_fs.f-&gt;linedefined = line;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* local name = function () 或者 local function name() 这两种函数定义格式对应的函数都是从‘(’开始，*/</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;(&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里看得出来self将是本fs的第一个locvar，占用一个正常的locvar
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** Proto.numparams 中也包含self
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (needself) {	<span style="color:#f00;font-style:italic">/* 处理 function modName:sub() body end 这种情况，参考funcname()代码可知 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;self&#34;</span>, 0);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">adjustlocalvars</span>(ls, 1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 解析显式形参 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">parlist</span>(ls);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;)&#39;</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">chunk</span>(ls);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 函数定义结束于哪一行 */</span>
</span></span><span style="display:flex;"><span>  new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_match</span>(ls, TK_END, TK_FUNCTION, line);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">close_func</span>(ls);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">pushclosure</span>(ls, &amp;new_fs, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 解析表达式，返回表达式中的项的数量 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">explist1</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* explist1 -&gt; expr { `,&#39; expr } */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> n = 1;  <span style="color:#f00;font-style:italic">/* at least one expression */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">expr</span>(ls, v);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_exp2nextreg</span>(ls-&gt;fs, v);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">expr</span>(ls, v);
</span></span><span style="display:flex;"><span>    n++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> n;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* funcargs -&gt; `(&#39; [ explist1 ] `)&#39; | constructor | STRING */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">funcargs</span> (LexState *ls, expdesc *f) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  expdesc args;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> base, nparams;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> line = ls-&gt;linenumber;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;(&#39;</span>: {  <span style="color:#f00;font-style:italic">/* funcargs -&gt; `(&#39; [ explist1 ] `)&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (line != ls-&gt;lastline)
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaX_syntaxerror</span>(ls,<span style="color:#009c00">&#34;ambiguous syntax (function call x new statement)&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;)&#39;</span>)  <span style="color:#f00;font-style:italic">/* arg list is empty? */</span>
</span></span><span style="display:flex;"><span>        args.k = VVOID;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">explist1</span>(ls, &amp;args);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_setmultret</span>(fs, &amp;args);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">check_match</span>(ls, <span style="color:#009c00">&#39;)&#39;</span>, <span style="color:#009c00">&#39;(&#39;</span>, line);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;{&#39;</span>: {  <span style="color:#f00;font-style:italic">/* funcargs -&gt; constructor */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">constructor</span>(ls, &amp;args);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_STRING: {  <span style="color:#f00;font-style:italic">/* funcargs -&gt; STRING */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">codestring</span>(ls, &amp;args, ls-&gt;t.seminfo.ts);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* must use `seminfo&#39; before `next&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#009c00">&#34;function arguments expected&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(f-&gt;k == VNONRELOC);
</span></span><span style="display:flex;"><span>  base = f-&gt;u.s.info;  <span style="color:#f00;font-style:italic">/* base register for call */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">hasmultret</span>(args.k))
</span></span><span style="display:flex;"><span>    nparams = LUA_MULTRET;  <span style="color:#f00;font-style:italic">/* open call */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (args.k != VVOID)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, &amp;args);  <span style="color:#f00;font-style:italic">/* close last argument */</span>
</span></span><span style="display:flex;"><span>    nparams = fs-&gt;freereg - (base+1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(f, VCALL, <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_CALL, base, nparams+1, 2));
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_fixline</span>(fs, line);
</span></span><span style="display:flex;"><span>  fs-&gt;freereg = base+1;  <span style="color:#f00;font-style:italic">/* call remove function and arguments and leaves
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">                            (unless changed) one result */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** {======================================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Expression parsing
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** =======================================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">prefixexp</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* prefixexp -&gt; NAME | &#39;(&#39; expr &#39;)&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;(&#39;</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> line = ls-&gt;linenumber;
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">expr</span>(ls, v);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">check_match</span>(ls, <span style="color:#009c00">&#39;)&#39;</span>, <span style="color:#009c00">&#39;(&#39;</span>, line);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_dischargevars</span>(ls-&gt;fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NAME: {
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/* 确定当前ls-&gt;t.token的变量类型(VLOCAL,VGLOBAL还是VUPVAL？)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      **     填充expdesc.u.s.info信息
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      ** 读取下一个Token
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">singlevar</span>(ls, v); 
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#009c00">&#34;unexpected symbol&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* primary：基本的 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">primaryexp</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* primaryexp -&gt; prefixexp { `.&#39; NAME | `[&#39; exp `]&#39; | `:&#39; NAME funcargs | funcargs } */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">prefixexp</span>(ls, v);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;.&#39;</span>: {  <span style="color:#f00;font-style:italic">/* field */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">field</span>(ls, v);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;[&#39;</span>: {  <span style="color:#f00;font-style:italic">/* `[&#39; exp1 `]&#39; */</span>
</span></span><span style="display:flex;"><span>        expdesc key;
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, v);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">yindex</span>(ls, &amp;key);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_indexed</span>(fs, v, &amp;key);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;:&#39;</span>: {  <span style="color:#f00;font-style:italic">/* `:&#39; NAME funcargs */</span>
</span></span><span style="display:flex;"><span>        expdesc key;
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">checkname</span>(ls, &amp;key);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_self</span>(fs, v, &amp;key);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">funcargs</span>(ls, v);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;(&#39;</span>: <span style="color:#00f">case</span> TK_STRING: <span style="color:#00f">case</span> <span style="color:#009c00">&#39;{&#39;</span>: {  <span style="color:#f00;font-style:italic">/* funcargs 函数调用 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, v);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">funcargs</span>(ls, v);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">default</span>: <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 对表达式进行初始化，间接表达式则生成求src.val的指令, 等待回填dst.reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">simpleexp</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">                  constructor | FUNCTION body | primaryexp */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NUMBER: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">init_exp</span>(v, VKNUM, 0);
</span></span><span style="display:flex;"><span>      v-&gt;u.nval = ls-&gt;t.seminfo.r;	<span style="color:#f00;font-style:italic">/* 直接赋值NUMBER */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_STRING: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">codestring</span>(ls, v, ls-&gt;t.seminfo.ts);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NIL: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">init_exp</span>(v, VNIL, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_TRUE: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">init_exp</span>(v, VTRUE, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_FALSE: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">init_exp</span>(v, VFALSE, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_DOTS: {  <span style="color:#f00;font-style:italic">/* vararg */</span>
</span></span><span style="display:flex;"><span>      FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">check_condition</span>(ls, fs-&gt;f-&gt;is_vararg,
</span></span><span style="display:flex;"><span>                      <span style="color:#009c00">&#34;cannot use &#34;</span> <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;...&#34;</span>) <span style="color:#009c00">&#34; outside a vararg function&#34;</span>);
</span></span><span style="display:flex;"><span>      fs-&gt;f-&gt;is_vararg &amp;= ~VARARG_NEEDSARG;  <span style="color:#f00;font-style:italic">/* don&#39;t need &#39;arg&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">init_exp</span>(v, VVARARG, <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_VARARG, 0, 1, 0));
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;{&#39;</span>: {  <span style="color:#f00;font-style:italic">/* constructor */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">constructor</span>(ls, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_FUNCTION: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">body</span>(ls, v, 0, ls-&gt;linenumber);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">primaryexp</span>(ls, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 返回TK可能的一元操作符TK */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> UnOpr <span style="color:#c34e00">getunopr</span> (<span style="color:#00f">int</span> op) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NOT: <span style="color:#00f">return</span> OPR_NOT;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;-&#39;</span>: <span style="color:#00f">return</span> OPR_MINUS;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;#&#39;</span>: <span style="color:#00f">return</span> OPR_LEN;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> OPR_NOUNOPR;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> BinOpr <span style="color:#c34e00">getbinopr</span> (<span style="color:#00f">int</span> op) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;+&#39;</span>: <span style="color:#00f">return</span> OPR_ADD;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;-&#39;</span>: <span style="color:#00f">return</span> OPR_SUB;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;*&#39;</span>: <span style="color:#00f">return</span> OPR_MUL;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;/&#39;</span>: <span style="color:#00f">return</span> OPR_DIV;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;%&#39;</span>: <span style="color:#00f">return</span> OPR_MOD;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;^&#39;</span>: <span style="color:#00f">return</span> OPR_POW;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_CONCAT: <span style="color:#00f">return</span> OPR_CONCAT;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_NE: <span style="color:#00f">return</span> OPR_NE;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_EQ: <span style="color:#00f">return</span> OPR_EQ;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&lt;&#39;</span>: <span style="color:#00f">return</span> OPR_LT;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_LE: <span style="color:#00f">return</span> OPR_LE;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&gt;&#39;</span>: <span style="color:#00f">return</span> OPR_GT;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_GE: <span style="color:#00f">return</span> OPR_GE;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_AND: <span style="color:#00f">return</span> OPR_AND;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_OR: <span style="color:#00f">return</span> OPR_OR;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> OPR_NOBINOPR;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 操作符的优先级分左右：用于处理结合性？ */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">const</span> <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>  lu_byte left;  <span style="color:#f00;font-style:italic">/* left priority for each binary operator */</span>
</span></span><span style="display:flex;"><span>  lu_byte right; <span style="color:#f00;font-style:italic">/* right priority */</span>
</span></span><span style="display:flex;"><span>} priority[] = {  <span style="color:#f00;font-style:italic">/* ORDER OPR */</span>
</span></span><span style="display:flex;"><span>   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  <span style="color:#f00;font-style:italic">/* `+&#39; `-&#39; `/&#39; `%&#39; */</span>
</span></span><span style="display:flex;"><span>   {10, 9}, {5, 4},                 <span style="color:#f00;font-style:italic">/* power and concat (right associative) */</span>
</span></span><span style="display:flex;"><span>   {3, 3}, {3, 3},                  <span style="color:#f00;font-style:italic">/* equality and inequality */</span>
</span></span><span style="display:flex;"><span>   {3, 3}, {3, 3}, {3, 3}, {3, 3},  <span style="color:#f00;font-style:italic">/* order */</span>
</span></span><span style="display:flex;"><span>   {2, 2}, {1, 1}                   <span style="color:#f00;font-style:italic">/* logical (and/or) */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define UNARY_PRIORITY	8  </span><span style="color:#f00;font-style:italic">/* priority for unary operators,一元操作符的优先级？ */</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** subexpr -&gt; (simpleexp | unop subexpr) { binop subexpr }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** where `binop&#39; is any binary operator with a priority higher than `limit&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 操作符表达式
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> BinOpr <span style="color:#c34e00">subexpr</span> (LexState *ls, expdesc *v, <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> limit) {
</span></span><span style="display:flex;"><span>  BinOpr op;
</span></span><span style="display:flex;"><span>  UnOpr uop;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterlevel</span>(ls);
</span></span><span style="display:flex;"><span>  uop = <span style="color:#c34e00">getunopr</span>(ls-&gt;t.token);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (uop != OPR_NOUNOPR) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">subexpr</span>(ls, v, UNARY_PRIORITY);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_prefix</span>(ls-&gt;fs, uop, v);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#c34e00">simpleexp</span>(ls, v);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* expand while operators have priorities higher than `limit&#39; */</span>
</span></span><span style="display:flex;"><span>  op = <span style="color:#c34e00">getbinopr</span>(ls-&gt;t.token);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (op != OPR_NOBINOPR &amp;&amp; priority[op].left &gt; limit) {
</span></span><span style="display:flex;"><span>    expdesc v2;
</span></span><span style="display:flex;"><span>    BinOpr nextop;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_next</span>(ls);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_infix</span>(ls-&gt;fs, op, v);
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* read sub-expression with higher priority */</span>
</span></span><span style="display:flex;"><span>    nextop = <span style="color:#c34e00">subexpr</span>(ls, &amp;v2, priority[op].right);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_posfix</span>(ls-&gt;fs, op, v, &amp;v2);
</span></span><span style="display:flex;"><span>    op = nextop;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leavelevel</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> op;  <span style="color:#f00;font-style:italic">/* return first untreated operator */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">expr</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">subexpr</span>(ls, v, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* }==================================================================== */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** {======================================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Rules for Statements
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** =======================================================================
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* repeat
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**   statements
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** until( condition )
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">block_follow</span> (<span style="color:#00f">int</span> token) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (token) {	<span style="color:#f00;font-style:italic">/* END和EOS还没理解 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_ELSE: <span style="color:#00f">case</span> TK_ELSEIF: <span style="color:#00f">case</span> TK_END:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_UNTIL: <span style="color:#00f">case</span> TK_EOS:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">block</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* block -&gt; chunk */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  BlockCnt bl;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterblock</span>(fs, &amp;bl, 0);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">chunk</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">lua_assert</span>(bl.breaklist == NO_JUMP);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leaveblock</span>(fs);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** structure to chain all variables in the left-hand side of an
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** assignment
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> LHS_assign {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> LHS_assign *prev;
</span></span><span style="display:flex;"><span>  expdesc v;  <span style="color:#f00;font-style:italic">/* variable (global, local, upvalue, or indexed) */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** check whether, in an assignment to a local variable, the local variable
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** is needed in a previous assignment (to a table). If so, save original
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** local value in a safe place and use this safe copy in the previous
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** assignment.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">check_conflict</span> (LexState *ls, <span style="color:#00f">struct</span> LHS_assign *lh, expdesc *v) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> extra = fs-&gt;freereg;  <span style="color:#f00;font-style:italic">/* eventual position to save local variable */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> conflict = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; lh; lh = lh-&gt;prev) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (lh-&gt;v.k == VINDEXED) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (lh-&gt;v.u.s.info == v-&gt;u.s.info) {  <span style="color:#f00;font-style:italic">/* conflict? */</span>
</span></span><span style="display:flex;"><span>        conflict = 1;
</span></span><span style="display:flex;"><span>        lh-&gt;v.u.s.info = extra;  <span style="color:#f00;font-style:italic">/* previous assignment will use safe copy */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (lh-&gt;v.u.s.aux == v-&gt;u.s.info) {  <span style="color:#f00;font-style:italic">/* conflict? */</span>
</span></span><span style="display:flex;"><span>        conflict = 1;
</span></span><span style="display:flex;"><span>        lh-&gt;v.u.s.aux = extra;  <span style="color:#f00;font-style:italic">/* previous assignment will use safe copy */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (conflict) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_MOVE, fs-&gt;freereg, v-&gt;u.s.info, 0);  <span style="color:#f00;font-style:italic">/* make copy */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_reserveregs</span>(fs, 1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">assignment</span> (LexState *ls, <span style="color:#00f">struct</span> LHS_assign *lh, <span style="color:#00f">int</span> nvars) {
</span></span><span style="display:flex;"><span>  expdesc e;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_condition</span>(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
</span></span><span style="display:flex;"><span>                      <span style="color:#009c00">&#34;syntax error&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>)) {  <span style="color:#f00;font-style:italic">/* assignment -&gt; `,&#39; primaryexp assignment */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">struct</span> LHS_assign nv;
</span></span><span style="display:flex;"><span>    nv.prev = lh;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">primaryexp</span>(ls, &amp;nv.v);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (nv.v.k == VLOCAL)
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">check_conflict</span>(ls, lh, &amp;nv.v);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaY_checklimit</span>(ls-&gt;fs, nvars, LUAI_MAXCCALLS - ls-&gt;L-&gt;nCcalls,
</span></span><span style="display:flex;"><span>                    <span style="color:#009c00">&#34;variables in assignment&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">assignment</span>(ls, &amp;nv, nvars+1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* assignment -&gt; `=&#39; explist1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> nexps;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;=&#39;</span>);
</span></span><span style="display:flex;"><span>    nexps = <span style="color:#c34e00">explist1</span>(ls, &amp;e);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (nexps != nvars) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">adjust_assign</span>(ls, nvars, nexps, &amp;e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (nexps &gt; nvars)
</span></span><span style="display:flex;"><span>        ls-&gt;fs-&gt;freereg -= nexps - nvars;  <span style="color:#f00;font-style:italic">/* remove extra values */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_setoneret</span>(ls-&gt;fs, &amp;e);  <span style="color:#f00;font-style:italic">/* close last expression */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_storevar</span>(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* avoid default */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  <span style="color:#f00;font-style:italic">/* default assignment */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_storevar</span>(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">cond</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* cond -&gt; exp */</span>
</span></span><span style="display:flex;"><span>  expdesc v;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">expr</span>(ls, &amp;v);  <span style="color:#f00;font-style:italic">/* read condition */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (v.k == VNIL) v.k = VFALSE;  <span style="color:#f00;font-style:italic">/* `falses&#39; are all equal here */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_goiftrue</span>(ls-&gt;fs, &amp;v);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> v.f;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">breakstat</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  BlockCnt *bl = fs-&gt;bl;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> upval = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (bl &amp;&amp; !bl-&gt;isbreakable) {
</span></span><span style="display:flex;"><span>    upval |= bl-&gt;upval;
</span></span><span style="display:flex;"><span>    bl = bl-&gt;previous;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!bl)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#009c00">&#34;no loop to break&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (upval)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_concat</span>(fs, &amp;bl-&gt;breaklist, <span style="color:#c34e00">luaK_jump</span>(fs));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">whilestat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* whilestat -&gt; WHILE cond DO block END */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> whileinit;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> condexit;
</span></span><span style="display:flex;"><span>  BlockCnt bl;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip WHILE */</span>
</span></span><span style="display:flex;"><span>  whileinit = <span style="color:#c34e00">luaK_getlabel</span>(fs);
</span></span><span style="display:flex;"><span>  condexit = <span style="color:#c34e00">cond</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterblock</span>(fs, &amp;bl, 1);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, TK_DO);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">block</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchlist</span>(fs, <span style="color:#c34e00">luaK_jump</span>(fs), whileinit);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_match</span>(ls, TK_END, TK_WHILE, line);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leaveblock</span>(fs);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchtohere</span>(fs, condexit);  <span style="color:#f00;font-style:italic">/* false conditions finish the loop */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">repeatstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* repeatstat -&gt; REPEAT block UNTIL cond */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> condexit;
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> repeat_init = <span style="color:#c34e00">luaK_getlabel</span>(fs);
</span></span><span style="display:flex;"><span>  BlockCnt bl1, bl2;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterblock</span>(fs, &amp;bl1, 1);  <span style="color:#f00;font-style:italic">/* loop block */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterblock</span>(fs, &amp;bl2, 0);  <span style="color:#f00;font-style:italic">/* scope block */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip REPEAT */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">chunk</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_match</span>(ls, TK_UNTIL, TK_REPEAT, line);
</span></span><span style="display:flex;"><span>  condexit = <span style="color:#c34e00">cond</span>(ls);  <span style="color:#f00;font-style:italic">/* read condition (inside scope block) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!bl2.upval) {  <span style="color:#f00;font-style:italic">/* no upvalues? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">leaveblock</span>(fs);  <span style="color:#f00;font-style:italic">/* finish scope */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_patchlist</span>(ls-&gt;fs, condexit, repeat_init);  <span style="color:#f00;font-style:italic">/* close the loop */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* complete semantics when there are upvalues */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">breakstat</span>(ls);  <span style="color:#f00;font-style:italic">/* if condition then break */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_patchtohere</span>(ls-&gt;fs, condexit);  <span style="color:#f00;font-style:italic">/* else... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">leaveblock</span>(fs);  <span style="color:#f00;font-style:italic">/* finish scope... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_patchlist</span>(ls-&gt;fs, <span style="color:#c34e00">luaK_jump</span>(fs), repeat_init);  <span style="color:#f00;font-style:italic">/* and repeat */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leaveblock</span>(fs);  <span style="color:#f00;font-style:italic">/* finish loop */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">exp1</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  expdesc e;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> k;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">expr</span>(ls, &amp;e);
</span></span><span style="display:flex;"><span>  k = e.k;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_exp2nextreg</span>(ls-&gt;fs, &amp;e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> k;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">forbody</span> (LexState *ls, <span style="color:#00f">int</span> base, <span style="color:#00f">int</span> line, <span style="color:#00f">int</span> nvars, <span style="color:#00f">int</span> isnum) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* forbody -&gt; DO block */</span>
</span></span><span style="display:flex;"><span>  BlockCnt bl;
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> prep, endfor;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjustlocalvars</span>(ls, 3);  <span style="color:#f00;font-style:italic">/* control variables */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, TK_DO);
</span></span><span style="display:flex;"><span>  prep = isnum ? <span style="color:#c34e00">luaK_codeAsBx</span>(fs, OP_FORPREP, base, NO_JUMP) : <span style="color:#c34e00">luaK_jump</span>(fs);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterblock</span>(fs, &amp;bl, 0);  <span style="color:#f00;font-style:italic">/* scope for declared variables */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjustlocalvars</span>(ls, nvars);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_reserveregs</span>(fs, nvars);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">block</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leaveblock</span>(fs);  <span style="color:#f00;font-style:italic">/* end of scope for declared variables */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchtohere</span>(fs, prep);
</span></span><span style="display:flex;"><span>  endfor = (isnum) ? <span style="color:#c34e00">luaK_codeAsBx</span>(fs, OP_FORLOOP, base, NO_JUMP) :
</span></span><span style="display:flex;"><span>                     <span style="color:#c34e00">luaK_codeABC</span>(fs, OP_TFORLOOP, base, 0, nvars);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_fixline</span>(fs, line);  <span style="color:#f00;font-style:italic">/* pretend that `OP_FOR&#39; starts the loop */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchlist</span>(fs, (isnum ? endfor : <span style="color:#c34e00">luaK_jump</span>(fs)), prep + 1);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">fornum</span> (LexState *ls, TString *varname, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* fornum -&gt; NAME = exp1,exp1[,exp1] forbody */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> base = fs-&gt;freereg;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;(for index)&#34;</span>, 0);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;(for limit)&#34;</span>, 1);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;(for step)&#34;</span>, 2);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvar</span>(ls, varname, 3);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;=&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">exp1</span>(ls);  <span style="color:#f00;font-style:italic">/* initial value */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">exp1</span>(ls);  <span style="color:#f00;font-style:italic">/* limit */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">exp1</span>(ls);  <span style="color:#f00;font-style:italic">/* optional step */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* default step = 1 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_codeABx</span>(fs, OP_LOADK, fs-&gt;freereg, <span style="color:#c34e00">luaK_numberK</span>(fs, 1));
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_reserveregs</span>(fs, 1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">forbody</span>(ls, base, line, 1, 1);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">forlist</span> (LexState *ls, TString *indexname) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* forlist -&gt; NAME {,NAME} IN explist1 forbody */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  expdesc e;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nvars = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> line;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> base = fs-&gt;freereg;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* create control variables */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;(for generator)&#34;</span>, nvars++);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;(for state)&#34;</span>, nvars++);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvarliteral</span>(ls, <span style="color:#009c00">&#34;(for control)&#34;</span>, nvars++);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* create declared variables */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvar</span>(ls, indexname, nvars++);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">new_localvar</span>(ls, <span style="color:#c34e00">str_checkname</span>(ls), nvars++);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, TK_IN);
</span></span><span style="display:flex;"><span>  line = ls-&gt;linenumber;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjust_assign</span>(ls, 3, <span style="color:#c34e00">explist1</span>(ls, &amp;e), &amp;e);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_checkstack</span>(fs, 3);  <span style="color:#f00;font-style:italic">/* extra space to call generator */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">forbody</span>(ls, base, line, nvars - 3, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">forstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* forstat -&gt; FOR (fornum | forlist) END */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  TString *varname;
</span></span><span style="display:flex;"><span>  BlockCnt bl;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterblock</span>(fs, &amp;bl, 1);  <span style="color:#f00;font-style:italic">/* scope for loop and control variables */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip `for&#39; */</span>
</span></span><span style="display:flex;"><span>  varname = <span style="color:#c34e00">str_checkname</span>(ls);  <span style="color:#f00;font-style:italic">/* first variable name */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;=&#39;</span>: <span style="color:#c34e00">fornum</span>(ls, varname, line); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;,&#39;</span>: <span style="color:#00f">case</span> TK_IN: <span style="color:#c34e00">forlist</span>(ls, varname); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#c34e00">luaX_syntaxerror</span>(ls, <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;=&#34;</span>) <span style="color:#009c00">&#34; or &#34;</span> <span style="color:#c34e00">LUA_QL</span>(<span style="color:#009c00">&#34;in&#34;</span>) <span style="color:#009c00">&#34; expected&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_match</span>(ls, TK_END, TK_FOR, line);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leaveblock</span>(fs);  <span style="color:#f00;font-style:italic">/* loop scope (`break&#39; jumps to this point) */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">test_then_block</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* test_then_block -&gt; [IF | ELSEIF] cond THEN block */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> condexit;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip IF or ELSEIF */</span>
</span></span><span style="display:flex;"><span>  condexit = <span style="color:#c34e00">cond</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">checknext</span>(ls, TK_THEN);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">block</span>(ls);  <span style="color:#f00;font-style:italic">/* `then&#39; part */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> condexit;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">ifstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> flist;	<span style="color:#f00;font-style:italic">/* false&#39;list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> escapelist = NO_JUMP;	<span style="color:#f00;font-style:italic">/* 块结束的addr */</span>
</span></span><span style="display:flex;"><span>  flist = <span style="color:#c34e00">test_then_block</span>(ls);  <span style="color:#f00;font-style:italic">/* IF cond THEN block */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (ls-&gt;t.token == TK_ELSEIF) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_concat</span>(fs, &amp;escapelist, <span style="color:#c34e00">luaK_jump</span>(fs));
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_patchtohere</span>(fs, flist);
</span></span><span style="display:flex;"><span>    flist = <span style="color:#c34e00">test_then_block</span>(ls);  <span style="color:#f00;font-style:italic">/* ELSEIF cond THEN block */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token == TK_ELSE) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_concat</span>(fs, &amp;escapelist, <span style="color:#c34e00">luaK_jump</span>(fs));
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_patchtohere</span>(fs, flist);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip ELSE (after patch, for correct line info) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">block</span>(ls);  <span style="color:#f00;font-style:italic">/* `else&#39; part */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">luaK_concat</span>(fs, &amp;escapelist, flist);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_patchtohere</span>(fs, escapelist);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">check_match</span>(ls, TK_END, TK_IF, line);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">localfunc</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  expdesc v, b;
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* local function funA(...) end 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 注册locvar(函数名)到Proto.nlocvars,填充name信息，建立fs-&gt;actvar[fs-&gt;nactvars]到p.nlocvars的映射
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">new_localvar</span>(ls, <span style="color:#c34e00">str_checkname</span>(ls), 0);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 给表达式填个初值先 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">init_exp</span>(&amp;v, VLOCAL, fs-&gt;freereg);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 上面新增了一个locvar,用掉了一个freereg，这里扩大点maxstacksize, 更新freereg */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_reserveregs</span>(fs, 1);	<span style="color:#f00;font-style:italic">/* reserve reg:准备寄存器 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 更新fs-&gt;nactvar, 填充上面新增的p.nlocvars变量的startpc */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjustlocalvars</span>(ls, 1);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">body</span>(ls, &amp;b, 0, ls-&gt;linenumber);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_storevar</span>(fs, &amp;v, &amp;b);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* debug information will only see the variable after this point! */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">getlocvar</span>(fs, fs-&gt;nactvar - 1).startpc = fs-&gt;pc;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">localstat</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* stat -&gt; LOCAL NAME {`,&#39; NAME} [`=&#39; explist1] */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nvars = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nexps;
</span></span><span style="display:flex;"><span>  expdesc e;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">do</span> {	<span style="color:#f00;font-style:italic">/* 登记左边的变量名到 Proto.locvars */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">new_localvar</span>(ls, <span style="color:#c34e00">str_checkname</span>(ls), nvars++);
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">while</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;,&#39;</span>));
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;=&#39;</span>))
</span></span><span style="display:flex;"><span>    nexps = <span style="color:#c34e00">explist1</span>(ls, &amp;e);	<span style="color:#f00;font-style:italic">/* 解析表达式 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    e.k = VVOID;
</span></span><span style="display:flex;"><span>    nexps = 0;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjust_assign</span>(ls, nvars, nexps, &amp;e);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">adjustlocalvars</span>(ls, nvars);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">funcname</span> (LexState *ls, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* funcname -&gt; NAME {field} [`:&#39; NAME] */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> needself = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">singlevar</span>(ls, v);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;.&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">field</span>(ls, v);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;:&#39;</span>) {
</span></span><span style="display:flex;"><span>    needself = 1;	<span style="color:#f00;font-style:italic">/* 需要给函数添加一个self参数 eg:           function modName:sub () body end */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">field</span>(ls, v);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> needself;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">funcstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* funcstat -&gt; FUNCTION funcname body */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> needself;
</span></span><span style="display:flex;"><span>  expdesc v, b;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip FUNCTION */</span>
</span></span><span style="display:flex;"><span>  needself = <span style="color:#c34e00">funcname</span>(ls, &amp;v);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">body</span>(ls, &amp;b, needself, line);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_storevar</span>(ls-&gt;fs, &amp;v, &amp;b);
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_fixline</span>(ls-&gt;fs, line);  <span style="color:#f00;font-style:italic">/* definition `happens&#39; in the first line */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 处理表达式stat */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">exprstat</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* stat -&gt; func | assignment */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> LHS_assign v;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">primaryexp</span>(ls, &amp;v.v);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (v.v.k == VCALL)  <span style="color:#f00;font-style:italic">/* stat -&gt; func */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">SETARG_C</span>(<span style="color:#c34e00">getcode</span>(fs, &amp;v.v), 1);  <span style="color:#f00;font-style:italic">/* call statement uses no results */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* stat -&gt; assignment */</span>
</span></span><span style="display:flex;"><span>    v.prev = NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">assignment</span>(ls, &amp;v, 1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">retstat</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* stat -&gt; RETURN explist */</span>
</span></span><span style="display:flex;"><span>  FuncState *fs = ls-&gt;fs;
</span></span><span style="display:flex;"><span>  expdesc e;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> first, nret;  <span style="color:#f00;font-style:italic">/* registers with returned values */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip RETURN */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (<span style="color:#c34e00">block_follow</span>(ls-&gt;t.token) || ls-&gt;t.token == <span style="color:#009c00">&#39;;&#39;</span>)
</span></span><span style="display:flex;"><span>    first = nret = 0;  <span style="color:#f00;font-style:italic">/* return no values */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    nret = <span style="color:#c34e00">explist1</span>(ls, &amp;e);  <span style="color:#f00;font-style:italic">/* optional return values */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (<span style="color:#c34e00">hasmultret</span>(e.k)) {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaK_setmultret</span>(fs, &amp;e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (e.k == VCALL &amp;&amp; nret == 1) {  <span style="color:#f00;font-style:italic">/* tail call? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">SET_OPCODE</span>(<span style="color:#c34e00">getcode</span>(fs,&amp;e), OP_TAILCALL);
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">lua_assert</span>(<span style="color:#c34e00">GETARG_A</span>(<span style="color:#c34e00">getcode</span>(fs,&amp;e)) == fs-&gt;nactvar);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      first = fs-&gt;nactvar;
</span></span><span style="display:flex;"><span>      nret = LUA_MULTRET;  <span style="color:#f00;font-style:italic">/* return all values */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (nret == 1)  <span style="color:#f00;font-style:italic">/* only one single value? */</span>
</span></span><span style="display:flex;"><span>        first = <span style="color:#c34e00">luaK_exp2anyreg</span>(fs, &amp;e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">luaK_exp2nextreg</span>(fs, &amp;e);  <span style="color:#f00;font-style:italic">/* values must go to the `stack&#39; */</span>
</span></span><span style="display:flex;"><span>        first = fs-&gt;nactvar;  <span style="color:#f00;font-style:italic">/* return all `active&#39; values */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">lua_assert</span>(nret == fs-&gt;freereg - first);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">luaK_ret</span>(fs, first, nret);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">statement</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> line = ls-&gt;linenumber;  <span style="color:#f00;font-style:italic">/* may be needed for error messages */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_IF: {  <span style="color:#f00;font-style:italic">/* stat -&gt; ifstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">ifstat</span>(ls, line);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_WHILE: {  <span style="color:#f00;font-style:italic">/* stat -&gt; whilestat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">whilestat</span>(ls, line);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_DO: {  <span style="color:#f00;font-style:italic">/* stat -&gt; DO block END */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip DO */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">block</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">check_match</span>(ls, TK_END, TK_DO, line);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_FOR: {  <span style="color:#f00;font-style:italic">/* stat -&gt; forstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">forstat</span>(ls, line);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_REPEAT: {  <span style="color:#f00;font-style:italic">/* stat -&gt; repeatstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">repeatstat</span>(ls, line);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_FUNCTION: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">funcstat</span>(ls, line);  <span style="color:#f00;font-style:italic">/* stat -&gt; funcstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_LOCAL: {  <span style="color:#f00;font-style:italic">/* stat -&gt; localstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip LOCAL */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (<span style="color:#c34e00">testnext</span>(ls, TK_FUNCTION))  <span style="color:#f00;font-style:italic">/* local function? */</span>
</span></span><span style="display:flex;"><span>	  	<span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	** local function funName()
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	** end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  	*/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">localfunc</span>(ls);	
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">localstat</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_RETURN: {  <span style="color:#f00;font-style:italic">/* stat -&gt; retstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">retstat</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 1;  <span style="color:#f00;font-style:italic">/* must be last statement */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> TK_BREAK: {  <span style="color:#f00;font-style:italic">/* stat -&gt; breakstat */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">luaX_next</span>(ls);  <span style="color:#f00;font-style:italic">/* skip BREAK */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">breakstat</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 1;  <span style="color:#f00;font-style:italic">/* must be last statement */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#c34e00">exprstat</span>(ls);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* to avoid warnings */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">chunk</span> (LexState *ls) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* chunk -&gt; { stat [`;&#39;] } */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> islast = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">enterlevel</span>(ls);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (!islast &amp;&amp; !<span style="color:#c34e00">block_follow</span>(ls-&gt;t.token)) {
</span></span><span style="display:flex;"><span>    islast = <span style="color:#c34e00">statement</span>(ls);
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* statement后面的&#39;;&#39;是可选的 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">testnext</span>(ls, <span style="color:#009c00">&#39;;&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lua_assert</span>(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp;
</span></span><span style="display:flex;"><span>               ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 释放上一个块占用的临时寄存器 */</span>
</span></span><span style="display:flex;"><span>    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  <span style="color:#f00;font-style:italic">/* free registers */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#c34e00">leavelevel</span>(ls);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* }====================================================================== */</span>
</span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lparse.h/" itemprop="url">
        lua源码注释 lparse.h
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-08">
    2021-06-08
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">2101 字 ~5分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: lparser.h,v 1.57.1.1 2007/12/27 13:02:25 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Lua Parser
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#ifndef lparser_h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define lparser_h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;llimits.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lzio.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/**************************** 官方的BNF **********************************
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">chunk ::= {stat [`;´]} [laststat [`;´]]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">block ::= chunk
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">stat ::=  varlist `=´ explist | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 functioncall | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 do block end | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 while exp do block end | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 repeat block until exp | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 if exp then block {elseif exp then block} [else block] end | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 for Name `=´ exp `,´ exp [`,´ exp] do block end | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 for namelist in explist do block end | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 function funcname funcbody | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 local function Name funcbody | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 local namelist [`=´ explist] 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">laststat ::= return [explist] | break
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">funcname ::= Name {`.´ Name} [`:´ Name]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">varlist ::= var {`,´ var}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">namelist ::= Name {`,´ Name}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">explist ::= {exp `,´} exp
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">exp ::=  nil | false | true | Number | String | `...´ | function | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 prefixexp | tableconstructor | exp binop exp | unop exp 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">prefixexp ::= var | functioncall | `(´ exp `)´
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">functioncall ::=  prefixexp args | prefixexp `:´ Name args 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">args ::=  `(´ [explist] `)´ | tableconstructor | String 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">function ::= function funcbody
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">funcbody ::= `(´ [parlist] `)´ block end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">parlist ::= namelist [`,´ `...´] | `...´
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">tableconstructor ::= `{´ [fieldlist] `}´
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">fieldlist ::= field {fieldsep field} [fieldsep]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">fieldsep ::= `,´ | `;´
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 `&lt;´ | `&lt;=´ | `&gt;´ | `&gt;=´ | `==´ | `~=´ | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 and | or
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">unop ::= `-´ | not | `#´
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**************************************************************************/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/**************************** 自己总结的BNF **********************************
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">chunk ::= {stat [`;´]}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">block ::= chunk
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">stat ::=  
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 ifstat | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 whilestat | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 DO block END | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 forstat | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 repeat | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 funcstat | 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 localstat |
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 retstat |
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 breaksat |
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	 exprstat
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">localstat  	::= local fun | localstat‘
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">localstat&#39; 	::= LOCAL NAME {`,´ NAME } [`=´ explist1]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">explist1   	::= expr { `,&#39; expr }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">expr 		::= subexpr
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">subexpr 	::= (simpleexp | unop subexpr) { binop subexpr }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">simpleexp 	::= NUMBER | STRING | NIL | true | false | ... |
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">                  constructor | FUNCTION body | primaryexp
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">primaryexp 	::= prefixexp { `.&#39; NAME | `[&#39; expr `]&#39; | `:&#39; NAME funcargs | funcargs }
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">prefixexp 	::= NAME | &#39;(&#39; expr &#39;)&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">funcargs 	::= `(&#39; [ explist1 ] `)&#39; | constructor | STRING
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">exprstat    := func | assignment
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">assignment 	::= `,&#39; primaryexp assignment |  `=&#39; explist1 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">ifstat 		::= IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">cond 		::= expr
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">test_then_block :: [IF | ELSEIF] cond THEN block
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">whilestat 	::= WHILE cond DO block END
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">repeatstat 	:: REPEAT block UNTIL cond
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">forstat 	::= FOR (fornum | forlist) END
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">fornum 		::= NAME = exp1,exp1[,exp1] forbody
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">forlist 	::= NAME {,NAME} IN explist1 forbody
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">forbody 	::= DO block
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">funcstat 	::= FUNCTION funcname body
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">funcname 	::= NAME {field} [`:&#39; NAME]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">field 		::= [&#39;.&#39; | &#39;:&#39;] NAME 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">body 		::=  `(&#39; parlist `)&#39; chunk END
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">parlist 	:: [ param { `,&#39; param } ] 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">param 		::= NAME | ...
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">constructor ::= {recfield|listfield}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">recfield 	::= (NAME | `[&#39;exp1`]&#39;) = exp1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">listfield   ::= exp1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">exp1        ::= (exp)   ?
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">retstat ::= RETURN explist
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**************************************************************************/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Expression descriptor
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式的&#34;类型&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** VNONRELOC, VRELOCABLE表示表达式的reg信息(已被安排到指定的reg或可以重定位到任一reg)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 其它的类型：表达式的类型 相关函数 luaK_dischargevars
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">typedef</span> <span style="color:#00f">enum</span> {
</span></span><span style="display:flex;"><span>  VVOID,		<span style="color:#f00;font-style:italic">/* no value:表示表达式尚未进行评估，也可能表达式就是空 */</span>
</span></span><span style="display:flex;"><span>  	
</span></span><span style="display:flex;"><span>  VNIL,
</span></span><span style="display:flex;"><span>  VTRUE,		<span style="color:#f00;font-style:italic">/* true */</span>
</span></span><span style="display:flex;"><span>  VFALSE,		<span style="color:#f00;font-style:italic">/* fales */</span>
</span></span><span style="display:flex;"><span>  VK,			<span style="color:#f00;font-style:italic">/* info = index of constant in `k&#39; 常量表达式 */</span>
</span></span><span style="display:flex;"><span>  VKNUM,		<span style="color:#f00;font-style:italic">/* nval = numerical value */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  VLOCAL,		<span style="color:#f00;font-style:italic">/* info = local register */</span>
</span></span><span style="display:flex;"><span>  VUPVAL,   	<span style="color:#f00;font-style:italic">/* info = index of upvalue in `upvalues&#39; */</span>
</span></span><span style="display:flex;"><span>  VGLOBAL,		<span style="color:#f00;font-style:italic">/* info = index of table; aux = index of global name in `k&#39; */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 索引表达式 eg: tbl(info).aux(aux) */</span>
</span></span><span style="display:flex;"><span>  VINDEXED,		<span style="color:#f00;font-style:italic">/* info = table register; aux = index register (or `k&#39;) */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 跳转表达式，常用于关系表达式 */</span>
</span></span><span style="display:flex;"><span>  VJMP,			<span style="color:#f00;font-style:italic">/* info = instruction pc */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 表达式尚未加载到reg（目标reg尚未确定，可以放在栈的任意位置，只要能访问到）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** info:本指令在指令数组中的索引，方便后面回填本指令的目标地址寄存器(R(A))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  VRELOCABLE,	<span style="color:#f00;font-style:italic">/* info = instruction pc */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 表达式的值已被加载到reg中了，info:对应寄存器的idx */</span>
</span></span><span style="display:flex;"><span>  VNONRELOC,	<span style="color:#f00;font-style:italic">/* info = result register */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  VCALL,		<span style="color:#f00;font-style:italic">/* info = instruction pc: info表示exp对应的指令在指令f的指令数组中的下标，下同 */</span>
</span></span><span style="display:flex;"><span>  VVARARG		<span style="color:#f00;font-style:italic">/* info = instruction pc   ... 变参操作符 */</span>
</span></span><span style="display:flex;"><span>} expkind;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> expdesc {
</span></span><span style="display:flex;"><span>  expkind k;	<span style="color:#f00;font-style:italic">/* 表达式类型，后面会更新为表达式占用寄存器的类型 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">union</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">struct</span> { <span style="color:#00f">int</span> info, aux; } s;	<span style="color:#f00;font-style:italic">/* 随着k不同,info,aux表示的意义随之变化,具体看expkind的注释 */</span>
</span></span><span style="display:flex;"><span>    lua_Number nval;				<span style="color:#f00;font-style:italic">/* 数值表达式的数值 */</span>
</span></span><span style="display:flex;"><span>  } u;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> t;  <span style="color:#f00;font-style:italic">/* patch list of `exit when true&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> f;  <span style="color:#f00;font-style:italic">/* patch list of `exit when false&#39; */</span>
</span></span><span style="display:flex;"><span>} expdesc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> upvaldesc {
</span></span><span style="display:flex;"><span>  lu_byte k;
</span></span><span style="display:flex;"><span>  lu_byte info;
</span></span><span style="display:flex;"><span>} upvaldesc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">struct</span> BlockCnt;  <span style="color:#f00;font-style:italic">/* defined in lparser.c */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* state needed to generate code for a given function 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 编译阶段的func状态机，成品则是Proto
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> FuncState {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> lua_State *L;  <span style="color:#f00;font-style:italic">/* copy of the Lua state */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> FuncState *prev;  <span style="color:#f00;font-style:italic">/* enclosing function,先编译完子函数，才能编译父函数 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> LexState *ls;  <span style="color:#f00;font-style:italic">/* lexical state */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Proto *f;  			<span style="color:#f00;font-style:italic">/* current function header */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">struct</span> BlockCnt *bl;  <span style="color:#f00;font-style:italic">/* chain of current blocks */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> pc;  				<span style="color:#f00;font-style:italic">/* 指向:下一个待生成的指令 next position to code (equivalent to `ncode&#39;) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> lasttarget;   	<span style="color:#f00;font-style:italic">/* `pc&#39; of last `jump target&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> jpc;  			<span style="color:#f00;font-style:italic">/* list of pending jumps to `pc&#39;：指向下一个待生成的指令的待回填的跳转链表 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 存储常量kvar在对应的 Proto.k 常量数组中的下标的映射表 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** local var= &#34;hello&#34; , 常量 &#34;hello&#34; 存在Proto.k常量数组中的第0个位置处
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** h[&#34;hello&#34;] = 0
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 查找常量过程如下 k=&#34;hello&#34;, 进入h表查找,找到v(0), 再用v到Proto.k中取值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 参考函数 lcode.c addk
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  Table *h;  			<span style="color:#f00;font-style:italic">/* table to find (and reuse) elements in `k&#39; */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> nk;  				<span style="color:#f00;font-style:italic">/* number of elements in `k&#39; */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> np;  				<span style="color:#f00;font-style:italic">/* number of elements in `p&#39; */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 第一个可用的reg的索引，随着locvar的申请和释放，这个值不断变化
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 随着编译过程中临时占用寄存器的申请和释放，这个值也在不断变化
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **  local a = b + c 计算完b+c的结果要存放到一个临时寄存器中，赋值给a后，这个寄存器要释放
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 由于locvar的存在需要&#34;始终&#34;占用一个reg，所以freereg&gt;=nactvar
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> freereg;  		<span style="color:#f00;font-style:italic">/* first free register */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 当前函数已使用的本地变量总和(下面的总和为6)，整个数组大小的定义在 Proto 的sizelocvars域中 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** do
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **   	local v1, v2, v3
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** do
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **	local v1, v2, v3
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** end
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** nlocvars:从1-&gt;6, 这样每一个locvar都有一个唯一的 Proto.locvars中对应的信息，
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **    至于运行到某一行时，v1到底指代哪一个v1,可以从startpc,endpc中推断出来（调试库也是靠pc推断的哦？）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">short</span> nlocvars;  		<span style="color:#f00;font-style:italic">/* number of elements in `locvars&#39; */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** declared-variable stack
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 当前激活的var的idx到f.locvars的映射 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">unsigned</span> <span style="color:#00f">short</span> actvar[LUAI_MAXVARS];
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* number of active local variables：当前激活中的locvar数量
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 对于上面的nlocvars第二次声明local时，nactvar:从1-&gt;3,因为离开第一个块后，块所属的locvar被释放了（变量的声明周期也结束了）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  lu_byte nactvar;  					
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  upvaldesc upvalues[LUAI_MAXUPVALUES];  <span style="color:#f00;font-style:italic">/* upvalues */</span>
</span></span><span style="display:flex;"><span>} FuncState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LUAI_FUNC Proto *<span style="color:#c34e00">luaY_parser</span> (lua_State *L, ZIO *z, Mbuffer *buff,
</span></span><span style="display:flex;"><span>                                            <span style="color:#00f">const</span> <span style="color:#00f">char</span> *name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#endif
</span></span></span></code></pre></div>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904%E7%9A%84%E6%89%A7%E8%A1%8C/" itemprop="url">
        lua源码分析4的执行
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-03">
    2021-06-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">1637 字 ~4分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="第3章-lua中函数调用的方法">第3章 lua中函数调用的方法</h1>
<p>前面，以及分析了lua中定义一个函数的方法，现在总结如下：</p>
<p>​	1、  将函数名作为局部变量存在局部变量表里，并在栈上开辟一个寄存器空间，在运行期，将新建一个closure，并存在已保留的寄存器里；</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904%E7%9A%84%E6%89%A7%E8%A1%8C/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC/" itemprop="url">
        lua源码分析3条件跳转
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-03">
    2021-06-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">3061 字 ~7分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="第2章-关于条件编译">第2章 关于条件编译</h1>
<p>​		首先，解释一下，为什么题目叫做：条件编译。其实很简单，现在这一章要分析的是，if、while、repeat、for语句。这些语句有个什么特点呢？那就是，都要有条件判断。根据条件判断的结果，以决定是否执行，该如何执行。我不知道该怎么称呼这样的语句，就一致称其为：条件编译。因为这一章的重点是研究，条件对于中间码的生成造成的影响，以及如何生成中间码以实现这种条件判断。
​    	首先分析if then elseif then else then end句型。
​    	这个很简单，实际上是lua处理的很简单。
​    	当lua遇到了if这个关键字的时候，就开始调用ifstat()，首先，这是进入一个块。这个块这个东西和函数是相同的重要，因为它关系到一个变量的作用域的问题。块由block()函数处理。不过在此之前，要注意一个重要的事情，那就是条件判断语句。lua是怎么处理条件判断的呢？
​    	首先，lua会跳过if关键字，然后，会进入一个十分常用的函数：cond()，这个函数还是比较复杂的，我现在要再看一遍这个函数，还是心有余悸的。
​    	cond()这个函数比较短，我还是贴出来吧：</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/" itemprop="url">
        lua源码分析2（局部函数的定义）
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-03">
    2021-06-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">2715 字 ~6分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="第二节-局部函数的声明">第二节 局部函数的声明</h2>
<p>​		前面研究了局部变量的定义，下面就研究下，lua中局部函数定义的方法。</p>
<p>​	其中局部函数定义的语法是：
​		local function FuncName (parlist) chunk END
​	首先，lua会检测到local function这两个关键字，知道后面是在定义局部函数，lua会跳过这两个关键字，分别用llex_next()和testnext()。testnext()和checknext()这两个函数的区别是，checknext()是期望后面是某个token，是的话就读取，如果不是的话，就会报错，而testnext()是检查后面是不是某个token，如果是就读取，不是的话也不会报错。
​    当跳过了local function这两个关键字。就到了局部函数函数名的地方了。这时，lua会把这个局部函数当作一个局部变量，为这个函数名字注册一个局部变量名。其中就用到了前面注册局部变量时用到的函数 newlocalvar()。这个函数在局部变量数字里增加一项，记录这个函数名。这里的记录并没有检查是否已经存在了这个局部变量。但是使用的时候，lua会从头开始遍历查找，也就是说第一次注册的这个局部变量会被使用。
​    如前所说，在语法解析的过程中，有一个数据结构非常重要，那就是expdesc，这个数据结构代表一个表达式。在局部函数定义的时候，会用到2个这样的数据结构，这里分别称为v和b。其中v代表这个函数，b代表body，也就是函数体。当解析到这里的时候，会初始化v，将其类型赋值为VLOCAL，v-&gt;k = VLOCAL，并在里面记录当前空闲寄存器的位置，v-&gt;u.s.info = fs-&gt;freereg。
​    接下来就是将空闲寄存器指针加一，将局部变量的个数加一。
​    于是，就进入解析函数体的部分了，body()。
​    首先，新建了一个FuncState数据结构，通过open_func()函数，这个数据结构就是我们一直看到的ls-&gt;fs这个fs。这个数据结构是在语法解析时用到的，代表一个函数，它有一个函数头，叫Proto，每个函数都以一个这样的头。每个函数记录自己的中间码，它存在于这个函数头Proto里面，具体就是ls-&gt;fs-&gt;f-&gt;code[]数组里。在语法解析的过程中，整个lua程序就当作了一个函数，也就是第一个FuncState，也就是第一个ls-&gt;fs，之后，遇到的每个定义的函数，都会新建一个FuncState，并链在ls-&gt;fs上，也就是，所有的ls-&gt;fs链成一个链表。而ls-&gt;fs就是当前解析到的函数。
​    新建了这个函数结构FuncState后，便将其及其常量数组压入栈中。
​    之后便是解析参数列表和函数体了。现在先不管这些，因为先从整体对解析函数有个了解。假设我们的函数是这个样子：
​    local function FuncName () END；
​    也就是说，没有参数表，也没有函数体的一个最简单的函数。
​    当lua解析这个函数的时候，如前所说，FuncName会被注册进局部变量表中，并且会新建一个FuncState数据结构，将其链在ls-&gt;fs上，并当作当前函数。
​    当lua检测到函数定义的语法都正确，也就是参数表包含在小括号()内，函数体以END结束，通过了检测，就会执行close_func()函数。
​    这个函数比较有意思，它里面包含了一些比较有趣的函数。其中第一个有趣的函数叫做removevar()，看字面意思是去除变量。是什么意思呢？是这么个意思：函数定义结束后，函数内部的变量是外部不看见的，所以，要从可见的地方去掉。这个函数就是处理这个情况的。它的做法很简单，就是把每个这个函数内的局部变量的endpc标记为当前pc。也就是说，到当前位置，当前代码以后，局部变量是不可见的。这里的可见度，作用域是与指令联系起来的，也就是说，从某条指令开始，局部变量可见，到某条指令结束，局部变量不可见。于是，便从当前可见域里remove了那个函数的局部变量。
​    然后会通过luaK_ret()函数，生成一条OP_RETURN指令。
​    最后，将这个函数从ls中踢掉，也就是ls-&gt;fs = fs-&gt;prev。到这里，这个函数算解析完了，但是，这个函数生成的指令码是在这个函数结构fs里面，现在踢掉了，当要调用的时候该怎么调用呢？
​    这是最后一个疑问，不过， body并没有结束，还有最后一个函数pushclosure()。看了这个函数，我们就会发现，其实，lua并没有把这个函数踢掉，而是把它保存在他的父函数里面。这里是这么回事：每个函数里面都可以定义函数，这个函数名首先会作为局部变量名保存在父函数的局部变量表里，当作其父函数的一个局部变量。然后，这个函数的结构FuncState会被保存在其父函数的内部函数数组里，也就是每个函数结构的头结构里面，fs-&gt;f，都会有一个函数头数组，fs-&gt;f-&gt;p[]，其中包含着在这个函数内部定义的函数。
​    pushclosure()首先就会做这件事，也就是将函数结构保存在其父函数结构的fs-&gt;f-&gt;p[]里面。
​    然后，就会生成一条指令，OP_CLOSURE，说明这里定义了一个函数。这条指令是做什么的呢？
​    别忘了刚开始我们说的，一个局部函数定义，和局部变量定义是同样的，在栈里会保留一个空槽（寄存器），但是，那个寄存器里到底存的是什么呢？这个就要留在运行时回答了。当lua虚拟机运行到OP_CLOSURE的时候，就会新建一个Closure，并用这个Closure初始化那个预留的寄存器，也就是那个局部函数。
​    而刚开始的那两个expdesc数据结构，其中之一b，也就是那个代表body的，就是用来储存这个OP_CLOSURE指令了。而那个v，其v-&gt;u.s.info存的是这个局部函数所存在的寄存器位置。这里，已经生成了一个OP_CLOSURE指令，但是，这条指令所执行时，生成的Closure存在栈的哪里呢？也就是，应该放在那个局部函数所对应的那个寄存器里。下面就是要完成这个操作的函数：luaK_storevar()。就把当初保存在e里面的寄存器位置保存在了那条指令OP_CLOSURE里面了。
​	这就是新建了一个局部函数，其实和局部变量差不多。写到现在，发现文章的架构太乱了，算是草稿吧，以后再改。
————————————————
版权声明：本文为CSDN博主「haxixi_keli」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/haxixi_keli/article/details/3210446</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/" itemprop="url">
        lua源码分析1（局部变量的定义）
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-03">
    2021-06-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">9557 字 ~20分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="第0节-一切从这里开始">第0节 一切从这里开始</h1>
<p>​		Lua是边进行语法分析，边词法分析。其中，词法分析的模块是：llex。其对外暴露的接口是：llex_next()。并且，在整个语法分析、词法分析的过程中，只有一个唯一的全局实例：llex_state。在词法分析的过程中，lua会处理以下几种情况：</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/06/03/lua%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/02/samba-445-%E8%A2%AB%E5%B0%81-%E5%85%AC%E7%BD%91%E8%AE%BF%E9%97%AE/" itemprop="url">
        samba 445 被封 公网访问
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-02">
    2021-06-02
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4" itemprop="url" rel="index">
        <span itemprop="name">运维</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">215 字 ~1分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h3 id="原因">原因</h3>
<p>​	由于安全原因，tcp的445端口被网络运营商封闭，造成无法访问公网的samba服务，即使打开了腾讯的安全组策略中的端口也无济于事</p>
<h3 id="解决思路">解决思路</h3>
<p>​	修改访问端口</p>
    </div>
    
    <div class="post-more-link text-center">
    <a class="btn" href="http://shanks.link/blog/2021/06/02/samba-445-%E8%A2%AB%E5%B0%81-%E5%85%AC%E7%BD%91%E8%AE%BF%E9%97%AE/" rel="contents">
      阅读全文 &raquo;
    </a>
    </div>
    
    <footer class="post-footer"><div class="post-eof"></div></footer>
  </article>

</section>
















<nav class="pagination">
    <a class="extend prev" rel="prev" href="http://shanks.link/p/64/"><i class="fa fa-angle-left"></i></a>
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/61/">61</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/62/">62</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/63/">63</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/64/">64</a>
        
        
    
        
        
          <span class="page-number current">65</span>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/66/">66</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/67/">67</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/68/">68</a>
        
        
    
        
        
          <a class="page-number" href="http://shanks.link/p/69/">69</a>
        
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
    <a class="extend next" rel="next" href="http://shanks.link/p/66/"><i class="fa fa-angle-right"></i></a>
</nav>




          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="" />
    <p class="site-author-name" itemprop="name"></p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
<div class="feed-link motion-element">
<a href="http://shanks.link/index.xml" rel="alternate" type="application/rss+xml" target="_blank">
    <i class="fa fa-rss"></i>
    RSS 订阅
</a>
</div>

      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2025</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" id="motion.page.archive">
  $('.archive-year').velocity('transition.slideLeftIn');
</script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>