<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Linux线程与信号 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="Linux线程与信号">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="Linux线程与信号 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2023/09/22/linux%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BF%A1%E5%8F%B7/" itemprop="url">
        Linux线程与信号
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2023-09-22">
    2023-09-22
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/c" itemprop="url" rel="index">
        <span itemprop="name">c</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/linux" itemprop="url" rel="index">
        <span itemprop="name">linux</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5796 字 ~12分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h3 id="信号与线程的关系"><strong>信号与线程的关系</strong></h3>
<p>POSIX标准对<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;spm=1001.2101.3001.7020">多线程</a>情况下的信号机制提出了一些要求：</p>
<ul>
<li>信号处理函数必须在多线程进程的<strong>所有线程之间共享</strong>， 但是每个线程要有自己的挂起信号集合和阻塞信号掩码。</li>
<li>POSIX函数kill/sigqueue必须面向进程， 而不是进程下的某个特定的线程。</li>
<li>每个发给多线程应用的信号仅递送给一个线程， 这个线程是由内核从不会阻塞该信号的线程中****随意选出来****的。</li>
<li>如果发送一个致命信号到多线程， 那么内核将杀死该应用的所有线程， 而不仅仅是接收信号的那个线程。</li>
</ul>
<p>这些就是POSIX标准提出的要求， Linux也要遵循这些要求， 那它是怎么做到的呢？</p>
<p><strong>线程之间共享信号处理函数</strong></p>
<p>在Linux内核实现中， 同一个线程组里的所有线程都共享一个struct sighand结构体。 该结构体中存在一个action数组， 数组共64项， 每一个成员都是k_sigaction结构体类型， 一个k_sigaction结构体对应一个信号的信号处理函数。
相关数据结构定义如下（这与架构相关， 这里给出的是x86_64位下的定义） ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">struct</span> sigaction {__sighandler_t sa_handler;
	<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

<span style="color:#00f">struct</span> k_sigaction {
	<span style="color:#00f">struct</span> sigaction sa;
};

<span style="color:#00f">struct</span> sighand_struct {
	atomic_t count;
	<span style="color:#00f">struct</span> k_sigaction action[_NSIG];
	spinlock_t siglock;
	wait_queue_head_t signalfd_wqh;
};

<span style="color:#00f">struct</span> task_struct{
	<span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>	<span style="color:#00f">struct</span> sighand_struct *sighand;
	<span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>}
</code></pre></div><p>多线程的进程中， 信号处理函数相关的数据结构如图所示。
内核中k_sigaction结构体的定义和glibc中sigaction函数中用到的struct sigaction结构体的定义几乎是一样的。 通过sigaction函数安装信号处理函数， 最终会影响到进程描述符中的sighand指针指向的sighand_struct结构体对应位置上的action成员变量。
在创建线程时， 最终会执行内核的do_fork函数， 由do_fork函数走进copy_sighand来实现线程组内信号处理函数的共享。 创建线程时， CLONE_SIGHAND标志位是置位的。 创建线程组的主线程时， 内核会分配sighand_struct结构体； 创建线程组内的其他线程时， 并不会另起炉灶， 而是共享主线程的sighand_struct结构体， 只须增加引用计数而已。
<img src="http://shanks.link/img/linux/2018120114522184.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzMyMzUw,size_16,color_FFFFFF,t_70" alt="img"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">copy_sighand</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> clone_flags, <span style="color:#00f">struct</span> task_struct *tsk)
{
	<span style="color:#00f">struct</span> sighand_struct *sig;
    
	<span style="color:#00f">if</span> (clone_flags &amp; CLONE_SIGHAND) {
		<span style="color:#f00;font-style:italic">//如果发现是线程， 则直接将引用计数++， 无须分配
</span><span style="color:#f00;font-style:italic"></span>		sighand_struct结构
		atomic_inc(&amp;current-&gt;sighand-&gt;count);
		<span style="color:#00f">return</span> 0;
	}

	sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);
	rcu_assign_pointer(tsk-&gt;sighand, sig);

	<span style="color:#00f">if</span> (!sig)
		<span style="color:#00f">return</span> -ENOMEM;

	atomic_set(&amp;sig-&gt;count, 1);
	memcpy(sig-&gt;action, current-&gt;sighand-&gt;action, <span style="color:#00f">sizeof</span>(sig-&gt;action));
	<span style="color:#00f">return</span> 0;
}
</code></pre></div><h4 id="-线程有独立的阻塞信号掩码信号集">*** 线程有独立的阻塞信号掩码（信号集）***</h4>
<p>每个线程都拥有独立的阻塞信号掩码。 在介绍这条性质之前， 首先需要介绍什么是阻塞信号掩码。</p>
<p>就像我们开重要会议时要关闭手机一样， 进程在执行某些重要操作时， 不希望内核递送某些信号， 阻塞信号掩码就是用来实现该功能的。</p>
<p>如果进程将某信号添加进了阻塞信号掩码， 纵然内核收到了该信号， 甚至该信号在挂起队列中已经存在了相当长的时间， 内核也不会将信号递送给进程， 直到进程解除对该信号的阻塞为止。</p>
<p>开会时关闭手机是一种比较极端的例子。 更合理的做法是暂时屏蔽部分人的电话。 对于某些重要的电话， 比如儿子老师的电话、 父母的电话或老板的电话， 是不希望被屏蔽的。 信号也是如此。 进程在执行某些操作的时候， 可能只需要屏蔽一部分信号， 而不是所有信号。</p>
<p>为了实现掩码的功能， Linux提供了一种新的数据结构： 信号集。 多个信号组成的集合被称为信号集， 其数据类型为sigset_t。 在Linux的实现中， sigset_t的类型是位掩码， <strong>每一个比特代表一个信号。</strong>
Linux提供了两个函数来初始化信号集， 如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span><span style="color:#f00;font-style:italic">&lt;signal.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">sigemptyset</span>(sigset_t *set);
<span style="color:#00f">int</span> <span style="color:#c34e00">sigfillset</span>(sigset_t *set);
</code></pre></div><p>sigemptyset函数用来初始化一个空的未包含任何信号的信号集， 而sigfillset函数则会初始化一个包含所有信号的信号集。</p>
<p><em><strong>*注意*</strong></em></p>
<p>必须要调用这两个初始化函数中的一个来初始化信号集， 对于声明了sigset_t类型的变量， 不能一厢情愿地假设它是空集合，也不能调用memset函数， 或者用赋值为0的方式来初始化。
初始化信号之后， Linux提供了sigaddset函数向信号集中添加一个信号， 同时还提供了sigdelset函数在信号集中移除一个信号：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">sigaddset</span>(sigset_t *set, <span style="color:#00f">int</span> signum);
<span style="color:#00f">int</span> sigdelset(sigset_t *set, <span style="color:#00f">int</span> signum)
</code></pre></div><p>为了判断某一个信号是否属于信号集， Linux提供了sigismember函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00f">int</span> <span style="color:#c34e00">sigismember</span>(<span style="color:#00f">const</span> sigset_t *set, <span style="color:#00f">int</span> signum);
</code></pre></div><p>如果signum属于信号集， 则返回1， 否则返回0。 出错的时候， 返回-1。</p>
<p>有了信号集， 就可以使用信号集来设置进程的<strong>阻塞信号掩码了</strong>。 Linux提供了sigprocmask函数来做这件事情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;signal.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">sigprocmask</span>(<span style="color:#00f">int</span> how, <span style="color:#00f">const</span> sigset_t *set, sigset_t *oldset);
</code></pre></div><p>sigprocmask根据how的值， 提供了三种用于改变进程的阻塞信号掩码的方式， 见表6-14。
<img src="http://shanks.link/img/linux/20181201150341738.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzMyMzUw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>注意</strong></p>
<p>我们知道SIGKILL信号和SIGSTOP信号不能阻塞， 可是如果调用sigprocmask函数时， 将SIGKILL信号和SIGSTOP信号添加进阻
塞信号集中， 会怎么样？
答案是不怎么样。 sigprocmask函数不会报错， 但是也不会将SIGKILL和SIGSTOP真的添加进阻塞信号集中。
对应的rt_sigprocmask系统调用会执行如下语句， 剔除掉集合中的SIGKILL和SIGSTOP：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">sigdelsetmask(&amp;new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));
</code></pre></div><p>对于多线程的进程而言， 每一个线程都有自己的阻塞信号集：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00f">struct</span> <span style="color:#007575">task_struct</span>{
    sigset_t blocked;
}
</code></pre></div><p>sigprocmask函数改变的是<strong>调用线程的阻塞信号掩码， 而不是整个进程</strong>。 sigprocmask出现得比较早， 它出现在线程尚未引入Linux的时代。 在单线程的时代， 进程的阻塞信号掩码和线程的阻塞掩码是一回事， 但是引入多线程之后， sigprocmask的语义就变成了设置调用线程的阻塞信号掩码。
为了更显式地设置线程的阻塞信号掩码， 线程库提供了pthread_sigmask函数来设置线程的阻塞信号掩码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;signal.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">pthread_sigmask</span>(<span style="color:#00f">int</span> how, <span style="color:#00f">const</span> sigset_t *set, sigset_t *oldset);
</code></pre></div><p>事实上pthread_sigmask函数和sigprocmask函数的行为是一样的。</p>
<h4 id="私有挂起信号和共享挂起信号"><strong>私有挂起信号和共享挂起信号</strong></h4>
<p>POSIX标准中有如下要求： 对于多线程的进程， kill和sigqueue发送的信号必须面对所有的线程， 而不是某个线程， 内核是如何做到的呢？而系统调用tkill和tgkill发送的信号， 又必须递送给进程下某个特定的线程。 内核又是如何做到的呢？
前面简单提到过内核维护有挂起队列， 尚未递送进程的信号可以挂入挂起队列中。 有意思的是， 内核的进程描述符task_struct之中， 维护了两套sigpending， 代码如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00f">struct</span> <span style="color:#007575">task_struct</span>{
	<span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>	<span style="color:#00f">struct</span> <span style="color:#007575">signal_struct</span> *signal;
	<span style="color:#00f">struct</span> <span style="color:#007575">sighand_struct</span> *sighand;
	<span style="color:#00f">struct</span> <span style="color:#007575">sigpending</span> pending;
	<span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>}

<span style="color:#00f">struct</span> <span style="color:#007575">signal_struct</span> {
	<span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>	<span style="color:#00f">struct</span> <span style="color:#007575">sigpending</span> shared_pending;
	<span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>}
</code></pre></div><p><img src="http://shanks.link/img/linux/20181201151015546.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzMyMzUw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>内核就是靠这两个挂起队列实现了POSIX标准的要求。 在Linux实现中， 线程作为独立的调度实体也有自己的进程描述符。 Linux下既可以向进程发送信号， 也可以向进程中的特定线程发送信号。 因此进程描述符中需要有两套sigpending结构。 其中task_struct结构体中的pending， 记录的是发送给线程的未决信号； 而通过signal指针指向signal_struct结构体的shared_pending， 记录的是发送给进程的未决信号。 每个线程都有自己的私有挂起队列（pending） ， 但是进程里的所有线程都会共享一个公有的挂起队列（shared_pending） 。</p>
<p>图6-4描述的是通过kill、 sigqueue、 tkill和tgkill发送信号后， 内核的相关处理流程。
<img src="http://shanks.link/img/linux/20181201151114501.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzMyMzUw,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>从图6-4中可以看出， 向进程发送信号也好， 向线程发送信号也罢， 最终都殊途同归， 在do_send_sig_info函数处会师。 尽管会师在一处， 却还是存在不同。 不同的地方在于， 到底将信号放入哪个挂起队列。
在__send_signal函数中， 通过group入参的值来判断需要将信号放入哪个挂起队列（如果需要进队列的话） 。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">__send_signal</span>(<span style="color:#00f">int</span> sig, <span style="color:#00f">struct</span> <span style="color:#007575">siginfo</span> *info, <span style="color:#00f">struct</span> <span style="color:#007575">task_struct</span> *t,

<span style="color:#00f">int</span> group, <span style="color:#00f">int</span> from_ancestor_ns)
{
    <span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>    pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;
    <span style="color:#f00;font-style:italic">//...
</span><span style="color:#f00;font-style:italic"></span>}
</code></pre></div><p>如果用户调用的是kill或sigqueue， 那么group就是1； 如果用户调用的是tkill或tgkill， 那么group参数就是0。 内核就是以此来区分该信号是发给进程的还是发给某个特定线程的， 如表6-15所示。
<img src="http://shanks.link/img/linux/2018120115124980.png" alt="img"></p>
<p>上述情景并不难理解。 多线程的进程就像是一个班级， 进程下的每一个线程就像是班级的成员。 kill和sigqueue函数发送的信号是给进程
的， 就像是优秀班集体的荣誉是颁发给整个班级的； tkill和tgkill发送的信号是给特定线程的， 就像是三好学生的荣誉是颁发给学生个的。</p>
<p>另一个需要解决的问题是， 多线程情况下发送给进程的信号， 到底由哪个线程来负责处理？ 这个问题就和高二（五） 班荣获优秀班集体，由谁负责上台领奖一样。</p>
<p>内核是不是一定会将信号递送给进程的主线程？</p>
<p>答案是不一定。 尽管如此， Linux还是采取了尽力而为的策略， 尽量地尊重函数调用者的意愿， 如果进程的主线程方便的话， 则优先选择主线程来处理信号； 如果主线程确实不方便， 那就有可能由线程组里的其他线程来负责处理信号。</p>
<p>用户在调用kill/sigqueue函数之后， 内核最终会走到__send_signal函数。 在该函数的最后， 由complete_signal函数负责寻找合适的线程来处理该信号。 因为主线程的线程ID等于进程ID， 所以该函数会优先查询进程的主线程是否方便处理信号。 如果主线程不方便， 则会遍历线程组中的
其他线程。 如果找到了方便处理信号的线程， 就调用signal_wake_up函数， 唤醒该线程去处理信号。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">signal_wake_up(t, sig == SIGKILL);
</code></pre></div><p>如果线程组内全都不方便处理信号， complete函数也就当即返回了。
如何判断方便不方便？ 内核通过wants_signal函数来判断某个调度实体是否方便处理某信号：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">int</span> <span style="color:#c34e00">wants_signal</span>(<span style="color:#00f">int</span> sig, <span style="color:#00f">struct</span> <span style="color:#007575">task_struct</span> *p)
{
	<span style="color:#00f">if</span> (sigismember(&amp;p-&gt;blocked, sig))  <span style="color:#f00;font-style:italic">/*位于阻塞信号集， 不方便*/</span>
		<span style="color:#00f">return</span> 0;

	<span style="color:#00f">if</span> (p-&gt;flags &amp; PF_EXITING)          <span style="color:#f00;font-style:italic">/*正在退出， 不方便*/</span>
		<span style="color:#00f">return</span> 0;

	<span style="color:#00f">if</span> (sig == SIGKILL)                <span style="color:#f00;font-style:italic">/*SIGKILL信号， 必须处理*/</span>
		<span style="color:#00f">return</span> 1;

	<span style="color:#00f">if</span> (task_is_stopped_or_traced(p))  <span style="color:#f00;font-style:italic">/*被调试或被暂停， 不方便*/</span>
		<span style="color:#00f">return</span> 0;

	<span style="color:#00f">return</span> task_curr(p) || !signal_pending(p);
}
</code></pre></div><p>glibc提供了一个API来获取当前线程的阻塞挂起信号， 如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;signal.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">sigpending</span>(sigset_t *set);
</code></pre></div><p>该函数很容易产生误解， 很多人认为该接口返回的是线程的挂起信号， 即还没有来得及处理的信号， 这种理解其实是错误的。
严格来讲， 返回的信号集中的信号必须同时满足以下两个条件：</p>
<ul>
<li>处于挂起状态。</li>
<li>信号属于线程的阻塞信号集。</li>
</ul>
<p>看下内核的do_sigpending函数的内容就不难理解sigpending函数的含义了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);

sigorsets(&amp;pending, &amp;current-&gt;pending.signal,&amp;current-&gt;signal-&gt;shared_pending.signal);

spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);
sigandsets(&amp;pending, &amp;current-&gt;blocked, &amp;pending);

error = -EFAULT;

<span style="color:#00f">if</span> (!copy_to_user(set, &amp;pending, sigsetsize))
	error = 0;
</code></pre></div><p>因此， 返回的挂起阻塞信号集合的计算方式是：
1） 进程共享的挂起信号和线程私有的挂起信号取并集， 得到集合1。
2） 对集合1和线程的阻塞信号集取交集， 以获得最终的结果。
从此处可以看出， sigprocmask函数会影响到sigpendig函数的输出结果。</p>
<h4 id="致命信号下-进程组全体退出"><strong>致命信号下， 进程组全体退出</strong></h4>
<p>关于进程的退出， 前面已经有所提及， Linux为了应对多线程， 提供了exit_group系统调用， 确保多
个线程一起退出。 对于线程收到致命信号的这种情况， 操作是类似的。 可以通过给每个调度实体的
pending上挂上一个SIGKILL信号以确保每个线程都会退出。 此处就不再赘述了。</p>
<p>总结：</p>
<ul>
<li>信号处理函数是进程层面的概念， 或者说是线程组层面的概念， 线程组内所有线程共享对信号的处理函数。</li>
<li>对于发送给进程的信号， 内核会任选一个线程来执行信号处理函数， 执行完后， 会将其从挂起信号队列中去除， 其他进程不会对一个信号重复响应。</li>
<li>可以针对进程中的某个线程发送信号， 那么只有该线程能响应， 执行相应的信号处理函数。</li>
<li>信号掩码是线程层面的概念， 信号处理函数在线程组内是统一的， 但是信号掩码是各自独立可配置的， 各个线程独立配置自己要阻止或放行的信号集合。</li>
<li>挂起信号（内核已经收到， 但尚未递送给线程处理的信号） 既是针对进程的， 又是针对线程的。</li>
</ul>
<p>内核维护两个挂起信号队列， 一个是进程共享的挂起信号队列， 一个是线程特有的挂起信号队列。 调用函数sigpending返回的是两者的并集。 对于线程而言， 优先递送发给线程自身的信号。</p>
<h4 id="设置线程的信号掩码"><strong>设置线程的信号掩码</strong></h4>
<p>前面已提到过， 信号掩码是针对线程的， 每个线程都可以自行设置自己的信号掩码。 如果自己不设置， 就会继承创建者的信号掩码。
NPTL实现了如下接口来设置线程的信号掩码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;signal.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">pthread_sigmask</span>(<span style="color:#00f">int</span> how, <span style="color:#00f">const</span> sigset_t *new, sigset_t *old);
</code></pre></div><p>how的值用来指定如何更改信号组：</p>
<ul>
<li>SIG_BLOCK向当前信号掩码中添加new， 其中new表示要阻塞的信号组。</li>
<li>SIG_UNBLOCK从当前信号掩码中删除new， 其中new表示要取消阻塞的信号组。</li>
<li>SIG_SETMASK将当前信号掩码替换为new， 其中new表示新的信号掩码。</li>
</ul>
<p>该接口的使用方式和sigprocmask一模一样， 在Linux上， 两个函数的实现是相同的。</p>
<p>说明 SIGCANCEL和SIGSETXID信号被用于NPTL实现， 因此用户不能也不应该改变这两个信号的行为方式。 好在用户不用操心这两个信号， sigprocmask函数和pthread_sigmask函数对这两者都做了特殊处理。</p>
<h4 id="-向线程发送信号">** 向线程发送信号**</h4>
<p>前面提到过向线程发送信号的系统调用tkill/tgkill， 无奈glibc并未将它们封装成可以直接调用的函数。 不过， 幸好提供了另外一个函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00f">int</span> <span style="color:#c34e00">pthread_kill</span>(pthread_t <span style="color:#00f">thread</span>, <span style="color:#00f">int</span> sig);
</code></pre></div><p>由于pthread_t类型的线程ID只在线程组内是唯一的， 其他进程完全可能存在线程ID相同的线程， 所以pthread_kill只能向同一个进程的线程发送信号。
除了这个接口外， Linux还提供了特有的函数将pthread_kill和sigqueue功能累加在一起：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#define _GNU_SOURCE
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#00f">int</span> <span style="color:#c34e00">pthread_sigqueue</span>(pthread_t <span style="color:#00f">thread</span>, <span style="color:#00f">int</span> sig,
                <span style="color:#00f">const</span> <span style="color:#00f">union</span> sigval value);
</code></pre></div><p>这个接口和sigqueue一样， 可以发送携带数据的信号。 当然， 只能发给同一个进程内的线程。</p>
<h4 id="-多线程程序对信号的处理">** 多线程程序对信号的处理**</h4>
<p>单线程的程序， 对信号的处理已经比较复杂了。 因为信号打断了进程的控制流， 所以信号处理函数只能调用异步信号安全的函数。 而异步信号安全是个很苛刻的条件。
多线程的引入， 加剧了这种复杂度。 因为信号可以发送给进程， 也可以发送给进程内的某一线程。 不同线程还可以设置自己的掩码来实现对信号的屏蔽。 而且， 没有一个线程相关的函数是异步信号安全的， 信号处理函数不能调用任何pthread函数， 也不能通过条件变量来通知其他线程。
正如陈硕在《Linux多线程服务器编程》 中提到的， 在多线程程序中， <strong>使用信号的第一原则就是不要使用信号。</strong></p>
<ul>
<li>不要主动使用信号作为进程间通信的手段， 收益和引入的风险完全不成比例。</li>
<li>不主动改变异常处理信号的信号处理函数。 用于管道和socket的SIGPIPE可能是例外， 默认语义是终止进程， 很多情况下， 需要忽略该信号。</li>
<li>如果无法避免， 必须要处理信号， 那么就采用sigwaitinfo或signalfd的方式同步处理信号， 减少异步处理带来的风险和引入bug的可能。</li>
</ul>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/c" rel="tag" title="c">#c#</a>
    
    <a href="http://shanks.link/tags/linux" rel="tag" title="linux">#linux#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2023/09/22/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%8D%81%E4%B8%AAc%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" rel="next" title="代码阅读——十个C开源项目">
        <i class="fa fa-chevron-left"></i> 代码阅读——十个C开源项目
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2023/09/22/sendmsg-%E5%92%8C-recvmsg-%E5%87%BD%E6%95%B0/" rel="prev" title="sendmsg 和 recvmsg 函数">
        sendmsg 和 recvmsg 函数 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2024</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>