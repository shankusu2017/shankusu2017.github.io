<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Linux PPP 源码分析 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="Linux PPP 源码分析">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="Linux PPP 源码分析 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/food/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />food
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/finance/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />投资
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2023/11/24/linux-ppp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url">
        Linux PPP 源码分析
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2023-11-24">
    2023-11-24
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/l2tp" itemprop="url" rel="index">
        <span itemprop="name">L2TP</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/ppp" itemprop="url" rel="index">
        <span itemprop="name">PPP</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">16711 字 ~34分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>Linux PPP实现源码分析
作者：kwest <a href="mailto:exboy@163.com">exboy@163.com</a>  版本：v0.7</p>
<p>©所有版权保留</p>
<p>转载请保留作者署名，严禁用于商业用途 。</p>
<p>前言：</p>
<p>PPP(Point to Point Protocol)协议是一种广泛使用的数据链路层协议，在国内广泛使用的宽带拨号协议PPPoE其基础就是PPP协议，此外和PPP相关的协议PPTP,L2TP也常应用于VPN虚拟专用网络。随着智能手机系统Android的兴起，PPP协议还被应用于GPRS拨号，3G/4G数据通路的建立，在嵌入式通信设备及智能手机中有着广泛的应用基础。本文主要分析Linux中PPP协议实现的关键代码和基本数据收发流程，对PPP协议的详细介绍请自行参考RFC和相关协议资料。</p>
<p>模块组成：
<img src="http://shanks.link/img/l2tp/20130521234210565.png" alt="ppp协议架构示意图"></p>
<p>上图为PPP模块组成示意图，包括：</p>
<p>PPPD：PPP用户态应用程序。</p>
<p>PPP驱动：PPP在内核中的驱动部分，kernel源码在/drivers/net/下的ppp_generic.c, slhc.c。</p>
<p>PPP线路规程*：PPP TTY线路规程，kernel源码在/drivers/net/下的ppp_async.c, ppp_synctty.c，本文只考虑异步PPP。</p>
<p>TTY核心：TTY驱动，线路规程的通用框架层。</p>
<p>TTY驱动：串口TTY驱动，和具体硬件相关，本文不讨论。</p>
<p>说明：本文引用的pppd源码来自于android 2.3源码包，kernel源码版本为linux-2.6.18。</p>
<p>Linux中PPP实现主要分成两大部分：PPPD和PPPK。PPPD是用户态应用程序，负责PPP协议的具体配置，如MTU、拨号模式、认证方式、认证所需用户名/密码等。 PPPK指的是PPP内核部分，包括上图中的PPP驱动和PPP线路规程。PPPD通过PPP驱动提供的设备文件接口/dev/ppp来对PPPK进行管理控制，将用户需要的配置策略通过PPPK进行有效地实现，并且PPPD还会负责PPP协议从LCP到PAP/CHAP认证再到IPCP三个阶段协议建立和状态机的维护。因此，从Linux的设计思想来看，PPPD是策略而PPPK是机制；从数据收发流程看，所有控制帧(LCP,PAP/CHAP/EAP,IPCP/IPXCP等)都通过PPPD进行收发协商，而链路建立成功后的数据报文直接通过PPPK进行转发，如果把Linux当做通信平台，PPPD就是Control Plane而PPPK是DataPlane。</p>
<p>在Linux中PPPD和PPPK联系非常紧密，虽然理论上也可以有其他的应用层程序调用PPPK提供的接口来实现PPP协议栈，但目前使用最广泛的还是PPPD。PPPD的源码比较复杂，支持众多类UNIX平台，里面包含TTY驱动，字符驱动，以太网驱动这三类主要驱动，以及混杂了TTY，PTY，Ethernet等各类接口，导致代码量大且难于理解，下文我们就抽丝剥茧将PPPD中的主干代码剥离出来，遇到某些重要的系统调用，我会详细分析其在Linux内核中的具体实现。</p>
<p>源码分析：</p>
<p>PPPD的主函数main：</p>
<p>第一阶段：</p>
<p>pppd/main.c -&gt; main():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">new_phase(PHASE_INITIALIZE); <span style="color:#f00;font-style:italic">//PPPD中的状态机，目前是初始化阶段
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Initialize magic number generator now so that protocols may
</span><span style="color:#f00;font-style:italic">    * use magic numbers in initialization.
</span><span style="color:#f00;font-style:italic">    */</span>
    magic_init();

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Initialize each protocol.
</span><span style="color:#f00;font-style:italic">    */</span>
    <span style="color:#00f">for</span>(i=0;(protp=protocols[i])!= NULL;++i) <span style="color:#f00;font-style:italic">//protocols[]是全局变量的协议数组
</span><span style="color:#f00;font-style:italic"></span>    	(*protp-&gt;init)(0); <span style="color:#f00;font-style:italic">//初始化协议数组中所有协议
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Initialize the default channel.
</span><span style="color:#f00;font-style:italic">    */</span>
    tty_init(); <span style="color:#f00;font-style:italic">//channel初始化，默认就是全局的tty_channel，里面包括很多TTY函数指针
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!options_from_file(_PATH_SYSOPTIONS,!privileged,0,1)<span style="color:#f00;font-style:italic">//解析/etc/ppp/options中的参数
</span><span style="color:#f00;font-style:italic"></span>
    ||!options_from_user()

    ||!parse_args(argc-1,argv+1)) <span style="color:#f00;font-style:italic">//解析PPPD命令行参数
</span><span style="color:#f00;font-style:italic"></span>
    exit(EXIT_OPTION_ERROR);

    devnam_fixed=1;       <span style="color:#f00;font-style:italic">/* can no longer change device name */</span>

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Work out the device name, if it hasn&#39;t already been specified,
</span><span style="color:#f00;font-style:italic">    * and parse the tty&#39;s options file.
</span><span style="color:#f00;font-style:italic">    */</span>
    <span style="color:#00f">if</span>(the_channel-&gt;process_extra_options)

    (*the_channel-&gt;process_extra_options)(); <span style="color:#f00;font-style:italic">//实际上是调用tty_process_extra_options解析TTY 参数
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!ppp_available()){ <span style="color:#f00;font-style:italic">//检测/dev/ppp设备文件是否有效
</span><span style="color:#f00;font-style:italic"></span>    	option_error(<span style="color:#009c00">&#34;%s&#34;</span>,no_ppp_msg);
    	exit(EXIT_NO_KERNEL_SUPPORT);
    }

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Check that the options given are valid and consistent.
</span><span style="color:#f00;font-style:italic">    */</span>
    check_options(); <span style="color:#f00;font-style:italic">//检查选项参数
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!sys_check_options()) <span style="color:#f00;font-style:italic">//检测系统参数，比如内核是否支持Multilink等
</span><span style="color:#f00;font-style:italic"></span>    	exit(EXIT_OPTION_ERROR);

    auth_check_options(); <span style="color:#f00;font-style:italic">//检查认证相关的参数
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#ifdef HAVE_MULTILINK
</span><span style="color:#f00;font-style:italic"></span>    mp_check_options();
<span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">for</span>(i=0;(protp=protocols[i])!= NULL;++i)

    <span style="color:#00f">if</span>(protp-&gt;check_options!= NULL)

    (*protp-&gt;check_options)(); <span style="color:#f00;font-style:italic">//检查每个控制协议的参数配置
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(the_channel-&gt;check_options)

    (*the_channel-&gt;check_options)(); <span style="color:#f00;font-style:italic">//实际上是调用tty_check_options检测TTY参数
</span><span style="color:#f00;font-style:italic"></span>
……

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Detach ourselves from the terminal, if required,
</span><span style="color:#f00;font-style:italic">    * and identify who is running us.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">if</span>(!nodetach&amp;&amp;!updetach)

    detach(); <span style="color:#f00;font-style:italic">//默认放在后台以daemon执行，也可配置/etc/ppp/option中的nodetach参数放在前台执行
</span><span style="color:#f00;font-style:italic"></span>
……

    syslog(LOG_NOTICE,<span style="color:#009c00">&#34;pppd %s started by %s, uid %d&#34;</span>,VERSION,p,uid); <span style="color:#f00;font-style:italic">//熟悉的log，现在准备执行了
</span><span style="color:#f00;font-style:italic"></span>
    script_setenv(<span style="color:#009c00">&#34;PPPLOGNAME&#34;</span>,p,0);

    <span style="color:#00f">if</span>(devnam[0])

    script_setenv(<span style="color:#009c00">&#34;DEVICE&#34;</span>,devnam,1);

    slprintf(numbuf,<span style="color:#00f">sizeof</span>(numbuf),<span style="color:#009c00">&#34;%d&#34;</span>,getpid());

    script_setenv(<span style="color:#009c00">&#34;PPPD_PID&#34;</span>,numbuf,1);

    setup_signals(); <span style="color:#f00;font-style:italic">//设置信号处理函数
</span><span style="color:#f00;font-style:italic"></span>
    create_linkpidfile(getpid()); <span style="color:#f00;font-style:italic">//创建PID文件
</span><span style="color:#f00;font-style:italic"></span>
    waiting=0;

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * If we&#39;re doing dial-on-demand, set up the interface now.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">if</span>(demand){ <span style="color:#f00;font-style:italic">//以按需拨号方式运行，可配置
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Open the loopback channel and set it up to be the ppp interface.
</span><span style="color:#f00;font-style:italic">    */</span>

    fd_loop=open_ppp_loopback(); <span style="color:#f00;font-style:italic">//详见下面分析
</span><span style="color:#f00;font-style:italic"></span>
    set_ifunit(1); <span style="color:#f00;font-style:italic">//设置IFNAME环境变量为接口名称如ppp0
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Configure the interface and mark it up, etc.
</span><span style="color:#f00;font-style:italic">    */</span>

    demand_conf();
(第二阶段)……
}
</code></pre></div><p>PPP协议里包括各种控制协议如LCP，PAP，CHAP，IPCP等，这些控制协议都有很多共同的地方，因此PPPD将每个控制协议都用结构protent表示，并放在控制协议数组protocols[]中，一般常用的是LCP，PAP，CHAP，IPCP这四个协议。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* PPP Data Link Layer &#34;protocol&#34; table.
</span><span style="color:#f00;font-style:italic">* One entry per supported protocol.
</span><span style="color:#f00;font-style:italic">* The last entry must be NULL.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">struct</span> protent*protocols[]={
    &amp;lcp_protent, <span style="color:#f00;font-style:italic">//LCP协议
</span><span style="color:#f00;font-style:italic"></span>    &amp;pap_protent, <span style="color:#f00;font-style:italic">//PAP协议
</span><span style="color:#f00;font-style:italic"></span>    &amp;chap_protent, <span style="color:#f00;font-style:italic">//CHAP协议
</span><span style="color:#f00;font-style:italic"></span><span style="color:#f00;font-style:italic">#ifdef CBCP_SUPPORT
</span><span style="color:#f00;font-style:italic"></span>    &amp;cbcp_protent,
<span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>
    &amp;ipcp_protent, <span style="color:#f00;font-style:italic">//IPCP协议,IPv4
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#ifdef INET6
</span><span style="color:#f00;font-style:italic"></span>    &amp;ipv6cp_protent, <span style="color:#f00;font-style:italic">//IPCP协议,IPv6
</span><span style="color:#f00;font-style:italic"></span><span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>
    &amp;ccp_protent,
    &amp;ecp_protent,

<span style="color:#f00;font-style:italic">#ifdef IPX_CHANGE
</span><span style="color:#f00;font-style:italic"></span>    &amp;ipxcp_protent,
<span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#ifdef AT_CHANGE
</span><span style="color:#f00;font-style:italic"></span>    &amp;atcp_protent,
<span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>
    &amp;eap_protent,
    NULL
};
</code></pre></div><p>每个控制协议由protent结构来表示，此结构包含每个协议处理用到的函数指针：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* The following struct gives the addresses of procedures to call
</span><span style="color:#f00;font-style:italic">* for a particular protocol.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">struct</span> protent{
    u_short protocol;            <span style="color:#f00;font-style:italic">/* PPP protocol number */</span>

    <span style="color:#f00;font-style:italic">/* Initialization procedure */</span>
    <span style="color:#00f">void</span>(*init)__P((<span style="color:#00f">int</span> unit));  <span style="color:#f00;font-style:italic">//初始化指针,在main()中被调用
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Process a received packet */</span>
    <span style="color:#00f">void</span>(*input)__P((<span style="color:#00f">int</span> unit, u_char *pkt,<span style="color:#00f">int</span> len)); <span style="color:#f00;font-style:italic">//接收报文处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Process a received protocol-reject */</span>
    <span style="color:#00f">void</span>(*protrej)__P((<span style="color:#00f">int</span> unit));  <span style="color:#f00;font-style:italic">//协议错误处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Lower layer has come up */</span>
    <span style="color:#00f">void</span>(*lowerup)__P((<span style="color:#00f">int</span> unit));  <span style="color:#f00;font-style:italic">//当下层协议UP起来后的处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Lower layer has gone down */</span>
    <span style="color:#00f">void</span>(*lowerdown)__P((<span style="color:#00f">int</span> unit));  <span style="color:#f00;font-style:italic">//当下层协议DOWN后的处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Open the protocol */</span>
    <span style="color:#00f">void</span>(*open)__P((<span style="color:#00f">int</span> unit));  <span style="color:#f00;font-style:italic">//打开协议
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Close the protocol */</span>
    <span style="color:#00f">void</span>(*close)__P((<span style="color:#00f">int</span> unit,<span style="color:#00f">char</span>*reason)); <span style="color:#f00;font-style:italic">//关闭协议
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Print a packet in readable form */</span>
    <span style="color:#00f">int</span> (*printpkt)__P((u_char*pkt,<span style="color:#00f">int</span> len,

    <span style="color:#00f">void</span>(*printer)__P((<span style="color:#00f">void</span>*,<span style="color:#00f">char</span>*,...)),

    <span style="color:#00f">void</span>*arg)); <span style="color:#f00;font-style:italic">//打印报文信息，调试用。
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Process a received data packet */</span>

    <span style="color:#00f">void</span>(*datainput)__P((<span style="color:#00f">int</span> unit, u_char *pkt,<span style="color:#00f">int</span> len)); <span style="color:#f00;font-style:italic">//处理已收到的数据包
</span><span style="color:#f00;font-style:italic"></span>
    boolenabled_flag;         <span style="color:#f00;font-style:italic">/* 0 iff protocol is disabled */</span>

    <span style="color:#00f">char</span>*name;                  <span style="color:#f00;font-style:italic">/* Text name of protocol */</span>

    <span style="color:#00f">char</span>*data_name;          <span style="color:#f00;font-style:italic">/* Text name of corresponding data protocol */</span>

    option_t*options;        <span style="color:#f00;font-style:italic">/* List of command-line options */</span>

    <span style="color:#f00;font-style:italic">/* Check requested options, assign defaults */</span>
    <span style="color:#00f">void</span>(*check_options)__P((<span style="color:#00f">void</span>)); <span style="color:#f00;font-style:italic">//检测和此协议有关的选项参数
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Configure interface for demand-dial */</span>
    <span style="color:#00f">int</span> (*demand_conf)__P((<span style="color:#00f">int</span> unit));  <span style="color:#f00;font-style:italic">//将接口配置为按需拨号需要做的 动作
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Say whether to bring up link for this pkt */</span>
    <span style="color:#00f">int</span> (*active_pkt)__P((u_char*pkt,<span style="color:#00f">int</span> len)); <span style="color:#f00;font-style:italic">//判断报文类型并激活链路
</span><span style="color:#f00;font-style:italic"></span>
};
</code></pre></div><p>在main()函数中会调用所有支持的控制协议的初始化函数init()，之后初始化TTY channel，解析配置文件或命令行参数，接着检测内核是否支持PPP驱动：</p>
<p>pppd/sys_linux.c</p>
<p>main() -&gt; ppp_avaiable():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">ppp_available</span>(<span style="color:#00f">void</span>)
{

……

    no_ppp_msg=

    <span style="color:#009c00">&#34;This system lacks kernel support for PPP. This could be because</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>
    <span style="color:#009c00">&#34;the PPP kernel module could not be loaded, or because PPP was not</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>
    <span style="color:#009c00">&#34;included in the kernel configuration. If PPP was included as a</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>
    <span style="color:#009c00">&#34;module, try `/sbin/modprobe -v ppp&#39;. If that fails, check that</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>
    <span style="color:#009c00">&#34;ppp.o exists in /lib/modules/`uname -r`/net.</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>
    <span style="color:#009c00">&#34;See README.linux file in the ppp distribution for more details.</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>;

    <span style="color:#f00;font-style:italic">/* get the kernel version now, since we are called before sys_init */</span>

    uname(&amp;utsname);

    osmaj=osmin=ospatch=0;

    sscanf(utsname.release,<span style="color:#009c00">&#34;%d.%d.%d&#34;</span>,&amp;osmaj,&amp;osmin,&amp;ospatch);

kernel_version=KVERSION(osmaj,osmin,ospatch);

    fd=open(<span style="color:#009c00">&#34;/dev/ppp&#34;</span>, O_RDWR);

    <span style="color:#00f">if</span>(fd&gt;=0){

    new_style_driver=1; <span style="color:#f00;font-style:italic">//支持PPPK
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* XXX should get from driver */</span>

    driver_version=2;

    driver_modification=4;

    driver_patch=0;

    close(fd);

    return1;

}

……

}
</code></pre></div><p>函数ppp_available会尝试打开/dev/ppp设备文件来判断PPP驱动是否已加载在内核中，如果此设备文件不能打开则通过uname判断内核版本号来区分当前内核版本是否支持PPP驱动，要是内核版本很老(2.3.x以下)，则打开PTY设备文件并设置PPP线路规程。目前常用的内核版本基本上都是2.6以上，绝大多数情况下使用的内核都支持PPP驱动，因此本文不分析使用PTY的old driver部分。</p>
<p>接下来会检查选项的合法性，这些选项可以来自于配置文件/etc/ppp/options，也可以是命令行参数，PPPD里面对选项的处理比较多，这里不一一分析了。</p>
<p>后面是把PPPD以daemon方式执行或保持在前台运行并设置一些环境变量和信号处理函数，最后进入到第一个关键部分，当demand这个变量为1时，表示PPPD以按需拨号方式运行。</p>
<p>什么是按需拨号呢？如果大家用过无线路由器就知道，一般PPPoE拨号配置页面都会有一个“按需拨号”的选项，若没有到外部网络的数据流，PPP链路就不会建立，当检测到有流量访问外部网络时，PPP就开始拨号和ISP的拨号服务器建立连接，拨号成功后才产生计费。反之，如果在一定时间内没有访问外网的流量，PPP就会断开连接，为用户节省流量费用。在宽带网络普及的今天，宽带费用基本上都是包月收费了，对家庭宽带用户此功能意义不大。不过对于3G/4G网络这种按流量收费的数据访问方式，按需拨号功能还是有其用武之地。</p>
<p>PPP的按需拨号功能如何实现的呢？首先调用open_ppp_loopback：</p>
<p>pppd/sys-linux.c</p>
<p>main() -&gt; open_ppp_loopback():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span>
<span style="color:#c34e00">open_ppp_loopback</span>(<span style="color:#00f">void</span>)
{

    intflags;

    looped=1; <span style="color:#f00;font-style:italic">//设置全局变量looped为1，后面会用到
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(new_style_driver){

    <span style="color:#f00;font-style:italic">/* allocate ourselves a ppp unit */</span>

    <span style="color:#00f">if</span>(make_ppp_unit()&lt;0) <span style="color:#f00;font-style:italic">//创建PPP网络接口
</span><span style="color:#f00;font-style:italic"></span>
    die(1);

    modify_flags(ppp_dev_fd,0, SC_LOOP_TRAFFIC); <span style="color:#f00;font-style:italic">//通过ioctl设置SC_LOOP_TRAFFIC
</span><span style="color:#f00;font-style:italic"></span>
    set_kdebugflag(kdebugflag);

    ppp_fd=-1;

    returnppp_dev_fd;

    }

……(下面是old driver，忽略)

}
</code></pre></div><p>全局变量new_style_driver，这个变量已经在ppp_avaliable函数里被设置为1了。接下来调用make_ppp_unit打开/dev/ppp设备文件并请求建立一个新的unit。</p>
<p>pppd/sys-linux.c</p>
<p>main() -&gt; open_ppp_loopback() -&gt; make_ppp_unit():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">make_ppp_unit</span>()
{
    <span style="color:#00f">int</span> x,flags;

    <span style="color:#00f">if</span>(ppp_dev_fd&gt;=0){ <span style="color:#f00;font-style:italic">//如果已经打开过，先关闭
</span><span style="color:#f00;font-style:italic"></span>    	dbglog(<span style="color:#009c00">&#34;in make_ppp_unit, already had /dev/ppp open?&#34;</span>);
    	close(ppp_dev_fd);
    }

    ppp_dev_fd=open(<span style="color:#009c00">&#34;/dev/ppp&#34;</span>, O_RDWR);  <span style="color:#f00;font-style:italic">//打开/dev/ppp
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ppp_dev_fd&lt;0)

    fatal(<span style="color:#009c00">&#34;Couldn&#39;t open /dev/ppp: %m&#34;</span>);

    flags=fcntl(ppp_dev_fd, F_GETFL);

    <span style="color:#00f">if</span>(flags==-1

    ||fcntl(ppp_dev_fd, F_SETFL,flags| O_NONBLOCK)==-1) <span style="color:#f00;font-style:italic">//设置为非阻塞
</span><span style="color:#f00;font-style:italic"></span>
    warn(<span style="color:#009c00">&#34;Couldn&#39;t set /dev/ppp to nonblock: %m&#34;</span>);

    ifunit=req_unit; <span style="color:#f00;font-style:italic">//传入请求的unit number，可通过/etc/ppp/options配置
</span><span style="color:#f00;font-style:italic"></span>
    x=ioctl(ppp_dev_fd, PPPIOCNEWUNIT,&amp;ifunit); <span style="color:#f00;font-style:italic">//请求建立一个新unit
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(x&lt;0&amp;&amp;req_unit&gt;=0&amp;&amp; errno == EEXIST){

    warn(<span style="color:#009c00">&#34;Couldn&#39;t allocate PPP unit %d as it is already in use&#34;</span>,req_unit);

    ifunit=-1;

    x=ioctl(ppp_dev_fd, PPPIOCNEWUNIT,&amp;ifunit);

    }

    <span style="color:#00f">if</span>(x&lt;0)

    error(<span style="color:#009c00">&#34;Couldn&#39;t create new ppp unit: %m&#34;</span>);

    returnx;
}
</code></pre></div><p>这里的unit可以理解为一个PPP接口，在Linux中通过ifconfig看到的ppp0就是通过ioctl(ppp_dev_fd, PPPIOCNEWUNIT, &amp;ifunit)建立起来的，unit number是可以配置的，不过一般都不用配置，传入-1会自动分配一个未使用的unit number，默认从0开始。这个ioctl调用的是PPPK中注册的ppp_ioctl：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; open_ppp_loopback() -&gt; make_ppp_unit() -&gt; ioctl(ppp_dev_fd,PPPIOCNEWUNIT,&amp;ifunit) -&gt; ppp_ioctl():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">ppp_ioctl</span>(<span style="color:#00f">struct</span> inode *inode,<span style="color:#00f">struct</span> file *file,
    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> cmd, <span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">struct</span> ppp_file*pf=file-&gt;private_data;

……

    <span style="color:#00f">if</span>(pf==0)

    returnppp_unattached_ioctl(pf,file,cmd,arg);
</code></pre></div><p>TIPS：这里还要解释一下PPPK中channel和unit的关系，一个channel相当于一个物理链路，而unit相当于一个接口。在Multilink PPP中，一个unit可以由多个channel组合而成，也就是说一个PPP接口下面可以有多个物理链路，这里的物理链路不一定是物理接口，也可以是一个物理接口上的多个频段（channel）比如HDLC channel。</p>
<p>PPPK中channel用结构channel表示，unit用结构ppp表示。</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Data structure describing one ppp unit.
</span><span style="color:#f00;font-style:italic">* A ppp unit corresponds to a ppp network interface device
</span><span style="color:#f00;font-style:italic">* and represents a multilink bundle.
</span><span style="color:#f00;font-style:italic">* It can have 0 or more ppp channels connected to it.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">struct</span> ppp{
    <span style="color:#00f">struct</span> ppp_file     file;        <span style="color:#f00;font-style:italic">/* stuff for read/write/poll 0 */</span>
    <span style="color:#00f">struct</span> file*owner;        <span style="color:#f00;font-style:italic">/* file that owns this unit 48 */</span>
    <span style="color:#00f">struct</span> list_headchannels;   <span style="color:#f00;font-style:italic">/* list of attached channels 4c */</span>
    <span style="color:#00f">int</span>          n_channels;   <span style="color:#f00;font-style:italic">/* how many channels are attached 54 */</span>
    spinlock_t    rlock;            <span style="color:#f00;font-style:italic">/* lock for receive side 58 */</span>
    spinlock_t    wlock;           <span style="color:#f00;font-style:italic">/* lock for transmit side 5c */</span>
    <span style="color:#00f">int</span>          mru;             <span style="color:#f00;font-style:italic">/* max receive unit 60 */</span>
    unsignedint   flags;            <span style="color:#f00;font-style:italic">/* control bits 64 */</span>
    unsignedint   xstate;          <span style="color:#f00;font-style:italic">/* transmit state bits 68 */</span>
    unsignedint   rstate;           <span style="color:#f00;font-style:italic">/* receive state bits 6c */</span>
    <span style="color:#00f">int</span>          debug;          <span style="color:#f00;font-style:italic">/* debug flags 70 */</span>
    <span style="color:#00f">struct</span> slcompress*vj;        <span style="color:#f00;font-style:italic">/* state for VJ header compression */</span>
    enumNPmode    npmode[NUM_NP];<span style="color:#f00;font-style:italic">/* what to do with each net proto 78 */</span>
    <span style="color:#00f">struct</span> sk_buff*xmit_pending;     <span style="color:#f00;font-style:italic">/* a packet ready to go out 88 */</span>
    <span style="color:#00f">struct</span> compressor*xcomp;<span style="color:#f00;font-style:italic">/* transmit packet compressor 8c */</span>
    <span style="color:#00f">void</span>*xc_state;     <span style="color:#f00;font-style:italic">/* its internal state 90 */</span>
    <span style="color:#00f">struct</span> compressor*rcomp; <span style="color:#f00;font-style:italic">/* receive decompressor 94 */</span>
    <span style="color:#00f">void</span>*rc_state;      <span style="color:#f00;font-style:italic">/* its internal state 98 */</span>
    unsignedlonglast_xmit;      <span style="color:#f00;font-style:italic">/* jiffies when last pkt sent 9c */</span>
    unsignedlonglast_recv;      <span style="color:#f00;font-style:italic">/* jiffies when last pkt rcvd a0 */</span>
    <span style="color:#00f">struct</span> net_device*dev;             <span style="color:#f00;font-style:italic">/* network interface device a4 */</span>

<span style="color:#f00;font-style:italic">#ifdef CONFIG_PPP_MULTILINK
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">int</span>          nxchan;         <span style="color:#f00;font-style:italic">/* next channel to send something on */</span>
    u32         nxseq;          <span style="color:#f00;font-style:italic">/* next sequence number to send */</span>
    <span style="color:#00f">int</span>          mrru;            <span style="color:#f00;font-style:italic">/* MP: max reconst. receive unit */</span>
    u32         nextseq; <span style="color:#f00;font-style:italic">/* MP: seq no of next packet */</span>
    u32         minseq;         <span style="color:#f00;font-style:italic">/* MP: min of most recent seqnos */</span>
    <span style="color:#00f">struct</span> sk_buff_head mrq;   <span style="color:#f00;font-style:italic">/* MP: receive reconstruction queue */</span>
<span style="color:#f00;font-style:italic">#endif</span><span style="color:#f00;font-style:italic">/* CONFIG_PPP_MULTILINK */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">struct</span> net_device_statsstats;     <span style="color:#f00;font-style:italic">/* statistics */</span>

<span style="color:#f00;font-style:italic">#ifdef CONFIG_PPP_FILTER
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">struct</span> sock_filter*pass_filter;    <span style="color:#f00;font-style:italic">/* filter for packets to pass */</span>
    <span style="color:#00f">struct</span> sock_filter*active_filter;<span style="color:#f00;font-style:italic">/* filter for pkts to reset idle */</span>
    <span style="color:#00f">unsigned</span> pass_len, active_len;
<span style="color:#f00;font-style:italic">#endif</span><span style="color:#f00;font-style:italic">/* CONFIG_PPP_FILTER */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
};

<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Private data structure for each channel.
</span><span style="color:#f00;font-style:italic">* This includes the data structure used for multilink.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">struct</span> channel{
    <span style="color:#00f">struct</span> ppp_file     file;        <span style="color:#f00;font-style:italic">/* stuff for read/write/poll */</span>
    <span style="color:#00f">struct</span> list_headlist;            <span style="color:#f00;font-style:italic">/* link in all/new_channels list */</span>
    <span style="color:#00f">struct</span> ppp_channel*chan;  <span style="color:#f00;font-style:italic">/* public channel data structure */</span>
    <span style="color:#00f">struct</span> rw_semaphorechan_sem;<span style="color:#f00;font-style:italic">/* protects `chan&#39; during chan ioctl */</span>
    spinlock_t    downl;           <span style="color:#f00;font-style:italic">/* protects `chan&#39;, file.xq dequeue */</span>
    <span style="color:#00f">struct</span> ppp*ppp;            <span style="color:#f00;font-style:italic">/* ppp unit we&#39;re connected to */</span>
    <span style="color:#00f">struct</span> list_headclist;          <span style="color:#f00;font-style:italic">/* link in list of channels per unit */</span>
    rwlock_t      upl;        <span style="color:#f00;font-style:italic">/* protects `ppp&#39; */</span>

<span style="color:#f00;font-style:italic">#ifdef CONFIG_PPP_MULTILINK
</span><span style="color:#f00;font-style:italic"></span>    u8           avail;            <span style="color:#f00;font-style:italic">/* flag used in multilink stuff */</span>
    u8           had_frag;      <span style="color:#f00;font-style:italic">/* &gt;= 1 fragments have been sent */</span>
    u32         lastseq;  <span style="color:#f00;font-style:italic">/* MP: last sequence # received */</span>
<span style="color:#f00;font-style:italic">#endif</span><span style="color:#f00;font-style:italic">/* CONFIG_PPP_MULTILINK */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
};

<span style="color:#00f">struct</span> ppp_file{
    <span style="color:#00f">enum</span>{
    	INTERFACE=1,CHANNEL
    }           kind; <span style="color:#f00;font-style:italic">//代表打开的/dev/ppp类型是channel还是unit
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">struct</span> sk_buff_headxq;          <span style="color:#f00;font-style:italic">/* pppd transmit queue */</span>
    <span style="color:#00f">struct</span> sk_buff_headrq;          <span style="color:#f00;font-style:italic">/* receive queue for pppd */</span>
    wait_queue_head_t rwait;		<span style="color:#f00;font-style:italic">/* for poll on reading /dev/ppp */</span>

    atomic_t       refcnt;          <span style="color:#f00;font-style:italic">/* # refs (incl /dev/ppp attached) */</span>
    <span style="color:#00f">int</span>         hdrlen;         	<span style="color:#f00;font-style:italic">/* space to leave for headers */</span>
    <span style="color:#00f">int</span>         index;         	 	<span style="color:#f00;font-style:italic">/* interface unit / channel number */</span>
    <span style="color:#00f">int</span>         dead;          	 	<span style="color:#f00;font-style:italic">/* unit/channel has been shut down */</span>
};
</code></pre></div><p>注意这两个结构体的第一个字段都是structppp_file，ppp_file的kind字段代表/dev/ppp的类型。</p>
<p>现在回到ppp_ioctl，它的执行要判定三种情况，没有任何绑定，绑定到PPP unit或绑定到PPP channel，在初始化时并没有任何绑定即file-&gt;private_data为空，因此这里会调用ppp_unattached_ioctl：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; open_ppp_loopback() -&gt; make_ppp_unit() -&gt; ioctl(ppp_dev_fd,PPPIOCNEWUNIT,&amp;ifunit) -&gt; ppp_ioctl() –&gt; ppp_unattached_ioctl():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">ppp_unattached_ioctl</span>(<span style="color:#00f">struct</span> ppp_file *pf,<span style="color:#00f">struct</span> file *file,
    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> cmd,<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">int</span> unit ,err = -EFAULT;
    <span style="color:#00f">struct</span> ppp*ppp;
    <span style="color:#00f">struct</span> channel*chan;

    int__user*p=(int__user*)arg;

    <span style="color:#00f">switch</span>(cmd){

    casePPPIOCNEWUNIT:

    <span style="color:#f00;font-style:italic">/* Create a new ppp unit */</span>

    <span style="color:#00f">if</span>(get_user(unit, p))

    <span style="color:#00f">break</span>;

    ppp=ppp_create_interface(unit,&amp;err); <span style="color:#f00;font-style:italic">//创建ppp网络接口
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ppp==0)

    <span style="color:#00f">break</span>;

    file-&gt;private_data=&amp;ppp-&gt;file; <span style="color:#f00;font-style:italic">//注意：现在绑定到了PPP unit，指向的是struct ppp_file结构
</span><span style="color:#f00;font-style:italic"></span>
    ppp-&gt;owner=file;

    err=-EFAULT;

    <span style="color:#00f">if</span>(put_user(ppp-&gt;file.index,p))

    <span style="color:#00f">break</span>;

    err=0;

    <span style="color:#00f">break</span>;
</code></pre></div><p>这个函数又会调用ppp_create_interface创建一个ppp网络接口：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; open_ppp_loopback() -&gt; make_ppp_unit() -&gt; ioctl(ppp_dev_fd,PPPIOCNEWUNIT,&amp;ifunit) -&gt; ppp_ioctl() –&gt; ppp_unattached_ioctl()-&gt; ppp_create_interface():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Create a new ppp interface unit.  Fails if it can&#39;t allocate memory
</span><span style="color:#f00;font-style:italic">* or if there is already a unit with the requested number.
</span><span style="color:#f00;font-style:italic">* unit == -1 means allocate a new number.
</span><span style="color:#f00;font-style:italic"> */</span>

staticstruct ppp*

<span style="color:#c34e00">ppp_create_interface</span>(intunit,<span style="color:#00f">int</span>*retp)
{

    <span style="color:#00f">struct</span> ppp*ppp;
    <span style="color:#00f">struct</span> net_device*dev=NULL;
    <span style="color:#00f">int</span> ret=-ENOMEM;
    inti;

    ppp=kzalloc(<span style="color:#00f">sizeof</span>(<span style="color:#00f">struct</span> ppp), GFP_KERNEL); <span style="color:#f00;font-style:italic">//分配struct ppp即新建一个unit
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!ppp)

    gotoout;

    dev=alloc_netdev(0,<span style="color:#009c00">&#34;&#34;</span>,ppp_setup); <span style="color:#f00;font-style:italic">//分配net_device，这个结构表示一个网络接口
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!dev)

    gotoout1;

    ppp-&gt;mru=PPP_MRU; <span style="color:#f00;font-style:italic">//初始化MRU（最大接收单元）
</span><span style="color:#f00;font-style:italic"></span>
    init_ppp_file(&amp;ppp-&gt;file,INTERFACE); <span style="color:#f00;font-style:italic">//初始化ppp_file结构，类型为INTERFACE
</span><span style="color:#f00;font-style:italic"></span>
    ppp-&gt;file.hdrlen=PPP_HDRLEN-2;   <span style="color:#f00;font-style:italic">/* don&#39;t count proto bytes */</span>

    <span style="color:#00f">for</span>(i=0;i&lt;NUM_NP;++i)
    ppp-&gt;npmode[i]=NPMODE_PASS;

    INIT_LIST_HEAD(&amp;ppp-&gt;channels); <span style="color:#f00;font-style:italic">//PPP接口中的channel链表
</span><span style="color:#f00;font-style:italic"></span>    spin_lock_init(&amp;ppp-&gt;rlock); <span style="color:#f00;font-style:italic">//接收队列的锁
</span><span style="color:#f00;font-style:italic"></span>    spin_lock_init(&amp;ppp-&gt;wlock); <span style="color:#f00;font-style:italic">//发送队列的锁
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#ifdef CONFIG_PPP_MULTILINK
</span><span style="color:#f00;font-style:italic"></span>    ppp-&gt;minseq=-1;
    skb_queue_head_init(&amp;ppp-&gt;mrq);
<span style="color:#f00;font-style:italic">#endif</span><span style="color:#f00;font-style:italic">/* CONFIG_PPP_MULTILINK */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
    ppp-&gt;dev=dev; <span style="color:#f00;font-style:italic">//指向分配的net_device结构
</span><span style="color:#f00;font-style:italic"></span>    dev-&gt;priv=ppp; <span style="color:#f00;font-style:italic">//ppp网络接口的私有结构就是struct ppp
</span><span style="color:#f00;font-style:italic"></span>    dev-&gt;hard_start_xmit=ppp_start_xmit; <span style="color:#f00;font-style:italic">//ppp网络接口数据包发送函数，被TCP/IP协议栈调用
</span><span style="color:#f00;font-style:italic"></span>
    dev-&gt;get_stats=ppp_net_stats; <span style="color:#f00;font-style:italic">//收发数据包统计
</span><span style="color:#f00;font-style:italic"></span>    dev-&gt;do_ioctl=ppp_net_ioctl; <span style="color:#f00;font-style:italic">//对ppp网络接口调用ioctl()时使用
</span><span style="color:#f00;font-style:italic"></span>    ret=-EEXIST;

    mutex_lock(&amp;all_ppp_mutex); <span style="color:#f00;font-style:italic">//互斥操作，由于从进程进来的，要用可睡眠的mutex
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(unit&lt;0) <span style="color:#f00;font-style:italic">//unit传入-1表示自动分配未使用的unit number
</span><span style="color:#f00;font-style:italic"></span>
    unit=cardmap_find_first_free(all_ppp_units);

    elseif(cardmap_get(all_ppp_units,unit)!=NULL)

    gotoout2;   <span style="color:#f00;font-style:italic">/* unit already exists */</span>

    <span style="color:#f00;font-style:italic">/* Initialize the new ppp unit */</span>

    ppp-&gt;file.index=unit; <span style="color:#f00;font-style:italic">//这里就是传送中的unit number
</span><span style="color:#f00;font-style:italic"></span>    sprintf(dev-&gt;name,<span style="color:#009c00">&#34;ppp%d&#34;</span>,unit); <span style="color:#f00;font-style:italic">//ppp后面加上unit number就是ppp接口名，如ppp0
</span><span style="color:#f00;font-style:italic"></span>    ret=register_netdev(dev); <span style="color:#f00;font-style:italic">//注册ppp网络接口，这时ifconfig才能看到这个接口
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ret!=0){
    	printk(KERN_ERR<span style="color:#009c00">&#34;PPP: couldn&#39;t register device %s (%d)</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,
    	dev-&gt;name, ret);
    	<span style="color:#00f">goto</span> out2;
    }

    atomic_inc(&amp;ppp_unit_count);

    ret=cardmap_set(&amp;all_ppp_units,unit,ppp);
    <span style="color:#00f">if</span>(ret!=0)
    <span style="color:#00f">goto</span> out3;
    
    mutex_unlock(&amp;all_ppp_mutex); <span style="color:#f00;font-style:italic">//互斥操作，解锁
</span><span style="color:#f00;font-style:italic"></span>    *retp=0;
    <span style="color:#00f">return</span> ppp;

……

}
</code></pre></div><p>OK，现在PPP网络接口已经创建起来了，例如建立的接口名为ppp0，这里的ppp0还只是一个“假接口”，其实到这里PPP的整个拨号过程根本就还没有开始，之所以建立这个接口只是为了让数据报文可以通过这个接口发送出去从而触发PPP拨号。</p>
<p>接下来回到PPPD的open_ppp_loopback，make_ppp_unit这时候成功返回后，还会调用modify_flags函数来设置标志位SC_LOOP_TRAFFIC，这个函数其实调用的还是ioctl()-&gt;ppp_ioctl()来设置的flag。</p>
<p>pppd/sys-linux.c</p>
<p>main() -&gt; open_ppp_loopback() –&gt; modify_flags():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">modify_flags</span>(<span style="color:#00f">int</span> fd,<span style="color:#00f">int</span> clear_bits,<span style="color:#00f">int</span> set_bits)
{
    <span style="color:#00f">int</span> flags;

    <span style="color:#00f">if</span>(ioctl(fd, PPPIOCGFLAGS,&amp;flags)==-1)
    	<span style="color:#00f">goto</span> err;

    flags=(flags&amp;~clear_bits)|set_bits;

    <span style="color:#00f">if</span>(ioctl(fd, PPPIOCSFLAGS,&amp;flags)==-1)
    	<span style="color:#00f">goto</span> err;

    return0;
</code></pre></div><p>标志位SC_LOOP_TRAFFIC相当的重要，当通过ppp0接口发送数据时，PPPK才会唤醒PPPD进程去建立真正的PPP连接。之前在内核中创建ppp接口时会注册一个接口数据包发送函数ppp_start_xmit，当网络程序通过ppp0接口发送数据时，TCP/IP协议栈最终会调用到此函数。这个函数的call trace为ppp_start_xmit() -&gt; ppp_xmit_process()-&gt; ppp_send_frame()：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_send_frame</span>(<span style="color:#00f">struct</span> ppp *ppp,<span style="color:#00f">struct</span> sk_buff *skb)
{

……

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * If we are waiting for traffic (demand dialling),
</span><span style="color:#f00;font-style:italic">    * queue it up for pppd to receive.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">if</span>(ppp-&gt;flags&amp;SC_LOOP_TRAFFIC){

    <span style="color:#00f">if</span>(ppp-&gt;file.rq.qlen&gt;PPP_MAX_RQLEN)

    gotodrop;

    skb_queue_tail(&amp;ppp-&gt;file.rq,skb); <span style="color:#f00;font-style:italic">//发送的数据包放在rq接收对列而不是发送队列！
</span><span style="color:#f00;font-style:italic"></span>
    wake_up_interruptible(&amp;ppp-&gt;file.rwait); <span style="color:#f00;font-style:italic">//唤醒PPPD进程!!!
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">return</span>;

    }

……

}
</code></pre></div><p>很显然，只要ppp-&gt;flags中SC_LOOP_TRAFFIC置位，就要做点特殊处理：把发送的数据包放在接收队列ppp-&gt;file.rq中而不是平常的发送队列，这是为啥呢？留待过会分解。唤醒PPPD进程进行处理，并没有将数据发送出去哦。</p>
<p>返回主函数main()中，当open_ppp_loopback调用返回后，其返回值同时被赋值给fd_loop代表/dev/ppp的文件描述符。此时，网络接口ppp0已创建好并注册到TCP/IP协议栈中，当然只有 ppp0接口还不够，我们还需要对ppp0接口做些配置，接着调用demand_conf：</p>
<p>pppd/demand.c</p>
<p>main() -&gt; demand_conf():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">void</span>
<span style="color:#c34e00">demand_conf</span>()
{
    inti;
    <span style="color:#00f">struct</span> protent*protp;

……
    netif_set_mtu(0,MIN(lcp_allowoptions[0].mru,PPP_MRU)); <span style="color:#f00;font-style:italic">//设置ppp0接口的MTU
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ppp_send_config(0,PPP_MRU,(u_int32_t)0,0,0)&lt;0

    ||ppp_recv_config(0,PPP_MRU,(u_int32_t)0,0,0)&lt;0)

    fatal(<span style="color:#009c00">&#34;Couldn&#39;t set up demand-dialled PPP interface: %m&#34;</span>);

……

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Call the demand_conf procedure for each protocol that&#39;s got one.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">for</span>(i=0;(protp=protocols[i])!= NULL;++i)

    <span style="color:#00f">if</span>(protp-&gt;enabled_flag&amp;&amp;protp-&gt;demand_conf!= NULL)

    <span style="color:#00f">if</span>(!((*protp-&gt;demand_conf)(0))) <span style="color:#f00;font-style:italic">//调用每个控制协议的demand_conf函数
</span><span style="color:#f00;font-style:italic"></span>
    die(1);

}
</code></pre></div><p>这个函数设置ppp0的MTU和MRU，然后调用每个控制协议的demand_conf函数。对于LCP，PAP，CHAP协议protp-&gt;demand_conf都为空， 只有IPCP协议有初始化这个函数指针：</p>
<p>pppd/ipcp.c</p>
<p>main() -&gt; demand_conf()-&gt; ip_demand_conf():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span>
<span style="color:#c34e00">ip_demand_conf</span>(u)
    <span style="color:#00f">int</span> u;
{

    ipcp_options*wo=&amp;ipcp_wantoptions[u];

    <span style="color:#00f">if</span>(wo-&gt;hisaddr==0){

    <span style="color:#f00;font-style:italic">/* make up an arbitrary address for the peer */</span>

    wo-&gt;hisaddr=htonl(0x0a707070+ifunit); <span style="color:#f00;font-style:italic">//对端地址
</span><span style="color:#f00;font-style:italic"></span>
    wo-&gt;accept_remote=1;

    }

    <span style="color:#00f">if</span>(wo-&gt;ouraddr==0){

    <span style="color:#f00;font-style:italic">/* make up an arbitrary address for us */</span>

    wo-&gt;ouraddr=htonl(0x0a404040+ifunit); <span style="color:#f00;font-style:italic">//本端地址
</span><span style="color:#f00;font-style:italic"></span>
    wo-&gt;accept_local=1;

    ask_for_local=0;     <span style="color:#f00;font-style:italic">/* don&#39;t tell the peer this address */</span>

    }

    <span style="color:#00f">if</span>(!sifaddr(u,wo-&gt;ouraddr,wo-&gt;hisaddr,GetMask(wo-&gt;ouraddr))) <span style="color:#f00;font-style:italic">//在ppp0接口上配置本端地址和对端地址及子网掩码
</span><span style="color:#f00;font-style:italic"></span>
    return0;

    <span style="color:#00f">if</span>(!sifup(u)) <span style="color:#f00;font-style:italic">//将ppp0接口设置为UP，接口类型为点对点。
</span><span style="color:#f00;font-style:italic"></span>
    return0;

    <span style="color:#00f">if</span>(!sifnpmode(u,PPP_IP,NPMODE_QUEUE))

    return0;

    <span style="color:#00f">if</span>(wo-&gt;default_route)

    <span style="color:#00f">if</span>(sifdefaultroute(u,wo-&gt;ouraddr,wo-&gt;hisaddr)) <span style="color:#f00;font-style:italic">//设置ppp0为默认网关接口
</span><span style="color:#f00;font-style:italic"></span>
    default_route_set[u]=1;

    <span style="color:#00f">if</span>(wo-&gt;proxy_arp)

    <span style="color:#00f">if</span>(sifproxyarp(u,wo-&gt;hisaddr))

    proxy_arp_set[u]=1;

    notice(<span style="color:#009c00">&#34;local IP address %I&#34;</span>,wo-&gt;ouraddr);

    notice(<span style="color:#009c00">&#34;remote IP address %I&#34;</span>,wo-&gt;hisaddr);

    return1;

}
</code></pre></div><p>上面提到在按需拨号模式下，要让数据报文通过ppp0接口发送才会触发PPP连接的建立。所以这里，IPCP协议块提供的ip_demand_conf函数就为ppp0配置了两个假的IP地址：本端IP地址为10.64.64.64，对端IP地址为10.112.112.112，并设置对端IP为默认网关。这样，当用户访问外部网络时，Linux路由子系统会选择ppp0接口发送数据包，从而触发PPP链路的建立。</p>
<p>第二阶段：</p>
<p>回到主函数main()中，接下来是最外层的for(;;)循环进行事件处理，</p>
<p>pppd/main.c -&gt; main():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">(第一阶段)……

    do_callback=0;

    <span style="color:#00f">for</span>(;;){ <span style="color:#f00;font-style:italic">/* 最外层for(;;)循环 */</span>

……

    doing_callback=do_callback;

    do_callback=0;

    <span style="color:#00f">if</span>(demand&amp;&amp;!doing_callback){<span style="color:#f00;font-style:italic">//按需拨号
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Don&#39;t do anything until we see some activity.
</span><span style="color:#f00;font-style:italic">    */</span>

    new_phase(PHASE_DORMANT); <span style="color:#f00;font-style:italic">//PPPD状态机
</span><span style="color:#f00;font-style:italic"></span>
    demand_unblock();

    add_fd(fd_loop); <span style="color:#f00;font-style:italic">//将fd_loop即/dev/ppp的文件描述符加入select的fds中
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">for</span>(;;){ <span style="color:#f00;font-style:italic">//嵌套for(;;)循环
</span><span style="color:#f00;font-style:italic"></span>
    handle_events(); <span style="color:#f00;font-style:italic">//select事件处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(asked_to_quit)

    <span style="color:#00f">break</span>;

    <span style="color:#00f">if</span>(get_loop_output()) <span style="color:#f00;font-style:italic">//发送数据有效就跳出循环
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

    }

    remove_fd(fd_loop); <span style="color:#f00;font-style:italic">//注意：要把/dev/ppp文件描述符从fds中remove掉，后面还会再加入
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(asked_to_quit)

    <span style="color:#00f">break</span>;

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Now we want to bring up the link.
</span><span style="color:#f00;font-style:italic">    */</span>

    demand_block();

    info(<span style="color:#009c00">&#34;Starting link&#34;</span>);

    }

(第三阶段)……

    }
</code></pre></div><p>如果是demand拨号模式，PPPD状态机进入PHASE_DORMANT， 主要包含两个部分：</p>
<ol>
<li>调用add_fd将/dev/ppp的文件描述符fd_loop加入in_fds中：</li>
</ol>
<p>pppd/sys-linux.c:</p>
<p>main() -&gt; add_fd():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* add_fd - add an fd to the set that wait_input waits for.
</span><span style="color:#f00;font-style:italic"> */</span>

voidadd_fd(intfd)

{

    <span style="color:#00f">if</span>(fd&gt;= FD_SETSIZE)

    fatal(<span style="color:#009c00">&#34;internal error: file descriptor too large (%d)&#34;</span>,fd);

    FD_SET(fd,&amp;in_fds);

    <span style="color:#00f">if</span>(fd&gt;max_in_fd)

    max_in_fd=fd;

}
</code></pre></div><ol start="2">
<li>在嵌套的for(;;)死循环里调用handle_events函数进行事件处理。</li>
</ol>
<p>pppd/main.c:</p>
<p>main() -&gt; handle_events():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* handle_events - wait for something to happen and respond to it.
</span><span style="color:#f00;font-style:italic"> */</span>

staticvoid

<span style="color:#c34e00">handle_events</span>()

{

    <span style="color:#00f">struct</span> timevaltimo;

    kill_link=open_ccp_flag=0;

    <span style="color:#00f">if</span>(sigsetjmp(sigjmp,1)==0){

    sigprocmask(SIG_BLOCK,&amp;signals_handled, NULL);

    <span style="color:#00f">if</span>(got_sighup||got_sigterm||got_sigusr2||got_sigchld){

    sigprocmask(SIG_UNBLOCK,&amp;signals_handled, NULL);

    }<span style="color:#00f">else</span>{

    waiting=1;

    sigprocmask(SIG_UNBLOCK,&amp;signals_handled, NULL);

    wait_input(timeleft(&amp;timo)); <span style="color:#f00;font-style:italic">//调用select进行I/O多路复用
</span><span style="color:#f00;font-style:italic"></span>
    }

    }

    waiting=0;

calltimeout(); <span style="color:#f00;font-style:italic">//调用注册的timer函数
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* 下面都是信号处理 */</span>

    <span style="color:#00f">if</span>(got_sighup){

    info(<span style="color:#009c00">&#34;Hangup (SIGHUP)&#34;</span>);

    kill_link=1;

    got_sighup=0;

    <span style="color:#00f">if</span>(status!=EXIT_HANGUP)

    status=EXIT_USER_REQUEST;

    }

    <span style="color:#00f">if</span>(got_sigterm){ <span style="color:#f00;font-style:italic">//收到SIGTERM信号时退出
</span><span style="color:#f00;font-style:italic"></span>
    info(<span style="color:#009c00">&#34;Terminating on signal %d&#34;</span>,got_sigterm);

    kill_link=1;

    asked_to_quit=1; <span style="color:#f00;font-style:italic">//注意
</span><span style="color:#f00;font-style:italic"></span>
    persist=0;

    status=EXIT_USER_REQUEST;

    got_sigterm=0;

    }

    <span style="color:#00f">if</span>(got_sigchld){

    got_sigchld=0;

    reap_kids(); <span style="color:#f00;font-style:italic">/* Don&#39;t leave dead kids lying around */</span>

    }

    <span style="color:#00f">if</span>(got_sigusr2){

    open_ccp_flag=1;

    got_sigusr2=0;

    }

}
</code></pre></div><p>这个函数里面重点是调用了wait_input对前面加入的/dev/ppp文件描述符调用select监听事件。</p>
<p>pppd/sys-linux.c:</p>
<p>main() -&gt; handle_events()-&gt; wait_input():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">void</span> <span style="color:#c34e00">wait_input</span>(<span style="color:#00f">struct</span> timeval*timo)

{

    fd_set ready,exc;

    intn;

    ready=in_fds; <span style="color:#f00;font-style:italic">//in_fds中包含有/dev/ppp的文件描述符
</span><span style="color:#f00;font-style:italic"></span>
    exc=in_fds;

    n=select(max_in_fd+1,&amp;ready, NULL,&amp;exc,timo); <span style="color:#f00;font-style:italic">//主菜在这里，调用select监听事件!!!
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(n&lt;0&amp;&amp; errno != EINTR)

    fatal(<span style="color:#009c00">&#34;select: %m&#34;</span>);

}
</code></pre></div><p>还记得吗，/dev/ppp在前面的make_ppp_unit函数中已经被设置为非阻塞，因此当没有事件发生时select调用不会一直阻塞下去，当超时时间到时wait_input会很快返回，calltimeout函数会被调用以处理注册的timer函数。这些timer函数是各控制协议及其fsm状态机需要用到的，从这里可以看出/dev/ppp被设置为非阻塞方式的必要性。</p>
<p>这个嵌套的for(;;)循环什么时候能跳出呢，这里有两个可能：</p>
<ol>
<li>变量asked_to_quit置为1。参考handle_events中对信号的处理，当收到SIGTERM时，表示用户想主动退出PPPD。</li>
<li>函数get_loop_output调用返回1。下面分析一下这个函数：</li>
</ol>
<p>pppd/sys-linux.c:</p>
<p>main() -&gt; get_loop_output():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/********************************************************************
</span><span style="color:#f00;font-style:italic">* 
</span><span style="color:#f00;font-style:italic">* get_loop_output - get outgoing packets from the ppp device,
</span><span style="color:#f00;font-style:italic">* and detect when we want to bring the real link up.
</span><span style="color:#f00;font-style:italic">* Return value is 1 if we need to bring up the link, 0 otherwise.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">int</span>

<span style="color:#c34e00">get_loop_output</span>(<span style="color:#00f">void</span>)

{

    intrv=0;

    intn;

    <span style="color:#00f">if</span>(new_style_driver){

    <span style="color:#00f">while</span>((n=read_packet(inpacket_buf))&gt;0) <span style="color:#f00;font-style:italic">//有数据通过ppp0发送
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(loop_frame(inpacket_buf,n))<span style="color:#f00;font-style:italic">//发送数据合法时为真
</span><span style="color:#f00;font-style:italic"></span>
    rv=1;<span style="color:#f00;font-style:italic">//返回1，导致嵌套的for(;;)循环退出
</span><span style="color:#f00;font-style:italic"></span>
    returnrv;

    }

……

}
</code></pre></div><p>首先调用read_packet读取数据到inpacket_buf中：</p>
<p>pppd/sys-linux.c:</p>
<p>main() -&gt; get_loop_output() -&gt; read_packet():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">read_packet</span>(unsignedchar*buf)
{

    <span style="color:#00f">int</span> len,nr;

    len=PPP_MRU+PPP_HDRLEN;

    <span style="color:#00f">if</span>(new_style_driver){
        *buf++=PPP_ALLSTATIONS;
        *buf++=PPP_UI;
        len-=2;
    }

    nr=-1;

    <span style="color:#00f">if</span>(ppp_fd&gt;=0){

    nr=read(ppp_fd,buf,len); <span style="color:#f00;font-style:italic">//读/dev/ppp
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(nr&lt;0&amp;&amp; errno != EWOULDBLOCK&amp;&amp; errno!= EAGAIN

    &amp;&amp; errno!= EIO&amp;&amp; errno!= EINTR)

    error(<span style="color:#009c00">&#34;read: %m&#34;</span>);

    <span style="color:#00f">if</span>(nr&lt;0&amp;&amp; errno == ENXIO)

    return0;

    }

    <span style="color:#00f">if</span>(nr&lt;0&amp;&amp;new_style_driver&amp;&amp;ppp_dev_fd&gt;=0&amp;&amp;!bundle_eof){

    <span style="color:#f00;font-style:italic">/* N.B. we read ppp_fd first since LCP packets come in there. */</span>

    nr=read(ppp_dev_fd,buf,len);

    <span style="color:#00f">if</span>(nr&lt;0&amp;&amp; errno != EWOULDBLOCK&amp;&amp; errno!= EAGAIN

    &amp;&amp; errno!= EIO&amp;&amp; errno!= EINTR)

    error(<span style="color:#009c00">&#34;read /dev/ppp: %m&#34;</span>);

    <span style="color:#00f">if</span>(nr&lt;0&amp;&amp; errno == ENXIO)

    nr=0;

    <span style="color:#00f">if</span>(nr==0&amp;&amp;doing_multilink){

    remove_fd(ppp_dev_fd);

    bundle_eof=1;

    }

    }

    <span style="color:#00f">if</span>(new_style_driver&amp;&amp;ppp_fd&lt;0&amp;&amp;ppp_dev_fd&lt;0)

    nr=0;

    <span style="color:#00f">return</span>(new_style_driver&amp;&amp;nr&gt;0)?nr+2:nr;

}
</code></pre></div><p>这个函数很简单，实际上就是调用标准的文件读函数read()读取/dev/ppp设备文件，其实就是调用到PPPK中的ppp_read：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; get_loop_output() -&gt; read_packet() -&gt; ppp_read():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#c34e00">ssize_tppp_read</span>(<span style="color:#00f">struct</span> file *file,char__user *buf,
    size_t count, loff_t *ppos)
{

    <span style="color:#00f">struct</span> ppp_file*pf=file-&gt;private_data;

    DECLARE_WAITQUEUE(wait, current);

    ssize_tret;

    <span style="color:#00f">struct</span> sk_buff*skb=NULL;

    ret=count;

    <span style="color:#00f">if</span>(pf==0)

    <span style="color:#00f">return</span>-ENXIO;

    add_wait_queue(&amp;pf-&gt;rwait,&amp;wait); <span style="color:#f00;font-style:italic">//注意：加入到等待队列，会被ppp_send_frame()唤醒
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">for</span>(;;){

    set_current_state(TASK_INTERRUPTIBLE); <span style="color:#f00;font-style:italic">//设置当前进程的状态为可中断睡眠
</span><span style="color:#f00;font-style:italic"></span>
    skb=skb_dequeue(&amp;pf-&gt;rq); <span style="color:#f00;font-style:italic">//从接收队列出队列一个数据包
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(skb) <span style="color:#f00;font-style:italic">//如果有数据包，表示有数据可读
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

    ret=0;

    <span style="color:#00f">if</span>(pf-&gt;dead) <span style="color:#f00;font-style:italic">//unit或channel已经不存在了，这里不讨论
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

    <span style="color:#00f">if</span>(pf-&gt;kind==INTERFACE){

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Return 0 (EOF) on an interface that has no
</span><span style="color:#f00;font-style:italic">    * channels connected, unless it is looping
</span><span style="color:#f00;font-style:italic">    * network traffic (demand mode).
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">struct</span> ppp*ppp=PF_TO_PPP(pf);

    <span style="color:#00f">if</span>(ppp-&gt;n_channels==0

    &amp;&amp;(ppp-&gt;flags&amp;SC_LOOP_TRAFFIC)==0)

    <span style="color:#00f">break</span>;

    }

    ret=-EAGAIN;

    <span style="color:#00f">if</span>(file-&gt;f_flags&amp; O_NONBLOCK)<span style="color:#f00;font-style:italic">//若fd为O_NONBLOCK，则不睡眠，直接跳出循环
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

    ret=-ERESTARTSYS;

    <span style="color:#00f">if</span>(signal_pending(current)) <span style="color:#f00;font-style:italic">//收到signal也不睡眠，直接跳出循环
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

    schedule(); <span style="color:#f00;font-style:italic">//进程调度器，让当前进程睡眠
</span><span style="color:#f00;font-style:italic"></span>
    }

    set_current_state(TASK_RUNNING);

    remove_wait_queue(&amp;pf-&gt;rwait,&amp;wait);

    <span style="color:#00f">if</span>(skb==0) <span style="color:#f00;font-style:italic">//能到这里表明fd为O_NONBLOCK或收到signal
</span><span style="color:#f00;font-style:italic"></span>
    gotoout;

    ret=-EOVERFLOW;

    <span style="color:#00f">if</span>(skb-&gt;len&gt;count)

    gotooutf;

    ret=-EFAULT;

    <span style="color:#00f">if</span>(copy_to_user(buf,skb-&gt;data,skb-&gt;len)) <span style="color:#f00;font-style:italic">//将数据拷贝到用户缓冲区
</span><span style="color:#f00;font-style:italic"></span>
    gotooutf;

    ret=skb-&gt;len; <span style="color:#f00;font-style:italic">//返回值就是数据长度
</span><span style="color:#f00;font-style:italic"></span>
 outf:

    kfree_skb(skb);

 out:

    returnret;

}
</code></pre></div><p>这个函数要把PPPD进程加入到等待队列中，若pf-&gt;rq队列不为空，则读取队列中的第一个数据包并立即返回。注意哦，上面提到当网络程序通过ppp0接口发送数据时，最终会调用内核函数ppp_send_frame，发送的数据则放在了该函数的ppp-&gt;file.rq队列中，这个队列就是这里的pf-&gt;rq队列，这就意味着ppp_read读取的数据其实就是刚才网络程序发送的数据。</p>
<p>反之，如果pf-&gt;rq队列为空，表示没有数据包需要通过ppp0接口发送，此函数直接返回-EAGAIN。也就是说，用户态函数 read_packet立即返回&lt;0导致get_loop_output返回0，嵌套for(;;)循环不能退出继续循环等待事件处理。</p>
<p>考虑有数据通过ppp0发送，read_packet返回读取的数据长度，这时loop_frame会被调用：</p>
<p>pppd/demand.c</p>
<p>main() -&gt; get_loop_output() -&gt; loop_frame():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span>

<span style="color:#c34e00">loop_frame</span>(frame,len)
    unsignedchar*frame;
    intlen;
{

    <span style="color:#00f">struct</span> packet*pkt;

    <span style="color:#f00;font-style:italic">/* dbglog(&#34;from loop: %P&#34;, frame, len); */</span>

    <span style="color:#00f">if</span>(len&lt;PPP_HDRLEN)

    return0;

    <span style="color:#00f">if</span>((PPP_PROTOCOL(frame)&amp;0x8000)!=0)

    return0;             <span style="color:#f00;font-style:italic">/* shouldn&#39;t get any of these anyway */</span>

    <span style="color:#00f">if</span>(!active_packet(frame,len)) <span style="color:#f00;font-style:italic">//检测发送的数据是否有效
</span><span style="color:#f00;font-style:italic"></span>
    return0;

    pkt=(<span style="color:#00f">struct</span> packet*)malloc(<span style="color:#00f">sizeof</span>(<span style="color:#00f">struct</span> packet)+len);

    <span style="color:#00f">if</span>(pkt!= NULL){

    pkt-&gt;length=len;

    pkt-&gt;next= NULL;

    memcpy(pkt-&gt;data,frame,len);

    <span style="color:#00f">if</span>(pend_q== NULL)

    pend_q=pkt;

    <span style="color:#00f">else</span>

    pend_qtail-&gt;next=pkt;

    pend_qtail=pkt;

    }

    return1;

}
</code></pre></div><p>这里实际上最后是调用IPCP协议块的ip_active_pkt函数来检查数据包有效性，这里就不具体分析了。如果发送数据是合法的IP报文，后面会保存这些数据包，并暂时放在pend_qtail队列中，留待PPP链路建立后重新发送。</p>
<p>第三阶段：</p>
<p>如果是demand拨号模式，并且假设有数据通过ppp0发送且是合法IP报文，第二阶段中的嵌套for(;;)循环会被跳出，接下来的代码和正常拨号模式就一样了，真是殊途同归啊。</p>
<p>再次回到主函数main() 中，我们要开始建立真正的PPP链路了：</p>
<p>pppd/main.c -&gt; main():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">……

    do_callback=0;

    <span style="color:#00f">for</span>(;;){ <span style="color:#f00;font-style:italic">/* 最外层for(;;)循环 */</span>

……

    lcp_open(0);       <span style="color:#f00;font-style:italic">/* Start protocol */</span> <span style="color:#f00;font-style:italic">//第一步：打开PPPK接口发送LCP帧
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">while</span>(phase!=PHASE_DEAD){ <span style="color:#f00;font-style:italic">//第二步：PPPD状态机循环进行事件处理
</span><span style="color:#f00;font-style:italic"></span>
    handle_events(); <span style="color:#f00;font-style:italic">//select事件处理
</span><span style="color:#f00;font-style:italic"></span>
    get_input(); <span style="color:#f00;font-style:italic">//对接收报文的处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(kill_link)

    lcp_close(0,<span style="color:#009c00">&#34;User request&#34;</span>);

    <span style="color:#00f">if</span>(asked_to_quit){

    bundle_terminating=1;

    <span style="color:#00f">if</span>(phase==PHASE_MASTER)

    mp_bundle_terminated();

    }

……

    }

……

    }
</code></pre></div><p>第一步：调用lcp_open(0)建立LCP链路。</p>
<p>pppd/lcp.c</p>
<p>Main() -&gt; lcp_open():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* lcp_open - LCP is allowed to come up.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">void</span>

<span style="color:#c34e00">lcp_open</span>(unit)

    intunit;

{

    fsm*f=&amp;lcp_fsm[unit]; <span style="color:#f00;font-style:italic">//LCP状态机
</span><span style="color:#f00;font-style:italic"></span>
    lcp_options*wo=&amp;lcp_wantoptions[unit];

    f-&gt;flags&amp;=~(OPT_PASSIVE|OPT_SILENT);

    <span style="color:#00f">if</span>(wo-&gt;passive)

    f-&gt;flags|=OPT_PASSIVE;

    <span style="color:#00f">if</span>(wo-&gt;silent)

    f-&gt;flags|=OPT_SILENT;

    fsm_open(f);

}
</code></pre></div><p>调用fsm_open打开LCP状态机：</p>
<p>pppd/fsm.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">void</span>

<span style="color:#c34e00">fsm_open</span>(f)
    fsm*f;
{

    <span style="color:#00f">switch</span>(f-&gt;state){

    caseINITIAL:

    f-&gt;state=STARTING;

    <span style="color:#00f">if</span>(f-&gt;callbacks-&gt;starting)

    (*f-&gt;callbacks-&gt;starting)(f); <span style="color:#f00;font-style:italic">//初始化时开始建立链路
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

……

    }
}
</code></pre></div><p>初始化状态，实际调用lcp_starting()-&gt; link_required()：</p>
<p>pppd/auth.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">void</span>
<span style="color:#c34e00">link_required</span>(unit)
    <span style="color:#00f">int</span> unit;
{

    new_phase(PHASE_SERIALCONN); <span style="color:#f00;font-style:italic">//PPPD状态机为“串口连接”阶段
</span><span style="color:#f00;font-style:italic"></span>
    devfd=the_channel-&gt;connect(); <span style="color:#f00;font-style:italic">//1. 调用connect_tty连接TTY驱动
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(devfd&lt;0)

    gotofail;

    <span style="color:#f00;font-style:italic">/* set up the serial device as a ppp interface */</span>

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * N.B. we used to do tdb_writelock/tdb_writeunlock around this
</span><span style="color:#f00;font-style:italic">    * (from establish_ppp to set_ifunit).  However, we won&#39;t be
</span><span style="color:#f00;font-style:italic">    * doing the set_ifunit in multilink mode, which is the only time
</span><span style="color:#f00;font-style:italic">    * we need the atomicity that the tdb_writelock/tdb_writeunlock
</span><span style="color:#f00;font-style:italic">    * gives us.  Thus we don&#39;t need the tdb_writelock/tdb_writeunlock.
</span><span style="color:#f00;font-style:italic">    */</span>

    fd_ppp=the_channel-&gt;establish_ppp(devfd); <span style="color:#f00;font-style:italic">//2. 调用 tty_establish_ppp
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(fd_ppp&lt;0){

    status=EXIT_FATAL_ERROR;

    gotodisconnect;

    }

    <span style="color:#00f">if</span>(!demand&amp;&amp;ifunit&gt;=0) <span style="color:#f00;font-style:italic">//如果是不是demand模式，需要设置 IFNAME环境变量
</span><span style="color:#f00;font-style:italic"></span>
    set_ifunit(1);

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Start opening the connection and wait for
</span><span style="color:#f00;font-style:italic">    * incoming events (reply, timeout, etc.).
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">if</span>(ifunit&gt;=0)

    notice(<span style="color:#009c00">&#34;Connect: %s &lt;--&gt; %s&#34;</span>,ifname,ppp_devnam);

    <span style="color:#00f">else</span>

    <span style="color:#c34e00">notice</span>(<span style="color:#009c00">&#34;Starting negotiation on %s&#34;</span>,ppp_devnam);

    add_fd(fd_ppp); <span style="color:#f00;font-style:italic">//把/dev/ppp文件描述加入fds。如果是demand模式，由于在main()中已经remove了需要再次加入，对于非demand模式则是首次加入
</span><span style="color:#f00;font-style:italic"></span>
    status=EXIT_NEGOTIATION_FAILED;

    new_phase(PHASE_ESTABLISH); <span style="color:#f00;font-style:italic">//PPPD状态机进入“链路建立”阶段
</span><span style="color:#f00;font-style:italic"></span>
    lcp_lowerup(0); <span style="color:#f00;font-style:italic">//3. 发送LCP Configure Request报文，向对方请求建立LCP链路
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">return</span>;

 disconnect:

    new_phase(PHASE_DISCONNECT);

    <span style="color:#00f">if</span>(the_channel-&gt;disconnect)

    the_channel-&gt;disconnect();

 fail:

    new_phase(PHASE_DEAD);

    <span style="color:#00f">if</span>(the_channel-&gt;cleanup)

    (*the_channel-&gt;cleanup)();

}
</code></pre></div><p>这个函数的主要作用从函数命名上就能看出，就是将需要的物理链路都带起来，现在PPPD状态机进入PHASE_SERIALCONN阶段。</p>
<ol>
<li>调用connect_tty打开串口TTY驱动并配置TTY参数，变量ppp_devnam是串口驱动的设备文件如/dev/ttyS0，/dev/ttyUSB0，/dev/ttyHDLC0等，具体可以参考相关的串口TTY驱动，这里不作具体分析。</li>
<li>然后调用tty_establish_ppp：</li>
</ol>
<p>pppd/sys-linux.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">inttty_establish_ppp(inttty_fd)

{

    intret_fd;

……

<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Set the current tty to the PPP discpline
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#f00;font-style:italic">#ifndef N_SYNC_PPP
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#defineN_SYNC_PPP 14
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>
    ppp_disc=(new_style_driver&amp;&amp;sync_serial)?N_SYNC_PPP: N_PPP;  <span style="color:#f00;font-style:italic">//同步还是异步PPP
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ioctl(tty_fd, TIOCSETD,&amp;ppp_disc)&lt;0){ <span style="color:#f00;font-style:italic">//2.1 设置PPP线路规程
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!ok_error(errno)){

    error(<span style="color:#009c00">&#34;Couldn&#39;t set tty to PPP discipline: %m&#34;</span>);

    <span style="color:#00f">return</span>-1;

    }

    }

    ret_fd=generic_establish_ppp(tty_fd); <span style="color:#f00;font-style:italic">//2.2 创建PPP接口
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#defineSC_RCVB(SC_RCV_B7_0 | SC_RCV_B7_1 | SC_RCV_EVNP | SC_RCV_ODDP)
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#defineSC_LOGB(SC_DEBUG | SC_LOG_INPKT | SC_LOG_OUTPKT | SC_LOG_RAWIN \
</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>    | SC_LOG_FLUSH)

    <span style="color:#00f">if</span>(ret_fd&gt;=0){

    modify_flags(ppp_fd,SC_RCVB|SC_LOGB,

    (kdebugflag* SC_DEBUG)&amp;SC_LOGB);

    }<span style="color:#00f">else</span>{

    <span style="color:#00f">if</span>(ioctl(tty_fd, TIOCSETD,&amp;tty_disc)&lt;0&amp;&amp;!ok_error(errno))

    warn(<span style="color:#009c00">&#34;Couldn&#39;t reset tty to normal line discipline: %m&#34;</span>);

    }

    returnret_fd;

}
</code></pre></div><p>分成两部分来具体深入分析：</p>
<p>2.1 首先调用ioctl(tty_fd, TIOCSETD, &amp;ppp_disc)将TTY驱动绑定到PPP线路规程，这里的ioctl是对TTY文件描述符的操作，实际上是调用了内核中的tty_ioctl() -&gt; tiocsetd()：</p>
<p>linux-2.6.18/drivers/char/tty_io.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() -&gt; tty_ioctl() -&gt; tiocsetd():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/**
</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">* tiocsetd -      set line discipline
</span><span style="color:#f00;font-style:italic">* @tty: tty device
</span><span style="color:#f00;font-style:italic">* @p: pointer to user data
</span><span style="color:#f00;font-style:italic">* 
</span><span style="color:#f00;font-style:italic">* Set the line discipline according to user request.
</span><span style="color:#f00;font-style:italic">* 
</span><span style="color:#f00;font-style:italic">* Locking: see tty_set_ldisc, this function is just a helper
</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"> */</span>

staticinttiocsetd(<span style="color:#00f">struct</span> tty_struct *tty,int__user*p)

{

    intldisc;

    <span style="color:#00f">if</span>(get_user(ldisc,p))

    <span style="color:#00f">return</span>-EFAULT;

    returntty_set_ldisc(tty,ldisc); <span style="color:#f00;font-style:italic">//设定线路规程，本文设定为N_PPP即异步PPP
</span><span style="color:#f00;font-style:italic"></span>
}
</code></pre></div><p>这个tiocsetd函数是个wrapper函数，只是把用户态传入的int参数放在内核态的ldisc中，再调用tty_set_ldist设置线路规程：</p>
<p>linux-2.6.18/drivers/char/tty_io.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() -&gt; tty_ioctl() -&gt; tiocsetd() -&gt; tty_set_ldisc():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">tty_set_ldisc</span>(<span style="color:#00f">struct</span> tty_struct *tty,<span style="color:#00f">int</span> ldisc)
{

    intretval=0;

    <span style="color:#00f">struct</span> tty_ldisco_ldisc;

    charbuf[64];

    intwork;

    unsignedlongflags;

    <span style="color:#00f">struct</span> tty_ldisc*ld;

    <span style="color:#00f">struct</span> tty_struct*o_tty;

    <span style="color:#00f">if</span>((ldisc&lt; N_TTY)||(ldisc&gt;= NR_LDISCS))

    <span style="color:#00f">return</span>-EINVAL;

restart:

    ld=tty_ldisc_get(ldisc); <span style="color:#f00;font-style:italic">//从tty_ldiscs全局数组找出注册的N_PPP线路规程
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/* Eduardo Blanco &lt;ejbs@cs.cs.com.uy&gt; */</span>

    <span style="color:#f00;font-style:italic">/* Cyrus Durgin &lt;cider@speakeasy.org&gt; */</span>

    <span style="color:#00f">if</span>(ld==NULL){

    request_module(<span style="color:#009c00">&#34;tty-ldisc-%d&#34;</span>,ldisc);

    ld=tty_ldisc_get(ldisc);

    }

    <span style="color:#00f">if</span>(ld==NULL)

    <span style="color:#00f">return</span>-EINVAL;

(如果当前TTY上已经设置了线路规程，这部分代码会detach现有的线路规程，这里忽略详细分析)……

    <span style="color:#f00;font-style:italic">/* Shutdown the current discipline. */</span>

    <span style="color:#00f">if</span>(tty-&gt;ldisc.close)  <span style="color:#f00;font-style:italic">//调用当前线路规程的close()函数
</span><span style="color:#f00;font-style:italic"></span>
    (tty-&gt;ldisc.close)(tty);

    <span style="color:#f00;font-style:italic">/* Now set up the new line discipline. */</span>

    tty_ldisc_assign(tty,ld); <span style="color:#f00;font-style:italic">//将上面获取的N_PPP线路规程attach到当前TTY
</span><span style="color:#f00;font-style:italic"></span>
    tty_set_termios_ldisc(tty,ldisc);

    <span style="color:#00f">if</span>(tty-&gt;ldisc.open)

    retval=(tty-&gt;ldisc.open)(tty); <span style="color:#f00;font-style:italic">//调用N_PPP线路规程的open()
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(retval&lt;0){

    tty_ldisc_put(ldisc);

    <span style="color:#f00;font-style:italic">/* There is an outstanding reference here so this is safe */</span>

    tty_ldisc_assign(tty,tty_ldisc_get(o_ldisc.num));

    tty_set_termios_ldisc(tty,tty-&gt;ldisc.num);

    <span style="color:#00f">if</span>(tty-&gt;ldisc.open&amp;&amp;(tty-&gt;ldisc.open(tty)&lt;0)){

    tty_ldisc_put(o_ldisc.num);

    <span style="color:#f00;font-style:italic">/* This driver is always present */</span>

    tty_ldisc_assign(tty,tty_ldisc_get(N_TTY));

    tty_set_termios_ldisc(tty, N_TTY);

    <span style="color:#00f">if</span>(tty-&gt;ldisc.open){

    intr=tty-&gt;ldisc.open(tty);

    <span style="color:#00f">if</span>(r&lt;0)

    panic(<span style="color:#009c00">&#34;Couldn&#39;t open N_TTY ldisc for &#34;</span>

    <span style="color:#009c00">&#34;%s --- error %d.&#34;</span>,

    tty_name(tty,buf),r);

    }

    }

    }

    <span style="color:#f00;font-style:italic">/* At this point we hold a reference to the new ldisc and a
</span><span style="color:#f00;font-style:italic">    a reference to the old ldisc. If we ended up flipping back
</span><span style="color:#f00;font-style:italic">    to the existing ldisc we have two references to it */</span>

    <span style="color:#00f">if</span>(tty-&gt;ldisc.num!=o_ldisc.num&amp;&amp;tty-&gt;driver-&gt;set_ldisc)

    tty-&gt;driver-&gt;set_ldisc(tty); <span style="color:#f00;font-style:italic">//如果是新的线路规程则调用TTY驱动的set_ldisc函数
</span><span style="color:#f00;font-style:italic"></span>
    tty_ldisc_put(o_ldisc.num); <span style="color:#f00;font-style:italic">//释放旧的线路规程参考计数
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">    *    Allow ldisc referencing to occur as soon as the driver
</span><span style="color:#f00;font-style:italic">    *    ldisc callback completes.
</span><span style="color:#f00;font-style:italic">    */</span>

    tty_ldisc_enable(tty); <span style="color:#f00;font-style:italic">//激活新的TTY线路规程，实际上是置位TTY_LDISC
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(o_tty)

    tty_ldisc_enable(o_tty);

    <span style="color:#f00;font-style:italic">/* Restart it in case no characters kick it off. Safe if
</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">    already running */</span>

    <span style="color:#00f">if</span>(work)

    schedule_delayed_work(&amp;tty-&gt;buf.work,1);

    returnretval;
}
</code></pre></div><p>这个函数为TTY驱动绑定N_PPP线路规程，绑定后调用线路规程的open()函数，对于N_PPP实际上是调用ppp_asynctty_open：</p>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() -&gt; tty_ioctl() -&gt; tiocsetd() -&gt; tty_set_ldisc() -&gt; ppp_asynctty_open():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Called when a tty is put into PPP line discipline. Called in process
</span><span style="color:#f00;font-style:italic">* context.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">static</span> <span style="color:#00f">int</span>
<span style="color:#c34e00">ppp_asynctty_open</span>(<span style="color:#00f">struct</span> tty_struct*tty)
{
    <span style="color:#00f">struct</span> asyncppp*ap;
    <span style="color:#00f">int</span> err;
    
    err=-ENOMEM;
    ap=kmalloc(<span style="color:#00f">sizeof</span>(*ap), GFP_KERNEL);
    
    <span style="color:#00f">if</span>(ap==0)
    	<span style="color:#00f">goto</span> out;

    <span style="color:#f00;font-style:italic">/* initialize the asyncppp structure */</span>

    memset(ap,0,<span style="color:#00f">sizeof</span>(*ap));

    ap-&gt;tty=tty;
    ap-&gt;mru=PPP_MRU;
    spin_lock_init(&amp;ap-&gt;xmit_lock);
    spin_lock_init(&amp;ap-&gt;recv_lock);

    ap-&gt;xaccm[0]=~0U;
    ap-&gt;xaccm[3]=0x60000000U;
    ap-&gt;raccm=~0U;
    ap-&gt;optr=ap-&gt;obuf;
    ap-&gt;olim=ap-&gt;obuf;
    ap-&gt;lcp_fcs=-1;

    skb_queue_head_init(&amp;ap-&gt;rqueue);

    tasklet_init(&amp;ap-&gt;tsk,ppp_async_process,(unsignedlong)ap);<span style="color:#f00;font-style:italic">//接收数据时使用的tasklet
</span><span style="color:#f00;font-style:italic"></span>
    atomic_set(&amp;ap-&gt;refcnt,1);

    init_MUTEX_LOCKED(&amp;ap-&gt;dead_sem);

    ap-&gt;chan.private=ap; <span style="color:#f00;font-style:italic">//channel反向指针指向struct asyncppp
</span><span style="color:#f00;font-style:italic"></span>    ap-&gt;chan.ops=&amp;async_ops; <span style="color:#f00;font-style:italic">//异步channel的操作函数集合
</span><span style="color:#f00;font-style:italic"></span>    ap-&gt;chan.mtu=PPP_MRU;

    err=ppp_register_channel(&amp;ap-&gt;chan); <span style="color:#f00;font-style:italic">//注册异步channel
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(err)

    gotoout_free;

    tty-&gt;disc_data=ap; <span style="color:#f00;font-style:italic">//现在tty结构可以找到asyncppp了
</span><span style="color:#f00;font-style:italic"></span>
    tty-&gt;receive_room=65536;

    return0;

 out_free:

    kfree(ap);

 out:
    <span style="color:#00f">return</span> err;
}
</code></pre></div><p>此函数分配并初始化struct asyncppp结构来表示一个异步PPP，并将tty结构的disc_data指向该结构。另外调用ppp_register_channel注册了一个异步PPP channel：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() -&gt; tty_ioctl() -&gt; tiocsetd() -&gt; tty_set_ldisc() -&gt; ppp_asynctty_open() -&gt; ppp_register_channel():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Create a new, unattached ppp channel.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">int</span>

<span style="color:#c34e00">ppp_register_channel</span>(<span style="color:#00f">struct</span> ppp_channel*chan)
{
    <span style="color:#00f">struct</span> channel*pch;

    pch=kzalloc(<span style="color:#00f">sizeof</span>(<span style="color:#00f">struct</span> channel), GFP_KERNEL);

    <span style="color:#00f">if</span>(pch==0)

    <span style="color:#00f">return</span>-ENOMEM;

    pch-&gt;ppp=NULL;  <span style="color:#f00;font-style:italic">//channel还不属于任何PPP unit，初始化为NULL
</span><span style="color:#f00;font-style:italic"></span>    pch-&gt;chan=chan;  <span style="color:#f00;font-style:italic">//channel中指向ppp_channel的指针
</span><span style="color:#f00;font-style:italic"></span>
    chan-&gt;ppp=pch;   <span style="color:#f00;font-style:italic">//ppp_channel中指向channel的指针
</span><span style="color:#f00;font-style:italic"></span>
    init_ppp_file(&amp;pch-&gt;file,CHANNEL); <span style="color:#f00;font-style:italic">//初始化ppp_file，类型为CHANNEL
</span><span style="color:#f00;font-style:italic"></span>
    pch-&gt;file.hdrlen=chan-&gt;hdrlen;

<span style="color:#f00;font-style:italic">#ifdef CONFIG_PPP_MULTILINK
</span><span style="color:#f00;font-style:italic"></span>    pch-&gt;lastseq=-1;
<span style="color:#f00;font-style:italic">#endif</span><span style="color:#f00;font-style:italic">/* CONFIG_PPP_MULTILINK */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
    init_rwsem(&amp;pch-&gt;chan_sem);

    spin_lock_init(&amp;pch-&gt;downl);
    rwlock_init(&amp;pch-&gt;upl);
    spin_lock_bh(&amp;all_channels_lock);

    pch-&gt;file.index=++last_channel_index; <span style="color:#f00;font-style:italic">//channel索引值，后面会用到
</span><span style="color:#f00;font-style:italic"></span>
    list_add(&amp;pch-&gt;list,&amp;new_channels); <span style="color:#f00;font-style:italic">//注册到new_channels全局链表
</span><span style="color:#f00;font-style:italic"></span>
    atomic_inc(&amp;channel_count);

    spin_unlock_bh(&amp;all_channels_lock);

    <span style="color:#00f">return</span> 0;
}
</code></pre></div><p>OK，到此ioctl(tty_fd, TIOCSETD, &amp;ppp_disc)在内核中的实现就分析完了。</p>
<p>2.2 返回tty_establish_ppp，继续调用generic_establish_ppp创建PPP接口：</p>
<p>pppd/sys-linux.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">generic_establish_ppp</span>(intfd)
{
    <span style="color:#00f">int</span> x;

    <span style="color:#00f">if</span> (new_style_driver){ <span style="color:#f00;font-style:italic">//进入到这里
</span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span> flags;
        <span style="color:#f00;font-style:italic">/* Open an instance of /dev/ppp and connect the channel to it */</span>

        <span style="color:#00f">if</span>(ioctl(fd, PPPIOCGCHAN,&amp;chindex)==-1){ <span style="color:#f00;font-style:italic">//1) 获取channel number
</span><span style="color:#f00;font-style:italic"></span>            error(<span style="color:#009c00">&#34;Couldn&#39;t get channel number: %m&#34;</span>);
        <span style="color:#00f">goto</span> err;
    }

    dbglog(<span style="color:#009c00">&#34;using channel %d&#34;</span>,chindex);

    fd=open(<span style="color:#009c00">&#34;/dev/ppp&#34;</span>, O_RDWR);  <span style="color:#f00;font-style:italic">//打开/dev/ppp
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(fd&lt;0){
        error(<span style="color:#009c00">&#34;Couldn&#39;t reopen /dev/ppp: %m&#34;</span>);
        <span style="color:#00f">goto</span> err;

    }

    (<span style="color:#00f">void</span>)fcntl(fd, F_SETFD, FD_CLOEXEC);

    <span style="color:#00f">if</span>(ioctl(fd, PPPIOCATTCHAN,&amp;chindex)&lt;0){ <span style="color:#f00;font-style:italic">//2) 将channel绑定到/dev/ppp
</span><span style="color:#f00;font-style:italic"></span>        error(<span style="color:#009c00">&#34;Couldn&#39;t attach to channel %d: %m&#34;</span>,chindex);
        <span style="color:#00f">goto</span> err_close;
    }

    flags=fcntl(fd, F_GETFL);

    <span style="color:#00f">if</span>(flags==-1||fcntl(fd, F_SETFL,flags| O_NONBLOCK)==-1) <span style="color:#f00;font-style:italic">//设为非阻塞fd
</span><span style="color:#f00;font-style:italic"></span>
    warn(<span style="color:#009c00">&#34;Couldn&#39;t set /dev/ppp (channel) to nonblock: %m&#34;</span>);

    set_ppp_fd(fd);  <span style="color:#f00;font-style:italic">//将这个fd保存到变量ppp_fd
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!looped)

    ifunit=-1;

    <span style="color:#00f">if</span>(!looped&amp;&amp;!multilink){ <span style="color:#f00;font-style:italic">//回想一下，在demand模式下open_ppp_loopback会将looped置为1
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Create a new PPP unit.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">if</span>(make_ppp_unit()&lt;0) <span style="color:#f00;font-style:italic">//3) demand模式下已经调用过make_ppp_unit了，这里用于正常拨号
</span><span style="color:#f00;font-style:italic"></span>
    gotoerr_close;

    }

    <span style="color:#00f">if</span>(looped)

    modify_flags(ppp_dev_fd, SC_LOOP_TRAFFIC,0); <span style="color:#f00;font-style:italic">//对demand模式，清除
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(!multilink){

    add_fd(ppp_dev_fd); <span style="color:#f00;font-style:italic">//把ppp_dev_fd加入到select的fds中
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ioctl(fd, PPPIOCCONNECT,&amp;ifunit)&lt;0){ <span style="color:#f00;font-style:italic">//4) 连接channel到unit
</span><span style="color:#f00;font-style:italic"></span>
    error(<span style="color:#009c00">&#34;Couldn&#39;t attach to PPP unit %d: %m&#34;</span>,ifunit);

    gotoerr_close;

    }

    }

    }<span style="color:#00f">else</span>{

(old driver忽略)……

    }

……

    looped=0;

    returnppp_fd;

……

}
</code></pre></div><p>这个函数可以分成4个主要部分：</p>
<ol>
<li>获取TTY中已注册的channel的索引值。</li>
<li>将注册的channel绑定到/dev/ppp文件描述符，并保存到ppp_fd。</li>
<li>对于正常拨号，调用make_ppp_unit创建ppp0网络接口并将此接口绑定，绑定后的/dev/ppp文件描述符保存在ppp_dev_fd。</li>
<li>将ppp_dev_fd加入到select的fds，并连接channe到PPP unit。</li>
</ol>
<p>第1部分：对TTY fd调用 ioctl(fd, PPPIOCGCHAN, &amp;chindex)，实际上调用内核中的tty_ioctl()：</p>
<p>linux-2.6.18/drivers/char/tty_io.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp() –&gt; tty_ioctl():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">inttty_ioctl(<span style="color:#00f">struct</span> inode *inode,<span style="color:#00f">struct</span> file *file,
    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> cmd,<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">struct</span> tty_struct *tty, *real_tty;

    void__user *p=(void__user*)arg;

    <span style="color:#00f">int</span> retval;

    <span style="color:#00f">struct</span> tty_ldisc*ld;
……

    ld=tty_ldisc_ref_wait(tty);<span style="color:#f00;font-style:italic">//前面TTY已绑定了PPP线路规程，所以返回的是异步PPP线路规程
</span><span style="color:#f00;font-style:italic"></span>
    retval=-EINVAL;

    <span style="color:#00f">if</span>(ld-&gt;ioctl){
        retval=ld-&gt;ioctl(tty,file,cmd,arg); <span style="color:#f00;font-style:italic">//实际调用ppp_asynctty_ioctl
</span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">if</span>(retval==-ENOIOCTLCMD)
            retval=-EINVAL;
    }

    tty_ldisc_deref(ld);
    returnretval;
}
</code></pre></div><p>异步PPP线路规程已经在内核文件ppp_async.c中初始化了，并且在前面已经设置TTY的异步PPP线路规程，因此这里的ld-&gt;ioctl实际指向的是ppp_asynctty_ioctl：</p>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp() –&gt; tty_ioctl() –&gt; ppp_asynctty_ioctl():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span>
<span style="color:#c34e00">ppp_asynctty_ioctl</span>(<span style="color:#00f">struct</span> tty_struct *tty,<span style="color:#00f">struct</span> file *file,
    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> cmd,<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">struct</span> asyncppp*ap=ap_get(tty);
    interr,val;

    int__user*p=(int__user*)arg;

    <span style="color:#00f">if</span>(ap==0)
    	<span style="color:#00f">return</span>-ENXIO;

    err=-EFAULT;

    <span style="color:#00f">switch</span>(cmd){
    	<span style="color:#00f">case</span>	PPPIOCGCHAN:
    		err =-ENXIO;
            <span style="color:#00f">if</span>(ap==0)
                <span style="color:#00f">break</span>;
    		err=-EFAULT;

    		<span style="color:#00f">if</span>(put_user(ppp_channel_index(&amp;ap-&gt;chan),p))<span style="color:#f00;font-style:italic">//拷贝channel索引值到chindex
</span><span style="color:#f00;font-style:italic"></span>    	<span style="color:#00f">break</span>;

    	err=0;
    <span style="color:#00f">break</span>;

……

}
</code></pre></div><p>ppp_channel_index实现：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp() –&gt; tty_ioctl() –&gt; ppp_asynctty_ioctl() –&gt; ppp_channel_index():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">ppp_channel_index</span>(<span style="color:#00f">struct</span> ppp_channel*chan)
{
    <span style="color:#00f">struct</span> channel*pch=chan-&gt;ppp;

    <span style="color:#00f">if</span>(pch!=0)
    	returnpch-&gt;file.index;<span style="color:#f00;font-style:italic">//返回ppp_register_channel()中初始化的channel索引值
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">return</span>-1;
}
</code></pre></div><p>第2部分：对/dev/ppp调用ioctl(fd, PPPIOCATTCHAN, &amp;chindex)，实际上调用ppp_ioctl -&gt; ppp_unattached_ioctl：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp() -&gt; ppp_ioctl() -&gt; ppp_unattached_ioctl():

<span style="color:#00f">static</span> <span style="color:#00f">int</span> ppp_unattached_ioctl(<span style="color:#00f">struct</span> ppp_file *pf,<span style="color:#00f">struct</span> file*file,
    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> cmd,<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">int</span> unit,err=-EFAULT;

    <span style="color:#00f">struct</span> ppp*ppp;
    <span style="color:#00f">struct</span> channel*chan;

    int__user*p=(int__user*)arg;

……

    <span style="color:#00f">case</span> PPPIOCATTCHAN:

    	<span style="color:#00f">if</span>	(get_user(unit, p))
    	<span style="color:#00f">break</span>;

    spin_lock_bh(&amp;all_channels_lock);

    err=-ENXIO;

    chan=ppp_find_channel(unit);<span style="color:#f00;font-style:italic">//通过参数chindex寻找注册的channel
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(chan!=0){

    atomic_inc(&amp;chan-&gt;file.refcnt);

    file-&gt;private_data=&amp;chan-&gt;file; <span style="color:#f00;font-style:italic">//绑定到channel，指向channel的ppp_file
</span><span style="color:#f00;font-style:italic"></span>
    err=0;
    }

    spin_unlock_bh(&amp;all_channels_lock);

    <span style="color:#00f">break</span>;

    <span style="color:#00f">default</span>:

    err=-ENOTTY;

    }

    <span style="color:#00f">return</span> err;

}
</code></pre></div><p>这个ioctl返回后，/dev/ppp文件描述符绑定了索引值为chindex的channel。然后通过set_ppp_fd(fd)保存在全局变量ppp_fd中。</p>
<p>第3部分：会判断是否是demand模式，对正常拨号会调用make_ppp_unit创建ppp0接口，而demand模式在第二阶段已经调用过make_ppp_unit了，这里就直接忽略。具体参见第二阶段中对make_ppp_unit的详细分析。</p>
<p>注意：ppp_dev_fd文件描述符代表的是一个unit，ppp_fd文件描述符代表的是一个channel。</p>
<p>第4部分：对绑定了channel的ppp_fd调用ioctl(fd, PPPIOCCONNECT, &amp;ifunit)将channel连接到unit。</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp() -&gt; ppp_ioctl()：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">ppp_ioctl</span>(<span style="color:#00f">struct</span> inode *inode,<span style="color:#00f">struct</span> file *file,
    <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> cmd, <span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">struct</span> ppp_file*pf=file-&gt;private_data;
    <span style="color:#00f">struct</span> ppp*ppp;

……

    <span style="color:#00f">if</span>(pf-&gt;kind==CHANNEL){

    <span style="color:#00f">struct</span> channel*pch=PF_TO_CHANNEL(pf);

    <span style="color:#00f">struct</span> ppp_channel*chan;

    <span style="color:#00f">switch</span>(cmd){

    casePPPIOCCONNECT:

    <span style="color:#00f">if</span>(get_user(unit, p))

    <span style="color:#00f">break</span>;

    err=ppp_connect_channel(pch,unit); <span style="color:#f00;font-style:italic">//连接channel到unit
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">break</span>;

    casePPPIOCDISCONN:

    err=ppp_disconnect_channel(pch);

    <span style="color:#00f">break</span>;

    <span style="color:#00f">default</span>:

    down_read(&amp;pch-&gt;chan_sem);

    chan=pch-&gt;chan;

    err=-ENOTTY;

    <span style="color:#00f">if</span>(chan&amp;&amp;chan-&gt;ops-&gt;ioctl)

    err=chan-&gt;ops-&gt;ioctl(chan,cmd,arg);

    up_read(&amp;pch-&gt;chan_sem);

    }

    returnerr;

    }

……

}
</code></pre></div><p>ppp_connect_channel实现：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; tty_establish_ppp() –&gt; generic_establish_ppp() -&gt; ppp_ioctl() -&gt; ppp_connect_channel()：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* Connect a PPP channel to a PPP interface unit.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">static</span> <span style="color:#00f">int</span>
<span style="color:#c34e00">ppp_connect_channel</span>(<span style="color:#00f">struct</span> channel*pch,<span style="color:#00f">int</span> unit)
{
    <span style="color:#00f">struct</span> ppp*ppp;

    intret=-ENXIO;

    inthdrlen;

    mutex_lock(&amp;all_ppp_mutex);

    ppp=ppp_find_unit(unit); <span style="color:#f00;font-style:italic">//根据unit number找到struct ppp
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(ppp==0)

    gotoout;

    write_lock_bh(&amp;pch-&gt;upl);

    ret=-EINVAL;

    <span style="color:#00f">if</span>(pch-&gt;ppp!=0)

    gotooutl;

    ppp_lock(ppp);

    <span style="color:#00f">if</span>(pch-&gt;file.hdrlen&gt;ppp-&gt;file.hdrlen)

    ppp-&gt;file.hdrlen=pch-&gt;file.hdrlen;

    hdrlen=pch-&gt;file.hdrlen+2;    <span style="color:#f00;font-style:italic">/* for protocol bytes */</span>

    <span style="color:#00f">if</span>(ppp-&gt;dev&amp;&amp;hdrlen&gt;ppp-&gt;dev-&gt;hard_header_len)

    ppp-&gt;dev-&gt;hard_header_len=hdrlen; <span style="color:#f00;font-style:italic">//PPP协议帧头长度
</span><span style="color:#f00;font-style:italic"></span>
    list_add_tail(&amp;pch-&gt;clist,&amp;ppp-&gt;channels); <span style="color:#f00;font-style:italic">//将channel加入到unit中的channel链表
</span><span style="color:#f00;font-style:italic"></span>
    ++ppp-&gt;n_channels; <span style="color:#f00;font-style:italic">//unit中的channel数目加1。注意：一个unit下可以有多个channel哦
</span><span style="color:#f00;font-style:italic"></span>
    pch-&gt;ppp=ppp; <span style="color:#f00;font-style:italic">//回忆一下，刚注册channel时ppp指针为空。
</span><span style="color:#f00;font-style:italic"></span>
    atomic_inc(&amp;ppp-&gt;file.refcnt);

    ppp_unlock(ppp);

    ret=0;

 outl:

    write_unlock_bh(&amp;pch-&gt;upl);

 out:

    mutex_unlock(&amp;all_ppp_mutex);

    returnret;
}
</code></pre></div><ol start="3">
<li>函数link_required中前两步已经配置好了链路接口，接下来该做正事了：PPPD状态机进入PHASE_ESTABLISH阶段，然后用lcp_lowerup(0)发送LCP报文去建立连接。</li>
</ol>
<p>实际调用lcp_lowerup() -&gt; fsm_lowerup() -&gt; fsm_sconfreq()-&gt; fsm_sdata() -&gt; output()：</p>
<p>pppd/sys-linux.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; lcp_lowerup() -&gt; fsm_lowerup() -&gt; fsm_sconfreq() -&gt; fsm_sdata() -&gt; output():

<span style="color:#00f">void</span> output(<span style="color:#00f">int</span> unit, <span style="color:#00f">unsigned</span> <span style="color:#00f">char</span> *p,<span style="color:#00f">int</span> len)
{
    <span style="color:#00f">int</span> fd=ppp_fd;

    <span style="color:#00f">int</span> proto;

    dump_packet(<span style="color:#009c00">&#34;sent&#34;</span>,p,len);

    <span style="color:#00f">if</span>(snoop_send_hook)snoop_send_hook(p,len);

    <span style="color:#00f">if</span>(len&lt;PPP_HDRLEN)
    	<span style="color:#00f">return</span>;

    <span style="color:#00f">if</span>(new_style_driver){ <span style="color:#f00;font-style:italic">//进入到这里
</span><span style="color:#f00;font-style:italic"></span>
    p+=2;

    len-=2;

    proto=(p[0]&lt;&lt;8)+p[1];

    <span style="color:#00f">if</span>(ppp_dev_fd&gt;=0&amp;&amp;!(proto&gt;=0xc000||proto== PPP_CCPFRAG))

    fd=ppp_dev_fd; <span style="color:#f00;font-style:italic">//注意：数据帧用ppp_dev_fd发送，LCP控制帧用ppp_fd发送
</span><span style="color:#f00;font-style:italic"></span>
    }

    <span style="color:#00f">if</span>(write(fd,p,len)&lt;0){<span style="color:#f00;font-style:italic">//调用内核函数ppp_write发送数据
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(errno== EWOULDBLOCK|| errno == EAGAIN|| errno== ENOBUFS

    || errno== ENXIO|| errno == EIO|| errno== EINTR)

    warn(<span style="color:#009c00">&#34;write: warning: %m (%d)&#34;</span>, errno);

    <span style="color:#00f">else</span>

    <span style="color:#c34e00">error</span>(<span style="color:#009c00">&#34;write: %m (%d)&#34;, errno)</span>;

    }

}
</code></pre></div><p>数据的发送要分两种情况：</p>
<ol>
<li>LCP控制帧用ppp_fd发送。</li>
<li>数据帧用ppp_dev_fd发送。</li>
</ol>
<p>不管是ppp_fd还是ppp_dev_fd打开的设备文件都是/dev/ppp，因此调用的都是同一个函数ppp_write：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; lcp_lowerup() -&gt; fsm_lowerup() -&gt; fsm_sconfreq() -&gt; fsm_sdata() -&gt; output() -&gt; ppp_write():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#c34e00">ssize_tppp_write</span>(<span style="color:#00f">struct</span> file *file,<span style="color:#00f">const</span> <span style="color:#00f">char</span> __user *buf,
    size_t count,loff_t *ppos)
{
    <span style="color:#00f">struct</span> ppp_file*pf=file-&gt;private_data;

    <span style="color:#00f">struct</span> sk_buff*skb;

    ssize_tret;

    <span style="color:#00f">if</span>(pf==0)

    <span style="color:#00f">return</span>-ENXIO;

    ret=-ENOMEM;

    skb=alloc_skb(count+pf-&gt;hdrlen, GFP_KERNEL); <span style="color:#f00;font-style:italic">//Linux内核用sk_buff存放网络数据包
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(skb==0)

    gotoout;

    skb_reserve(skb,pf-&gt;hdrlen);

    ret=-EFAULT;

    <span style="color:#00f">if</span>(copy_from_user(skb_put(skb,count),buf,count)){ <span style="color:#f00;font-style:italic">//将发送数据拷贝到skb
</span><span style="color:#f00;font-style:italic"></span>
    kfree_skb(skb);

    gotoout;

    }

    skb_queue_tail(&amp;pf-&gt;xq,skb); <span style="color:#f00;font-style:italic">//将skb放在发送队列xq的队尾
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">switch</span>(pf-&gt;kind){ <span style="color:#f00;font-style:italic">//注意：通过ppp_file的kind字段判断/dev/ppp绑定的是unit还是channel
</span><span style="color:#f00;font-style:italic"></span>
    caseINTERFACE: <span style="color:#f00;font-style:italic">//接口即unit
</span><span style="color:#f00;font-style:italic"></span>
    ppp_xmit_process(PF_TO_PPP(pf));

    <span style="color:#00f">break</span>;

    caseCHANNEL: <span style="color:#f00;font-style:italic">//channel
</span><span style="color:#f00;font-style:italic"></span>
    ppp_channel_push(PF_TO_CHANNEL(pf));

    <span style="color:#00f">break</span>;

    }

    ret=count;

 out:

    returnret;

}
</code></pre></div><p>继续对这个函数分析，现在要发送LCP帧去建立连接，因此调用ppp_channel_push来进行发送：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; lcp_lowerup() -&gt; fsm_lowerup() -&gt; fsm_sconfreq() -&gt; fsm_sdata() -&gt; output() -&gt; ppp_write() -&gt; ppp_channel_push():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_channel_push</span>(<span style="color:#00f">struct</span> channel*pch)
{

    <span style="color:#00f">struct</span> sk_buff*skb;

    <span style="color:#00f">struct</span> ppp*ppp;

    spin_lock_bh(&amp;pch-&gt;downl);

    <span style="color:#00f">if</span>(pch-&gt;chan!=0){ <span style="color:#f00;font-style:italic">//已经在前面的ppp_register_channel初始化了，这里不为空
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">while</span>(!skb_queue_empty(&amp;pch-&gt;file.xq)){ <span style="color:#f00;font-style:italic">//skb已放在发送队列xq中
</span><span style="color:#f00;font-style:italic"></span>
    skb=skb_dequeue(&amp;pch-&gt;file.xq);

    <span style="color:#f00;font-style:italic">/* 前面的ppp_asynctty_open已经初始化了ops为async_ops，所以这里
</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">实际调用ppp_async_send*/</span>

    <span style="color:#00f">if</span>(!pch-&gt;chan-&gt;ops-&gt;start_xmit(pch-&gt;chan,skb)){

    <span style="color:#f00;font-style:italic">/* put the packet back and try again later */</span>

    skb_queue_head(&amp;pch-&gt;file.xq,skb);

    <span style="color:#00f">break</span>;

    }

    }

    }<span style="color:#00f">else</span>{

    <span style="color:#f00;font-style:italic">/* channel got deregistered */</span>

    skb_queue_purge(&amp;pch-&gt;file.xq);

    }

    spin_unlock_bh(&amp;pch-&gt;downl);

    <span style="color:#f00;font-style:italic">/* see if there is anything from the attached unit to be sent */</span>

    <span style="color:#00f">if</span>(skb_queue_empty(&amp;pch-&gt;file.xq)){

    read_lock_bh(&amp;pch-&gt;upl);

    ppp=pch-&gt;ppp;

    <span style="color:#00f">if</span>(ppp!=0)<span style="color:#f00;font-style:italic">//如果channel已经连接到unit了，则不为空
</span><span style="color:#f00;font-style:italic"></span>
    ppp_xmit_process(ppp); <span style="color:#f00;font-style:italic">//这个函数用于发送数据帧
</span><span style="color:#f00;font-style:italic"></span>
    read_unlock_bh(&amp;pch-&gt;upl);

    }

}
</code></pre></div><p>实际调用ppp_async_send发送LCP帧：</p>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<p>main() -&gt; lcp_open() -&gt; fsm_open() -&gt; lcp_starting() -&gt; link_required() -&gt; lcp_lowerup() -&gt; fsm_lowerup() -&gt; fsm_sconfreq() -&gt; fsm_sdata() -&gt; output() -&gt; ppp_write() -&gt; ppp_channel_push() -&gt; ppp_async_send():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span>

<span style="color:#c34e00">ppp_async_send</span>(<span style="color:#00f">struct</span> ppp_channel*chan,<span style="color:#00f">struct</span> sk_buff*skb)
{
    <span style="color:#00f">struct</span> asyncppp*ap=chan-&gt;private;

    ppp_async_push(ap); <span style="color:#f00;font-style:italic">//push到TTY驱动去发送
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(test_and_set_bit(XMIT_FULL,&amp;ap-&gt;xmit_flags))

    return0;      <span style="color:#f00;font-style:italic">/* already full */</span>

    ap-&gt;tpkt=skb;

    ap-&gt;tpkt_pos=0;

    ppp_async_push(ap);

    return1;

}
</code></pre></div><p>实际调用ppp_async_push：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">int</span>
<span style="color:#c34e00">ppp_async_push</span>(<span style="color:#00f">struct</span> asyncppp*ap)
{

    intavail,sent,done=0;

    <span style="color:#00f">struct</span> tty_struct*tty=ap-&gt;tty;

    inttty_stuffed=0;

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * We can get called recursively here if the tty write
</span><span style="color:#f00;font-style:italic">    * function calls our wakeup function.  This can happen
</span><span style="color:#f00;font-style:italic">    * for example on a pty with both the master and slave
</span><span style="color:#f00;font-style:italic">    * set to PPP line discipline.
</span><span style="color:#f00;font-style:italic">    * We use the XMIT_BUSY bit to detect this and get out,
</span><span style="color:#f00;font-style:italic">    * leaving the XMIT_WAKEUP bit set to tell the other
</span><span style="color:#f00;font-style:italic">    * instance that it may now be able to write more now.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">if</span>(test_and_set_bit(XMIT_BUSY,&amp;ap-&gt;xmit_flags))

    return0;

    spin_lock_bh(&amp;ap-&gt;xmit_lock);

    <span style="color:#00f">for</span>(;;){

    <span style="color:#00f">if</span>(test_and_clear_bit(XMIT_WAKEUP,&amp;ap-&gt;xmit_flags))

    tty_stuffed=0;

    <span style="color:#00f">if</span>(!tty_stuffed&amp;&amp;ap-&gt;optr`&lt;ap-&gt;`olim){

    avail=ap-&gt;olim-ap-&gt;optr;

    set_bit(TTY_DO_WRITE_WAKEUP,&amp;tty-&gt;flags);

    sent=tty-&gt;driver-&gt;write(tty,ap-&gt;optr,avail); <span style="color:#f00;font-style:italic">//最终调用TTY驱动的write发送帧
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(sent&lt;0)

    gotoflush;   <span style="color:#f00;font-style:italic">/* error, e.g. loss of CD */</span>

……

}
</code></pre></div><pre><code>到此，LCP Configure Request帧就发送出去了。
</code></pre>
<p>现在，再次返回到PPPD中的主函数main()中：</p>
<p>第二步：PPPD状态机循环进行事件处理</p>
<p>pppd/main.c -&gt; main():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">……

    do_callback=0;

    <span style="color:#00f">for</span>(;;){ <span style="color:#f00;font-style:italic">/* 最外层for(;;)循环 */</span>

……

    lcp_open(0);       <span style="color:#f00;font-style:italic">/* Start protocol */</span> <span style="color:#f00;font-style:italic">//第一步：打开PPPK接口发送LCP帧
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">while</span>(phase!=PHASE_DEAD){ <span style="color:#f00;font-style:italic">//第二步：PPPD状态机循环进行事件处理
</span><span style="color:#f00;font-style:italic"></span>
    handle_events(); <span style="color:#f00;font-style:italic">//select事件处理
</span><span style="color:#f00;font-style:italic"></span>
    get_input(); <span style="color:#f00;font-style:italic">//对接收报文的处理
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(kill_link)

    lcp_close(0,<span style="color:#009c00">&#34;User request&#34;</span>);

    <span style="color:#00f">if</span>(asked_to_quit){

    bundle_terminating=1;

    <span style="color:#00f">if</span>(phase==PHASE_MASTER)

    mp_bundle_terminated();

    }

……

    }

……

    }
</code></pre></div><p>调用handle_events处理事件，见demand模式下对此函数的分析。注意：这里等待事件处理的fds中包含有ppp_dev_fd。接下来调用get_input处理收到的报文：</p>
<p>pppd/main.c</p>
<p>main() -&gt; get_input():</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">get_input</span>()
{
    intlen,i;

    u_char *p;

    u_short protocol;

    <span style="color:#00f">struct</span> protent*protp;

    p=inpacket_buf; <span style="color:#f00;font-style:italic">/* point to beginning of packet buffer */</span>

    len=read_packet(inpacket_buf); <span style="color:#f00;font-style:italic">//读取接收报文到inpacket_buf缓冲区
</span><span style="color:#f00;font-style:italic"></span>
(检查接收数据的有效性，这里不做分析)……

    p+=2;                         <span style="color:#f00;font-style:italic">/* Skip address and control */</span>

    GETSHORT(protocol,p); <span style="color:#f00;font-style:italic">//获取报文中带的协议号
</span><span style="color:#f00;font-style:italic"></span>
    len-=PPP_HDRLEN; <span style="color:#f00;font-style:italic">//有效数据长度
</span><span style="color:#f00;font-style:italic"></span>
……

    <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">    * Upcall the proper protocol input routine.
</span><span style="color:#f00;font-style:italic">    */</span>

    <span style="color:#00f">for</span>(i=0;(protp=protocols[i])!= NULL;++i){

    <span style="color:#00f">if</span>(protp-&gt;protocol==protocol&amp;&amp;protp-&gt;enabled_flag){

    (*protp-&gt;input)(0,p,len); <span style="color:#f00;font-style:italic">//调用每个协议块的input函数来处理接收报文
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">return</span>;

    }

    <span style="color:#00f">if</span>(protocol==(protp-&gt;protocol&amp;~0x8000)&amp;&amp;protp-&gt;enabled_flag

    &amp;&amp;protp-&gt;datainput!= NULL){

    (*protp-&gt;datainput)(0,p,len);

    <span style="color:#00f">return</span>;

    }

    }

……

}
</code></pre></div><p>此函数调用read_packet读取接收报文到inpacket_buf缓冲区，再提取出收到报文的协议号(LCP为0xC021)，然后根据协议号匹配调用对应协议块的input和datainput函数。在第二阶段分析demand模式时已经分析了read_packet函数，这里就不啰嗦了。</p>
<p>至此，PPPD建立连接所需的数据收发基本流程就勾画出来了，这里我们看到的PPPD收发的数据包都是PPP控制帧如LCP，那像IP数据包这种数据流也都要经过PPPD吗？如果连数据流都经过PPPD那效率岂不是很低？</p>
<p>首先来看数据流的接收：</p>
<p>当底层TTY驱动收到数据时会产生一个中断，并在中断处理函数（硬中断或软中断BH）中调用TTY所绑定的线路规程的receive_buf函数指针。</p>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">struct</span> tty_ldiscppp_ldisc={

    .owner =THIS_MODULE,

    .magic    = TTY_LDISC_MAGIC,

    .name    =<span style="color:#009c00">&#34;ppp&#34;</span>,

    .open     =ppp_asynctty_open,

    .close     =ppp_asynctty_close,

    .hangup  =ppp_asynctty_hangup,

    .read      =ppp_asynctty_read,

    .write     =ppp_asynctty_write,

    .ioctl      =ppp_asynctty_ioctl,

    .poll=ppp_asynctty_poll,

    .receive_buf=ppp_asynctty_receive,

    .write_wakeup=ppp_asynctty_wakeup,

};
</code></pre></div><p>对于本文中绑定了N_PPP线路规程的TTY驱动来讲，就是调用ppp_asynctty_receive：</p>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">* This can now be called from hard interrupt level as well
</span><span style="color:#f00;font-style:italic">* as soft interrupt level or mainline.
</span><span style="color:#f00;font-style:italic"> */</span>

<span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_asynctty_receive</span>(<span style="color:#00f">struct</span> tty_struct *tty, <span style="color:#00f">const</span> <span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*buf,
    <span style="color:#00f">char</span> *cflags,<span style="color:#00f">int</span> count)
{
    <span style="color:#00f">struct</span> asyncppp*ap=ap_get(tty);

    unsignedlongflags;

    <span style="color:#00f">if</span>(ap==0)
    <span style="color:#00f">return</span>;

    spin_lock_irqsave(&amp;ap-&gt;recv_lock,flags);

    ppp_async_input(ap,buf,cflags,count); <span style="color:#f00;font-style:italic">//1. 分配skb并放在ap-&gt;rqueue队列中
</span><span style="color:#f00;font-style:italic"></span>
    spin_unlock_irqrestore(&amp;ap-&gt;recv_lock,flags);

    <span style="color:#00f">if</span>(!skb_queue_empty(&amp;ap-&gt;rqueue)) <span style="color:#f00;font-style:italic">//很显然队列不为空
</span><span style="color:#f00;font-style:italic"></span>    tasklet_schedule(&amp;ap-&gt;tsk); <span style="color:#f00;font-style:italic">//2. 调度tasklet来处理skb
</span><span style="color:#f00;font-style:italic"></span>
    ap_put(ap);

    <span style="color:#00f">if</span>(test_and_clear_bit(TTY_THROTTLED,&amp;tty-&gt;flags)
    &amp;&amp;tty-&gt;driver-&gt;unthrottle)
    tty-&gt;driver-&gt;unthrottle(tty);
}
</code></pre></div><ol>
<li>这个函数首先调用ppp_async_input：</li>
</ol>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>

<span style="color:#c34e00">ppp_async_input</span>(<span style="color:#00f">struct</span> asyncppp *ap,<span style="color:#00f">const</span> <span style="color:#00f">unsigned</span> <span style="color:#00f">char</span> *buf,
    <span style="color:#00f">char</span>*flags,intcount)
{

    <span style="color:#00f">struct</span> sk_buff*skb;

    intc,i,j,n,s,f;

    unsignedchar*sp;

(解析buf中的数据并分配一个skb并将ap-&gt;rpkt指针指向这个skb)……

    c=buf[n];

    <span style="color:#00f">if</span>(flags!=NULL&amp;&amp;flags[n]!=0){

    ap-&gt;state|=SC_TOSS;

    }elseif(c==PPP_FLAG){ <span style="color:#f00;font-style:italic">//看到PPP帧结束字符
</span><span style="color:#f00;font-style:italic"></span>
    process_input_packet(ap); <span style="color:#f00;font-style:italic">//把skb放在队列中
</span><span style="color:#f00;font-style:italic"></span>
……

}
</code></pre></div><p>函数ppp_asyc_input读取buf中的数据放在sk_buff中，然后调用process_input_packet把收到的数据包放在接收队列中：</p>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">process_input_packet</span>(<span style="color:#00f">struct</span> asyncppp *ap)
{
    <span style="color:#00f">struct</span> sk_buff*skb;

    unsignedchar*p;

    unsignedintlen,fcs,proto;

    skb=ap-&gt;rpkt; <span style="color:#f00;font-style:italic">//之前保存接收数据的skb
</span><span style="color:#f00;font-style:italic"></span>
(对skb中数据进行有效性检查)……

    <span style="color:#f00;font-style:italic">/* queue the frame to be processed */</span>

    skb-&gt;cb[0]=ap-&gt;state;

    skb_queue_tail(&amp;ap-&gt;rqueue,skb);   <span style="color:#f00;font-style:italic">//把skb放在接收队列中
</span><span style="color:#f00;font-style:italic"></span>
    ap-&gt;rpkt=NULL;

    ap-&gt;state=0;

    <span style="color:#00f">return</span>;
……
}
</code></pre></div><ol start="2">
<li>再用tasklet_schedule(&amp;ap-&gt;tsk)调度tasklet来处理，这个ap-&gt;tsk在哪个地方初始化的呢？前面分析过的ppp_asynctty_open已经初始化了tasklet。这时tasklet函数ppp_async_process会被执行：</li>
</ol>
<p>linux-2.6.18/drivers/net/ppp_async.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">ppp_async_process</span>(<span style="color:#00f">unsigned</span> <span style="color:#00f">long</span> arg)
{
    <span style="color:#00f">struct</span> asyncppp*ap=(<span style="color:#00f">struct</span> asyncppp*)arg;

    <span style="color:#00f">struct</span> sk_buff*skb;

    <span style="color:#f00;font-style:italic">/* process received packets */</span>

    <span style="color:#00f">while</span>((skb=skb_dequeue(&amp;ap-&gt;rqueue))!=NULL){ <span style="color:#f00;font-style:italic">//循环处理队列中所有skb
</span><span style="color:#f00;font-style:italic"></span>
    <span style="color:#00f">if</span>(skb-&gt;cb[0])

    ppp_input_error(&amp;ap-&gt;chan,0);

    ppp_input(&amp;ap-&gt;chan,skb); <span style="color:#f00;font-style:italic">//调用ppp_input来处理skb
</span><span style="color:#f00;font-style:italic"></span>
    }

    <span style="color:#f00;font-style:italic">/* try to push more stuff out */</span>

    <span style="color:#00f">if</span>(test_bit(XMIT_WAKEUP,&amp;ap-&gt;xmit_flags)&amp;&amp;ppp_async_push(ap))

    ppp_output_wakeup(&amp;ap-&gt;chan);
}
</code></pre></div><p>饶了一个圈，实际上是调用ppp_input来处理接收数据包：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_input</span>(<span style="color:#00f">struct</span> ppp_channel *chan,<span style="color:#00f">struct</span> sk_buff *skb)
{
    <span style="color:#00f">struct</span> channel*pch=chan-&gt;ppp;
    <span style="color:#00f">int</span> proto;
    <span style="color:#00f">if</span>(pch==0||skb-&gt;len==0){
    	kfree_skb(skb);
    	<span style="color:#00f">return</span>;
    }

    proto=PPP_PROTO(skb);
    read_lock_bh(&amp;pch-&gt;upl);

    <span style="color:#f00;font-style:italic">/* LCP的协议号为0xC021，因此对控制帧在这里处理 */</span>
    <span style="color:#00f">if</span>(pch-&gt;ppp==0||proto&gt;=0xc000||proto==PPP_CCPFRAG){
        <span style="color:#f00;font-style:italic">/* put it on the channel queue */</span>
        skb_queue_tail(&amp;pch-&gt;file.rq,skb); <span style="color:#f00;font-style:italic">//放在channel的接收队列中
</span><span style="color:#f00;font-style:italic"></span>
        <span style="color:#f00;font-style:italic">/* drop old frames if queue too long */</span>
        <span style="color:#00f">while</span>(pch-&gt;file.rq.qlen&gt;PPP_MAX_RQLEN
    			&amp;&amp;(skb=skb_dequeue(&amp;pch-&gt;file.rq))!=0)
    	kfree_skb(skb);
    	wake_up_interruptible(&amp;pch-&gt;file.rwait); <span style="color:#f00;font-style:italic">//唤醒PPPD进程进行read处理
</span><span style="color:#f00;font-style:italic"></span>    }<span style="color:#00f">else</span>{
    	ppp_do_recv(pch-&gt;ppp,skb,pch); <span style="color:#f00;font-style:italic">//对非控制帧进行处理
</span><span style="color:#f00;font-style:italic"></span>    }
    read_unlock_bh(&amp;pch-&gt;upl);
}
</code></pre></div><p>函数ppp_input分两种情况分发报文：</p>
<ol>
<li>对控制流，放在channel的接收队列中并唤醒PPPD进程读取。</li>
<li>对数据流，调用ppp_do_recv：</li>
</ol>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_do_recv</span>(<span style="color:#00f">struct</span> ppp *ppp,<span style="color:#00f">struct</span> sk_buff *skb,<span style="color:#00f">struct</span> channel *pch)
{
    ppp_recv_lock(ppp);

    <span style="color:#f00;font-style:italic">/* ppp-&gt;dev == 0 means interface is closing down */</span>
    <span style="color:#00f">if</span>(ppp-&gt;dev!=0)
    	ppp_receive_frame(ppp,skb,pch);
    <span style="color:#00f">else</span>
         kfree_skb(skb);

    ppp_recv_unlock(ppp);
}
</code></pre></div><p>由于PPP unit上已建立了ppp0网络接口，这里会调用ppp_receive_frame：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_receive_frame</span>(<span style="color:#00f">struct</span> ppp *ppp,<span style="color:#00f">struct</span> sk_buff *skb, <span style="color:#00f">struct</span> channel *pch)
{
    <span style="color:#00f">if</span>(skb-&gt;len&gt;=2){
<span style="color:#f00;font-style:italic">#ifdef CONFIG_PPP_MULTILINK
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">/*XXX do channel-level decompression here */</span>
    <span style="color:#00f">if</span>(PPP_PROTO(skb)== PPP_MP)
    	ppp_receive_mp_frame(ppp, skb, pch);
    <span style="color:#00f">else</span>
<span style="color:#f00;font-style:italic">#endif</span><span style="color:#f00;font-style:italic">/* CONFIG_PPP_MULTILINK */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>    	ppp_receive_nonmp_frame(ppp,skb); <span style="color:#f00;font-style:italic">//非多链路PPP
</span><span style="color:#f00;font-style:italic"></span>    	<span style="color:#00f">return</span>;
    }

    <span style="color:#00f">if</span>(skb-&gt;len&gt;0)
    <span style="color:#f00;font-style:italic">/* note: a 0-length skb is used as an error indication */</span>
    ++ppp-&gt;stats.rx_length_errors;

    kfree_skb(skb);
    ppp_receive_error(ppp);
}
</code></pre></div><p>对于非多链路PPP调用ppp_receive_nonmp_frame：</p>
<p>linux-2.6.18/drivers/net/ppp_generic.c</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span>
<span style="color:#c34e00">ppp_receive_nonmp_frame</span>(<span style="color:#00f">struct</span> ppp*ppp,<span style="color:#00f">struct</span> sk_buff*skb)
{

    <span style="color:#00f">struct</span> sk_buff*ns;

    intproto,len,npi;

……

    <span style="color:#00f">if</span>((ppp-&gt;dev-&gt;flags&amp;IFF_UP)==0

    ||ppp-&gt;npmode[npi]!=NPMODE_PASS){

    kfree_skb(skb);

    }<span style="color:#00f">else</span>{

    <span style="color:#f00;font-style:italic">/* chop off protocol */</span>

    skb_pull_rcsum(skb,2);

    skb-&gt;dev=ppp-&gt;dev;

    skb-&gt;protocol=htons(npindex_to_ethertype[npi]);

    skb-&gt;mac.raw=skb-&gt;data;

    netif_rx(skb); <span style="color:#f00;font-style:italic">//把skb放入Linux协议栈去处理
</span><span style="color:#f00;font-style:italic"></span>
    ppp-&gt;dev-&gt;last_rx=jiffies;

    }

    }

    <span style="color:#00f">return</span>;

……
}
</code></pre></div><p>对于数据流，最终还是调用netif_rx(skb)将数据包放入Linux协议栈去处理。</p>
<p>结论：在PPP连接成功建立之前，为建立连接而传输的控制流都要通过PPPD进行报文解析并根据各控制协议的状态机和用户配置进行报文的收发、超时及状态迁移等处理。 当PPP连接经过三阶段LCP-&gt;PAP/CHAP-&gt;IPCP成功建立之后， 经过ppp0接口的数据流就直接通过Linux内核进行处理而不必经过PPPD，实现了控制路径与数据路径，策略与机制的有效分离。</p>
<p><a href="https://blog.csdn.net/osnetdev/article/details/8958058">以上内容转载自本连接</a></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/l2tp" rel="tag" title="L2TP">#L2TP#</a>
    
    <a href="http://shanks.link/tags/ppp" rel="tag" title="PPP">#PPP#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2023/12/01/%E4%B8%AD%E5%B9%B4%E4%BA%BA%E7%9A%84%E7%9B%AE%E6%A0%87/" rel="next" title="中年人的目标">
        <i class="fa fa-chevron-left"></i> 中年人的目标
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2023/11/24/pppoe%E7%AE%80%E4%BB%8B/" rel="prev" title="PPPOE简介">
        PPPOE简介 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2024</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>