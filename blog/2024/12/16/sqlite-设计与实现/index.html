<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>sqlite 设计与实现 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="sqlite 设计与实现">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="sqlite 设计与实现 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/food/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />food
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/finance/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />投资
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2024/12/16/sqlite-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url">
        sqlite 设计与实现
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2024-12-16">
    2024-12-16
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/db" itemprop="url" rel="index">
        <span itemprop="name">db</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/sqlite" itemprop="url" rel="index">
        <span itemprop="name">sqlite</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/c" itemprop="url" rel="index">
        <span itemprop="name">c</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">29761 字 ~60分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="第二章-sqlite概述">第二章 SQLite概述</h1>
<h3 id="学术目标">学术目标</h3>
<ul>
<li>SOLite数据库系统及其功能</li>
<li>SOLite支持哪些显著特性</li>
<li>SOLite如何将表存储在数据库文件中</li>
<li>如何编写、编译和执行SQLite应用程序</li>
<li>一些最常用的SOLite API</li>
<li>模块化的SOLite体系结构</li>
<li>SQLite的限制</li>
</ul>
<h3 id="章节概要">章节概要</h3>
<pre><code>SQLite是一个小型的、零配置的、定制的、可嵌入的、线程安全的、易于维护的、面向事务的、基于SOL的关系数据库管理系统。它将整个数据库存储在包含所有表和索引的单个文件中。它将所有表组织成单独的B+树，并将索引组织成B树。它支持核心事务属性，即原子性、一致性、隔离性和持久性。它使用基于锁的并发控制方案和基于日志的恢复方案。
</code></pre>
<p>SQLite 支持 ANSI SOL-92 功能的较大子集和许多 SQLite 特定命令。此外，它提供了一个良好的框架，您可以在其中定义定制的 SOL函数、聚合器和排序序列。它还支持基于 Unicode 文本的 UTF-8和 UTF-16 标准的编码。</p>
<pre><code>本章几乎涵盖了SQLite的所有功能。它提供了一个高层次的概述，介绍SOLite如何与SOL应用程序一起工作。通过展示一些简单的应用程序，它认您熟悉一些SOLiteAPI，这些API用于SOLite和数据库应用程序之间的正常交互。它还展示了SQLite源代码的结构和组织。总的来说，本章是SQLite的简短介绍。
</code></pre>
<h3 id="21-solite简介">2.1 SOLite简介</h3>
<pre><code>在过去的几十年里，许多数据库管理系统(DBMS)已经被开发出来。Informix、Ingres、MySOL、甲骨文、PostgreSOL、SOLServer、Sybase是这里要提到的个商业上成功的企业数据库应用程序。成功的嵌入式数据库系统包括SybaseiAnywhere、系统间缓存、微软Jet。SQLite[22]SQLite是关系数据库管理系统(RDBMS)家族中的一个新成员，也是一个非常成功的嵌入式数据库系统。1SQLite 于2000年5月29日首次公开发布，作为Alpha代码的初始公开发布，其功能集非常有限。SQLite1.0于2000年8月17日发布。自那时以来，它已经走过了漫长的旅程。SOLite2.0.0于2001年9月20日发布，SOLite3.0.0于2004年6月18日发布。截至 2011年9月19日，最新的版本是SQLite3.7.8。本书基于这个特定的版本。SOLite 开发团队继续发布新版本。您可以通过访问 SOLite 主页http://www.sqlite.org获取最新版本。您可以在 http://www.sqlite.org/changes.html网页上找到功能开发的时序事件。(当这本书在你手中时，SOLite肯定会有不同的更新版本。但是，核心功能和处理数据的方式预计不会变化太大。在这里学到的知识将帮助你理解新功能。通过阅读这本书，你一定会对设计和开发嵌入式数据库系统所需的内容有感觉。我鼓励你自己开发一个。
</code></pre>
<h4 id="211显著的sqlite特性">2.1.1显著的SQLite特性</h4>
<pre><code>SQLite完全使用ANSIC程序设计语言开发。它是一个易于维护、相对快速基于SQL的RDBMS。它具有以下优良、差异化和值得称道的特点。
</code></pre>
<ul>
<li>零配置:在使用SQLite数据库管理软件之前，您不需要执行任何单独的安装或设置步骤来初始化它。没有特定的步骤来启动SOLite。没有配置文件来控制不同的行为。数据库不需要任何管理。您可以从其主页 <a href="http://www.sqlite.org/download.html">http://www.sqlite.org/download.html</a>，使用您喜欢的C编译器将其编译为可执行库，并开始将库作为数据库应用程序的一部分使用。对于有限数量的平台，您可以从那里获取库。</li>
<li>可嵌入:您不需要单独的服务器进程专门用于 SOLite。SOLite库可以嵌入到您自己的应用程序中。应用程序不需要包含任何进程间通信方案来与SOLite 交互。</li>
<li>应用程序接口:SOLite为C应用程序提供了一个SOL环境来操作数据库。它为动态SOL提供了一组调用级应用程序编程接口(API)函数;您可以动态组装SQL陈述并将其传递到接口进行执行。此外，您还可以使用许多回调功能。应用程序没有特殊的预处理和编译要求;普通的C编译器可以完成这项工作。</li>
<li>事务支持:SQLite支持核心事务属性，即原子性、一致性、隔离性和持久性(ACID)。在系统崩溃或电源故障时，数据库用户或管理员无需采取任何操作即可恢复数据库。当SQLite读取数据库时，它会自动以用户透明的方式对数据库执行必要的恢复操作。</li>
<li>线程安全:SOLite是一个线程安全的库，应用程序中的多个线程可以同时访问相同或不同的数据库。SOLite 处理数据库级别的线程并发。</li>
<li>轻量级:在启用所有 SQLite功能时，SQLite库的占用空间约为 324KB(在Linux上使用 gcc-0s时为 331835 字节)。如果从源代码构建库时禁用所有言级功能，占用空间可以减少到约 190KB。</li>
<li>可定制性:SOLite提供了一个良好的框架，您可以在其中定义和使用定制的SQL函数、聚合函数和整理序列。</li>
<li>Unicode:SOLite支持基干UTF-8和UTF-16标准的Unicode文本编码。
UTF16 同时支持小单位和大单位形式。</li>
<li>防止内存泄漏:如果应用程序严格遵循推荐的与SQLite库交互的协议，则该库声称从不泄漏内存。</li>
<li>内存需求:虽然SOLite可以使用无限量的堆栈和堆空间，但可以设置最小的堆栈空间为4KB和大约100KB的堆。这个特性对于受内存限制的小型设备(如手机)非常有效。主内存量很小。但是，可用内存越多，SOLite性能越好。</li>
<li>多平台:SOLite运行在Linux、Windows、MacOSX、0S/2、0penBSD和其他一些操作系统上。它也运行在嵌入式操作系统上，如Android、Symbian、Palm、VxWroks.
单个数据库文件:每个数据库完全存储在单个本地文件中;用户数据和元数据存储在同一个文件中。单文件方法简化了将数据库从一个地方移动/复制到另一个地方的过程。(SQLite在操作数据库时会使用许多临时文件。)</li>
<li>跨平台:SQLite 允许您在平台之间移动数据库文件。例如，您可以在Linuxx86机器上创建一个数据库，并在ARM、Windows或MAC平台上使用相同的数据库(通过复制)而无需任何更改。数据库在所有支持的平台上都具有相同的行为。您可以在 32位和 64 位机器之间或在大小端系统之间使用相同的数据库而没有任何问题。</li>
<li>向后兼容性:SOLite3具有向后兼容性。这意味着任何较新的库版本都可以与较早库版本创建的数据库一起工作。SQLite 开发团队努力保持库的向后兼容性。但是，版本3的库无法与版本2的数据库一起工作。</li>
</ul>
<h4 id="212使用简单">2.1.2使用简单</h4>
<p>        与大多数现代 SOL数据库管理系统不同，SOLite的首要设计目标是简单。SQLite 开发团队信奉 KISS 哲学:保持简单和卓越。他们努力保持 SOLite的简单性，即使这会导致某些功能的低效实现。本质上，SOLite是</p>
<ul>
<li>
<p>易于管理。</p>
</li>
<li>
<p>操作简单。</p>
</li>
<li>
<p>简单地嵌入到C应用程序中。</p>
</li>
<li>
<p>易于维护。</p>
</li>
<li>
<p>易于定制。</p>
</li>
<li>
<p>实现了 ACID 要求。</p>
<p><strong>简单性</strong>:	简单的软件更容易实现、测试、维护、增强、集成、文档等。SQLite满足这些标准
为了实现简单性，SQLite开发团队选择牺牲许多数据库用户认为有用的DBMS特性，如高事务并发、细粒度访问控制、许多内置函数、存储过程-些SQL语言特性(如对象关系)、太字节或拍字节的可扩展性等。
可靠性:SQLite非常可靠。这种可靠性似乎是其简单性的结果。</p>
</li>
</ul>
<h4 id="213-sql特性和sqlite命令">2.1.3 SQL特性和SQLite命令</h4>
<p>        SOLite支持ASIC SOL-92数据定义和数据操作功能的大子集，以及一些SQLite特定的命令。(这些命令类似于SOL陈述，但它们本身不会操纵用户数据。)您可以使用标准数据定义SOL结构创建表、索引、触发器和视图。您可以使用SYS、SYS、GROUP和SEN SOL结构来操作存储的信息。以下是自SOLite3.7.8版本起支持的SOL功能列表。(未来的每个新版本都可能具有其他功能。可从SOLite网页http:/www.sqlite.org/lang.html获取最新的受支持功能集。
1.数据定义语言DDL:</p>
<ul>
<li>
<p>创建表、索引、视图和触发器;</p>
</li>
<li>
<p>删除表、索引、视图和触发器;</p>
</li>
<li>
<p>部分支持ALTERTABLE(重命名表和添加列):</p>
</li>
<li>
<p>唯一，非空，并检查约束条件;</p>
</li>
<li>
<p>掭轆顶足縲衍键约束;</p>
</li>
<li>
<p>自动增量，整理列;</p>
</li>
<li>
<p>解决冲突。</p>
<p>2.数据操作语言DML:</p>
</li>
<li>
<p>插入、删除、更新和选择;</p>
</li>
<li>
<p>子查询，包括相关子查询;</p>
</li>
<li>
<p>按组别、按顺序、抵消限额、整理;</p>
</li>
<li>
<p>内接头，左外接头，自然接头;</p>
</li>
<li>
<p>联合，联合所有，相互作用，除外:</p>
</li>
<li>
<p>命名参数和参数绑定;</p>
</li>
<li>
<p>每行触发器。</p>
<p>3.事务性命令:</p>
</li>
<li>
<p>开始;</p>
</li>
<li>
<p>承诺;</p>
</li>
<li>
<p>滚动;</p>
</li>
<li>
<p>保存点;</p>
</li>
<li>
<p>滚动返回;</p>
</li>
<li>
<p>释放。</p>
<p>4.SQLite命令:</p>
</li>
<li>
<p>reindex;</p>
</li>
<li>
<p>附着，拆卸;</p>
</li>
<li>
<p>解释;</p>
</li>
<li>
<p>pragma.</p>
</li>
</ul>
<p>        SQL标准规定了大量的关键字，这些关键字不能用作表、视图、索引、列、约束或数据库的名称。SQLite放宽了这一限制，允许您使用关键字作为标识符，方法是在它们周围使用反引号或单引号或双引号或'【和&quot;】&lsquo;对。此外，SOLite提供了一个良好的框架，您可以在其中定义和使用自定义SOL函数聚合函数和排序序列。宏是特殊的SOLite命令，用于更改SOLite库的行为或查询库的内部(非表)元数据。SOLiteattach命令可帮助事务同时在多个数据库工作。此类事务也符合ACID要求。</p>
<p>在SQLite3.7.8发行版中，尚未支持以下ANSISOL-92特性(有关当前列表，请参阅http://www.sqlite.org/omitted.html网页)。</p>
<ol>
<li>许多ALTERTABLE特性，例如重命名或删除列，添加或删除约束;</li>
<li>对于每个语句触发器;</li>
<li>右侧和完全外部接头;</li>
<li>更新视图;</li>
<li>授予和撤销。</li>
</ol>
<h4 id="214数据库存储">2.1.4数据库存储</h4>
<p>        SQLite将整个数据库存储在单个的普通本地文件中，文件可以位于本地文件系统目录中的任何位置。我们经常说文件与数据库是同义词，因为没有其他文件存储有关数据库本身的信息。具有读取文件权限的用户可以从数据库中读取任何内容。具有写入文件和容器目录权限的用户可以更改数据库中的任何内容。只要本地操作系统/文件系统允许文件增长，数据库就可以增长。SOLite在Linux系统上支持非常大的文件(&gt;2GBytes)选项，如果这些系统有此选项。它将所有表和索引分别组织为单独的B+树和B树。它使用单独的日志文件来保存事务恢复信息，这些信息在发生事务中断或系统故障时使用。</p>
<h4 id="215有限的并发性">2.1.5有限的并发性</h4>
<p>SQLite允许多个应用程序同时访问同一个数据库。然而，它只支持有限形式的并发事务。它允许在数据库上进行任意数量的并发读取事务，但只允许个独占的写入事务。它没有支持更精细数据粒度(如表、页、行、列或单元格)并发的能力。</p>
<h4 id="216-usage">2.1.6 usage</h4>
<p>    QLite是一个非常成功的嵌入式RDBMS。它已被广泛用于低到中等层次的数据库应用程序，如Web服务、手机、掌上电脑、机顶盒、独立设备。你甚至可以在初学者数据库课程中使用它来教授关系数据库和SOL语言。你也可以在高级数据库管理课程中使用它，或者在数据库项目中作为参考技术使用，它是免费提供的，而且由于它处于公共领域，所以没有许可证的复杂性。(虽然有一些可选的专有部件，如用于智能卡的SQLite，以及需要从SQLite的拥有者Hwaci订购的加密解决方案。课程学生可能不担心这些专有组件擰攥饕*鯀峱)砑
Web服务器:基于SQLite的Web服务器工作良好，每天平均分配的点击量可达100，000次;SQLite开发团队已经证明SQLite甚至可以承受每天1，000，000次的点击量。</p>
<p>        SOLite是开源的，并且可以在公共领域使用(有关开源的更多信息，请访问http://opensource.org)。您可以从网页http://www.sqlite.org/download.html下载SOLite源代码，使用您喜欢的C编译器将其编译为可执行库，并使用数据库应用程序开始使用该库。SOLite在Linux、Windows、MACOSX、0S/2、Solaris、OpenBSD和其他一些操作系统上运行。在这本书中，我仅限于SQLite3.7.8的Linux版本，这是截至9月19.2011年的最新版本。</p>
<h2 id="22-示例sqlite应用程序">2.2 示例SQLite应用程序</h2>
<p>        在本节中，我将向您介绍一些简单的数据库应用程序，这些应用程序展示了SQLite 的各种核心功能。您将熟悉一些最重要和最常用的 SOLite API函数和 API常量。除了第 2.2.2 节讨论一些 API外，应用程序将在以下小节中介绍。您可能记得，SQLite是一个嵌入式库，它被嵌入到应用程序进程地址空间中。图 2.1展示了 SOLite 应用程序的一般架构。如图所示，SOLite库被嵌入到应用程序进程中，进程堆空间的一部分用于存储 SQLite 的运行时数据。当然，当SQLite的API函数被调用时，它会使用堆。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216145358.png" alt="图2.1:一个使用SQL库的通用数据库应用程序。"></p>
<h3 id="221一个简单的应用程序">2.2.1一个简单的应用程序</h3>
<p>让我们通过研究一个非常简单的应用程序来开始对SQLite领域的探索。图22展示了一个典型的SOLite应用程序。这是一个典型的C程序，它调用SOLiteAPI函数来处理单个SOLite数据库。它演示了使用SOLite通过执行SOL查询来访问数据库的简单方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3*db=0;<span style="color:#f00;font-style:italic">/*connection handle */</span>
    sqlite3_stmt*stmt=0;<span style="color:#f00;font-style:italic">/*statement handle */</span>
    <span style="color:#00f">int</span> retcode;
    retcode = sqlite3_open(<span style="color:#009c00">&#34;MyDB”, &amp;db); /* Open a database named MyDB */</span>
    <span style="color:#00f">if</span> (retcode !- SQLITE_OK){
        sqlite3_close(db);
        fprintf(stderr,<span style="color:#009c00">&#34;Could not open the MyDB database</span><span style="color:#009c00">\n</span><span style="color:#009c00">” );</span>
        <span style="color:#00f">return</span> retcode;
    }

    retcode=sqlite3_prepare(db,<span style="color:#009c00">&#34;select SID from Students order by SID&#34;</span>,-1,&amp;stmt, 0)
    <span style="color:#00f">if</span> (retcode != SQLITE_OK) {
        sqlite3_close(db):
        fprintf(stderr,<span style="color:#009c00">&#34;Could not compile a select statement</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>);
        <span style="color:#00f">return</span> retcode;
    }

    <span style="color:#00f">while</span>(sqlite3_step(stmt)=-SQLITE_ROW) {
        <span style="color:#00f">int</span> i =  sqlite3_column_int(stmt, 0);
        printf(<span style="color:#009c00">&#34;SID = %d</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, i);
    }

    sqlite3 finalize(stmt);
    sqlite3_close(db);
    <span style="color:#00f">return</span> SQLITE_OK:
}
</code></pre></div><p>        您可以编译上述示例应用程序并执行它。本文件中显示的示例输出是在Linux 机器上生成的，但这些示例将在 SOLite 运行的其他平台上工作。</p>
<p><strong>注:</strong> 这些示例假定您已经准备了sqlite3可执行文件、libsqlite3.so(Windows上为 sqlite3.dll，Mac OSX上为 libsqlite3.dylib)共享库和 sqlite3.h接囗定义文件。您可以从 <a href="http://www.sqlite.org">http://www.sqlite.org</a> 以源代码或二进制形式获取这些文件。(二进制文件仅适用于 Linux、MACOSX和Windows。)如果您将所有三个文件(sqlite3、共享库和 sqlite3。</p>
<p>        例如，假设你正在Linux系统上，并将示例程序保存为app1.c，与libsqlite3.so、sqlite3和sqlite3.h位于同一目录中</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gcc app1.c -o./app1 -lsqlite3 -L.
</code></pre></div><p>        它将在当前工作目录下生成一个名为appl的二进制文件。您可能执行该应用程序以查看输出。要在Linux系统上拉取SQLite库，您可能需要将工作目录名称包含在LD.LIBRARY PATH环境变量中。是的，您运行了app1，但它没有产生任何输出;这是因为您当前工作目录中缺少应用程序所需的“MyDB”数据库。</p>
<p><strong>注意:</strong> SQLite源代码和应用程序必须使用相同的编译器进行编译。如果您已将SQLite作为软件包安装，或者您的操作系统发行版预装了SQLite，则可能需要使用不同的编译器参数。例如，在Ubuntu上，您可以使用命令sudoaptitudeinstall sqlite3 libsqlite3-dev安装SOLite，并使用命令cc appl.c-o./app11sqlite3编译示例应用程序。由于SQLite包含在MacOSX的较新版本中，因此相同的编译命令也适用干Mac OSX。</p>
<p>        该应用程序在当前工作目录中打开MyDB数据库文件。该数据库至少需要个名为Students的表;该表必须至少有一个名为SID的整数列。在下一个示例应用程序中，您将学习如何在数据库中创建新表，以及如何插入表中的行，但就目前而言，您可以使用sqlite3实用程序通过这些命令创建和填充表:
./sqlite3 MyDB&quot;创建学生表(SID整数)
./sqlite3 MyDB&quot;插入学生值(200)&quot;
./sqlite3 MyDB&quot;插入学生值(100)1
./sqlite3 MyDB&quot;插入学生值(300)
如果您现在运行 app1，您将看到以下输出:
SID =100
SID =200
SID =300</p>
<p><strong>注意:</strong> 在Linux、Unix和Mac 0SX上，在命令提示符下键入app1名称时，可能需要将它前缀为./，如:./app1
        打开数据库后，应用程序app1首先准备SQL语句:selectSIDfromStudentsorder bySID。然后，它遍历由该语句生成的结果行集，逐个获取SID值，并打印这些值。最后，它关闭准备好的语句和数据库。</p>
<p>        SQLite 是一个调用级接口库，在运行时嵌入到应用程序进程的地址空间中。该库将所有 SQLite API实现为C函数。所有 API函数名都以sqlite3开头(API常量以 SQLITE_开头)，它们的签名在 sqlite3.h中声明。其中几个函数在 app1应用程序中使用，即 sqlite3 open、sqlite3_prepare、sqlite3_step、sqlite3column int、sqlite3 finalize和sqlite3 close.
该应用程序还使用了一些助记API常量，即SOLITEOK和SOLITE.ROW，用于比较API函数返回的值。在介绍其他SOLite应用程序之前，下一节将讨论一些关键的SOLite APl.</p>
<h3 id="222-sqlite-apis">2.2.2 SQLite APIs</h3>
<p>SQLite接口定义了一组API(一组C函数和一组命名常量)。API函数是应用程序和SQLite库之间正常通信的唯一手段。(SOLite还使用回调C函数，这些函数驻留在应用程序空间中。)我在上一节中概述了一些API函数。这里我介绍一组基本的API函数，它们在SOLite应用程序中最为常用。这些和其他API函数的详细讨论可以在SOLite网页http://www.sqlite.org/capi3refhtml中找到。大约有185个API函数。所有API函数和常量的列表可以在http://www.sqlite.org/c3ref/funclist.html双页上找到。</p>
<ol>
<li>sqlite3 open:这个函数有两个参数，一个输入，另一个输出。输入是-个数据库文件名。通过执行open函数，应用程序与SQLite库建立一个新的连接或会话，以访问给定的数据库文件。在这本书中，我将其称为库连接。(应用程序可能有其他打开的库连接来访问相同或不同的数据库。SQLite对这些库连接进行区分处理，在SQLite的范围内它们是相互独立的。)在库连接内部，函数打开数据库文件。如果文件不存在，该函数会自动创建数据库文件;默认文件权限为0644。如果数据库成功打开(或创建)，则该函数将SQLITE OK返回给应用程序。否则，应用程序将获得错误代码。
<strong>懒散的文件打开:</strong> 在打开或创建数据库文件时，SQLite遵循一种懒散的方法-一实际的打开或创建被推迟到文件被读取时。如果数据库文件确实存在，SQLite会自动恢复数据库到一个一致的状态，如果需要的话。懒散的文件创建给你一个机会，使用pragma命令(这些设置参数将在第3章中讨论)来(重新)定义各种数据库设置参数。
open 函数通过输出参数(在前面的示例中为 db)返回一个连接句柄(指向sqlite3 类型对象的指针)，该句柄用于对库连接(对于此打开的 SQLite 会话)执行进一步操作。该句柄表示此库连接的完整状态。
图2.3显示了一个典型的场景，其中应用程序已经打开了两个到SQLite库的连接，以访问同一个数据库文件。库连接是相互独立的，它们分别由单独的sqlite3对象表示。-个单独的sqlite3库中的对象表示和管理单个库连接。如图所示，理语句，而另一个连接没有。我接下来讨论预处理语句。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216151314.png" alt="图2.3:应用程序与SQLite库的连接。">
**较新的APIs:**最近，SQLite开发团队不鼓励使用这个open函数;他们推荐使用sqlite3_open_v2函数。还有其他许多_V2 API函数。为了保持应用程序呈现的简洁性，我避免在本书中使用这些较新的API函数。</li>
<li>sqlite3_prepare:此函数编译一个SQL语句，并生成一个等效的内部对象(类型为sqlite3 stmt)。在数据库文献中，此对象通常被称为预置语句，并在SOLite中以字节码程序实现。字节码程序是数据库引警执行的SOL语包的抽象表示。我将在175页的7.2节中讨论字节码程序设计语言。在本书中，我可以互换使用字节码、程序和准备语句来表示相同的意思。该函数在成功时返回SQLITEOK，在失败时返回适当的错误代码。
prepare 函数通过一个形式参数(如前面的示例中的 stmt)返回一个语句句柄(一个sqlite3 stmt类型的对象的指针)，该句柄用于对准备好的语句执行进一步的操作。在前面的示例程序中，我将从Students 表中选择 SID 的语句作为语句句柄。该句柄类似于一个打开的游标，用于获取选择语句产生的结果行集，一次一行。游标通过执行sqlite3 step APl函数向前移动，我将在下面讨论该函数。</li>
<li>sqlite3 step: 在使用 sqlite3 prepare 函数准备 SOL语句后，必须调用sqlite3_step 函数一次或多次来执行准备好的语句。每次调用 step 函数都会执行字节码程序，直到遇到断点(因为它产生了新的输出行)或直到没有更多行为止。在前一种情况下，该函数返回调用者SQLITE.ROW，在后一种情况下返回 SQLITE DONE。在前一种情况下，应用程序可以使用适当的 sqlite3 column*AP|函数读取行的列值。(参见列表中的下一个项目。)再次调用步骤函数以检索下一行。步骤函数移动 SELECT语分结果的游标位置。最初，游标指向输出行集的第一行之前。每次执行步骤函数时，游标指针都会移动到行集中的下一行。游标只能向前移动。对于不返回行的 SOL语句(如UPDATE、INSERT、DELETE、CREATE 和DROP)，由于没有行需要处理，步骤函数始终返回SOLITE DONE。最终，step 函数返回 SOLITE DONE。(如果没有先调用 sqlite3 reset函数将程序执行重置回初始状态，则不应再次调用此语句句柄上的 step 函数。我稍后将讨论重置函数。)
如果在执行步骤函数时出现错误，返回代码为SOLITE BUSY、SOLITEERROR或SOLITE.MISUSE。SOLITE.BUSY表示引擎尝试访问一个繁忙(即锁定)的数据库，并且没有注册回调函数来解决这种情况，或者回调函数已决定中断执行。应用程序可以稍后再次调用步骤函数以重试预编译语句的执行。SOLITE ERROR表示发生运行时错误(如约束违反);不应再次在语句句柄上调用步骤函数。SOLITE MISUSE表示步骤函数调用不当。可能在已完成的预处理语句(即已关闭的语句)或先前返回SQLITEERROR或SOLITE DONE的语句上调用该语句。</li>
<li>sqlite3 column <em>:如果sqlite step函数返回SQLITE ROW，您可以通过执行sqlite3 column</em>API函数之一来检索该行中每个列的值。SOL/SOLite和C语言之间的数据类型不匹配由引擎自动处理:列函数将数据从一种语言转换为另一种语言，并从存储类型转换为请求的类型。(例如，如果值的内部表示是FLOAT，而应用程序请求文本输出值，则SOLite在内部使用sprintf()进行值转换。)
以下五个列AP|函数可用:sqlite3 column int，sqlite3 col int64,sqlite3 column double、sqlite3 column text和sqlite3 column blob 用于从列中读取数据。每个函数名称的最后一个部分指示应用程序可以从SQLite 库中期望哪种值。在上面的示例应用程序中，每个输出行都是一个整数值，我们通过执行sqlite3 column int函数来读取 SID 列的值，该函数返回整数值。(如果语句句柄当前未指向有效行，或者如果列索引超出范围，则这些函数产生的输出是未定义的。最左边的列的索引是0，下一个是1，下
2,等等。您可以使用 sqlite3 column countAPl函数获取列的总数量。对干非选择语句，它返回0。)Blob和文本值需要应用程序知道它们的大小。SOLite有sqlite3 column bytes函数，该函数返回列值的大小，单位为字节。</li>
<li>sqlite3 finalize:此函数关闭并销毁一个语句句柄和相关联的预处理语句。也就是说它会擦除字节码程序，并释放分配给语句句柄的所有资源。语句句柄变为无效，不能再次使用。
如果语句执行成功或根本没有执行，则finalize 函数返回 SQLITE OK如果先前执行的语句失败，则该函数返回错误代码。finalize函数可以在执行预处理语句的任何时间点调用。如果引擎在执行此例程时尚未完成语句执行，则就像在执行过程中遇到错误或中断一样。不完整的更新将被回滚，执行将被中断，返回的结果代码将是 SOLITE ABORT。</li>
<li>sqlite3 close:此函数关闭库连接，并释放分配给该连接的所有资源。连接句柄变为无效。如果成功，此函数返回SOLITEOK，如果失败，则返回其他错误代码。如果存在尚未完成的预处理语句，则返回SQLITEBUSY，连接保持打开状态。</li>
<li>其他有用的函数:上面讨论的六个(类别)API函数是SQLite库的核心，它处理两个主要数据结构，即sqlite3和sqlite3 stmt。其他广泛使用的API函数是sqlite3 bind *和sqlite3 reset.
在SOL语句字符串(传递给sqlite3 prepare函数的输入)中，您可以使用SQL位置参数标记&rsquo;?'(或编号或命名的参数?NNN，:AAA，@AAA或SAAA，其中NNN是整数，AAA是字母数字标识符)替换一个或多个字面值。它们成为预处理语句的输入参数。对于无编号/无命名参数，最左边的参数具有索引1。对于编号参数，索引是数字。对于命名参数，索引可以通过以下方式获得调用 sqlite3 bind parameter index AP|函数。这些参数的值可以使用绑定函数设置。(如果在多个地方使用命名或编号参数，则对所有地方使用相同的绑定值。)如果未将值绑定到参数，则使用 SOLNULL值。以下七个绑定AP|函数可用:sqlite3 bind null、sqlite3 bind int、sqlite3 bind int64、sqlite3 bind double、sqlite3 bind text.sqlite3 bind blob和 sqlite3 bind value。每个函数名称的最后一个部分指示可以使用该函数将哪种值绑定到参数。(sqlite3 bindvalue函数帮助绑定泛型值。)
重置API函数将语句句柄(即预编译语句)重置为其初始状态，但有一个例外:所有已绑定值的参数保留其值。语句变得准备好由应用程序重新执行，并在重新执行时重用这些绑定值。但是，在开始重新执行之前，应用程序可以通过再次执行绑定函数来替换这些值的一部分或全部。或者，可以通过执行sqlite3 clear bindings APl函数来删除所有绑定值。 重置功能对于重复查询非常有用。</li>
<li>返回值:所有API函数都返回零整数或正整数值。SOLite开发团队强烈建议使用记忆术检查返回值，而不是硬编码整数值。返回值SOLTEOK表示成功;SQLITE ROW表示sqlite3step函数在SE-LECT语句返回的行集中找到了新行;SOLITE·DONE表示语句执行完成。截至SOLite3.7.8发行版，共有28个主要的和一些扩展的成功和错误代码。由于返回代码是SQLite接口的一部分，它们的值不会从一个小版本到另一个版本发生变化。</li>
</ol>
<p>        总之，应用程序准备SOL语句，如果需要，则将值绑定到准备好的语句多次执行准备好的语句，然后重置准备好的语句以便再次执行具有相同或不同绑定值的语句。应用程序最终确定语句以销毁准备好的语句。
Unicode AP1:上述API函数处理UTF-8编码的输入文本。还有单独的API函数只处理UTF-16编码的文本。</p>
<h3 id="223-sol直接执行">2.2.3 SOL直接执行</h3>
<p>图2.42展示了另一个可以从命令行运行的SQLite应用程序，用于交互式地操作数据库。该命令有两个参数:第一个参数是数据库文件名，第二个是 SQL语句。它首先打开数据库文件，然后通过执行sqlite3execAPI函数将语句应用于数据库，最后关闭数据库文件。exec函数直接执行SQL语句，而不需要应用程序像之前的示例应用程序那样手动执行prepare、step 和 finalize AP|函数。如果语句产生输出，则 exec函数为每个输出行执行回调函数，并允许应用程序进一步处理该行。您必须对给定的数据库文件拥有读取权限，并且根据查询类型，您可能需要对文件及其包含的目录拥有写入权限。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>include <span style="color:#009c00">&#34;sqlite3.h&#34;</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> callback(<span style="color:#00f">void</span> *unused, <span style="color:#00f">int</span> argc, <span style="color:#00f">char</span> **argv, <span style="color:#00f">char</span> **colName)
{
    <span style="color:#00f">int</span> i;
    <span style="color:#00f">for</span>(i= 0;i&lt; argc; i++) {<span style="color:#f00;font-style:italic">//Loop over each column in the current row
</span><span style="color:#f00;font-style:italic"></span>        printf(<span style="color:#009c00">&#34;%s=%s</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,colNamel[i],argv[i] ? argv[i] : <span style="color:#009c00">&#34;NULL&#34;</span>);
    }
    printf(<span style="color:#009c00">&#34;</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>);
    <span style="color:#00f">return</span> 0;
}

<span style="color:#00f">int</span> main(<span style="color:#00f">int</span> argc, <span style="color:#00f">char</span> **argv){
    sqlite3*db=0;
    <span style="color:#00f">char</span>*errMsg=0:
    <span style="color:#00f">int</span> rc;
    <span style="color:#00f">if</span> (argc != 3){
        fprintf(stderr, <span style="color:#009c00">&#34;Usage: %S DATABASE-NAME SQL-STATEMENT</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, argv0]);
        <span style="color:#00f">return</span> -l;
    }
    rc= sqlite3_open(argv1,&amp;db)
    <span style="color:#00f">if</span> (re != SQLITE_OK) {
        fprintf(stderr,<span style="color:#009c00">&#34;Can&#39;t open database %s: %s</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,argv1,sqlite3_errmsg(db));
        sqlite3_close(db);
        <span style="color:#00f">return</span> -2;
    }
    rc=sqlite3_exec(db,argv2,callback,0,&amp;errMsg);
    <span style="color:#00f">if</span> (re != SQLITE_OK) {
        fprintf(stderr,<span style="color:#009c00">&#34;SQL execution error:%s</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,errMsg)
    }
    sqlite3_close(db);
    <span style="color:#00f">return</span> rc;
}
</code></pre></div><p><strong>sqlite3 exec:</strong> 此函数直接执行一个或多个 SOL语句。(两个连续的 SOL语句由分号分隔。)在内部，它按输入的左到右顺序依次编译和执行语句。如果任何语句执行结果导致错误，则不执行剩余的语句。如果语句有SOL参数标记，则使用 SOLNULL值。如果语句产生输出，则exec函数为每个输出行调用用户指定的回调函数。回调函数的签名可以在图2.4中找到。(column)<code>和</code>finalize<code>函数的方exec 函数是</code>prepare、蓙淫闰Ⓜ笙step',便包装器。然而，SQLite开发团队不鼓励使用该函数，因为他们可能会在未来的版本中删除它。</p>
<p><strong>sqlite3 errmsg:</strong> 在API函数执行过程中发生错误时，可以通过调用此函数获取有关错误的更多信息。该函数返回在库连接上发生的最后一个错误。消息基本上是错误的一种英语描述。
您可以将应用程序代码编译成可执行文件，例如app2。现在，您可以发出对数据库操作的SQL语句。假设您在当前工作目录中处理同一个MyDB数据库。通过执行以下命令行，您可以在Students表中插入新行:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/app2 MyDB <span style="color:#009c00">&#34;insert into Students values(100)&#34;</span>
/app2 MyDB <span style="color:#009c00">&#34;insert into Students values(10)&#34;</span>
/app2 MyDB <span style="color:#009c00">&#34;insert into Students values(1000)&#34;</span>
</code></pre></div><p>如果您现在运行上一个应用程序(app1)，您将看到以下输出:
SID = 10
SID = 100
SID = 100
SID = 200
SID = 300
SID = 1000
你也可以在数据库中创建新表;例如，./app2MyDBExtn&quot;create table Coursesname varchar,SlDinteger)&ldquo;在当前工作目录中的新MyDBExtn数据库中创建Courses表。
<strong>注意:</strong> SQLite有一个前面提到的交互式命令行实用程序(sqlite3)，您可以使用它来发出SOL命令。您可以从SOLite下载网页下载预编译的二进制版本，或者从源代码中编译。这个app2示例本质上是 sqlite3的基本实现。</p>
<h3 id="224-多线程应用程序">2.2.4 多线程应用程序</h3>
<p>SQLite 可以在单线程或多线程模式下使用。对于后者，一个进程中的多个线程可以通过相同的库连接同时访问相同或不同的数据库。但是，为了使它成为一个线程安全的库，它必须以稍微不同的方式构建。</p>
<p><strong>线程模式:</strong> 线程模式由SQLITE.THREADSAFE预处理器宏控制。为了线程安全，SQLite源代码必须在宏设置为1(用于序列化和2(用于正常多线程)时编译。如果宏设置为0，则库处于单线程模式。这意味着单个进程中的多个线程可以使用相同的SQLite库，但由单个线程创建的SQLite(连接和语句)无法安全地由另一个线程使用;同时使用多个线程同时使用SQLite也是不安全的。在前两种情况下，这种限制被放宽，并且该库被称为“fthread-safe”。在正常的多线程模式(安全值2)下，虽然多个线程可以使用相同的库连接，但它们不能同时使用;它们可以相互排他地使用连接:它们可以同时使用不同的连接。在列化的多线程模式下没有这样的限制。默认是序列化模式。您可以通过调用sqlite3 threadsafe API函数来找出您使用的SQLite库是否线程安全。如果编译时选项是多线程或席列化的，则可以在库启动时或运行时使用sqlite3 open v2或sqlite3 configAPl函数更改此选项。</p>
<p>图2.5展示了一个非常简单的多线程应用程序。该应用程序创建了10个线程，每个线程都尝试在同一MyDB数据库的Students表中插入一行。SOLite实现了一种基于锁的并发方案，因此由于锁冲突，一些INSERT语句可能会失败。应用程序不需要担心并发控制和数据库一致性问题;它不会破坏数据库。SOLite会处理并发控制和一致性问题。但是，您需要检查失败情况，并在代码中适当地处理它们(例如，您可以重试失败的语句，或者通知用户失败并让她3决定下一步做什么)。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">void</span>* <span style="color:#c34e00">myInsert</span>(<span style="color:#00f">void</span>* arg)
{
    sqlite3* db =0;
    sqlite3_stmt*stmt=0;
    <span style="color:#00f">int</span> val=(<span style="color:#00f">int</span>)arg;
    <span style="color:#00f">int</span> SQL[100];
    <span style="color:#00f">int</span> rc;

    rc=sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>,&amp;db);<span style="color:#f00;font-style:italic">/* Open a database named MyDB */</span>
    <span style="color:#00f">if</span>(rc != SQLITE_OK){
        fprintf(stderr,<span style="color:#009c00">&#34;Thread%d fails to open the MyDB database</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, val);
        <span style="color:#00f">goto</span> errorRet:
    }

    sprintf(SQL, <span style="color:#009c00">&#34;insert into Students values(%d)&#34;</span>, val);<span style="color:#f00;font-style:italic">/* Dynamically compose a SQL*/</span>
    rc=sqlite3_prepare(db, SQL,-1,&amp;stmt, 0);<span style="color:#f00;font-style:italic">/* Prepare the insert statement */</span>
    <span style="color:#00f">if</span> (rc != SOLITE OK){
        fprintf(stderr, <span style="color:#009c00">&#34;Thread %d fails to prepare SQL: %s; return code %d</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, val, $QL, rc)
        <span style="color:#00f">goto</span> errorRet;
    }

    rc= sqlite3_step(stmt);
    <span style="color:#00f">if</span>(rc != SOLITE DONE) {
        fprintf(stderr,<span style="color:#009c00">&#34;Thread %d fails to execute SQL: %s; return code %d</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, val. SOL,rc)
    } <span style="color:#00f">else</span> {
        printf(”Thread[%dsuccessfully executes $QL: %s\n”, val, SQL);
    }
    sqlite3_fnalize(stmt),
    errorRet:
    sqlte3_close(db)
    <span style="color:#00f">return</span>(<span style="color:#00f">void</span>*)rc;
}

<span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    pthread_t t[10];
    <span style="color:#00f">int</span> i;
    <span style="color:#00f">for</span>(i=0:i &lt; 10; i++) {
        pthread_create(&amp;ti,0,myInsert,(<span style="color:#00f">void</span>*)i);<span style="color:#f00;font-style:italic">/* pass the value of i */</span>
    }
    <span style="color:#00f">for</span> (i=0;i&lt; 10; i++) {
        pthread_join(&amp;ti,0); <span style="color:#f00;font-style:italic">/* wait for all threads to finish */</span>
    }
    <span style="color:#00f">return</span> 0;
}
</code></pre></div><p><strong>警告!</strong> 此应用程序可能无法在Windows和MacOSX上“直接”运行。您可能需要重新编译带有线程支持的SOLite，并/或获取pthread库以使该应用程序在这些平台上运行。MacOSX包含pthread，您可以在http://sourceware.org/pthreads-win32/上获取Windows的pthread库</p>
<p>        在示例应用程序中，每个线程都打开自己的连接到相同的数据库，并在连接柄上工作。这在早期的SOLite版本中是工作模式。对于这些版本，SQLite开发团队不建议在跨线程中使用任何SQLite句柄。尽管SQLiteAPI可能在跨线程使用句柄时工作，但其正确性无法保证。实际上，在某些版本的Linux中，SOLite库可能会崩溃并产生核心转储。</p>
<p>        在 SOLite 3.3.1及后续版本中，对线程间共享库连接的上述限制有所放宽。线程可以在互斥(在正常多线程模式下)中安全地使用库连接。这意味着，只要前一个线程没有在连接上持有任何本地文件锁定，你就可以将连接从一个线程切换到另一个线程。如果线程没有未决事务，并且已经重置或完成了连接上的所有语句，则可以安全地假设没有持有任何锁定。在序列化模式下，没有这样的限制。
<strong>Fork Warning!</strong> 在Unix/Linux系统中，您不能通过fork系统调用将打开的SOLite数据库传递给子进程。如果您这样做，可能会出现数据库损坏或应用程序崩溃等问题。</p>
<h3 id="225使用多个数据库">2.2.5使用多个数据库</h3>
<p>图2.6显示了一个在两个数据库上工作的典型SQLite应用程序。(我简化了代码，没有包括函数调用的错误检查。)应用程序首先打开MyDB数据库，然后将MyDBExtn数据库附加到当前库连接。在完成附加命令的执行后，单个库连接具有两个数据库连接，应用程序现在可以通过相同的库连接访问两个数据库中的所有表。我假设MyDB数据库有一个Students(SID)表，MyDBExtn数据库有一个Courses(name，SID)表。应用程序执行SQL选择语句，访问两个数据库中的两个表。</p>
<p><strong>Library Connection vs,Database Connection Confusion:</strong> 与SOLite库的连接可以关联多个数据库。参见图2.7。在图中，单个库连接具有三个数据库连接，每个连接都指向不同的数据库文件。应用程序可以通过相同的库连接访问所有数据库虽然应用程序只看到一个库连接，但在内部，SQLite会打开多个数据库连接，每个数据库一个。如果一个库连接只有一个数据库，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3* db=0;
    sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>,&amp;db);<span style="color:#f00;font-style:italic">/* Open a database named MyDB */</span>
    sqlite3_exec(db,<span style="color:#009c00">&#34;attach database MyDBExtn as DB1&#34;</span>,0, 0, 0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;select* from Students S,Courses C where S.sid= C.sid&#34;</span>, callback, 0. 0);sqlite3_close(db);
    <span style="color:#00f">return</span> 0;
}
</code></pre></div><p>我们天真地把它也称为数据库连接。你已经被警告过连接混乱
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216154127.png" alt="图2.7:库连接与数据库连接。"></p>
<h3 id="226处理交易">2.2.6处理交易</h3>
<p>图2.8显示了一个使用事务的典型SOLite应用程序。该应用程序通过执行begin命令来打开事务，在事务内部将一行插入到学生表中，另一行插入到课程表中，最后通过执行commit命令提交事务。INSERT语句不需要回调函数，因此，在示例应用程序中的sqlite3exec调用中，我将0作为回调参数传递。如果第二个插入失败，您可以执行回滚命令而不是提交命令，第一个插入将被撤销。我将在第63页第2.3节中更多地谈论交易。</p>
<p><strong>注意:</strong> SOLite允许在单个exec API调用中包含多个SOL语句;图2.8中的同一批命令可以通过在单个exec调用中传递此语句序列来执行:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3*db=0;
    sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>,&amp;db);<span style="color:#f00;font-style:italic">/*Open a database named MyDB */</span>
    sqlite3_exec(db,<span style="color:#009c00">&#34;attach database MyDBExtn as DB1&#34;</span>,0, 0, 0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;begin&#34;</span>,0,0,0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(2000)&#34;</span>,0,0,0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;commit&#34;</span>,0.0，0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Courses values(&#39;SQLite Database’, 2000)&#34;</span>,0,0. 0);
    sqlite3_close(db);
    <span style="color:#00f">return</span> O;
}
</code></pre></div><h3 id="227-使用目录">2.2.7 使用目录</h3>
<p>数据库系统还存储有关用户信息的信息(元)信息。元信息也被表示为称为目录或系统表的表格，以区别于用户表。实质上，目录是由SOLite本身创建和维护的表格，它存储有关数据库的一些元信息。在每个数据库中，SOLite维护一个名为sqlite master的主目录。主目录存储有关表、索引、触发器和视图的架构信息。您可以查询主目录(例如，select*fromsqlitemaster)，但您不能手动删除或直接修改目录。还有其他可选的目录表。所有目录表名称都以 sqlite 的前缀开始，这些名称是 SQLite 开发团队为内部使用而保留的。(你不能以大写、小写或混合大小写的方式创建具有这些名称的数据库对象，如表、视图、索引和触发器。)在第 67 页的第 2.4节中，我将更详细地讨论目录。</p>
<h3 id="228-使用-sqlite3-可执行文件">2.2.8 使用 sqlite3 可执行文件</h3>
<p>上述示例应用程序使用 SOLite 库形式。您可以将 SOLite 构建为独立实用程序应用程序:它通常被称为 sqlite3。(这与用作连接句柄的 sqlite3 对象不同。)此实用程序允许您手动执行 SOL语句。它还支持 SOLite特定的点命令:这些命令以点&quot;开头。例如，sqlite3.help 将为您提供该实用程序支持的所有点命令的列表。点命令是方便的实用函数，用于获取有关模式、导入/导出数据、设置各种显示选项等信息。例如，sqlite3 MyDB.dump将整个数据库输出到标准输出。在本书中，我不讨论 sqlite3 实用程序。您可以访问 SOLite 网页 <a href="http://www.sqlite.org/sqlite.htm">http://www.sqlite.org/sqlite.htm</a>! 以了解点命令。</p>
<h2 id="23-transactional-support">2.3 Transactional Support</h2>
<p>SQLite 为数据库用户提供了一个轻松开发和运行数据库应用程序(C程序)的环境。它处理动态 SQL语句，这些语句可以在运行时组装，并确保语句执行的 ACID 属性。默认情况下，SOLite 在自动提交模式下运行。在这种模式下，它执行每个 SQL语句，每个SOL语句都是一个独立的事务:对于SQL查询语句是读取事务，对于其他语句是写入事务。对于每个SQL语句，它都会创建一个新的事务，并在语句执行结束时关闭(即提交或取消)该事务。也就是说，对于每个SOL语句，一旦语句执行成功完成或失败，数据库中的所有更改都将立即提交或撤销。这些事务对应用程序是透明的。也就是说，应用程序不需要包含处理这些事务的代码，应用程序逻辑也不依赖于这些事务的管理。</p>
<p><strong>警告!</strong> 在SOLite文档中，他们通常指写事务。在这本书中，当需要时，我区分读事务和写事务。读事务在SQLite中是隐含的。因此，存在一些混淆的范畴。你已经得到了警告!</p>
<p>        默认的自动提交模式可能对某些应用程序非常昂贵，并且对性能有害，特别是对于高写入密集型的应用程序。这是因为SQLite需要为每个SQL插入、删除和更新语句重新打开、写入和关闭日志文件。此外，由于应用程序需要为每个SQL语句执行重新获取和释放数据库文件上的锁，因此还存在并发控制开销。这些开销可能会导致显著的性能损失(特别是对于大型应用程序。开销只能通过围绕许多 SQL语句打开一个“用户级”事务来减少。应用程序可以在“BEGINTRANSACTION”命令和“COMMITTRANSACTION或“ROLLBACKTRANSACTION”命令中包含一系列SOL语句。(关键字 TRANSACTION 是可选的。)我在第62页的图2.8中展示了一个这样的应用程序。除了少数例外，您可以将任何 SOL语句放入用户事务中。</p>
<p>        BEGIN 命令使 SQLite 退出自动提交模式，我们说系统处于手动提交模式。连续SQL语句的影响成为用户事务的一部分。执行COMMIT/ROLLBACK命令会关闭用户事务，SQLite 返回自动提交模式。COMMIT命令实际上工作得有些不同。它可能不会立即完成整个事务。如果有未完成的更新操作，则提交失败，事务保持打开状态。否则，它将事务中的所有更改提交到数据库，然后启用默认的自动提交模式。(您可以确信，在提交结束时，事务中执行的所有 SOL语句的所有更改都将生效并永久化。)这提交写事务，但如果有正在进行的查询语句执行，则事务在自动提交模式下转换为读事务。然后，在读事务内所有挂起的选择陈述执行(如果有)结束时，常规自动提交逻辑接管并导致读事务的实际提交。ROLLBACK命令还通过打开自动提交返回来操作，但它还设置了一个标志，告诉自动提交逻辑回滚而不是提交用户事务。然而，ROLLBACK命令可以终止部分或所有挂起的选择执行。(The从写事务修改的表中读取的选择执行将被取消。它们各自下次调用sqlite3step API函数时将得到SQLITE ABORT错误代码。</p>
<p>        总之，一个典型的应用程序通过执行“BEGINTRANSACTION”命令来启动用户事务。所有后续的SQL语句都在事务内执行。在某个时间之后，应用程序执行“ROLLBACKTRANSACTION”命令来中断事务或“COMMITTRANSACTION”命令来使更新持久化。无论哪种情况，事务都会结束，SQLite都会恢复到自动提交模式。要启动新的用户事务，应用程序需要再次执行“BEGIN TRANSACTION”命令。如果应用程序未在用户事务中显式执行“COMMITTRANSACTION”或“ROLL-BACKTRANSACTION”命令，则SQLite将在应用程序关闭数据库连接时回滚事务。</p>
<p>        图2.9展示了另一个使用用户事务能力的应用程序。该应用程序打开一个用户级事务，然后在事务中插入四行，最后提交事务。如果在到达提交语句之前发生任何错误，它将关闭数据库连接。因此，在下一个数据库关闭API调用期间，SOLite会自动回滚事务。</p>
<p>        SQLite支持标准的平面事务模型:事务中的所有操作要么一起成功，要么全部回滚。无法提交或回滚事务的一部分。SOLite不支持歌套事务。因此在事务中执行“BEGIN TRANSACTION”命令没有任何效果，实际上，SOLite不会处理该语句，而是返回错误代码给应用程序。由于应用程序一次不能在打开的库连接上打开多个用户事务，因此在SQLite中事务管理大大简化。如果语句执行失败，SOLite不会强行中止容器事务(除非冲突解决程序指示回滚)。如果在事务中通过多个API调用拆分SOL语句，则您的应用程序必须处理这些调用中的每个失败，因为否则应用程序的行为可能会异常。如果确实发生失败，SQLite会自动中止相应的SOL语句，但不会中止整个用户事务。在最终提交或中止之前，事务可以继续执行其他新的SQL语句。SQLite还支持设置手动保存点，应用程序可以通过回滚某些最近的SOL语句执行的效果来稍后回滚。Savepoint允许事务恢复到先前建立的数据库状态。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3*db=NULL;
    <span style="color:#00f">int</span> retcode;
    retcode= sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>, &amp;db);<span style="color:#f00;font-style:italic">//Open a database named MyDB */
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> (retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;begin transaction&#34;</span>,NULL,NULL, NULL;
    <span style="color:#00f">if</span> (retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1001,&#39;Sibsankar’Sunnyvale, California’)&#34;</span>,NULL,NULL,NULL);
    <span style="color:#00f">if</span>(retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1002, &#39;Richard&#39;.Charlotte,North Carolina’&#34;</span>,NULL,NUL,NULL);
    <span style="color:#00f">if</span> (retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1003, &#39;Richard’.Sunnyvale,California&#39;&#34;</span>,NULL,NULL,NULL);
    <span style="color:#00f">if</span>(retcode != SQLITE OK) <span style="color:#00f">goto</span> errorRet;

    retcode=sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1004,&#39;Sibsankar’</span>
Charlotte,North Carolina’)<span style="color:#009c00">&#34;,NULL,NULL,NULL);</span>
    <span style="color:#00f">if</span> (retcode != SQLITE OK) <span style="color:#00f">goto</span> errorRet;
    retcode = sqlite3_exec(db,<span style="color:#009c00">&#34;commit transaction”,NULL,NULL, NULL):errorRet:</span>
sqlite3_close(db)<span style="color:#009c00">&#34;;</span>

    <span style="color:#00f">return</span> retcode
}
</code></pre></div><p>        下两个小节将讨论事务管理的两大支柱，即并发控制和故障恢复。</p>
<h3 id="231并发控制">2.3.1并发控制</h3>
<p>SQLite将整个数据库存储在单个本地文件中。它实现了一个简单的数据库级(而不是表、行、列或单元格级)锁定框架，在支持的本地操作系统文件锁定原语之上，以协调事务对数据库的访问。它允许许多并发读取事务，但数据库上只能有一个写入事务。这意味着如果任何事务正在从数据库的任何部分读取，则所有其他事务(在本进程和其他进程中)都被阻止写入数据库的任何其他部分。同样，如果任何事务向数据库的任何部分写入，则所有其他事务都禁止读取或写入数据库的任何其他部分。SOLite遵循严格的两阶段锁定(即在事务终止时释放锁)，从而确保并发事务的可串行执行。</p>
<h3 id="232数据库恢复">2.3.2数据库恢复</h3>
<p>SQLite为每个数据库文件使用一个单独的日志文件，以便在应用程序决定中止事务时提供回滚写事务的能力。(没有回滚日志用于读事务。)回滚日志总是创建在与数据库文件相同的目录中，具有相同的名称，但未尾添加&rdquo;-journal'。(例如，MyDB数据库将具有&rsquo;MyDB-journal&rsquo;文件，用于存储恢复信息。)日志文件以日志记录的形式存储与事务执行期间对数据库文件所做的所有更改相关的信息。该日志是一个按条目顺序排列的文件，并将日志记录存储在当前事务产生的相同顺序中。SQLite使用物理或值日志进行撤销。SOLite日志效率低下:即使事务只修改了页面中的一个字节，每个日志记录都包含整个数据库页面的图像。这样做是为了使恢复逻辑尽可能简单，并控制SQLite库的大小。</p>
<p><strong>日志文件保留:</strong> 您可能会注意到，在 SQLite 中，日志是默认操作模式下的临时文件。SQLite为每个写事务创建日志文件，并在事务完成时删除该文件。实际上，在提交的情况下，日志文件的删除是事务提交点。有选项可以避免删除日志文件将其截断为零，或在事务提交/取消时无效化。(无效化选项也可能将文件截断为预先定义的大小。)这些选项在文件创建和删除成本较高的平台上将非常有益。在后续中，我使用“日志最终化”一词来指代这四个选项中的任何一个。在SQLite 3.7.0版本中，他们引入了一种新的日志记录方案，称为WAL，其中使用“wal”日志文件代替“-journa!”文件，并在事务提交/取消后保留。我将在第249页的10.17节中讨论WAL日志记录。</p>
<p>在用户事务中，SOLite以单独的方式执行每个(非选择性)SOL语句子事务。您可能会注意到，在用户事务中最多只能有一个子事务打开。也就是说，事务中不能有并发更新。(但是，可以与子事务执行并发执行的SELECT语句执行可以有任意数量。我在后面的章节中详细讨论。)当前子事务的失败不会自动中止容器事务(或并发SELECT语句执行)。每个子事务使用一个单独的临时文件作为语句日志，用于仅存储语句级恢复的信息。
        SQLite允许应用程序在单个用户事务中操作多个数据库。在这种情况下对图书馆连接的事务显式为每个数据库连接上的单独事务。SOLite使用各自的回滚日志文件，并另外使用一个主日志文件。主日志仅记录单个回滚日志文件的名字。我将在第4和第5章中更详细地讨论日志。</p>
<h2 id="24-solite目录">2.4 SOLite目录</h2>
<p>大多数DBMS将有关所有用户表和不同表中索引的元信息保存在称为目录的不同表中。在RDBMS中，目录本身是表(通常称为系统表)。RDBMS通常以与用户表在数据库中存储相同的方式存储它们。例如，式描述(SQL创建语句)作为行存储在目录中。通常，会有不同的目录用于不同的目的。我们可能有一个目录用于存储所有表名;另一个用于表属性名称、它们的类型和任何默认值;另一个用于完整性约束。 我们还可能有一个用于查看名称及其定义的目录，另一个用于索引信息的目录，以此类推。
不同的RDBMS维护不同的目录数量。SOLite简化了目录的使用，并仅维护一个目录。它在一个名为sqlite master的单个目录中存储有关表、索引、触发器和视图的架构信息。4 主表存储在数据库文件本身的一个特定位置。主表的结构如下，使用等效的SQL创建表语句表示。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">create table sqlite_master(
text.type
text.name
tbl_name text,
rootpage integer,
text
);
</code></pre></div><hr>
<p>4尽管还有其他可选的目录。主目录是唯一始终存在于数据库中的目录。所有目录名称都以sqlite_的前缀开始，这些名称是 SQLite 开发团队为内部使用而保留的。您不能创建具有此类名称的数据库对象(表、视图、索引和触发器)(大写、小写或混合大小写)。</p>
<p>        当数据库初始化时，主表被创建并初始化为空。当你执行新的架构定义(一个创建 SOL语句)时，主表会添加一行。这行描述了刚刚创建的新对象。类型列指定该对象是表、视图、索引还是触发器，其值分别为“table“view”或“trigger”。名称列指定该对象的名称。(&ldquo;in煺拌dex”对于自动创建的索引，名称是“sqlite autoindex TABLE N”，其中TABLE是索引所在的表名，N是一个从1开始的整数。)tblname列指定该对象关联的表或视图名称。(对于表和视图，其值与名称列的值相同。)rootpage列指定对象(B树或B+树)的根所在的数据库页号。5sq1列指定创建此类对象的SQL语句。(在sql列中，SQLite将关键字转换为大写，删除冗余空格等。对于SOLite为唯一约束创建的索引，sql列将为NULL。)SOLite数据库中的每个对象(除sqlitemaster表外)在sqlitemaster表中都有一个条目。当 SQLite 打开并读取数据库文件时，它会首先扫描整个主表，预处理每一行的 sql列，并生成许多内存中的目录对象，这些对象实际上相当于许多 DBMS 中使用的不同的持久目录表。这些内存中的目录对象共同定义了一个模式缓存。</p>
<p>         还有一个名为sqlite_temp_master的目录表，它在运行时可用，并存储有关所有临时对象(表、索引、触发器和视图)的架构信息。您可能会注意到，对于每个打开的库连接，SQLite维护一个并行、用户透明、临时数据库，该数据库存储在库连接上创建的所有临时对象。(这意味着每个库连接至少建立两个数据库连接，其中一个用于临时数据库。)例如，您可以通过在库连接上执行createtemp table templ(ainteger primary key,bvarchar)语句在临时数据库中创建一个临时表temp 1。临时数据库存储在本地文件系统默认临时文件目录中的-个临时文件中。该文件对其他由相同或不同进程打开的与SQLite库的连接是不可见的。当应用程序关闭库连接时，临时文件会被SQLite删除。temp目录的逻辑结构与以下SOL语句创建的表等效:createtemptablesqlite temp master(type text, name text,tbl _name text,rootpage integer,sqltext)。这些列与sqlite_master架构中相同。</p>
<hr>
<p>如果rootpage值为0，表示该对象物理上不存在。表和索引非零，视图和触发器为零。</p>
<p>         您可以通过执行SELECT语句来查询这两个主表，就像它们是任何其他用户表一样。但是，您不允许直接使用INSERT、DELETE或UPDATE语句更改这两个表。您也不能在这些表上创建索引。SQLite也不会在这些表上创建索引。更改主表必须使用用户对象(如表、索引)的CREATE、ALTER和DROP语句，因为当添加或删除表和索引时，SOLite也需要更新其内部内存目录对象。 SQLite引擎会自动执行这些操作。您可能会注意到，通过主表SOLite跟踪数据库中所有其他表和索引树，因此，它是SOLite数据库中最珍贵的对象。</p>
<p>         没有其他与创建语句相关的目录。有可选目录。例如，SOLite可以根据需要创建另一个名为sqlite sequence的目录。如果任何用户表具有“整数主键自动递增”列，则SQLite将为用户表在序列目录中维护一行。目录结构与以下SQL语句创建的表等效:createtablesqlite sequence(nametext,seqinteger)。name列指定表名称。seq是迄今为止为自动递增列分配的最大值。(您可能会注意到，表最多只能有一个自动递增列，这就是为什么列名不会出现在序列目录中。)序列目录是在您尝试在具有整数主键自动递增列的任何用户表中插入一行时创建的。一旦创建，该表将永远不会被删除。SOLite还使用其他可选目录，我稍后会讨论一些。</p>
<h2 id="25-solite的限制">2.5 SOLite的限制</h2>
<p>在前面的章节中，您已经看到了 SQLite 的强大之处，但它也有一些缺点。SQLite 与大多数其他现代 SQL数据库不同，其主要设计目标是简单。SOLite 开发团队牢记这一目标，为DBMS添加新功能，即使这会导致某些功能的低效实现。以下是 SOLite 的缺点列表:</p>
<ul>
<li>
<p>SQL-92功能:如前所述，SQLite不支持许多企业数据库系统中可用的某些ANSI SQL-92功能。您可以从http://www.sqlite.org/omitted.html网页获取最新信息。</p>
</li>
<li>
<p>没有嵌套：SQLite只支持Hat事务；它不具有一般的嵌套能力（嵌套意味着在事务中具有完整的子事务的能力）。后者为前者提供了一个执行环境。</p>
</li>
<li>
<p>低并发:SQLite无法确保高度的事务并发。它使用文件级锁来实现并发控制，即在数据库文件的粒度上检测访问冲突。它允许多个并发读取事务，但单个数据库文件上只能有一个独占写入事务。这一限制意味着如果任何事务正在从数据库文件的任何部分读取，则所有其他事务将被阻止写入文件中的任何部分。同样，如果任何事务正在向数据库文件的任何部分写入，则所有其他事务将被阻止读取或写入文件中的任何部分。</p>
</li>
<li>
<p>应用程序限制:由于其有限的并发事务，SQLite仅适用于小型事务，其中每个事务都能快速完成数据库工作，因此没有事务会占用数据库超过几毫秒。但是，有些应用程序，特别是写密集型应用程序，需要更精细的并发粒度(表或行级锁定，而不是数据库级锁定)，您可能更愿意为这些应用程序使用不同的DBMS解决方案。SQLite不是用来取代企业级DBMS的。在数据库实现、维护和管理的简单性比企业DBMS提供的复杂功能更重要的情况下，这是一个很好的选择。</p>
</li>
<li>
<p>NFS问题:SQLite使用原生操作系统支持的锁原语进行并发控制。当数据库文件位于网络分区时，这可能会导致一些问题。许多NFS实现(在Unix和Windows上)在文件锁定逻辑中已知存在错误。如果文件锁定没有按SOLite预期的方式工作，则可能同时由两个或多个事务修改同一数据库;这可能会导致数据库损坏。由于此问题源于底层文件系统实现的错误，因此SOLite开发团队无法找到解决方案来防止它。
另一个淘气的事情是，由于大多数NFS的高延迟，数据库性能可能不好。在这样的环境中，数据库文件必须通过网络访问，实现客户机-服务器模式的DBMS可能比SOLite更有效。</p>
</li>
<li>
<p>数据库对象的数量和类型:表或索引最多限制为264-1个条目。(当然由于247字节的数据库大小限制，您不能有这么多条目;我在第84页的3.2.1节中讨论了此限制。)在SQLite的当前实现中，单个条目最多可以存储231-1(=2,147,483,647)字节的数据。(底层文件格式支持最多约262字节的数据大小。同样，字符串或BLOB数据的最大数据大小为2311;默认值为10亿。):在打开数据库文件时，SOLite会读取并预处理主目录表中的所有条目。创建许多内存中的目录对象。因此，为了获得最佳性能，最好保持表索引、视图和触发器的数量。同样，表、索引、视图、选择的结果集更新的集合列表、分组/排序的术语数量、插入的值数量都有限制。默认值为2000，但可以高达32,767。但是，索引的前63个列是某些优化的候选项。SQL语句的长度、连接中的表数量(最大为64)等也有其他限制。</p>
<p>您可以使用 sqlite3_limit APl函数按限制类别更改各种参数(对于库连接)的极限值。限制类别为:(1)字符串、BLOB 或表行的长度，(2)SOL语句的长度，(3)表定义、选择结果列、索引、orderby、groupby的列数，4)任何表达式上的解析树深度，(5)复合选择语句中的术语数，(6)SOL函数中的参数数，(7)附加数据库数，(8)LIKE或 GLOB 中模式参数的字符串长度，(9)具有有限值的 SQL语句中的参数数，(10)触发器的递归深度，(11)连接中的表数，(12)数据库文件中的页数。每个类别都有硬上界，您的应用程序不能跨越。看见http://www.sqlite.org/limits.html.</p>
</li>
<li>
<p>主机变量引用:在某些嵌入式数据库管理系统中，SOL语句可以直接引用主机变量(即来自应用程序空间的变量)。在SQLite中这是不可能的。相反，SOLite允许使用sqlite3 bind*API函数将主机变量绑定到SQL语句作为输入参数，而不是输出值。这种方法通常比直接访问方法更好，因为后者需要一个特殊的预处理程序将SOL语句转换为特殊的API调用。</p>
</li>
<li>
<p>存储过程:许多数据库管理系统都有创建和存储存储过程的能力。存储过程是一组SQL语句，形成一个逻辑工作单元并执行特定任务。SQL查询可以使用这些过程。SOLite没有这种能力。</p>
</li>
</ul>
<h2 id="26-solite体系结构">2.6 SOLite体系结构</h2>
<p>SQLite开发团队宣称采用非常模块化的架构。该架构由七个主要组件子系统(也称为模块)组成，分为两个部分:前端解析系统和后端引擎。前端编译每个SOL语句，后端执行编译后的语句。图2.10中给出了两个方块图，显示了组件子系统及其相互关系。每个方块图都是一堆模块。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216161847.png" alt="Componenet of Sqlite">
<strong>架构:</strong> 系统的架构提供了一种模型，说明系统如何被划分为子系统，以及这些子系统如何相互通信。换句话说，子系统的排列及其关系就是架构。</p>
<h3 id="261前端">2.6.1前端</h3>
<p>前端预处理由应用程序作为输入发送到它的SOL语句和SQLite命令。它解析这些语句(和命令)，优化它们，并生成后端可以执行的等值SQLite内部字节码程序。前端划分由三个模块组成:记号赋予器、解析器和代码生成器。</p>
<ul>
<li>令牌器:它将输入的SQL语句分成令牌。</li>
<li>解析器:它通过分析分词器产生的标记来分析 SQL语句的结构，并从标记生成解析树。解析器还包括一个优化器，该优化器重新构建解析树，并找到等效的解析树，该解析树将产生高效的字节码程序。</li>
<li>代码生成器:它遍历解析树，生成一个等价的字节码程序，当后端执行时，将产生SQL语句的效果。</li>
</ul>
<p>前端实现sqlite3_prepare APl函数。在函数执行过程中，解析和代码生成步骤交织在一起。</p>
<h3 id="262后端">2.6.2后端</h3>
<p>后端是执行由前端生成的字节码程序的引擎。引擎执行实际的数据库处理工作。后端部分由四个模块组成:虚拟机、树、分页器和操作系统接口。</p>
<ul>
<li>虚拟机(VM):它执行字节码程序以执行相应的SQL语句和SQLite命令。它是来自数据库的最终数据操纵者。它将数据库视为表和索引的集合，其中表或索引是一组元组或记录。</li>
<li>tree: 它将每个元组集组织成一个有序的树数据结构;表和索引分别存储在单独的B+-树和B-树中。它帮助虚拟机在树中搜索、插入、删除和更新元组。它还帮助虚拟机创建新树并删除旧树。</li>
<li>pager: 它在原生字节导向文件的基础上实现了一个面向页的数据库文件抽象。它管理一个内存中的缓存(数据库页)，树块使用这个缓存，此外，它还管理锁定和页面日志记录，以实现事务性的ACID属性。它是SQLite中的数据、锁定、日志和交易管理器。
*操作系统界面: 它为不同的原生操作系统提供了统一的界面。这是一个非常薄的层，它使SOLite应用程序独立于原生操作系统。它实现了文件I0、线程互斥、休眠、定时、随机数生成等例程。
后端实现了sqlite3 bind *、sqlite3 step、sqlite 3column *、SQLite3 reset和sqlite3 finalize APl函数。</li>
</ul>
<h3 id="263界面">2.6.3界面</h3>
<p>应用程序不能直接访问前端或后端(内部)API。前者需要通过顶层的SQLite接口层将请求转发给后者。这是数据库应用程序与SQLite库交互的唯一方式。接口将请求路由到前端或后端。</p>
<h2 id="27-sqlite源组织">2.7 SQLite源组织</h2>
<p>SOLite的源代码被组织成单个主目录(名为sqlite)和七个主要子目录:artcontrib、doc、ext、src、test和tool。art子目录包含许多与SOLite徽标相关的GIF文件。contrib子目录包含一个TCL/TK控制台小部件。doc子目录包含关于Lemon解析器生成器的程序员文档。ext子目录包含可加载的版本扩展，如异步I/0、rtree、fts(全文本搜索)和icu(用于Unicode的国际化组件)。src 子目录包含构建 SOLite库和 sqlite3 可执行文件的源代码。它大约有 94个C代码和头文件(73个.c和15个.h;在编译过程中生成6 个)。还有 11个文件用于 FTS3和 RTREE 扩展。截至 SQLite 3.7.8发布版本，这些文件中大约有 114K行文本(68K代码和46K注释)。测试子目录包含许多旨在验证 SQLite 库可靠性的回归测试。工具子目录包含代码生成器的源代码。它包含了Lemon解析器生成器的源代码:lemon.c和lempar.c，以及由词法分析器使用的关键字哈希表生成器的源代码:mkkeywordhash.c。顶层sqlite目录包含几个控制文件。(1)makefiles和实用程序用于从src目录构建SOLite库和sqlite3可执行文件。(2)VERSION文件包含发布6的版本号。(3)configure、configure.ac、Makefile.in和其他文件由GNUautoconf使用。(4)为Linux、vxworksarm 和 main.mk提供的替代 Makefile提供了更多的控制，并用于交叉编译。风(5)publish.sh 是一个 shell 脚本，为 SOLite 网站构建一个发布版本。</p>
<p>        在以下小节中，我将讨论如何从src目录中的源文件中构建SQLite组件子系统/模块。模块(参见第72页上的图2.10)以自上而下的方式呈现。大多数模块都导出自己的接口。除了以sqlite3 开头的接口外，SOLite应用程序不得使用这些接</p>
<h3 id="271-sqlite-apis">2.7.1 SQLite APIs</h3>
<p>许多面向 SQLite 库的公共 API都在 main.c、legacy.c和 vdbeapi.c源文件中实现-些 API在其他源文件中实现，这些文件可以访问fle 范围内的本地定义的数据结构。例如，sqlite3 mprintf函数在 printf.c中实现，TCL接口在 tclsqlite.c中实现。有关 SOLite AP|的更多信息，请参见 SOLite 网页 <a href="http://www.sqlite.org/capi3ref.html">http://www.sqlite.org/capi3ref.html</a>。所有 SQLite API函数名称都以sqlite3 开头，API常量名称以SQLITE 开头。
6版本字符串的格式为“X.Y.Z<trailing string>”其中X是主要版本号，Y是次要版本号，Z是发行版本号。尾随字符串通常是alpha”或“beta”;例如“3.3.0beta”。在非常特殊的情况下，版本字符串可以是四位数，如3.6.23.1</p>
<hr>
<p>版本字符串的格式是&rdquo; X.Y，。Z&lt;尾随字符串&gt;“，其中X为主要版本号，Y为次要版本号，2为发行号，尾随字符串通常为” alpha “或” beta&quot;；exampl“3.3.0beta”。在非常特殊的情况下，版本字符串可以是四种顺序，例如3.6.23.1。</p>
<h3 id="272-tokenizer">2.7.2 Tokenizer</h3>
<p>当应用程序将SOL语句或SQLite命令字符串发送到SQLite接口进行编译或执行时，会将该字符串传递给令牌器。令牌器将原始输入字符串分解为单个令牌，并将这些令牌逐个提供给解析器。记号赋予器代码在记号赋予器.c源文件中定义。
注:在SQLite中，词法分析器调用解析器。熟悉YACC和/或BISON的人习惯于相反的方式，即解析器调用词法分析器。SQLite的架构师和主要开发者理查德·希普(Richard Hipp)尝试了两种方式，发现词法分析器调用解析器效果更好。</p>
<h3 id="273-解析器">2.7.3 解析器</h3>
<p>解析器根据使用上下文为令牌生成者生成的令牌赋予意义。SQLite解析器是使用Lemon LALR(1)解析器生成器生成的。Lemon所做的工作与更熟悉的YACC/BISON所做的工作相同。它生成的解析器具有伸缩性、线程安全和防止内存泄漏。驱动Lemon的源文件可以在parse.y中找到。此文件定义 SOLite 实现的 SOL语法它还定义了 SOLite 特定的命令。Lemon生成parse.c和parse.h文件。parse.h包含所有令牌类型的数值代码，而parse.c实现SOLite分析器。
<strong>注意:</strong> lemon解析器生成程序通常不会在开发机器上找到。柠檬的完整源代码(仅个C文件，lemon.c)包含在工具子目录中。关于柠的文档在doc子目录中。</p>
<h3 id="274-代码生成器">2.7.4 代码生成器</h3>
<p>解析器从记号赋予器接收并组装SQL语句的所有记号后，它调用代码生成器生成字节码程序，当虚拟机执行该字节码程序时，将生成SOL语句所请求的结果。代码生成工作涉及许多文件:attach.c、auth.c、build.c、delete.c、expr.c、insert.c、pragma.c、select.c、trigger.c、update.c、vacuum.c和where.c。这些文件是大多数SQLite算法和逻辑所在的文件。expr.c文件处理表达式的代码生成，以及SELECT、UPDATE和DELETE语句中的WHERE子句的where.c代码生成。文件attach.c、delete.c、insert.c、select.c、trigger.c、update.c和vacuum.c处理具有相同名称的 SQL/SQLite 语句的代码生成。(这些文件中的每一个都在必要时调用 expr.c和 where.c中的例程。)所有其他 SQL语句都从 build.c中编码出来auth.c文件实现 sqlite3_set_authorizer Pl函数的功能。</p>
<h3 id="275虚拟机">2.7.5虚拟机</h3>
<p>由代码生成器生成的字节码程序由虚拟机(VM)执行。字节码程序很像机一个线性的字节码指令序列。每个字节码指令包含一个操作器语言程序一码和最多五个操作数。VM一次读取、解码和执行字节码指令，从而实现一个专门设计用于操作数据库和处理事务的抽象计算机器。</p>
<p>        虚拟机本身完全包含在 vdbe.c源文件中。(Vdbe 代表虚拟数据库引擎在本书中，VM和 VDBE是同义词。)VM也有自己的头文件:vdbe.h定义了 VM 和 SOLite 库其余部分之间的接口，而 vdbelnt.h 定义了 VM 私有的各种数据结构。vdbeaux.c文件包含 VM 使用的辅助函数，以及库其余部分使用的接口模块，用于构建字节码程序。vdbeapi.c文件包含对VM的外部接口，如 sqlite3 bind*家族API函数。单个值(字符串、整数、浮点数和BLOB)存储在名为“Mem”的内部对象中，该对象在vdbemem.c中实现。</p>
<p>        SOLite 使用回调函数实现 SOL函数，甚至内置的 SOL函数也是这种方式实现的。大多数内置 SQL函数(例如 coalesce、count、substr等)可以在 func.c文件中找到。日期和时间转换函数可以在 date.c文件中找到。</p>
<p>        内存分配和不区分大小写的字符串比较例程可在util.c文件中找到。哈希函数在hash.c中定义。c源文件包含UTF8和UTF16文本之间的Unicode转换子例程。SQLite在printf.c源文件中有自己的printf函数私有实现(带有一些扩展)，在random.c文件中有自己的随机数生成器。</p>
<h3 id="276-the-tree">2.7.6 The tree</h3>
<p>在btree.c源文件中定义了处理分别为B-树和B+-树的所有索引和表的代码。为每个表单维护一个单独的B+树，为每个索引维护一个B树。到树模块的接口在btree.h源文件中声明。</p>
<h3 id="277-the-pager">2.7.7 The Pager</h3>
<p>树模块以固定大小的块(称为数据库页面或简单地说为页面)从数据库文件中请求信息。页面管理器负责读取、写入和缓存数据库页面。它还提供回滚和原子提交并协调事务并发性.树模块向寻呼器请求特定页面，并在希望修改这些页面或提交/回滚更改时通知寻呼器。寻呼器处理所有必要的细节，以确保请求得到快速、安全和效的处理。它充当典型DBMS的数据管理器、事务管理器、日志管理器和锁管理器。实现分页器的代码在pager.c源文件中定义。分页模块的接口是在pager.h源文件中声明的。</p>
<h3 id="278操作系统界面">2.7.8操作系统界面</h3>
<p>为了在POSIX、Windows和其他操作环境之间提供可移植性，SOLite使用一个抽象的接口层来与各种操作系统交互。它是一层很薄的膜。操作系统象层的接口是在os.h源文件中声明的;它被称为VFSadapter。SQLite通过适配器从平台获取服务。每个受支持的操作系统都有自己的实现:osunix.c用于Unix(以及Linux和MACOSX)，oswin.c用于Windows(Win32和WinCE)，os操作系统2.c用于OS/2。对于Unix，osunix.c文件包含锁定代码。构建过程会在库编译过程中获取适当的代码。</p>
<p><strong>SOLite使用的Linux原语:</strong> SOLite使用本地操作系统和文件系统的一小部分原语来获得它们的服务。这个子集包括open、read、write、close、fcntl、fsync、fdatasync、malloc、free、unlink、access和一些pthread APl。 可以从Linuxmanpages中获取有关这些原语的信息。SOLite还使用Linux标准的临时文件目录来创建临时文件。这些临时文件的名称以etilgs 开头，后面跟着16个随机的字母数字字符，没有任何文件扩展名。
在本书中我没有谈到操作系统界面，你可能会认为这个层提供了诸如打开、读取、写入、同步、锁定、关闭、删除等功能，这些功能可以应用在文件上。</p>
<h2 id="28-sqlite-构建过程">2.8 Sqlite 构建过程</h2>
<p>构建过程如图2.11所示。构建过程包括以下六个连续的步骤:(1)构建sqlite3.h接口文件，(2)构建SOL解析器，(3)构建VM指令码，(4)构建指令码名称，(5)构建 SOL关键字，(6)构建库。
在构建过程中，生成六个C文件，用于构建最终库。两个中间C程序(lemon.c和mkkeywordhash.c)被编译以在构建机器上运行，以生成三个C文件:keywordhash.h、parse.h和parse.c。keywordhash.h文件中包含一个SOL/SOLite关键字的静态哈希表。柠檬程序生成解析器代码。Linux实用程序 awk和sed用于生成其他三个C文件:sqlite3.h、opcodes.h和opcodes.c。sqlite3.h文件包含SOLiteAPI函数和常量声明。(SOLite应用程序只需要这个文件和SOLite库。)opcodes.c文件包含用于字节码编程的opcode的文本名称。awk脚本扫描vdbe.c源文件以创建opcodes.h文件，该文件为操作符分配数值
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241216163718.png" alt="Figure 2.11:SQLite build process">
        您可以从其主页下载 SQLite 源代码[22]并尝试构建过程。在配置下载的源代码时，将在根sqlite目录中生成一个Makefile。maketarget source命令执行所有源代码生成和预处理，并将最终编译的C文件放入新创建的tsrc子目录中。make命令除了构建库之外，还执行所有操作。要构建库，您需要编译tsrc子目录</p>
<p>        最近，SQLite开发团队提供了一个熟的合并文件(sqlite3.c)和相应的sqlite3.h文件，您可以使用它来构建库。(在最开始sqlite3.c文件还包含sqlite3.h文件的副本。)合并文件具有各种SQLite编译时间选项的默认设置值。已经发现，由合并文件生成的库效率提高了5-10%，因为C编译器可以进行更多的代码优化。您还可以将sqlite3.c文件与其他.c文件一起编译，使sqlite成为应用程序的一部分。SOLite开发团队强烈建议使用合并文件。如果希望使用命令行实用程序sqlite3，还需要shell.c源文件。(更多细节请参见 <a href="http://www.sqlite.org/howtocompile.html">http://www.sqlite.org/howtocompile.html</a>页面。)</p>
<p>        SQLite允许自定义构建，其中某些SQLite功能可以使用各种编译标志关闭。我在第252页的10.18节中讨论了这些标志。</p>
<h2 id="总结">总结</h2>
<p>SOLite是一个基干SOL-92规范的嵌入式关系数据库管理系统，用于用C语言编写的数据库应用程序;整个SQLite代码库是用ANSI开发的C.SOLite 的第一个版本于 2000年5月29 日发布。自那时以来，它已经取得了长足的发展。它在数据库应用程序中易于使用。它具有零配置、定制、嵌入式、线程安全、易于维护、面向事务等值得称赞的特性。</p>
<p>        本章介绍了一些简单的单线程和多线程SOLite应用程序，展示了如何使用一些常用的SOLiteAPl函数，如sqlite3 open、sqlite3 close、sqlite3_prepare、sqlite3 step、sqlite3 finalize、sqlite3 exec、sqlite3 reset、sqlite3 bind *.sqlite3 column *等。这些应用程序展示了使用SQLite操作数据库是多么容易。</p>
<p>        本章概述了 SQLite 处理事务的方式。每个 SQL语句都在事务中执行。当应用程序不通过执行 begin 命令手动打开事务时，SOLite会自动创建事务。在前一种情况下，我们说系统处于自动提交模式，SOLite在SOL语句执行结束时关闭(提交或回滚)事务。在后一种情况下，应用程序必须通过行commit或 rollback命令手动关闭事务。在那之前，所有SOL语句的执行都成为事务的一部分。SQLite确保事务的执行是可序列化的，为了实现ACID属性，它使用数据库级别的锁定方案和基于日志的故障恢复方案。</p>
<p>        每个SOLite数据库都存储在单个本地文件中。该文件至少有一个目录(也称为系统表)，即sqlite master;对于临时数据库，它被称为sqlitetemp master。当数据库本身初始化时，主表被创建和初始化。该表包含每个表、视图、索引和触发器定义(除主表外)的一行。该表有五个列:类型名称、表名、根页和sql。行被添加和从table 中，因为用户会分别创建和删除 database 对象。表是整个数据库的锚点。
SOLite 根据需要使用其他可选目录，例如sqlite sequence。</p>
<p>        SQLite DBMS具有非常简单的模块化软件架构。有两个部分:前端解析系统和后端引擎。前端由三个模块组成:记号赋予器、解析器和代码生成器。后端是虚拟机，它从树和寻呼模块获取存储支持。最低级别的模块是操作系统接口，使SQLite可移植到多个操作系统。前端部门将SQL语句编译为后端引擎执行的内部字节码程序。</p>
<p>        SOLite是开源的，并且可以在公共领域使用。可以从http://www.sqlite.org/download.html网页下载源代码和二进制文件，并且可以用于任何目的，而无需担心任何许可问题。</p>
<p>        本章对SQLite领域进行了非常简短的介绍。本章中介绍的所有概念以及新引入的概念将在后续章节中详细讨论。在下一章中，我将讨论数据库和志文件的存储结构。</p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/db-sqlite" rel="tag" title="db， sqlite">#db， sqlite#</a>
    
    <a href="http://shanks.link/tags/c" rel="tag" title="c">#c#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2022/04/10/%E7%86%B5%E5%A2%9E%E5%AE%9A%E5%BE%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%86%B5%E5%A2%9E%E7%90%86%E8%AE%BA%E8%AE%A9%E5%A5%BD%E5%A4%9A%E4%BA%BA%E4%B8%80%E4%B8%8B%E5%AD%90%E9%A1%BF%E6%82%9F%E4%BA%86/" rel="next" title="熵增定律：为什么熵增理论让好多人一下子顿悟了">
        <i class="fa fa-chevron-left"></i> 熵增定律：为什么熵增理论让好多人一下子顿悟了
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2024/12/03/linux-%E4%B8%8B%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8Bcpu%E4%BD%BF%E7%94%A8%E7%8E%87/" rel="prev" title="linux 下监控进程CPU使用率">
        linux 下监控进程CPU使用率 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2024</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>