<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>sqlite 设计与实现 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="sqlite 设计与实现">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="sqlite 设计与实现 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/food/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />food
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/finance/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />投资
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2024/12/18/sqlite-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url">
        sqlite 设计与实现
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2024-12-18">
    2024-12-18
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/db" itemprop="url" rel="index">
        <span itemprop="name">db</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/sqlite" itemprop="url" rel="index">
        <span itemprop="name">sqlite</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/c" itemprop="url" rel="index">
        <span itemprop="name">c</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">96725 字 ~194分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="第二章-sqlite概述">第二章 SQLite概述</h1>
<h3 id="学术目标">学术目标</h3>
<ul>
<li>SOLite数据库系统及其功能</li>
<li>SOLite支持哪些显著特性</li>
<li>SOLite如何将表存储在数据库文件中</li>
<li>如何编写、编译和执行SQLite应用程序</li>
<li>一些最常用的SOLite API</li>
<li>模块化的SOLite体系结构</li>
<li>SQLite的限制</li>
</ul>
<h3 id="章节概要">章节概要</h3>
<p>        SQLite是一个小型的、零配置的、定制的、可嵌入的、线程安全的、易于维护的、面向事务的、基于SOL的关系数据库管理系统。它将整个数据库存储在包含所有表和索引的单个文件中。它将所有表组织成单独的B+树，并将索引组织成B树。它支持核心事务属性，即原子性、一致性、隔离性和持久性。它使用基于锁的并发控制方案和基于日志的恢复方案。</p>
<p>        SQLite 支持 ANSI SOL-92 功能的较大子集和许多 SQLite 特定命令。此外，它提供了一个良好的框架，您可以在其中定义定制的 SOL函数、聚合器和排序序列。它还支持基于 Unicode 文本的 UTF-8和 UTF-16 标准的编码。</p>
<p>        本章几乎涵盖了SQLite的所有功能。它提供了一个高层次的概述，介绍SOLite如何与SOL应用程序一起工作。通过展示一些简单的应用程序，它认您熟悉一些SOLiteAPI，这些API用于SOLite和数据库应用程序之间的正常交互。它还展示了SQLite源代码的结构和组织。总的来说，本章是SQLite的简短介绍。</p>
<h3 id="21-solite简介">2.1 SOLite简介</h3>
<p>        在过去的几十年里，许多数据库管理系统(DBMS)已经被开发出来。Informix、Ingres、MySOL、甲骨文、PostgreSOL、SOLServer、Sybase是这里要提到的个商业上成功的企业数据库应用程序。成功的嵌入式数据库系统包括SybaseiAnywhere、系统间缓存、微软Jet。SQLite[22]SQLite是关系数据库管理系统(RDBMS)家族中的一个新成员，也是一个非常成功的嵌入式数据库系统。1SQLite 于2000年5月29日首次公开发布，作为Alpha代码的初始公开发布，其功能集非常有限。SQLite1.0于2000年8月17日发布。自那时以来，它已经走过了漫长的旅程。SOLite2.0.0于2001年9月20日发布，SOLite3.0.0于2004年6月18日发布。截至 2011年9月19日，最新的版本是SQLite3.7.8。本书基于这个特定的版本。SOLite 开发团队继续发布新版本。您可以通过访问 SOLite 主页http://www.sqlite.org获取最新版本。您可以在 <a href="http://www.sqlite.org/changes.html">http://www.sqlite.org/changes.html</a>网页上找到功能开发的时序事件。(当这本书在你手中时，SOLite肯定会有不同的更新版本。但是，核心功能和处理数据的方式预计不会变化太大。在这里学到的知识将帮助你理解新功能。通过阅读这本书，你一定会对设计和开发嵌入式数据库系统所需的内容有感觉。我鼓励你自己开发一个。</p>
<h4 id="211显著的sqlite特性">2.1.1显著的SQLite特性</h4>
<p>        SQLite完全使用ANSIC程序设计语言开发。它是一个易于维护、相对快速基于SQL的RDBMS。它具有以下优良、差异化和值得称道的特点。</p>
<ul>
<li>零配置:在使用SQLite数据库管理软件之前，您不需要执行任何单独的安装或设置步骤来初始化它。没有特定的步骤来启动SOLite。没有配置文件来控制不同的行为。数据库不需要任何管理。您可以从其主页 <a href="http://www.sqlite.org/download.html">http://www.sqlite.org/download.html</a>，使用您喜欢的C编译器将其编译为可执行库，并开始将库作为数据库应用程序的一部分使用。对于有限数量的平台，您可以从那里获取库。</li>
<li>可嵌入:您不需要单独的服务器进程专门用于 SOLite。SOLite库可以嵌入到您自己的应用程序中。应用程序不需要包含任何进程间通信方案来与SOLite 交互。</li>
<li>应用程序接口:SOLite为C应用程序提供了一个SOL环境来操作数据库。它为动态SOL提供了一组调用级应用程序编程接口(API)函数;您可以动态组装SQL陈述并将其传递到接口进行执行。此外，您还可以使用许多回调功能。应用程序没有特殊的预处理和编译要求;普通的C编译器可以完成这项工作。</li>
<li>事务支持:SQLite支持核心事务属性，即原子性、一致性、隔离性和持久性(ACID)。在系统崩溃或电源故障时，数据库用户或管理员无需采取任何操作即可恢复数据库。当SQLite读取数据库时，它会自动以用户透明的方式对数据库执行必要的恢复操作。</li>
<li>线程安全:SOLite是一个线程安全的库，应用程序中的多个线程可以同时访问相同或不同的数据库。SOLite 处理数据库级别的线程并发。</li>
<li>轻量级:在启用所有 SQLite功能时，SQLite库的占用空间约为 324KB(在Linux上使用 gcc-0s时为 331835 字节)。如果从源代码构建库时禁用所有言级功能，占用空间可以减少到约 190KB。</li>
<li>可定制性:SOLite提供了一个良好的框架，您可以在其中定义和使用定制的SQL函数、聚合函数和整理序列。</li>
<li>Unicode:SOLite支持基干UTF-8和UTF-16标准的Unicode文本编码。
UTF16 同时支持小单位和大单位形式。</li>
<li>防止内存泄漏:如果应用程序严格遵循推荐的与SQLite库交互的协议，则该库声称从不泄漏内存。</li>
<li>内存需求:虽然SOLite可以使用无限量的堆栈和堆空间，但可以设置最小的堆栈空间为4KB和大约100KB的堆。这个特性对于受内存限制的小型设备(如手机)非常有效。主内存量很小。但是，可用内存越多，SOLite性能越好。</li>
<li>多平台:SOLite运行在Linux、Windows、MacOSX、0S/2、0penBSD和其他一些操作系统上。它也运行在嵌入式操作系统上，如Android、Symbian、Palm、VxWroks.
单个数据库文件:每个数据库完全存储在单个本地文件中;用户数据和元数据存储在同一个文件中。单文件方法简化了将数据库从一个地方移动/复制到另一个地方的过程。(SQLite在操作数据库时会使用许多临时文件。)</li>
<li>跨平台:SQLite 允许您在平台之间移动数据库文件。例如，您可以在Linuxx86机器上创建一个数据库，并在ARM、Windows或MAC平台上使用相同的数据库(通过复制)而无需任何更改。数据库在所有支持的平台上都具有相同的行为。您可以在 32位和 64 位机器之间或在大小端系统之间使用相同的数据库而没有任何问题。</li>
<li>向后兼容性:SOLite3具有向后兼容性。这意味着任何较新的库版本都可以与较早库版本创建的数据库一起工作。SQLite 开发团队努力保持库的向后兼容性。但是，版本3的库无法与版本2的数据库一起工作。</li>
</ul>
<h4 id="212使用简单">2.1.2使用简单</h4>
<p>        与大多数现代 SOL数据库管理系统不同，SOLite的首要设计目标是简单。SQLite 开发团队信奉 KISS 哲学:保持简单和卓越。他们努力保持 SOLite的简单性，即使这会导致某些功能的低效实现。本质上，SOLite是</p>
<ul>
<li>
<p>易于管理。</p>
</li>
<li>
<p>操作简单。</p>
</li>
<li>
<p>简单地嵌入到C应用程序中。</p>
</li>
<li>
<p>易于维护。</p>
</li>
<li>
<p>易于定制。</p>
</li>
<li>
<p>实现了 ACID 要求。</p>
<p><strong>简单性</strong>:	简单的软件更容易实现、测试、维护、增强、集成、文档等。SQLite满足这些标准
为了实现简单性，SQLite开发团队选择牺牲许多数据库用户认为有用的DBMS特性，如高事务并发、细粒度访问控制、许多内置函数、存储过程-些SQL语言特性(如对象关系)、太字节或拍字节的可扩展性等。
可靠性:SQLite非常可靠。这种可靠性似乎是其简单性的结果。</p>
</li>
</ul>
<h4 id="213-sql特性和sqlite命令">2.1.3 SQL特性和SQLite命令</h4>
<p>        SOLite支持ASIC SOL-92数据定义和数据操作功能的大子集，以及一些SQLite特定的命令。(这些命令类似于SOL陈述，但它们本身不会操纵用户数据。)您可以使用标准数据定义SOL结构创建表、索引、触发器和视图。您可以使用SYS、SYS、GROUP和SEN SOL结构来操作存储的信息。以下是自SOLite3.7.8版本起支持的SOL功能列表。(未来的每个新版本都可能具有其他功能。可从SOLite网页http:/www.sqlite.org/lang.html获取最新的受支持功能集。
1.数据定义语言DDL:</p>
<ul>
<li>
<p>创建表、索引、视图和触发器;</p>
</li>
<li>
<p>删除表、索引、视图和触发器;</p>
</li>
<li>
<p>部分支持ALTERTABLE(重命名表和添加列):</p>
</li>
<li>
<p>唯一，非空，并检查约束条件;</p>
</li>
<li>
<p>掭轆顶足縲衍键约束;</p>
</li>
<li>
<p>自动增量，整理列;</p>
</li>
<li>
<p>解决冲突。</p>
<p>2.数据操作语言DML:</p>
</li>
<li>
<p>插入、删除、更新和选择;</p>
</li>
<li>
<p>子查询，包括相关子查询;</p>
</li>
<li>
<p>按组别、按顺序、抵消限额、整理;</p>
</li>
<li>
<p>内接头，左外接头，自然接头;</p>
</li>
<li>
<p>联合，联合所有，相互作用，除外:</p>
</li>
<li>
<p>命名参数和参数绑定;</p>
</li>
<li>
<p>每行触发器。</p>
<p>3.事务性命令:</p>
</li>
<li>
<p>开始;</p>
</li>
<li>
<p>承诺;</p>
</li>
<li>
<p>滚动;</p>
</li>
<li>
<p>保存点;</p>
</li>
<li>
<p>滚动返回;</p>
</li>
<li>
<p>释放。</p>
<p>4.SQLite命令:</p>
</li>
<li>
<p>reindex;</p>
</li>
<li>
<p>附着，拆卸;</p>
</li>
<li>
<p>解释;</p>
</li>
<li>
<p>pragma.</p>
</li>
</ul>
<p>        SQL标准规定了大量的关键字，这些关键字不能用作表、视图、索引、列、约束或数据库的名称。SQLite放宽了这一限制，允许您使用关键字作为标识符，方法是在它们周围使用反引号或单引号或双引号或'【和&quot;】&lsquo;对。此外，SOLite提供了一个良好的框架，您可以在其中定义和使用自定义SOL函数聚合函数和排序序列。宏是特殊的SOLite命令，用于更改SOLite库的行为或查询库的内部(非表)元数据。SOLiteattach命令可帮助事务同时在多个数据库工作。此类事务也符合ACID要求。</p>
<p>在SQLite3.7.8发行版中，尚未支持以下ANSISOL-92特性(有关当前列表，请参阅http://www.sqlite.org/omitted.html网页)。</p>
<ol>
<li>许多ALTERTABLE特性，例如重命名或删除列，添加或删除约束;</li>
<li>对于每个语句触发器;</li>
<li>右侧和完全外部接头;</li>
<li>更新视图;</li>
<li>授予和撤销。</li>
</ol>
<h4 id="214数据库存储">2.1.4数据库存储</h4>
<p>        SQLite将整个数据库存储在单个的普通本地文件中，文件可以位于本地文件系统目录中的任何位置。我们经常说文件与数据库是同义词，因为没有其他文件存储有关数据库本身的信息。具有读取文件权限的用户可以从数据库中读取任何内容。具有写入文件和容器目录权限的用户可以更改数据库中的任何内容。只要本地操作系统/文件系统允许文件增长，数据库就可以增长。SOLite在Linux系统上支持非常大的文件(&gt;2GBytes)选项，如果这些系统有此选项。它将所有表和索引分别组织为单独的B+树和B树。它使用单独的日志文件来保存事务恢复信息，这些信息在发生事务中断或系统故障时使用。</p>
<h4 id="215有限的并发性">2.1.5有限的并发性</h4>
<p>SQLite允许多个应用程序同时访问同一个数据库。然而，它只支持有限形式的并发事务。它允许在数据库上进行任意数量的并发读取事务，但只允许个独占的写入事务。它没有支持更精细数据粒度(如表、页、行、列或单元格)并发的能力。</p>
<h4 id="216-usage">2.1.6 usage</h4>
<p>    QLite是一个非常成功的嵌入式RDBMS。它已被广泛用于低到中等层次的数据库应用程序，如Web服务、手机、掌上电脑、机顶盒、独立设备。你甚至可以在初学者数据库课程中使用它来教授关系数据库和SOL语言。你也可以在高级数据库管理课程中使用它，或者在数据库项目中作为参考技术使用，它是免费提供的，而且由于它处于公共领域，所以没有许可证的复杂性。(虽然有一些可选的专有部件，如用于智能卡的SQLite，以及需要从SQLite的拥有者Hwaci订购的加密解决方案。课程学生可能不担心这些专有组件擰攥饕*鯀峱)砑
Web服务器:基于SQLite的Web服务器工作良好，每天平均分配的点击量可达100，000次;SQLite开发团队已经证明SQLite甚至可以承受每天1，000，000次的点击量。</p>
<p>        SOLite是开源的，并且可以在公共领域使用(有关开源的更多信息，请访问http://opensource.org)。您可以从网页http://www.sqlite.org/download.html下载SOLite源代码，使用您喜欢的C编译器将其编译为可执行库，并使用数据库应用程序开始使用该库。SOLite在Linux、Windows、MACOSX、0S/2、Solaris、OpenBSD和其他一些操作系统上运行。在这本书中，我仅限于SQLite3.7.8的Linux版本，这是截至9月19.2011年的最新版本。</p>
<h2 id="22-示例sqlite应用程序">2.2 示例SQLite应用程序</h2>
<p>        在本节中，我将向您介绍一些简单的数据库应用程序，这些应用程序展示了SQLite 的各种核心功能。您将熟悉一些最重要和最常用的 SOLite API函数和 API常量。除了第 2.2.2 节讨论一些 API外，应用程序将在以下小节中介绍。您可能记得，SQLite是一个嵌入式库，它被嵌入到应用程序进程地址空间中。图 2.1展示了 SOLite 应用程序的一般架构。如图所示，SOLite库被嵌入到应用程序进程中，进程堆空间的一部分用于存储 SQLite 的运行时数据。当然，当SQLite的API函数被调用时，它会使用堆。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216145358.png" alt="图2.1:一个使用SQL库的通用数据库应用程序。"></p>
<h3 id="221一个简单的应用程序">2.2.1一个简单的应用程序</h3>
<p>让我们通过研究一个非常简单的应用程序来开始对SQLite领域的探索。图22展示了一个典型的SOLite应用程序。这是一个典型的C程序，它调用SOLiteAPI函数来处理单个SOLite数据库。它演示了使用SOLite通过执行SOL查询来访问数据库的简单方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3*db=0;<span style="color:#f00;font-style:italic">/*connection handle */</span>
    sqlite3_stmt*stmt=0;<span style="color:#f00;font-style:italic">/*statement handle */</span>
    <span style="color:#00f">int</span> retcode;
    retcode = sqlite3_open(<span style="color:#009c00">&#34;MyDB”, &amp;db); /* Open a database named MyDB */</span>
    <span style="color:#00f">if</span> (retcode !- SQLITE_OK){
        sqlite3_close(db);
        fprintf(stderr,<span style="color:#009c00">&#34;Could not open the MyDB database</span><span style="color:#009c00">\n</span><span style="color:#009c00">” );</span>
        <span style="color:#00f">return</span> retcode;
    }

    retcode=sqlite3_prepare(db,<span style="color:#009c00">&#34;select SID from Students order by SID&#34;</span>,-1,&amp;stmt, 0)
    <span style="color:#00f">if</span> (retcode != SQLITE_OK) {
        sqlite3_close(db):
        fprintf(stderr,<span style="color:#009c00">&#34;Could not compile a select statement</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>);
        <span style="color:#00f">return</span> retcode;
    }

    <span style="color:#00f">while</span>(sqlite3_step(stmt)=-SQLITE_ROW) {
        <span style="color:#00f">int</span> i =  sqlite3_column_int(stmt, 0);
        printf(<span style="color:#009c00">&#34;SID = %d</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, i);
    }

    sqlite3 finalize(stmt);
    sqlite3_close(db);
    <span style="color:#00f">return</span> SQLITE_OK:
}
</code></pre></div><p>        您可以编译上述示例应用程序并执行它。本文件中显示的示例输出是在Linux 机器上生成的，但这些示例将在 SOLite 运行的其他平台上工作。</p>
<p><strong>注:</strong> 这些示例假定您已经准备了sqlite3可执行文件、libsqlite3.so(Windows上为 sqlite3.dll，Mac OSX上为 libsqlite3.dylib)共享库和 sqlite3.h接囗定义文件。您可以从 <a href="http://www.sqlite.org">http://www.sqlite.org</a> 以源代码或二进制形式获取这些文件。(二进制文件仅适用于 Linux、MACOSX和Windows。)如果您将所有三个文件(sqlite3、共享库和 sqlite3。</p>
<p>        例如，假设你正在Linux系统上，并将示例程序保存为app1.c，与libsqlite3.so、sqlite3和sqlite3.h位于同一目录中</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gcc app1.c -o./app1 -lsqlite3 -L.
</code></pre></div><p>        它将在当前工作目录下生成一个名为appl的二进制文件。您可能执行该应用程序以查看输出。要在Linux系统上拉取SQLite库，您可能需要将工作目录名称包含在LD.LIBRARY PATH环境变量中。是的，您运行了app1，但它没有产生任何输出;这是因为您当前工作目录中缺少应用程序所需的“MyDB”数据库。</p>
<p><strong>注意:</strong> SQLite源代码和应用程序必须使用相同的编译器进行编译。如果您已将SQLite作为软件包安装，或者您的操作系统发行版预装了SQLite，则可能需要使用不同的编译器参数。例如，在Ubuntu上，您可以使用命令sudoaptitudeinstall sqlite3 libsqlite3-dev安装SOLite，并使用命令cc appl.c-o./app11sqlite3编译示例应用程序。由于SQLite包含在MacOSX的较新版本中，因此相同的编译命令也适用干Mac OSX。</p>
<p>        该应用程序在当前工作目录中打开MyDB数据库文件。该数据库至少需要个名为Students的表;该表必须至少有一个名为SID的整数列。在下一个示例应用程序中，您将学习如何在数据库中创建新表，以及如何插入表中的行，但就目前而言，您可以使用sqlite3实用程序通过这些命令创建和填充表:
./sqlite3 MyDB&quot;创建学生表(SID整数)
./sqlite3 MyDB&quot;插入学生值(200)&quot;
./sqlite3 MyDB&quot;插入学生值(100)1
./sqlite3 MyDB&quot;插入学生值(300)
如果您现在运行 app1，您将看到以下输出:
SID =100
SID =200
SID =300</p>
<p><strong>注意:</strong> 在Linux、Unix和Mac 0SX上，在命令提示符下键入app1名称时，可能需要将它前缀为./，如:./app1
        打开数据库后，应用程序app1首先准备SQL语句:selectSIDfromStudentsorder bySID。然后，它遍历由该语句生成的结果行集，逐个获取SID值，并打印这些值。最后，它关闭准备好的语句和数据库。</p>
<p>        SQLite 是一个调用级接口库，在运行时嵌入到应用程序进程的地址空间中。该库将所有 SQLite API实现为C函数。所有 API函数名都以sqlite3开头(API常量以 SQLITE_开头)，它们的签名在 sqlite3.h中声明。其中几个函数在 app1应用程序中使用，即 sqlite3 open、sqlite3_prepare、sqlite3_step、sqlite3column int、sqlite3 finalize和sqlite3 close.
该应用程序还使用了一些助记API常量，即SOLITEOK和SOLITE.ROW，用于比较API函数返回的值。在介绍其他SOLite应用程序之前，下一节将讨论一些关键的SOLite APl.</p>
<h3 id="222-sqlite-apis">2.2.2 SQLite APIs</h3>
<p>SQLite接口定义了一组API(一组C函数和一组命名常量)。API函数是应用程序和SQLite库之间正常通信的唯一手段。(SOLite还使用回调C函数，这些函数驻留在应用程序空间中。)我在上一节中概述了一些API函数。这里我介绍一组基本的API函数，它们在SOLite应用程序中最为常用。这些和其他API函数的详细讨论可以在SOLite网页http://www.sqlite.org/capi3refhtml中找到。大约有185个API函数。所有API函数和常量的列表可以在http://www.sqlite.org/c3ref/funclist.html双页上找到。</p>
<ol>
<li>sqlite3 open:这个函数有两个参数，一个输入，另一个输出。输入是-个数据库文件名。通过执行open函数，应用程序与SQLite库建立一个新的连接或会话，以访问给定的数据库文件。在这本书中，我将其称为库连接。(应用程序可能有其他打开的库连接来访问相同或不同的数据库。SQLite对这些库连接进行区分处理，在SQLite的范围内它们是相互独立的。)在库连接内部，函数打开数据库文件。如果文件不存在，该函数会自动创建数据库文件;默认文件权限为0644。如果数据库成功打开(或创建)，则该函数将SQLITE OK返回给应用程序。否则，应用程序将获得错误代码。
<strong>懒散的文件打开:</strong> 在打开或创建数据库文件时，SQLite遵循一种懒散的方法-一实际的打开或创建被推迟到文件被读取时。如果数据库文件确实存在，SQLite会自动恢复数据库到一个一致的状态，如果需要的话。懒散的文件创建给你一个机会，使用pragma命令(这些设置参数将在第3章中讨论)来(重新)定义各种数据库设置参数。
open 函数通过输出参数(在前面的示例中为 db)返回一个连接句柄(指向sqlite3 类型对象的指针)，该句柄用于对库连接(对于此打开的 SQLite 会话)执行进一步操作。该句柄表示此库连接的完整状态。
图2.3显示了一个典型的场景，其中应用程序已经打开了两个到SQLite库的连接，以访问同一个数据库文件。库连接是相互独立的，它们分别由单独的sqlite3对象表示。-个单独的sqlite3库中的对象表示和管理单个库连接。如图所示，理语句，而另一个连接没有。我接下来讨论预处理语句。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216151314.png" alt="图2.3:应用程序与SQLite库的连接。">
**较新的APIs:**最近，SQLite开发团队不鼓励使用这个open函数;他们推荐使用sqlite3_open_v2函数。还有其他许多_V2 API函数。为了保持应用程序呈现的简洁性，我避免在本书中使用这些较新的API函数。</li>
<li>sqlite3_prepare:此函数编译一个SQL语句，并生成一个等效的内部对象(类型为sqlite3 stmt)。在数据库文献中，此对象通常被称为预置语句，并在SOLite中以字节码程序实现。字节码程序是数据库引警执行的SOL语包的抽象表示。我将在175页的7.2节中讨论字节码程序设计语言。在本书中，我可以互换使用字节码、程序和准备语句来表示相同的意思。该函数在成功时返回SQLITEOK，在失败时返回适当的错误代码。
prepare 函数通过一个形式参数(如前面的示例中的 stmt)返回一个语句句柄(一个sqlite3 stmt类型的对象的指针)，该句柄用于对准备好的语句执行进一步的操作。在前面的示例程序中，我将从Students 表中选择 SID 的语句作为语句句柄。该句柄类似于一个打开的游标，用于获取选择语句产生的结果行集，一次一行。游标通过执行sqlite3 step APl函数向前移动，我将在下面讨论该函数。</li>
<li>sqlite3 step: 在使用 sqlite3 prepare 函数准备 SOL语句后，必须调用sqlite3_step 函数一次或多次来执行准备好的语句。每次调用 step 函数都会执行字节码程序，直到遇到断点(因为它产生了新的输出行)或直到没有更多行为止。在前一种情况下，该函数返回调用者SQLITE.ROW，在后一种情况下返回 SQLITE DONE。在前一种情况下，应用程序可以使用适当的 sqlite3 column*AP|函数读取行的列值。(参见列表中的下一个项目。)再次调用步骤函数以检索下一行。步骤函数移动 SELECT语分结果的游标位置。最初，游标指向输出行集的第一行之前。每次执行步骤函数时，游标指针都会移动到行集中的下一行。游标只能向前移动。对于不返回行的 SOL语句(如UPDATE、INSERT、DELETE、CREATE 和DROP)，由于没有行需要处理，步骤函数始终返回SOLITE DONE。最终，step 函数返回 SOLITE DONE。(如果没有先调用 sqlite3 reset函数将程序执行重置回初始状态，则不应再次调用此语句句柄上的 step 函数。我稍后将讨论重置函数。)
如果在执行步骤函数时出现错误，返回代码为SOLITE BUSY、SOLITEERROR或SOLITE.MISUSE。SOLITE.BUSY表示引擎尝试访问一个繁忙(即锁定)的数据库，并且没有注册回调函数来解决这种情况，或者回调函数已决定中断执行。应用程序可以稍后再次调用步骤函数以重试预编译语句的执行。SOLITE ERROR表示发生运行时错误(如约束违反);不应再次在语句句柄上调用步骤函数。SOLITE MISUSE表示步骤函数调用不当。可能在已完成的预处理语句(即已关闭的语句)或先前返回SQLITEERROR或SOLITE DONE的语句上调用该语句。</li>
<li>sqlite3 column <em>:如果sqlite step函数返回SQLITE ROW，您可以通过执行sqlite3 column</em>API函数之一来检索该行中每个列的值。SOL/SOLite和C语言之间的数据类型不匹配由引擎自动处理:列函数将数据从一种语言转换为另一种语言，并从存储类型转换为请求的类型。(例如，如果值的内部表示是FLOAT，而应用程序请求文本输出值，则SOLite在内部使用sprintf()进行值转换。)
以下五个列AP|函数可用:sqlite3 column int，sqlite3 col int64,sqlite3 column double、sqlite3 column text和sqlite3 column blob 用于从列中读取数据。每个函数名称的最后一个部分指示应用程序可以从SQLite 库中期望哪种值。在上面的示例应用程序中，每个输出行都是一个整数值，我们通过执行sqlite3 column int函数来读取 SID 列的值，该函数返回整数值。(如果语句句柄当前未指向有效行，或者如果列索引超出范围，则这些函数产生的输出是未定义的。最左边的列的索引是0，下一个是1，下
2,等等。您可以使用 sqlite3 column countAPl函数获取列的总数量。对干非选择语句，它返回0。)Blob和文本值需要应用程序知道它们的大小。SOLite有sqlite3 column bytes函数，该函数返回列值的大小，单位为字节。</li>
<li>sqlite3 finalize:此函数关闭并销毁一个语句句柄和相关联的预处理语句。也就是说它会擦除字节码程序，并释放分配给语句句柄的所有资源。语句句柄变为无效，不能再次使用。
如果语句执行成功或根本没有执行，则finalize 函数返回 SQLITE OK如果先前执行的语句失败，则该函数返回错误代码。finalize函数可以在执行预处理语句的任何时间点调用。如果引擎在执行此例程时尚未完成语句执行，则就像在执行过程中遇到错误或中断一样。不完整的更新将被回滚，执行将被中断，返回的结果代码将是 SOLITE ABORT。</li>
<li>sqlite3 close:此函数关闭库连接，并释放分配给该连接的所有资源。连接句柄变为无效。如果成功，此函数返回SOLITEOK，如果失败，则返回其他错误代码。如果存在尚未完成的预处理语句，则返回SQLITEBUSY，连接保持打开状态。</li>
<li>其他有用的函数:上面讨论的六个(类别)API函数是SQLite库的核心，它处理两个主要数据结构，即sqlite3和sqlite3 stmt。其他广泛使用的API函数是sqlite3 bind *和sqlite3 reset.
在SOL语句字符串(传递给sqlite3 prepare函数的输入)中，您可以使用SQL位置参数标记&rsquo;?'(或编号或命名的参数?NNN，:AAA，@AAA或SAAA，其中NNN是整数，AAA是字母数字标识符)替换一个或多个字面值。它们成为预处理语句的输入参数。对于无编号/无命名参数，最左边的参数具有索引1。对于编号参数，索引是数字。对于命名参数，索引可以通过以下方式获得调用 sqlite3 bind parameter index AP|函数。这些参数的值可以使用绑定函数设置。(如果在多个地方使用命名或编号参数，则对所有地方使用相同的绑定值。)如果未将值绑定到参数，则使用 SOLNULL值。以下七个绑定AP|函数可用:sqlite3 bind null、sqlite3 bind int、sqlite3 bind int64、sqlite3 bind double、sqlite3 bind text.sqlite3 bind blob和 sqlite3 bind value。每个函数名称的最后一个部分指示可以使用该函数将哪种值绑定到参数。(sqlite3 bindvalue函数帮助绑定泛型值。)
重置API函数将语句句柄(即预编译语句)重置为其初始状态，但有一个例外:所有已绑定值的参数保留其值。语句变得准备好由应用程序重新执行，并在重新执行时重用这些绑定值。但是，在开始重新执行之前，应用程序可以通过再次执行绑定函数来替换这些值的一部分或全部。或者，可以通过执行sqlite3 clear bindings APl函数来删除所有绑定值。 重置功能对于重复查询非常有用。</li>
<li>返回值:所有API函数都返回零整数或正整数值。SOLite开发团队强烈建议使用记忆术检查返回值，而不是硬编码整数值。返回值SOLTEOK表示成功;SQLITE ROW表示sqlite3step函数在SE-LECT语句返回的行集中找到了新行;SOLITE·DONE表示语句执行完成。截至SOLite3.7.8发行版，共有28个主要的和一些扩展的成功和错误代码。由于返回代码是SQLite接口的一部分，它们的值不会从一个小版本到另一个版本发生变化。</li>
</ol>
<p>        总之，应用程序准备SOL语句，如果需要，则将值绑定到准备好的语句多次执行准备好的语句，然后重置准备好的语句以便再次执行具有相同或不同绑定值的语句。应用程序最终确定语句以销毁准备好的语句。
Unicode AP1:上述API函数处理UTF-8编码的输入文本。还有单独的API函数只处理UTF-16编码的文本。</p>
<h3 id="223-sol直接执行">2.2.3 SOL直接执行</h3>
<p>图2.42展示了另一个可以从命令行运行的SQLite应用程序，用于交互式地操作数据库。该命令有两个参数:第一个参数是数据库文件名，第二个是 SQL语句。它首先打开数据库文件，然后通过执行sqlite3execAPI函数将语句应用于数据库，最后关闭数据库文件。exec函数直接执行SQL语句，而不需要应用程序像之前的示例应用程序那样手动执行prepare、step 和 finalize AP|函数。如果语句产生输出，则 exec函数为每个输出行执行回调函数，并允许应用程序进一步处理该行。您必须对给定的数据库文件拥有读取权限，并且根据查询类型，您可能需要对文件及其包含的目录拥有写入权限。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>include <span style="color:#009c00">&#34;sqlite3.h&#34;</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> callback(<span style="color:#00f">void</span> *unused, <span style="color:#00f">int</span> argc, <span style="color:#00f">char</span> **argv, <span style="color:#00f">char</span> **colName)
{
    <span style="color:#00f">int</span> i;
    <span style="color:#00f">for</span>(i= 0;i&lt; argc; i++) {<span style="color:#f00;font-style:italic">//Loop over each column in the current row
</span><span style="color:#f00;font-style:italic"></span>        printf(<span style="color:#009c00">&#34;%s=%s</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,colNamel[i],argv[i] ? argv[i] : <span style="color:#009c00">&#34;NULL&#34;</span>);
    }
    printf(<span style="color:#009c00">&#34;</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>);
    <span style="color:#00f">return</span> 0;
}

<span style="color:#00f">int</span> main(<span style="color:#00f">int</span> argc, <span style="color:#00f">char</span> **argv){
    sqlite3*db=0;
    <span style="color:#00f">char</span>*errMsg=0:
    <span style="color:#00f">int</span> rc;
    <span style="color:#00f">if</span> (argc != 3){
        fprintf(stderr, <span style="color:#009c00">&#34;Usage: %S DATABASE-NAME SQL-STATEMENT</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, argv0]);
        <span style="color:#00f">return</span> -l;
    }
    rc= sqlite3_open(argv1,&amp;db)
    <span style="color:#00f">if</span> (re != SQLITE_OK) {
        fprintf(stderr,<span style="color:#009c00">&#34;Can&#39;t open database %s: %s</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,argv1,sqlite3_errmsg(db));
        sqlite3_close(db);
        <span style="color:#00f">return</span> -2;
    }
    rc=sqlite3_exec(db,argv2,callback,0,&amp;errMsg);
    <span style="color:#00f">if</span> (re != SQLITE_OK) {
        fprintf(stderr,<span style="color:#009c00">&#34;SQL execution error:%s</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>,errMsg)
    }
    sqlite3_close(db);
    <span style="color:#00f">return</span> rc;
}
</code></pre></div><p><strong>sqlite3 exec:</strong> 此函数直接执行一个或多个 SOL语句。(两个连续的 SOL语句由分号分隔。)在内部，它按输入的左到右顺序依次编译和执行语句。如果任何语句执行结果导致错误，则不执行剩余的语句。如果语句有SOL参数标记，则使用 SOLNULL值。如果语句产生输出，则exec函数为每个输出行调用用户指定的回调函数。回调函数的签名可以在图2.4中找到。(column)<code>和</code>finalize<code>函数的方exec 函数是</code>prepare、蓙淫闰Ⓜ笙step',便包装器。然而，SQLite开发团队不鼓励使用该函数，因为他们可能会在未来的版本中删除它。</p>
<p><strong>sqlite3 errmsg:</strong> 在API函数执行过程中发生错误时，可以通过调用此函数获取有关错误的更多信息。该函数返回在库连接上发生的最后一个错误。消息基本上是错误的一种英语描述。
您可以将应用程序代码编译成可执行文件，例如app2。现在，您可以发出对数据库操作的SQL语句。假设您在当前工作目录中处理同一个MyDB数据库。通过执行以下命令行，您可以在Students表中插入新行:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/app2 MyDB <span style="color:#009c00">&#34;insert into Students values(100)&#34;</span>
/app2 MyDB <span style="color:#009c00">&#34;insert into Students values(10)&#34;</span>
/app2 MyDB <span style="color:#009c00">&#34;insert into Students values(1000)&#34;</span>
</code></pre></div><p>如果您现在运行上一个应用程序(app1)，您将看到以下输出:
SID = 10
SID = 100
SID = 100
SID = 200
SID = 300
SID = 1000
你也可以在数据库中创建新表;例如，./app2MyDBExtn&quot;create table Coursesname varchar,SlDinteger)&ldquo;在当前工作目录中的新MyDBExtn数据库中创建Courses表。
<strong>注意:</strong> SQLite有一个前面提到的交互式命令行实用程序(sqlite3)，您可以使用它来发出SOL命令。您可以从SOLite下载网页下载预编译的二进制版本，或者从源代码中编译。这个app2示例本质上是 sqlite3的基本实现。</p>
<h3 id="224-多线程应用程序">2.2.4 多线程应用程序</h3>
<p>SQLite 可以在单线程或多线程模式下使用。对于后者，一个进程中的多个线程可以通过相同的库连接同时访问相同或不同的数据库。但是，为了使它成为一个线程安全的库，它必须以稍微不同的方式构建。</p>
<p><strong>线程模式:</strong> 线程模式由SQLITE.THREADSAFE预处理器宏控制。为了线程安全，SQLite源代码必须在宏设置为1(用于序列化和2(用于正常多线程)时编译。如果宏设置为0，则库处于单线程模式。这意味着单个进程中的多个线程可以使用相同的SQLite库，但由单个线程创建的SQLite(连接和语句)无法安全地由另一个线程使用;同时使用多个线程同时使用SQLite也是不安全的。在前两种情况下，这种限制被放宽，并且该库被称为“fthread-safe”。在正常的多线程模式(安全值2)下，虽然多个线程可以使用相同的库连接，但它们不能同时使用;它们可以相互排他地使用连接:它们可以同时使用不同的连接。在列化的多线程模式下没有这样的限制。默认是序列化模式。您可以通过调用sqlite3 threadsafe API函数来找出您使用的SQLite库是否线程安全。如果编译时选项是多线程或席列化的，则可以在库启动时或运行时使用sqlite3 open v2或sqlite3 configAPl函数更改此选项。</p>
<p>图2.5展示了一个非常简单的多线程应用程序。该应用程序创建了10个线程，每个线程都尝试在同一MyDB数据库的Students表中插入一行。SOLite实现了一种基于锁的并发方案，因此由于锁冲突，一些INSERT语句可能会失败。应用程序不需要担心并发控制和数据库一致性问题;它不会破坏数据库。SOLite会处理并发控制和一致性问题。但是，您需要检查失败情况，并在代码中适当地处理它们(例如，您可以重试失败的语句，或者通知用户失败并让她3决定下一步做什么)。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;pthread.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">void</span>* <span style="color:#c34e00">myInsert</span>(<span style="color:#00f">void</span>* arg)
{
    sqlite3* db =0;
    sqlite3_stmt*stmt=0;
    <span style="color:#00f">int</span> val=(<span style="color:#00f">int</span>)arg;
    <span style="color:#00f">int</span> SQL[100];
    <span style="color:#00f">int</span> rc;

    rc=sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>,&amp;db);<span style="color:#f00;font-style:italic">/* Open a database named MyDB */</span>
    <span style="color:#00f">if</span>(rc != SQLITE_OK){
        fprintf(stderr,<span style="color:#009c00">&#34;Thread%d fails to open the MyDB database</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, val);
        <span style="color:#00f">goto</span> errorRet:
    }

    sprintf(SQL, <span style="color:#009c00">&#34;insert into Students values(%d)&#34;</span>, val);<span style="color:#f00;font-style:italic">/* Dynamically compose a SQL*/</span>
    rc=sqlite3_prepare(db, SQL,-1,&amp;stmt, 0);<span style="color:#f00;font-style:italic">/* Prepare the insert statement */</span>
    <span style="color:#00f">if</span> (rc != SOLITE OK){
        fprintf(stderr, <span style="color:#009c00">&#34;Thread %d fails to prepare SQL: %s; return code %d</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, val, $QL, rc)
        <span style="color:#00f">goto</span> errorRet;
    }

    rc= sqlite3_step(stmt);
    <span style="color:#00f">if</span>(rc != SOLITE DONE) {
        fprintf(stderr,<span style="color:#009c00">&#34;Thread %d fails to execute SQL: %s; return code %d</span><span style="color:#009c00">\n</span><span style="color:#009c00">&#34;</span>, val. SOL,rc)
    } <span style="color:#00f">else</span> {
        printf(”Thread[%dsuccessfully executes $QL: %s\n”, val, SQL);
    }
    sqlite3_fnalize(stmt),
    errorRet:
    sqlte3_close(db)
    <span style="color:#00f">return</span>(<span style="color:#00f">void</span>*)rc;
}

<span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    pthread_t t[10];
    <span style="color:#00f">int</span> i;
    <span style="color:#00f">for</span>(i=0:i &lt; 10; i++) {
        pthread_create(&amp;ti,0,myInsert,(<span style="color:#00f">void</span>*)i);<span style="color:#f00;font-style:italic">/* pass the value of i */</span>
    }
    <span style="color:#00f">for</span> (i=0;i&lt; 10; i++) {
        pthread_join(&amp;ti,0); <span style="color:#f00;font-style:italic">/* wait for all threads to finish */</span>
    }
    <span style="color:#00f">return</span> 0;
}
</code></pre></div><p><strong>警告!</strong> 此应用程序可能无法在Windows和MacOSX上“直接”运行。您可能需要重新编译带有线程支持的SOLite，并/或获取pthread库以使该应用程序在这些平台上运行。MacOSX包含pthread，您可以在http://sourceware.org/pthreads-win32/上获取Windows的pthread库</p>
<p>        在示例应用程序中，每个线程都打开自己的连接到相同的数据库，并在连接柄上工作。这在早期的SOLite版本中是工作模式。对于这些版本，SQLite开发团队不建议在跨线程中使用任何SQLite句柄。尽管SQLiteAPI可能在跨线程使用句柄时工作，但其正确性无法保证。实际上，在某些版本的Linux中，SOLite库可能会崩溃并产生核心转储。</p>
<p>        在 SOLite 3.3.1及后续版本中，对线程间共享库连接的上述限制有所放宽。线程可以在互斥(在正常多线程模式下)中安全地使用库连接。这意味着，只要前一个线程没有在连接上持有任何本地文件锁定，你就可以将连接从一个线程切换到另一个线程。如果线程没有未决事务，并且已经重置或完成了连接上的所有语句，则可以安全地假设没有持有任何锁定。在序列化模式下，没有这样的限制。
<strong>Fork Warning!</strong> 在Unix/Linux系统中，您不能通过fork系统调用将打开的SOLite数据库传递给子进程。如果您这样做，可能会出现数据库损坏或应用程序崩溃等问题。</p>
<h3 id="225使用多个数据库">2.2.5使用多个数据库</h3>
<p>图2.6显示了一个在两个数据库上工作的典型SQLite应用程序。(我简化了代码，没有包括函数调用的错误检查。)应用程序首先打开MyDB数据库，然后将MyDBExtn数据库附加到当前库连接。在完成附加命令的执行后，单个库连接具有两个数据库连接，应用程序现在可以通过相同的库连接访问两个数据库中的所有表。我假设MyDB数据库有一个Students(SID)表，MyDBExtn数据库有一个Courses(name，SID)表。应用程序执行SQL选择语句，访问两个数据库中的两个表。</p>
<p><strong>Library Connection vs,Database Connection Confusion:</strong> 与SOLite库的连接可以关联多个数据库。参见图2.7。在图中，单个库连接具有三个数据库连接，每个连接都指向不同的数据库文件。应用程序可以通过相同的库连接访问所有数据库虽然应用程序只看到一个库连接，但在内部，SQLite会打开多个数据库连接，每个数据库一个。如果一个库连接只有一个数据库，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3* db=0;
    sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>,&amp;db);<span style="color:#f00;font-style:italic">/* Open a database named MyDB */</span>
    sqlite3_exec(db,<span style="color:#009c00">&#34;attach database MyDBExtn as DB1&#34;</span>,0, 0, 0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;select* from Students S,Courses C where S.sid= C.sid&#34;</span>, callback, 0. 0);sqlite3_close(db);
    <span style="color:#00f">return</span> 0;
}
</code></pre></div><p>我们天真地把它也称为数据库连接。你已经被警告过连接混乱
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216154127.png" alt="图2.7:库连接与数据库连接。"></p>
<h3 id="226处理交易">2.2.6处理交易</h3>
<p>图2.8显示了一个使用事务的典型SOLite应用程序。该应用程序通过执行begin命令来打开事务，在事务内部将一行插入到学生表中，另一行插入到课程表中，最后通过执行commit命令提交事务。INSERT语句不需要回调函数，因此，在示例应用程序中的sqlite3exec调用中，我将0作为回调参数传递。如果第二个插入失败，您可以执行回滚命令而不是提交命令，第一个插入将被撤销。我将在第63页第2.3节中更多地谈论交易。</p>
<p><strong>注意:</strong> SOLite允许在单个exec API调用中包含多个SOL语句;图2.8中的同一批命令可以通过在单个exec调用中传递此语句序列来执行:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;sqlite3.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3*db=0;
    sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>,&amp;db);<span style="color:#f00;font-style:italic">/*Open a database named MyDB */</span>
    sqlite3_exec(db,<span style="color:#009c00">&#34;attach database MyDBExtn as DB1&#34;</span>,0, 0, 0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;begin&#34;</span>,0,0,0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(2000)&#34;</span>,0,0,0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;commit&#34;</span>,0.0，0);
    sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Courses values(&#39;SQLite Database’, 2000)&#34;</span>,0,0. 0);
    sqlite3_close(db);
    <span style="color:#00f">return</span> O;
}
</code></pre></div><h3 id="227-使用目录">2.2.7 使用目录</h3>
<p>数据库系统还存储有关用户信息的信息(元)信息。元信息也被表示为称为目录或系统表的表格，以区别于用户表。实质上，目录是由SOLite本身创建和维护的表格，它存储有关数据库的一些元信息。在每个数据库中，SOLite维护一个名为sqlite master的主目录。主目录存储有关表、索引、触发器和视图的架构信息。您可以查询主目录(例如，select*fromsqlitemaster)，但您不能手动删除或直接修改目录。还有其他可选的目录表。所有目录表名称都以 sqlite 的前缀开始，这些名称是 SQLite 开发团队为内部使用而保留的。(你不能以大写、小写或混合大小写的方式创建具有这些名称的数据库对象，如表、视图、索引和触发器。)在第 67 页的第 2.4节中，我将更详细地讨论目录。</p>
<h3 id="228-使用-sqlite3-可执行文件">2.2.8 使用 sqlite3 可执行文件</h3>
<p>上述示例应用程序使用 SOLite 库形式。您可以将 SOLite 构建为独立实用程序应用程序:它通常被称为 sqlite3。(这与用作连接句柄的 sqlite3 对象不同。)此实用程序允许您手动执行 SOL语句。它还支持 SOLite特定的点命令:这些命令以点&quot;开头。例如，sqlite3.help 将为您提供该实用程序支持的所有点命令的列表。点命令是方便的实用函数，用于获取有关模式、导入/导出数据、设置各种显示选项等信息。例如，sqlite3 MyDB.dump将整个数据库输出到标准输出。在本书中，我不讨论 sqlite3 实用程序。您可以访问 SOLite 网页 <a href="http://www.sqlite.org/sqlite.htm">http://www.sqlite.org/sqlite.htm</a>! 以了解点命令。</p>
<h2 id="23-transactional-support">2.3 Transactional Support</h2>
<p>SQLite 为数据库用户提供了一个轻松开发和运行数据库应用程序(C程序)的环境。它处理动态 SQL语句，这些语句可以在运行时组装，并确保语句执行的 ACID 属性。默认情况下，SOLite 在自动提交模式下运行。在这种模式下，它执行每个 SQL语句，每个SOL语句都是一个独立的事务:对于SQL查询语句是读取事务，对于其他语句是写入事务。对于每个SQL语句，它都会创建一个新的事务，并在语句执行结束时关闭(即提交或取消)该事务。也就是说，对于每个SOL语句，一旦语句执行成功完成或失败，数据库中的所有更改都将立即提交或撤销。这些事务对应用程序是透明的。也就是说，应用程序不需要包含处理这些事务的代码，应用程序逻辑也不依赖于这些事务的管理。</p>
<p><strong>警告!</strong> 在SOLite文档中，他们通常指写事务。在这本书中，当需要时，我区分读事务和写事务。读事务在SQLite中是隐含的。因此，存在一些混淆的范畴。你已经得到了警告!</p>
<p>        默认的自动提交模式可能对某些应用程序非常昂贵，并且对性能有害，特别是对于高写入密集型的应用程序。这是因为SQLite需要为每个SQL插入、删除和更新语句重新打开、写入和关闭日志文件。此外，由于应用程序需要为每个SQL语句执行重新获取和释放数据库文件上的锁，因此还存在并发控制开销。这些开销可能会导致显著的性能损失(特别是对于大型应用程序。开销只能通过围绕许多 SQL语句打开一个“用户级”事务来减少。应用程序可以在“BEGINTRANSACTION”命令和“COMMITTRANSACTION或“ROLLBACKTRANSACTION”命令中包含一系列SOL语句。(关键字 TRANSACTION 是可选的。)我在第62页的图2.8中展示了一个这样的应用程序。除了少数例外，您可以将任何 SOL语句放入用户事务中。</p>
<p>        BEGIN 命令使 SQLite 退出自动提交模式，我们说系统处于手动提交模式。连续SQL语句的影响成为用户事务的一部分。执行COMMIT/ROLLBACK命令会关闭用户事务，SQLite 返回自动提交模式。COMMIT命令实际上工作得有些不同。它可能不会立即完成整个事务。如果有未完成的更新操作，则提交失败，事务保持打开状态。否则，它将事务中的所有更改提交到数据库，然后启用默认的自动提交模式。(您可以确信，在提交结束时，事务中执行的所有 SOL语句的所有更改都将生效并永久化。)这提交写事务，但如果有正在进行的查询语句执行，则事务在自动提交模式下转换为读事务。然后，在读事务内所有挂起的选择陈述执行(如果有)结束时，常规自动提交逻辑接管并导致读事务的实际提交。ROLLBACK命令还通过打开自动提交返回来操作，但它还设置了一个标志，告诉自动提交逻辑回滚而不是提交用户事务。然而，ROLLBACK命令可以终止部分或所有挂起的选择执行。(The从写事务修改的表中读取的选择执行将被取消。它们各自下次调用sqlite3step API函数时将得到SQLITE ABORT错误代码。</p>
<p>        总之，一个典型的应用程序通过执行“BEGINTRANSACTION”命令来启动用户事务。所有后续的SQL语句都在事务内执行。在某个时间之后，应用程序执行“ROLLBACKTRANSACTION”命令来中断事务或“COMMITTRANSACTION”命令来使更新持久化。无论哪种情况，事务都会结束，SQLite都会恢复到自动提交模式。要启动新的用户事务，应用程序需要再次执行“BEGIN TRANSACTION”命令。如果应用程序未在用户事务中显式执行“COMMITTRANSACTION”或“ROLL-BACKTRANSACTION”命令，则SQLite将在应用程序关闭数据库连接时回滚事务。</p>
<p>        图2.9展示了另一个使用用户事务能力的应用程序。该应用程序打开一个用户级事务，然后在事务中插入四行，最后提交事务。如果在到达提交语句之前发生任何错误，它将关闭数据库连接。因此，在下一个数据库关闭API调用期间，SOLite会自动回滚事务。</p>
<p>        SQLite支持标准的平面事务模型:事务中的所有操作要么一起成功，要么全部回滚。无法提交或回滚事务的一部分。SOLite不支持歌套事务。因此在事务中执行“BEGIN TRANSACTION”命令没有任何效果，实际上，SOLite不会处理该语句，而是返回错误代码给应用程序。由于应用程序一次不能在打开的库连接上打开多个用户事务，因此在SQLite中事务管理大大简化。如果语句执行失败，SOLite不会强行中止容器事务(除非冲突解决程序指示回滚)。如果在事务中通过多个API调用拆分SOL语句，则您的应用程序必须处理这些调用中的每个失败，因为否则应用程序的行为可能会异常。如果确实发生失败，SQLite会自动中止相应的SOL语句，但不会中止整个用户事务。在最终提交或中止之前，事务可以继续执行其他新的SQL语句。SQLite还支持设置手动保存点，应用程序可以通过回滚某些最近的SOL语句执行的效果来稍后回滚。Savepoint允许事务恢复到先前建立的数据库状态。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> <span style="color:#c34e00">main</span>(<span style="color:#00f">void</span>)
{
    sqlite3*db=NULL;
    <span style="color:#00f">int</span> retcode;
    retcode= sqlite3_open(<span style="color:#009c00">&#34;MyDB&#34;</span>, &amp;db);<span style="color:#f00;font-style:italic">//Open a database named MyDB */
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> (retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;begin transaction&#34;</span>,NULL,NULL, NULL;
    <span style="color:#00f">if</span> (retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1001,&#39;Sibsankar’Sunnyvale, California’)&#34;</span>,NULL,NULL,NULL);
    <span style="color:#00f">if</span>(retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1002, &#39;Richard&#39;.Charlotte,North Carolina’&#34;</span>,NULL,NUL,NULL);
    <span style="color:#00f">if</span> (retcode != SQLITE_OK) <span style="color:#00f">goto</span> errorRet;

    retcode= sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1003, &#39;Richard’.Sunnyvale,California&#39;&#34;</span>,NULL,NULL,NULL);
    <span style="color:#00f">if</span>(retcode != SQLITE OK) <span style="color:#00f">goto</span> errorRet;

    retcode=sqlite3_exec(db,<span style="color:#009c00">&#34;insert into Students values(1004,&#39;Sibsankar’</span>
Charlotte,North Carolina’)<span style="color:#009c00">&#34;,NULL,NULL,NULL);</span>
    <span style="color:#00f">if</span> (retcode != SQLITE OK) <span style="color:#00f">goto</span> errorRet;
    retcode = sqlite3_exec(db,<span style="color:#009c00">&#34;commit transaction”,NULL,NULL, NULL):errorRet:</span>
sqlite3_close(db)<span style="color:#009c00">&#34;;</span>

    <span style="color:#00f">return</span> retcode
}
</code></pre></div><p>        下两个小节将讨论事务管理的两大支柱，即并发控制和故障恢复。</p>
<h3 id="231并发控制">2.3.1并发控制</h3>
<p>SQLite将整个数据库存储在单个本地文件中。它实现了一个简单的数据库级(而不是表、行、列或单元格级)锁定框架，在支持的本地操作系统文件锁定原语之上，以协调事务对数据库的访问。它允许许多并发读取事务，但数据库上只能有一个写入事务。这意味着如果任何事务正在从数据库的任何部分读取，则所有其他事务(在本进程和其他进程中)都被阻止写入数据库的任何其他部分。同样，如果任何事务向数据库的任何部分写入，则所有其他事务都禁止读取或写入数据库的任何其他部分。SOLite遵循严格的两阶段锁定(即在事务终止时释放锁)，从而确保并发事务的可串行执行。</p>
<h3 id="232数据库恢复">2.3.2数据库恢复</h3>
<p>SQLite为每个数据库文件使用一个单独的日志文件，以便在应用程序决定中止事务时提供回滚写事务的能力。(没有回滚日志用于读事务。)回滚日志总是创建在与数据库文件相同的目录中，具有相同的名称，但未尾添加&rdquo;-journal'。(例如，MyDB数据库将具有&rsquo;MyDB-journal&rsquo;文件，用于存储恢复信息。)日志文件以日志记录的形式存储与事务执行期间对数据库文件所做的所有更改相关的信息。该日志是一个按条目顺序排列的文件，并将日志记录存储在当前事务产生的相同顺序中。SQLite使用物理或值日志进行撤销。SOLite日志效率低下:即使事务只修改了页面中的一个字节，每个日志记录都包含整个数据库页面的图像。这样做是为了使恢复逻辑尽可能简单，并控制SQLite库的大小。</p>
<p><strong>日志文件保留:</strong> 您可能会注意到，在 SQLite 中，日志是默认操作模式下的临时文件。SQLite为每个写事务创建日志文件，并在事务完成时删除该文件。实际上，在提交的情况下，日志文件的删除是事务提交点。有选项可以避免删除日志文件将其截断为零，或在事务提交/取消时无效化。(无效化选项也可能将文件截断为预先定义的大小。)这些选项在文件创建和删除成本较高的平台上将非常有益。在后续中，我使用“日志最终化”一词来指代这四个选项中的任何一个。在SQLite 3.7.0版本中，他们引入了一种新的日志记录方案，称为WAL，其中使用“wal”日志文件代替“-journa!”文件，并在事务提交/取消后保留。我将在第249页的10.17节中讨论WAL日志记录。</p>
<p>在用户事务中，SOLite以单独的方式执行每个(非选择性)SOL语句子事务。您可能会注意到，在用户事务中最多只能有一个子事务打开。也就是说，事务中不能有并发更新。(但是，可以与子事务执行并发执行的SELECT语句执行可以有任意数量。我在后面的章节中详细讨论。)当前子事务的失败不会自动中止容器事务(或并发SELECT语句执行)。每个子事务使用一个单独的临时文件作为语句日志，用于仅存储语句级恢复的信息。
        SQLite允许应用程序在单个用户事务中操作多个数据库。在这种情况下对图书馆连接的事务显式为每个数据库连接上的单独事务。SOLite使用各自的回滚日志文件，并另外使用一个主日志文件。主日志仅记录单个回滚日志文件的名字。我将在第4和第5章中更详细地讨论日志。</p>
<h2 id="24-solite目录">2.4 SOLite目录</h2>
<p>大多数DBMS将有关所有用户表和不同表中索引的元信息保存在称为目录的不同表中。在RDBMS中，目录本身是表(通常称为系统表)。RDBMS通常以与用户表在数据库中存储相同的方式存储它们。例如，式描述(SQL创建语句)作为行存储在目录中。通常，会有不同的目录用于不同的目的。我们可能有一个目录用于存储所有表名;另一个用于表属性名称、它们的类型和任何默认值;另一个用于完整性约束。 我们还可能有一个用于查看名称及其定义的目录，另一个用于索引信息的目录，以此类推。
不同的RDBMS维护不同的目录数量。SOLite简化了目录的使用，并仅维护一个目录。它在一个名为sqlite master的单个目录中存储有关表、索引、触发器和视图的架构信息。4 主表存储在数据库文件本身的一个特定位置。主表的结构如下，使用等效的SQL创建表语句表示。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">create table sqlite_master(
text.type
text.name
tbl_name text,
rootpage integer,
text
);
</code></pre></div><hr>
<p>4尽管还有其他可选的目录。主目录是唯一始终存在于数据库中的目录。所有目录名称都以sqlite_的前缀开始，这些名称是 SQLite 开发团队为内部使用而保留的。您不能创建具有此类名称的数据库对象(表、视图、索引和触发器)(大写、小写或混合大小写)。</p>
<p>        当数据库初始化时，主表被创建并初始化为空。当你执行新的架构定义(一个创建 SOL语句)时，主表会添加一行。这行描述了刚刚创建的新对象。类型列指定该对象是表、视图、索引还是触发器，其值分别为“table“view”或“trigger”。名称列指定该对象的名称。(&ldquo;in煺拌dex”对于自动创建的索引，名称是“sqlite autoindex TABLE N”，其中TABLE是索引所在的表名，N是一个从1开始的整数。)tblname列指定该对象关联的表或视图名称。(对于表和视图，其值与名称列的值相同。)rootpage列指定对象(B树或B+树)的根所在的数据库页号。5sq1列指定创建此类对象的SQL语句。(在sql列中，SQLite将关键字转换为大写，删除冗余空格等。对于SOLite为唯一约束创建的索引，sql列将为NULL。)SOLite数据库中的每个对象(除sqlitemaster表外)在sqlitemaster表中都有一个条目。当 SQLite 打开并读取数据库文件时，它会首先扫描整个主表，预处理每一行的 sql列，并生成许多内存中的目录对象，这些对象实际上相当于许多 DBMS 中使用的不同的持久目录表。这些内存中的目录对象共同定义了一个模式缓存。</p>
<p>         还有一个名为sqlite_temp_master的目录表，它在运行时可用，并存储有关所有临时对象(表、索引、触发器和视图)的架构信息。您可能会注意到，对于每个打开的库连接，SQLite维护一个并行、用户透明、临时数据库，该数据库存储在库连接上创建的所有临时对象。(这意味着每个库连接至少建立两个数据库连接，其中一个用于临时数据库。)例如，您可以通过在库连接上执行createtemp table templ(ainteger primary key,bvarchar)语句在临时数据库中创建一个临时表temp 1。临时数据库存储在本地文件系统默认临时文件目录中的-个临时文件中。该文件对其他由相同或不同进程打开的与SQLite库的连接是不可见的。当应用程序关闭库连接时，临时文件会被SQLite删除。temp目录的逻辑结构与以下SOL语句创建的表等效:createtemptablesqlite temp master(type text, name text,tbl _name text,rootpage integer,sqltext)。这些列与sqlite_master架构中相同。</p>
<hr>
<p>如果rootpage值为0，表示该对象物理上不存在。表和索引非零，视图和触发器为零。</p>
<p>         您可以通过执行SELECT语句来查询这两个主表，就像它们是任何其他用户表一样。但是，您不允许直接使用INSERT、DELETE或UPDATE语句更改这两个表。您也不能在这些表上创建索引。SQLite也不会在这些表上创建索引。更改主表必须使用用户对象(如表、索引)的CREATE、ALTER和DROP语句，因为当添加或删除表和索引时，SOLite也需要更新其内部内存目录对象。 SQLite引擎会自动执行这些操作。您可能会注意到，通过主表SOLite跟踪数据库中所有其他表和索引树，因此，它是SOLite数据库中最珍贵的对象。</p>
<p>         没有其他与创建语句相关的目录。有可选目录。例如，SOLite可以根据需要创建另一个名为sqlite sequence的目录。如果任何用户表具有“整数主键自动递增”列，则SQLite将为用户表在序列目录中维护一行。目录结构与以下SQL语句创建的表等效:createtablesqlite sequence(nametext,seqinteger)。name列指定表名称。seq是迄今为止为自动递增列分配的最大值。(您可能会注意到，表最多只能有一个自动递增列，这就是为什么列名不会出现在序列目录中。)序列目录是在您尝试在具有整数主键自动递增列的任何用户表中插入一行时创建的。一旦创建，该表将永远不会被删除。SOLite还使用其他可选目录，我稍后会讨论一些。</p>
<h2 id="25-solite的限制">2.5 SOLite的限制</h2>
<p>在前面的章节中，您已经看到了 SQLite 的强大之处，但它也有一些缺点。SQLite 与大多数其他现代 SQL数据库不同，其主要设计目标是简单。SOLite 开发团队牢记这一目标，为DBMS添加新功能，即使这会导致某些功能的低效实现。以下是 SOLite 的缺点列表:</p>
<ul>
<li>
<p>SQL-92功能:如前所述，SQLite不支持许多企业数据库系统中可用的某些ANSI SQL-92功能。您可以从http://www.sqlite.org/omitted.html网页获取最新信息。</p>
</li>
<li>
<p>没有嵌套：SQLite只支持Hat事务；它不具有一般的嵌套能力（嵌套意味着在事务中具有完整的子事务的能力）。后者为前者提供了一个执行环境。</p>
</li>
<li>
<p>低并发:SQLite无法确保高度的事务并发。它使用文件级锁来实现并发控制，即在数据库文件的粒度上检测访问冲突。它允许多个并发读取事务，但单个数据库文件上只能有一个独占写入事务。这一限制意味着如果任何事务正在从数据库文件的任何部分读取，则所有其他事务将被阻止写入文件中的任何部分。同样，如果任何事务正在向数据库文件的任何部分写入，则所有其他事务将被阻止读取或写入文件中的任何部分。</p>
</li>
<li>
<p>应用程序限制:由于其有限的并发事务，SQLite仅适用于小型事务，其中每个事务都能快速完成数据库工作，因此没有事务会占用数据库超过几毫秒。但是，有些应用程序，特别是写密集型应用程序，需要更精细的并发粒度(表或行级锁定，而不是数据库级锁定)，您可能更愿意为这些应用程序使用不同的DBMS解决方案。SQLite不是用来取代企业级DBMS的。在数据库实现、维护和管理的简单性比企业DBMS提供的复杂功能更重要的情况下，这是一个很好的选择。</p>
</li>
<li>
<p>NFS问题:SQLite使用原生操作系统支持的锁原语进行并发控制。当数据库文件位于网络分区时，这可能会导致一些问题。许多NFS实现(在Unix和Windows上)在文件锁定逻辑中已知存在错误。如果文件锁定没有按SOLite预期的方式工作，则可能同时由两个或多个事务修改同一数据库;这可能会导致数据库损坏。由于此问题源于底层文件系统实现的错误，因此SOLite开发团队无法找到解决方案来防止它。
另一个淘气的事情是，由于大多数NFS的高延迟，数据库性能可能不好。在这样的环境中，数据库文件必须通过网络访问，实现客户机-服务器模式的DBMS可能比SOLite更有效。</p>
</li>
<li>
<p>数据库对象的数量和类型:表或索引最多限制为264-1个条目。(当然由于247字节的数据库大小限制，您不能有这么多条目;我在第84页的3.2.1节中讨论了此限制。)在SQLite的当前实现中，单个条目最多可以存储231-1(=2,147,483,647)字节的数据。(底层文件格式支持最多约262字节的数据大小。同样，字符串或BLOB数据的最大数据大小为2311;默认值为10亿。):在打开数据库文件时，SOLite会读取并预处理主目录表中的所有条目。创建许多内存中的目录对象。因此，为了获得最佳性能，最好保持表索引、视图和触发器的数量。同样，表、索引、视图、选择的结果集更新的集合列表、分组/排序的术语数量、插入的值数量都有限制。默认值为2000，但可以高达32,767。但是，索引的前63个列是某些优化的候选项。SQL语句的长度、连接中的表数量(最大为64)等也有其他限制。</p>
<p>您可以使用 sqlite3_limit APl函数按限制类别更改各种参数(对于库连接)的极限值。限制类别为:(1)字符串、BLOB 或表行的长度，(2)SOL语句的长度，(3)表定义、选择结果列、索引、orderby、groupby的列数，4)任何表达式上的解析树深度，(5)复合选择语句中的术语数，(6)SOL函数中的参数数，(7)附加数据库数，(8)LIKE或 GLOB 中模式参数的字符串长度，(9)具有有限值的 SQL语句中的参数数，(10)触发器的递归深度，(11)连接中的表数，(12)数据库文件中的页数。每个类别都有硬上界，您的应用程序不能跨越。看见http://www.sqlite.org/limits.html.</p>
</li>
<li>
<p>主机变量引用:在某些嵌入式数据库管理系统中，SOL语句可以直接引用主机变量(即来自应用程序空间的变量)。在SQLite中这是不可能的。相反，SOLite允许使用sqlite3 bind*API函数将主机变量绑定到SQL语句作为输入参数，而不是输出值。这种方法通常比直接访问方法更好，因为后者需要一个特殊的预处理程序将SOL语句转换为特殊的API调用。</p>
</li>
<li>
<p>存储过程:许多数据库管理系统都有创建和存储存储过程的能力。存储过程是一组SQL语句，形成一个逻辑工作单元并执行特定任务。SQL查询可以使用这些过程。SOLite没有这种能力。</p>
</li>
</ul>
<h2 id="26-solite体系结构">2.6 SOLite体系结构</h2>
<p>SQLite开发团队宣称采用非常模块化的架构。该架构由七个主要组件子系统(也称为模块)组成，分为两个部分:前端解析系统和后端引擎。前端编译每个SOL语句，后端执行编译后的语句。图2.10中给出了两个方块图，显示了组件子系统及其相互关系。每个方块图都是一堆模块。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216161847.png" alt="Componenet of Sqlite">
<strong>架构:</strong> 系统的架构提供了一种模型，说明系统如何被划分为子系统，以及这些子系统如何相互通信。换句话说，子系统的排列及其关系就是架构。</p>
<h3 id="261前端">2.6.1前端</h3>
<p>前端预处理由应用程序作为输入发送到它的SOL语句和SQLite命令。它解析这些语句(和命令)，优化它们，并生成后端可以执行的等值SQLite内部字节码程序。前端划分由三个模块组成:记号赋予器、解析器和代码生成器。</p>
<ul>
<li>令牌器:它将输入的SQL语句分成令牌。</li>
<li>解析器:它通过分析分词器产生的标记来分析 SQL语句的结构，并从标记生成解析树。解析器还包括一个优化器，该优化器重新构建解析树，并找到等效的解析树，该解析树将产生高效的字节码程序。</li>
<li>代码生成器:它遍历解析树，生成一个等价的字节码程序，当后端执行时，将产生SQL语句的效果。</li>
</ul>
<p>前端实现sqlite3_prepare APl函数。在函数执行过程中，解析和代码生成步骤交织在一起。</p>
<h3 id="262后端">2.6.2后端</h3>
<p>后端是执行由前端生成的字节码程序的引擎。引擎执行实际的数据库处理工作。后端部分由四个模块组成:虚拟机、树、分页器和操作系统接口。</p>
<ul>
<li>虚拟机(VM):它执行字节码程序以执行相应的SQL语句和SQLite命令。它是来自数据库的最终数据操纵者。它将数据库视为表和索引的集合，其中表或索引是一组元组或记录。</li>
<li>tree: 它将每个元组集组织成一个有序的树数据结构;表和索引分别存储在单独的B+-树和B-树中。它帮助虚拟机在树中搜索、插入、删除和更新元组。它还帮助虚拟机创建新树并删除旧树。</li>
<li>pager: 它在原生字节导向文件的基础上实现了一个面向页的数据库文件抽象。它管理一个内存中的缓存(数据库页)，树块使用这个缓存，此外，它还管理锁定和页面日志记录，以实现事务性的ACID属性。它是SQLite中的数据、锁定、日志和交易管理器。
*操作系统界面: 它为不同的原生操作系统提供了统一的界面。这是一个非常薄的层，它使SOLite应用程序独立于原生操作系统。它实现了文件I0、线程互斥、休眠、定时、随机数生成等例程。
后端实现了sqlite3 bind *、sqlite3 step、sqlite 3column *、SQLite3 reset和sqlite3 finalize APl函数。</li>
</ul>
<h3 id="263界面">2.6.3界面</h3>
<p>应用程序不能直接访问前端或后端(内部)API。前者需要通过顶层的SQLite接口层将请求转发给后者。这是数据库应用程序与SQLite库交互的唯一方式。接口将请求路由到前端或后端。</p>
<h2 id="27-sqlite源组织">2.7 SQLite源组织</h2>
<p>SOLite的源代码被组织成单个主目录(名为sqlite)和七个主要子目录:artcontrib、doc、ext、src、test和tool。art子目录包含许多与SOLite徽标相关的GIF文件。contrib子目录包含一个TCL/TK控制台小部件。doc子目录包含关于Lemon解析器生成器的程序员文档。ext子目录包含可加载的版本扩展，如异步I/0、rtree、fts(全文本搜索)和icu(用于Unicode的国际化组件)。src 子目录包含构建 SOLite库和 sqlite3 可执行文件的源代码。它大约有 94个C代码和头文件(73个.c和15个.h;在编译过程中生成6 个)。还有 11个文件用于 FTS3和 RTREE 扩展。截至 SQLite 3.7.8发布版本，这些文件中大约有 114K行文本(68K代码和46K注释)。测试子目录包含许多旨在验证 SQLite 库可靠性的回归测试。工具子目录包含代码生成器的源代码。它包含了Lemon解析器生成器的源代码:lemon.c和lempar.c，以及由词法分析器使用的关键字哈希表生成器的源代码:mkkeywordhash.c。顶层sqlite目录包含几个控制文件。(1)makefiles和实用程序用于从src目录构建SOLite库和sqlite3可执行文件。(2)VERSION文件包含发布6的版本号。(3)configure、configure.ac、Makefile.in和其他文件由GNUautoconf使用。(4)为Linux、vxworksarm 和 main.mk提供的替代 Makefile提供了更多的控制，并用于交叉编译。风(5)publish.sh 是一个 shell 脚本，为 SOLite 网站构建一个发布版本。</p>
<p>        在以下小节中，我将讨论如何从src目录中的源文件中构建SQLite组件子系统/模块。模块(参见第72页上的图2.10)以自上而下的方式呈现。大多数模块都导出自己的接口。除了以sqlite3 开头的接口外，SOLite应用程序不得使用这些接</p>
<h3 id="271-sqlite-apis">2.7.1 SQLite APIs</h3>
<p>许多面向 SQLite 库的公共 API都在 main.c、legacy.c和 vdbeapi.c源文件中实现-些 API在其他源文件中实现，这些文件可以访问fle 范围内的本地定义的数据结构。例如，sqlite3 mprintf函数在 printf.c中实现，TCL接口在 tclsqlite.c中实现。有关 SOLite AP|的更多信息，请参见 SOLite 网页 <a href="http://www.sqlite.org/capi3ref.html">http://www.sqlite.org/capi3ref.html</a>。所有 SQLite API函数名称都以sqlite3 开头，API常量名称以SQLITE 开头。
6版本字符串的格式为“X.Y.Z<trailing string>”其中X是主要版本号，Y是次要版本号，Z是发行版本号。尾随字符串通常是alpha”或“beta”;例如“3.3.0beta”。在非常特殊的情况下，版本字符串可以是四位数，如3.6.23.1</p>
<hr>
<p>版本字符串的格式是&rdquo; X.Y，。Z&lt;尾随字符串&gt;“，其中X为主要版本号，Y为次要版本号，2为发行号，尾随字符串通常为” alpha “或” beta&quot;；exampl“3.3.0beta”。在非常特殊的情况下，版本字符串可以是四种顺序，例如3.6.23.1。</p>
<h3 id="272-tokenizer">2.7.2 Tokenizer</h3>
<p>当应用程序将SOL语句或SQLite命令字符串发送到SQLite接口进行编译或执行时，会将该字符串传递给令牌器。令牌器将原始输入字符串分解为单个令牌，并将这些令牌逐个提供给解析器。记号赋予器代码在记号赋予器.c源文件中定义。
注:在SQLite中，词法分析器调用解析器。熟悉YACC和/或BISON的人习惯于相反的方式，即解析器调用词法分析器。SQLite的架构师和主要开发者理查德·希普(Richard Hipp)尝试了两种方式，发现词法分析器调用解析器效果更好。</p>
<h3 id="273-解析器">2.7.3 解析器</h3>
<p>解析器根据使用上下文为令牌生成者生成的令牌赋予意义。SQLite解析器是使用Lemon LALR(1)解析器生成器生成的。Lemon所做的工作与更熟悉的YACC/BISON所做的工作相同。它生成的解析器具有伸缩性、线程安全和防止内存泄漏。驱动Lemon的源文件可以在parse.y中找到。此文件定义 SOLite 实现的 SOL语法它还定义了 SOLite 特定的命令。Lemon生成parse.c和parse.h文件。parse.h包含所有令牌类型的数值代码，而parse.c实现SOLite分析器。
<strong>注意:</strong> lemon解析器生成程序通常不会在开发机器上找到。柠檬的完整源代码(仅个C文件，lemon.c)包含在工具子目录中。关于柠的文档在doc子目录中。</p>
<h3 id="274-代码生成器">2.7.4 代码生成器</h3>
<p>解析器从记号赋予器接收并组装SQL语句的所有记号后，它调用代码生成器生成字节码程序，当虚拟机执行该字节码程序时，将生成SOL语句所请求的结果。代码生成工作涉及许多文件:attach.c、auth.c、build.c、delete.c、expr.c、insert.c、pragma.c、select.c、trigger.c、update.c、vacuum.c和where.c。这些文件是大多数SQLite算法和逻辑所在的文件。expr.c文件处理表达式的代码生成，以及SELECT、UPDATE和DELETE语句中的WHERE子句的where.c代码生成。文件attach.c、delete.c、insert.c、select.c、trigger.c、update.c和vacuum.c处理具有相同名称的 SQL/SQLite 语句的代码生成。(这些文件中的每一个都在必要时调用 expr.c和 where.c中的例程。)所有其他 SQL语句都从 build.c中编码出来auth.c文件实现 sqlite3_set_authorizer Pl函数的功能。</p>
<h3 id="275虚拟机">2.7.5虚拟机</h3>
<p>由代码生成器生成的字节码程序由虚拟机(VM)执行。字节码程序很像机一个线性的字节码指令序列。每个字节码指令包含一个操作器语言程序一码和最多五个操作数。VM一次读取、解码和执行字节码指令，从而实现一个专门设计用于操作数据库和处理事务的抽象计算机器。</p>
<p>        虚拟机本身完全包含在 vdbe.c源文件中。(Vdbe 代表虚拟数据库引擎在本书中，VM和 VDBE是同义词。)VM也有自己的头文件:vdbe.h定义了 VM 和 SOLite 库其余部分之间的接口，而 vdbelnt.h 定义了 VM 私有的各种数据结构。vdbeaux.c文件包含 VM 使用的辅助函数，以及库其余部分使用的接口模块，用于构建字节码程序。vdbeapi.c文件包含对VM的外部接口，如 sqlite3 bind*家族API函数。单个值(字符串、整数、浮点数和BLOB)存储在名为“Mem”的内部对象中，该对象在vdbemem.c中实现。</p>
<p>        SOLite 使用回调函数实现 SOL函数，甚至内置的 SOL函数也是这种方式实现的。大多数内置 SQL函数(例如 coalesce、count、substr等)可以在 func.c文件中找到。日期和时间转换函数可以在 date.c文件中找到。</p>
<p>        内存分配和不区分大小写的字符串比较例程可在util.c文件中找到。哈希函数在hash.c中定义。c源文件包含UTF8和UTF16文本之间的Unicode转换子例程。SQLite在printf.c源文件中有自己的printf函数私有实现(带有一些扩展)，在random.c文件中有自己的随机数生成器。</p>
<h3 id="276-the-tree">2.7.6 The tree</h3>
<p>在btree.c源文件中定义了处理分别为B-树和B+-树的所有索引和表的代码。为每个表单维护一个单独的B+树，为每个索引维护一个B树。到树模块的接口在btree.h源文件中声明。</p>
<h3 id="277-the-pager">2.7.7 The Pager</h3>
<p>树模块以固定大小的块(称为数据库页面或简单地说为页面)从数据库文件中请求信息。页面管理器负责读取、写入和缓存数据库页面。它还提供回滚和原子提交并协调事务并发性.树模块向寻呼器请求特定页面，并在希望修改这些页面或提交/回滚更改时通知寻呼器。寻呼器处理所有必要的细节，以确保请求得到快速、安全和效的处理。它充当典型DBMS的数据管理器、事务管理器、日志管理器和锁管理器。实现分页器的代码在pager.c源文件中定义。分页模块的接口是在pager.h源文件中声明的。</p>
<h3 id="278操作系统界面">2.7.8操作系统界面</h3>
<p>为了在POSIX、Windows和其他操作环境之间提供可移植性，SOLite使用一个抽象的接口层来与各种操作系统交互。它是一层很薄的膜。操作系统象层的接口是在os.h源文件中声明的;它被称为VFSadapter。SQLite通过适配器从平台获取服务。每个受支持的操作系统都有自己的实现:osunix.c用于Unix(以及Linux和MACOSX)，oswin.c用于Windows(Win32和WinCE)，os操作系统2.c用于OS/2。对于Unix，osunix.c文件包含锁定代码。构建过程会在库编译过程中获取适当的代码。</p>
<p><strong>SOLite使用的Linux原语:</strong> SOLite使用本地操作系统和文件系统的一小部分原语来获得它们的服务。这个子集包括open、read、write、close、fcntl、fsync、fdatasync、malloc、free、unlink、access和一些pthread APl。 可以从Linuxmanpages中获取有关这些原语的信息。SOLite还使用Linux标准的临时文件目录来创建临时文件。这些临时文件的名称以etilgs 开头，后面跟着16个随机的字母数字字符，没有任何文件扩展名。
在本书中我没有谈到操作系统界面，你可能会认为这个层提供了诸如打开、读取、写入、同步、锁定、关闭、删除等功能，这些功能可以应用在文件上。</p>
<h2 id="28-sqlite-构建过程">2.8 Sqlite 构建过程</h2>
<p>构建过程如图2.11所示。构建过程包括以下六个连续的步骤:(1)构建sqlite3.h接口文件，(2)构建SOL解析器，(3)构建VM指令码，(4)构建指令码名称，(5)构建 SOL关键字，(6)构建库。
在构建过程中，生成六个C文件，用于构建最终库。两个中间C程序(lemon.c和mkkeywordhash.c)被编译以在构建机器上运行，以生成三个C文件:keywordhash.h、parse.h和parse.c。keywordhash.h文件中包含一个SOL/SOLite关键字的静态哈希表。柠檬程序生成解析器代码。Linux实用程序 awk和sed用于生成其他三个C文件:sqlite3.h、opcodes.h和opcodes.c。sqlite3.h文件包含SOLiteAPI函数和常量声明。(SOLite应用程序只需要这个文件和SOLite库。)opcodes.c文件包含用于字节码编程的opcode的文本名称。awk脚本扫描vdbe.c源文件以创建opcodes.h文件，该文件为操作符分配数值
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241216163718.png" alt="Figure 2.11:SQLite build process">
        您可以从其主页下载 SQLite 源代码[22]并尝试构建过程。在配置下载的源代码时，将在根sqlite目录中生成一个Makefile。maketarget source命令执行所有源代码生成和预处理，并将最终编译的C文件放入新创建的tsrc子目录中。make命令除了构建库之外，还执行所有操作。要构建库，您需要编译tsrc子目录</p>
<p>        最近，SQLite开发团队提供了一个熟的合并文件(sqlite3.c)和相应的sqlite3.h文件，您可以使用它来构建库。(在最开始sqlite3.c文件还包含sqlite3.h文件的副本。)合并文件具有各种SQLite编译时间选项的默认设置值。已经发现，由合并文件生成的库效率提高了5-10%，因为C编译器可以进行更多的代码优化。您还可以将sqlite3.c文件与其他.c文件一起编译，使sqlite成为应用程序的一部分。SOLite开发团队强烈建议使用合并文件。如果希望使用命令行实用程序sqlite3，还需要shell.c源文件。(更多细节请参见 <a href="http://www.sqlite.org/howtocompile.html">http://www.sqlite.org/howtocompile.html</a>页面。)</p>
<p>        SQLite允许自定义构建，其中某些SQLite功能可以使用各种编译标志关闭。我在第252页的10.18节中讨论了这些标志。</p>
<h2 id="总结">总结</h2>
<p>SOLite是一个基干SOL-92规范的嵌入式关系数据库管理系统，用于用C语言编写的数据库应用程序;整个SQLite代码库是用ANSI开发的C.SOLite 的第一个版本于 2000年5月29 日发布。自那时以来，它已经取得了长足的发展。它在数据库应用程序中易于使用。它具有零配置、定制、嵌入式、线程安全、易于维护、面向事务等值得称赞的特性。</p>
<p>        本章介绍了一些简单的单线程和多线程SOLite应用程序，展示了如何使用一些常用的SOLiteAPl函数，如sqlite3 open、sqlite3 close、sqlite3_prepare、sqlite3 step、sqlite3 finalize、sqlite3 exec、sqlite3 reset、sqlite3 bind *.sqlite3 column *等。这些应用程序展示了使用SQLite操作数据库是多么容易。</p>
<p>        本章概述了 SQLite 处理事务的方式。每个 SQL语句都在事务中执行。当应用程序不通过执行 begin 命令手动打开事务时，SOLite会自动创建事务。在前一种情况下，我们说系统处于自动提交模式，SOLite在SOL语句执行结束时关闭(提交或回滚)事务。在后一种情况下，应用程序必须通过行commit或 rollback命令手动关闭事务。在那之前，所有SOL语句的执行都成为事务的一部分。SQLite确保事务的执行是可序列化的，为了实现ACID属性，它使用数据库级别的锁定方案和基于日志的故障恢复方案。</p>
<p>        每个SOLite数据库都存储在单个本地文件中。该文件至少有一个目录(也称为系统表)，即sqlite master;对于临时数据库，它被称为sqlitetemp master。当数据库本身初始化时，主表被创建和初始化。该表包含每个表、视图、索引和触发器定义(除主表外)的一行。该表有五个列:类型名称、表名、根页和sql。行被添加和从table 中，因为用户会分别创建和删除 database 对象。表是整个数据库的锚点。
SOLite 根据需要使用其他可选目录，例如sqlite sequence。</p>
<p>        SQLite DBMS具有非常简单的模块化软件架构。有两个部分:前端解析系统和后端引擎。前端由三个模块组成:记号赋予器、解析器和代码生成器。后端是虚拟机，它从树和寻呼模块获取存储支持。最低级别的模块是操作系统接口，使SQLite可移植到多个操作系统。前端部门将SQL语句编译为后端引擎执行的内部字节码程序。</p>
<p>        SOLite是开源的，并且可以在公共领域使用。可以从http://www.sqlite.org/download.html网页下载源代码和二进制文件，并且可以用于任何目的，而无需担心任何许可问题。</p>
<p>        本章对SQLite领域进行了非常简短的介绍。本章中介绍的所有概念以及新引入的概念将在后续章节中详细讨论。在下一章中，我将讨论数据库和志文件的存储结构。</p>
<h1 id="第三章-储存组织">第三章 储存组织</h1>
<h3 id="学术目标-1">学术目标</h3>
<p>阅读本章后，你应该能够解释/描述</p>
<ul>
<li>单个SOLite数据库的组织</li>
<li>数据库和各种日志文件的格式</li>
<li>SOLite上下文中页面的概念和各种页面的目的</li>
<li>如何使数据库独立于平台</li>
</ul>
<h3 id="章节概要-1">章节概要</h3>
<p>        本章讨论了SOLite在最低级别上如何组织数据库和日志文件的内容。它定义了这些文件的格式。整个数据库文件被划分为固定大小的页面，用于存储B/B+-树页面、自由列表页面和其他页面。在默认的日志模式中，日志文件将数据库页面的前图像内容作为日志记录存储:但在WAL日志模式中，日志文件将存储数据库页面的后图像内容。本章讨论了这些文件的命名方式及其内部组织。</p>
<h2 id="31-数据库命名约定">3.1 数据库命名约定</h2>
<p>        数据库被完整地存储在单个文件中，称为数据库文件。(数据库与文件是同义词.因为没有其他文件存储有关数据库的任何信息。)当应用程序通过调用sqlite3open API函数尝试连接到数据库时，它会将数据库文件的名称作为参数传递给该数。文件名可以是相对于当前工作目录的相对路径名或从系统文件树的根开始。任何被本地文件系统接受的常规文件名都是好的。然而，有两个显著的例外。</p>
<ol>
<li>
<p>如果给定的文件名是C语言的NULL指针(即0)或空字符串(“”)或包含所有空格字符的字符串，则SQLite会创建并打开一个新的临时文件。(但是，SOLite会尽量将尽可能多的数据存储在内存中。)这种情况的不同实例将具有不同的临时文件。当通过附加命令打开空或空格字符串时也会发生这种情况。</p>
</li>
<li>
<p>如果给定的文件名是“:memory:，SOLite将创建一个内存数据库。这个数据库不使用任何文件。如果应用程序两次或多次打开“:memory:”数据库，那么在进程地址空间中将存在许多独立的内存数据库副本，而不是一个副本!通过附加命令打开“:memory:”数据库时也是如此。</p>
</li>
</ol>
<p>在这两种特殊情况下(通过 sqlite3 open 显式打开或通过 attach 命令打开)，数据库是临时的，即非持久的，当应用程序关闭数据库连接时，数据库会消失，即被SQLite 自动删除。</p>
<p><strong>数据库文件名惯例:</strong> 建议选择以.db扩展名结尾的文件名。这样你就能知道➆饪蕥П谣些是数据库文件。</p>
<p><strong>URI文件名:</strong> 从SOLite 3.7.7开始，SQLite 支持 URI(统一资源标识符)文件名URI以文件:前缀开始。URI可以包含 vfs、模式、缓存等查询字符串参数-值对。要启用此功能，必须使用 SQLITE_USE.URI编译时标志编译 SQLite 库。有关此功能的更多信息，请参见 <a href="http://www.sqlite.org/uri.html">http://www.sqlite.org/uri.html</a>。</p>
<p><strong>临时文件的使用:</strong> 除了上述项目(1)中提到的临时文件使用外，SQLite还将其用于其他许多目的，如回滚日志、语句日志、多数据库主日志、临时索引、真空命令使用的临时数据库、视图的物化以及子查询。</p>
<p><strong>临时数据库文件名:</strong> SQLite 随机选择所有临时文件名。文件名以 etilgs为前缀，后跟 16 个随机字母数字字符，没有文件扩展名。您可以使用 SOLITE TEMPFILE_PREFIX 编译宏将前缀更改为不同的单词。文件存储在标准的本地临时文件目录中。SOLite按以下顺序尝试目录(1)/var/tmp、(2)/usr/tmp和(3)/tmp。但是，您可以通过设置TMPDIR环境变量来使用不同的临时目录。当应用程序关闭临时文件时，它们会自动被删除。但是，如果应用程序或系统在关闭它们之前崩溃，这些文件会保留。</p>
<p>        在上述任何一种打开数据库的方式(持久文件、临时数据库或内存数据库)中，由SQLite创建和/或打开的数据库在内部命名为主要数据库。SOLite为应用程序通过sqlite3 open API函数打开的每个库连接维护一个独立的临时数据库;数据库名为临时数据库。参见图3.1，其中应用程序通过两个不同的库连接两次打开同一个主数据库;每个打开实例都有自己的(不同的)临时文件。临时数据库存储临时对象，如表及其索引。(应用程序可以在查询中使用这两个名称，即主和临时。)例如，selectfrom temp.tablel返回 temp 数据库中 tablel 表中的所有行，而不是主数据库中的行。temp数据库的目录名为sqlite temp master。临时对象仅在同一库连接中可见(在其他库连接中不可见，即使它们在同一线程、进程或其他进程中打开相同的主数据库文件)。如图所示，SQLite将temp数据库存储在单独的一个临时文件中，该文件与主数据库文件不同。当应用程序在库连接上执行第一个create temporarytabletablel&hellip;语句时，实际上会创建该文件。当应用程序关闭库连接时，SOLite会删除临时文件。主数据库和临时数据库的结构是相同的。除了通过SQLite之外，用户不得自行篡改这些临时文件(无论是修改、删除还是重命名)，否则数据库可能会损坏。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216170756.png" alt="图3.1:描述临时数据库的库连接"></p>
<p>        您可能会注意到，在内部，数据库文件名不是数据库名称。它们是SQLite中的两个不同但相关的概念。通过使用SOLite附加命令，可以将任何数据库文件与库连接关联为不同的数据库名称(除了主、临时和已在库连接中使用的那些之外)。您可以通过这些数据库名称对附加的数据库文件执行操作。例如，SOLite命令attach/home/sibsankar/MyDBasDB1使MyDB数据库文件对库库连接可用;附加的数据库在内部命名为DB1。从DB1.table1中选择*返回 DB1数据库中 tablel表的所有行，即 MyDB表没有固有的附加临时参数。附件的数据库文件。可以通过执行detach命令(例如detachDB1)从库连接中释放数据库(主数据库和临时数据库除外)。</p>
<p><strong>连接混淆:</strong> 即使 sqlite3 open API函数接受数据库文件名，它也会打开一个库连接。这个库连接将与主数据库和临时数据库建立连接。在后文中，这些数据库连接被称为数据库连接。主数据库连接是到给定文件的连接。attach命令将新的数据库连接添加到库连接中，而 detach 命令可以将前者从后者中移除。当没有附加的数据库时，库连接和主数据库连接是同义词。</p>
<h2 id="32数据库文件结构">3.2数据库文件结构</h2>
<p>除了内存数据库，SQLite将整个(持久或临时)数据库存储在单个数据库文件中。在其生命周期中，数据库文件会增长和缩小。(只要本地操作系统1文件系统允许文件增长，数据库文件就可以增长。)本地文件系统将数据库文件视为普通文件。它不解释文件的内容;它将文件视为简单的字节串。它实现读写原语，以从任何偏移位置读取/写入文件中的任意字节数。它还支持对 fles 进行同步(又名 flush)操作。在本节的其余部分，我将讨论如何将数据库文件构建为(逻辑)页面，以及这些页面是如何组织的。</p>
<h3 id="321页面抽象">3.2.1页面抽象</h3>
<p>为了便于空间管理和从数据库文件中读写数据，SQLite将每个数据库文件(包括内存中的数据库)划分为固定大小的区域，称为数据库页或简单地说为页。因此，数据库文件的大小总是页的倍数。页按1开始线性编号。第一页称为页1，第二页为页2，以此类推。页面0被视为空页或“非页面”-页面在物理上不存在。从页1开始，页面一个接一个地线性存储到数据库文件中，从文件偏移量0开始，如图所示。3.2.您可以将数据库文件视为固定大小页面的可变大小数组，页面编号用作数组中的索引以访问页面。(实际上，页面模块在原生文件系统之上创建了这种抽象。)</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216171028.png" alt="Figure 3.2: Organization of space in a database fle partitioned into fxed size pages"></p>
<h3 id="322页面大小">3.2.2页面大小</h3>
<p>默认页大小为1024字节，但它是一个编译时可自定义的参数。当从源代码编译SQLite库时，可以更改该值。页面大小必须为2，范围从512(=29)到65，536(=216)，均包括在内。后一个约束是由于在代码和外部存储的不同地方需要将页面大小存储在2字节无符号整数变量中而施加的限制。一个数据库文件最多可以有2,147,483,647页(=231-1);这个数字在pager.c源文件的PAGER MAXPGNO宏中被硬编码。因此，一个数据库的大小可以达到大约140太字节(≈216x231=247)字节，当然，也要受到原生文件系统所施加的限制。
<strong>更改页面大小:</strong> 一旦数据库文件被创建，SQLite使用编译时的默认页面大小，但您可以通过在创建数据库中的第一个表之前使用page size pragma命令来更改大小。SQLite将大小值存储为文件元数据的一部分(参见第3.2.4节)。它将使用此页面大小值而不是默认值。即使您稍后使用不同的SOLite库，该库针对不同的默认页面大小进行了定制，数据库也将完美运行。</p>
<h3 id="323页面类型">3.2.3页面类型</h3>
<p>SOLite 会跟踪分配给数据库文件的页面，无论这些页面当前是否正在使用中。它会将跟踪信息保存在文件本身中。它计算所有页面，没有悬空的页面需要垃圾回收。(SOLite 中没有垃圾回收方案。)根据使用情况，页面被分为四种类型:空闲、树、指针映射(用于自动真空和增量真空功能，见第10.8节，第235 页)和锁字节(见第4.2.6节，第105页)。树页被细分为叶子页、内部页和溢出页。空闲页是未使用的(即当前未使用的)页;其他是活动页，它们属于B-或B+树，除了指针映射和锁字节页。B+树内部页包含用于搜索树的导航信息。(B-树内部页既包含搜索信息又包含数据)。叶子页在B+树中存储实际数据(例如，表行)。如果一行的数据太大而无法容纳在单个页中，则部分数据存储在树页中，其余部分存储在一个或多个溢出页中。</p>
<h3 id="324数据库元数据">3.2.4数据库元数据</h3>
<p>SQLite可以为任何页面类型使用任何数据库页面。第1页是惟一的例外，它总是一个B+树内部页面，存储sqlite master或sqlite temp master的根结点。该页还包含一个100字节的文件头记录，该记录从文件偏移量0开始存储。见图。3.3.</p>
<hr>
<p>SQLite开发团队在2000年运行了许多基准测试应用程序后，通过试错方法决定了默认值。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216171237.png" alt="Figure 3.3:Gross structure of Page 1"></p>
<p>        文件头信息描述了数据库文件的结构。它定义了各种数据库设置参数的各种值，即元数据。SOLite在创建文件时初始化头信息。它使用第1页(包括文件头和B+-树)作为稳定的锚点，以跟踪文件中的其他页面。文件头格式如图3.4所示。图中的前两列是字节。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216171345.png" alt="Figure 3.4:Structure of database fle header."></p>
<p>        下面是对每个元数据元素(又称数据库设置参数)的描述</p>
<ul>
<li>
<p>标题字符串:这是16字节的字符串:&ldquo;SOLite格式3&rdquo;，以UTF-8格式表示。在编译时，您可以通过定义SOLITE FILE HEADER编译宏来选择不同的16字节字符串，包括空终止符。)</p>
</li>
<li>
<p>页面大小:这是此数据库中每个页面的大小。值必须在512和32.768(包括两者)之间的2的幂次，或1表示65.536。如上所述，SOLite在操作文件时使用此页面大小。(相同的SOLite库可以同时处理具有不同页面大小的数据库文件。</p>
</li>
<li>
<p>文件格式:偏移量18和19处的两个字节用于指示文件格式版本。在当前版本的SQLite中，它们都必须是1或2，否则会出现错误，无法访问数据库。值1用于遗留的回滚日志记录(在SOLite 3.7.0发布之前)，值2用于SOLite 3.7.0中弓入的WAL日志记录。如果读取或写入的值大于2，则分别无法读取或写入数据库。如果将来文件格式再次更改，这些数字将增加到指示新的文件格式版本号。</p>
</li>
<li>
<p>保留空间:SOLite 可以在每个页面的未尾保留少量固定空间(&lt;=255 字节)以用于其自身目的，并且该值存储在偏移量20处;默认值为 0。当数据库使用SQLite 的内置(专有)加密技术时，它是非零的。每个页面末尾的额外字节存储该页面的加密算法使用的 nonce。页面的第一部分(页面大小减去保留大小)是存储数据库内容的可用空间。此空间必须至少为 480 字节。</p>
</li>
<li>
<p>嵌入式载荷:最大嵌入式载荷部分值(在偏移量21处)是标准B/B+-树内部节点的单个条目(称为单元格或记录)可以消耗的页面总可用空间量。值为255表示100%。该值必须为64(即25%):该值用于限制最大单元格大小，以便至少四个单元格适合一个节点。如果单元格的载荷大于最大值，则部分载荷溢出到溢出页中。一旦SQLite分配了一个溢出页，它会将尽可能多的字节移动到溢出页中，而不会让单元格大小下降到最小嵌入式载荷部分值(在偏移22处)以下。值必须为32，即12.5%。
min leaf payload fraction值(在偏移量23处)与min embedded payloadfraction类似，但仅适用干B+-树叶子页。该值必须为32，即12.5%。叶子节点的最大payload fraction值始终为100%(或255)，因此在头文件中未指定。(B树中没有特殊用途的叶子节点。)
这三个领域的最初目的最近没有得到支持。</p>
</li>
<li>
<p>文件更改计数器:文件更改计数器(在偏移量24处)被事务使用。计数器初始化为0。每个成功写入数据库的写事务都会递增计数器的值。该值用于指示数据库何时已更改，以便页面可以清除其页面缓存。(当文件格式指示使用WAL日志时，此计数器不适用。)</p>
</li>
<li>
<p>数据库大小:数据库当前保存的页数以偏移量28存储。</p>
</li>
<li>
<p>自由列表:未使用页面的自由列表源自偏移量为32的文件头。空闲页面的总数存储在偏移量为36处。有关自由列表组织的更多信息，请参见下一节。</p>
</li>
<li>
<p>数据库模式Cookie:在偏移量40处存储一个4字节的整数，初始值为0。每当数据库模式更改时，其值会增加1，并用于预处理语句的自身有效性测试。</p>
</li>
<li>
<p>其他元变量:在偏移量44处，有14个4字节的整数值，这些值被保留用于树和VM模块。它们代表许多元变量的值，包括偏移量44处的模式格式编号、48处的(建议的)页面缓存大小、52处的自动真空相关信息(0表示没有自动真空，否则为数据库中最近根页面的页号)、56处的文本编码(值1表示UTF-8,2表示UTF-16LE，3表示UTF-16 BE)、60处的用户版本号(SOLite不使用，但用户使用)、64处的增量真空模式(0表示没有真空，其他值表示真空)以及偏移量92和96处的版本号;3其余字节被保留用于未来使用，必须清零。您可以在SQLite源文件(特别是btree.c)中找到有关这些变量的更多信息。</p>
</li>
</ul>
<p><strong>增量真空 vs.自动真空:</strong> 如果文件偏移量 52的4字节整数是 0，那么偏移量 60 的4 字节值必须为 0;数据库文件将不会执行自动真空。但是，用户可以通过执行真空命令来执行手动真空。如果文件偏移量 52 处的4字节整数不为零且偏移量 60处的4字节值为零，则自动真空正在运行;否则，自动真空关闭，增量真空正在运行。</p>
<p><strong>跨平台使用:</strong> SQLite将所有多字节整数值存储在big-endian(最显著的字节在前)顺序中。这使得您可以将数据库文件安全地从一个平台移动到另一个平台。例如，您可以在x-86机器上创建一个数据库，并在ARM平台上使用相同的数据库(通过进行盲复制)而无需任何更改。数据库在新的平台上按预期工作。</p>
<p><strong>向后兼容性:</strong> 数据库文件格式向后兼容到版本3.0.0。这意味着任何后续版本的 SOLite 都可以读取和写入最初由版本 3.0.0创建的数据库文件。这在其他方向上也基本成立&ndash;版本 3.0.0的 SOLite 通常可以读取和写入由该库华后续版本创建的任何 SOLite 数据库。然而，后续版本的 SOLite引入了一版本 3.0.0不理解的新功能，如果数据库包含这些可选的新功能，则较旧版本的库将无法读取和理解它。</p>
<hr>
<p>        不同的SQLite主版本可能使用不同的内部文件格式。此元信息用于检测数据库与库的不匹配，其值为1.2.3。或者43</p>
<p>        最近修改数据库文件的SQLite库的版本号存储在olset 96。当这个值被改变时，从ofisset 24开始的瞬时改变计数器的值被保存在偏移量92处</p>
<p>        如前所述，文件头之后是第1页上的B+树内部节点。该节点是主目录表的根节点，对于常规(即，主或附加)数据库，分别命名为sqlitemaster或sqlite tempmaster。如第67页第2.4节所述，该表存储同一数据库中所有其他树的根页编号。因此，第1页帮助SOLite跟踪其他树和溢出页。它是最珍贵的页面。</p>
<h3 id="325自由名单的结构">3.2.5自由名单的结构</h3>
<p>未使用页的列表起源于偏移量为32的文件头。未使用页的总数量存储在偏移量为36处。未使用页列表以根树干的形式组织，如图3.5所示。未使用页分为两种子类型:树干页和叶子页。文件头指向链接的树干页列表中的第-个。每个树干页指向多个叶子页。，(叶子页的内容未指定，可以是垃圾o
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216172210.png" alt="图3.5:自由名单的结构。"></p>
<p>        一个 trunk页的格式如下所示，从页的底部(也称为较低偏移量)开始:(1)下一个 trunk页的4字节页号(如果没有下一页则为 0);(2)一个4字节的整数值，表示存储在此页上的leaf指针的数量;(3)零个或多个4字节的leaf页页窍。
注意:由于3.6.0之前的版本存在一个错误，所以SOLite不会在主干页面上写
入最后6个条目。</p>
<p>        当一个页面变得不活动时，SOLite将其添加到自由列表中，但不会将其释放到本地文件系统。当您在数据库中添加新信息时，SQLite从自由列表中取出空闲页面以存储信息。(因此，新信息可能存储在数据库文件中的任何位置。)如果自由列表为空，则SQLite从本地文件系统中获取新页面，并将它们附加到数据库文件的末尾。</p>
<p>        在某些情况下，当自由页的数量变得过高时，你可能会感到担忧。你可以运行VACUUM命令来清除自由列表，缩小数据库文件，并将未使用的页面释放回文件系统。在“自动真空”模式下创建的数据库将在每个事务提交时自动缩小数据库。自由列表在事务之间保持空，尽管事务可以在提交之前建立自由列表。</p>
<p>        自由列表清理:当您通过执行真空命令来清理自由列表时，该命令将数据库的副本复制到一个临时文件中。然后，它将在事务的保护下用临时副本覆盖原始数据库。</p>
<h2 id="33期刊文件结构">3.3期刊文件结构</h2>
<p>SQLite使用三种日志文件，即回滚日志、语句日志和主日志。(这些被称为遗留日志。在SQLite3.7.0版本中，SQLite开发团队引入了WAL日志记录方案。数据库文件可以处于遗留日志记录独占或WAL日志记录模式。)它们的结构以及遗留日志记录的记录结构在下面的三个小节中介绍。我在第249页的第10.17节中讨论WAL日志记录。</p>
<h3 id="331-回溯日记">3.3.1 回溯日记</h3>
<p>对于每个数据库，SOLite 维护一个单一的回滚日志文件。(内存数据库不使用日志文件。它们使用主内存来存储日志信息。)回滚日志始终与原(主、临时或附加)数据库文件位于同一目录下。日志文件名与数据库文件名相同，后缀为-journal。您可能会注意到，在默认操作模式下，日志是临时的。SQLite为每个写事务创建日志文件，并在事务完成时删除该文件。</p>
<p>        SQLite 将每个回滚日志文件分割成可变大小的日志段，如图3.6所示。每个日志段以段头记录开始，后面跟着一个或多个日志记录。这些将在接下来的两个子小节中讨论。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216172527.png" alt="图3.6:将回滚日志文件中的空间组织为可变大小段。"></p>
<h4 id="3311分段头结构">3.3.1.1分段头结构</h4>
<p>段头文件的格式如图3.7所示。头文件以以下八个魔术字节的顺序开始(在较低的偏移量处):0xD9,0xD5,0x05,0xF9,0x20,0xA1,0x63,0xD7。序列将在后续中称为魔术数字。该数字被随机选择一次，仅用于sanitycheck，没有其他特殊意义。记录数(nRec，简称)组件指定此日志段中有多少个有效的日志记录。对于异步事务，nRec值最初为-1（作为带符号的值为0xFFFFFFFF），对于同步事务，nRec值为0。随机数组件的值用于计算单个日志记录的“校验和”。初始数据库页计数组件记录了当前日志记录开始时原始数据库文件中有多少页，扇区大小是数据库文件所在磁盘扇区的大小，段头占用整个磁盘扇区。也就是说，报头大小等于报头本身指定的扇区大小。页面大小是数据库页面的大小。标题中未使用的空间作为填充符保留在那里。所有的整数都以大端字节格式存储。
<img src="http://shanks.link/imig/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216172731.png" alt="Figure 3.7:Structure of iournal segment header"></p>
<p>**扇区大小确定:**SOLite询问底层文件系统以获取扇区大小。(如果文件系统没有此信息则默认扇区大小为512字节。)SOLite假定文件系统不允许就地更改扇区中的单个字节。我们需要逐扇区地从文件系统写入或读取扇区。</p>
<p>        回滚日志文件通常包含一个日志段。但是，在某些情况下，它是一个多段文件，SOLite会在文件中多次写入段头记录。(我将在第140页的5.4.13节中讨论此类场景。)每次写入段头记录时，它都会写入扇区边界。在多段日志文件中，任何段头中的nRec字段不能为-1(即0XFFFFFFFF)。</p>
<p><strong>日志文件保留:</strong> 在默认操作模式下，SQLite会在事务提交/回滚时删除日志文件。但是，您可以通过使用pragmajournalmode命令来持久化日志(头被清零/无效或文件被截断)来改变这种行为。也就是说，日志式是DELETE、PERSIST或TRUNCATE;默认是DELETE。我将在本书后面介绍其他日志模式。如果应用程序使用排他锁定模式(pragmalockingmode-exclusive)。SOLite创建回滚日志该日志在应用程序移出排他锁定模式之前一直存在。在这种情况下，跨事务，日志文件被截断或其头被清零。</p>
<p><strong>日志维护:</strong> 如果回滚日志在偏移量为0的位置包含有效的段头，则该日志有效。如果文件大小为0或包含无效的段头，则该日志不用于事务回滚。</p>
<p><strong>异步事务:</strong> SOLite支持异步事务，其速度比同步(同步)事务更快，异步事务在任何时候都不会刷新日志文件或数据库文件。日志文件将只有一个日志段。nRec的值始终为-1，实际值由文件大小得出。SOLite不建议使用异步事务，但可以通过执行一个pragma命令来设置异步模式。这种模式通常在应用程序开发阶段使用，以减少开发时间。这种模式也适用于测试一些不需要测试从失败中恢复的应用程序。</p>
<h4 id="3312日志记录结构">3.3.1.2日志记录结构</h4>
<p>当前写事务中的非SELECT语句会产生日志记录。SQLite在页面级别使用旧值日志技术。在首次更改任何页面之前，该页面的原始内容(连同其页面编号)被写入日志中的新日志记录。图3.8显示了单个日志记录的结构。该记录还包含32位校验和。校验和包括页面编号和页面图像。在日志段头中出现的32位随机值(参见图中的第三个组件)。3.7)作为校验码密钥。随机数很重要，因为出现在日志未尾的垃圾数据很可能是曾经存在于其他文件中但现在已被删除的数据。如果垃圾数据来自过时的日志文件，则检查总数可能是正确的。但是，通过将校验和初始化为对不同日志文件不同的随机值，SOLite可以最小化这种风险。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216173234.png" alt="图3.8:日志记录的结构"></p>
<p><strong>校验和位置:</strong> 您可能会注意到页码存储在日志记录的起始处，而校验和存储在未尾这种设置很重要。SQLite开发团队假定文件中的数据是以字节串线性写入的。因0此，如果由于电源故障导致日志损坏，最有可能的情况是记录的一端或另一端会损坏。日志记录的两端都正确而中间损坏的情况非常不可能发生。因此，尽管这种校验和方案快速且简单，但它能够捕捉到最有可能的损坏类型。</p>
<h3 id="332-statement-journal">3.3.2 Statement journal</h3>
<p>在用户的交易过程中，SQLite会为最新的INSERT、UPDATE或DELETESQL语句执行维护一个语句子日志，这些语句可能修改多行，并可能在触发器中导致约束违反或引发异常。子日志用于从语句执行失败中恢复数据库。语句日志是一个单独的、普通的回滚日志文件。它是一个任意命名的临时文件前缀为etilgs );它位于临时文件的本机目录中。崩溃恢复操作不需要日志文件;它仅用于语句中止。当语句执行完成时，SQLite会删除文件。日志中没有段头记录。nRec(日志记录数)值保存在内存数据结构中，数据库文件大小也保存在内存数据结构中，直到语句开始执行。这些日志记录没有任何校验和信息。</p>
<p><strong>语句日志保留:</strong> 语句日志文件在语句执行结束时被删除。但是，为了实施SAVEPOINTS，SQLite 会保留语句日志，直到保存点被释放或用户事务提交。</p>
<h3 id="333多数据库事务日志主日志">3.3.3多数据库事务日志、主日志</h3>
<p>你可能记得，应用程序可以通过执行ATTACH命令将附加数据库附加到已打开的库连接。在此场景中，SQLite允许用户事务读取和修改多个数据库。(参见第62页的图2.8。)如果事务修改多个数据库，则每个数据库都有自己的回滚日志。它们是独立回滚日志，彼此不知道。这样的事务在每个它更新的数据库中单独提交。因此，事务可能不是全局原子的。为了使(多数据库)事务具有全局原子性，SQLite还维护一个单独的聚合日志，称为主日志。4日志不包含任何用于回滚目的的日志记录，而是包含参与事务的所有个人回滚日志的UTF8格式名称。(在这种情况下，回滚日志称为子日志)子日志名称是全路径名称，由主日志文件中的空字符分隔。主日志总是与主数据库文件位于同一目录中，并且具有相同的名称，后缀为'-mi'，接着是八个随机选择的4位十六进制数字。它是一个临时的文件;当事务尝试提交时创建，并在提交处理完成后删除。事务中断不会创建主日志文件。</p>
<p>        每个子日志还包含主日志的(完整路径)名称，如图3.9所示。(如果没有附加数据库，或者如果没有附加数据库参与当前事务的更新，则不会创建主日志，子日志不包含任何有关主日志的信息。)如图所示，主日志记录是在事务提交时附加到子日志文件中的最后一个条目。该记录在磁盘扇区边界对齐。 校验和字段存储主日志名的校验和。长度字段指定主日志名的长度。主日志名总是以UTF8格式的文本存储，不包括终止的空字符。禁止的页号是包含锁定偏移字节的页的编号(见第4章):SQLite从不写入锁定字节页;它被保留用于解决Windows/POSIX不兼容问题。</p>
<hr>
<p>4-如果主数据库是内存数据库，则不使用主日志。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216173959.png" alt="Figure 3.9:Structure of child journal fle."></p>
<h2 id="总结-1">总结</h2>
<p>SQLite将所有(用户和元)信息存储在单个本地文件中，该文件名与数据库名同义。SOLite还支持临时和内存数据库。这些数据库在应用程序打开它们时创建和初始化，并在应用程序关闭它们时删除。</p>
<p>        每个数据库文件都是固定大小的页的倍数。从逻辑上讲，数据库是一组页，并且该数组可以扩展和收缩。默认页面大小为1024，但可以设置为512和65,536之间的值，但值必须是2的幂。数据库文件可以有多达231-2页。有四种类型的页:空闲、树、锁定字节和指针映射。树页被细分为内部、叶和溢出。</p>
<p>        第一页(从文件偏移量0开始)是锚点页。前100个字节存储数据库元数据，如头字符串、页面大小、文件格式等，页面上剩余的空间存储 sqlite 主目录或sqlite temp 主目录的根。所有空闲页面都组织在一个有根的树干树中。</p>
<p>        SOLite使用三种类型的日志文件进行(默认)遗留日志记录方案:回滚日志语句日志和主日志。回滚日志和主日志与主数据库位于同一位置，但语句日志位于临时目录中，如/tmp。回滚日志存储可变大小的日志段，每个日志段以头信息开始，后面跟着一个或多个日志记录。日志记录由页号、页的旧映像和校验和组成主日志记录单个多数据库事务中涉及的所有回滚日志的名称。语句日志存储单次插入/更新/删除语句执行的日志。</p>
<h1 id="第四章-transaction-vanagement">第四章 Transaction Vanagement</h1>
<p><strong>学术目标</strong>
阅读本章后，你应该能够解释/描述</p>
<ul>
<li>SQLite如何实现ACID属性中</li>
<li>管理各种锁及其与本地文件锁和锁转换映射的SOLite方法</li>
<li>SQLite如何避免死锁</li>
<li>SOLite如何实现日志协议</li>
<li>SOLite如何在用户事务中管理保存点</li>
</ul>
<p><strong>章节概要</strong>
数据库管理系统(DBMS)的主要职责是帮助用户执行对数据库的操作，以处理存储在数据库中的数据。此外，DBMS保护数据库免受多个并发用户的影响，并在发生应用程序、系统或电源故障时恢复数据库到可接受的连贯状态。为了这些目的，DBMS在事务的抽象中执行数据库操作。管理事务对于维护数据库一致性至关重要。DBMS实现ACID事务属性以确保数据库一致性SQLite 依赖于原生的锁机制和页面日志记录来实现 ACID 属性。你可能记得，SQLite 只支持平面事务;它没有嵌套能力。本章讨论了SQLite如何为可能更新单个或多个数据库的事务实现 ACID 属性。在下一章中，我将解释 SQLite 事务管理器 pager 的内部工作原理。</p>
<h2 id="41交易类型">4.1交易类型</h2>
<p>几乎所有的数据库管理系统都使用锁定机制进行并发控制，并使用日志来保存恢复信息。在事务修改数据库项之前，数据库管理系统会在日志中写入一些包含恢复信息(例如，项的旧值和新值)的日志记录。数据库管理系统确保在原始数据库中的项被更改之前，日志记录到达稳定存储。在事务取消或其他故障发生时，数据库管理系统在日志中拥有足够的信息，可以将数据库恢复到可接受的一致状态，该状态包含所有已提交事务的更新，并且不受其他(取消或失败的)事务的影响。在恢复数据库时，DBMS会撤销数据库中已放弃/失败事务的影响，并重做已提交事务对数据库的影响。在SQLite中，锁定和日志活动取决于我在此部分中讨论的事务类型。它们的管理将在以下两个部分中讨论。</p>
<h3 id="411系统交易">4.1.1系统交易</h3>
<p>SOLite 在事务中执行每个SOL语句。它同时支持读事务和写事务。(在SOLite 文档中，术语“事务”的使用有点抽象。事务可能仅指读事务或写事务。有时它不止于此:它包括写事务和一次或多次读事务。在本书中，每当需要时，我都会详细说明事务的类型。)应用程序只能在读事务或写事务中从数据库中读取任何数据，并且只能在写事务中写入任何数据。它们不需要明确告知SQLite在(适当的)事务中执行单个SQL语句。SOLite会自动执行此操作:这是默认行为，系统处于自动提交模式。这些事务称为系统或自动或隐含事务。对于SELECT语句，SOLite创建一个读取事务来执行该语句。对于非SELECT语句，SQLite首先创建一个读取事务，然后将其转换为写入事务。每个(读取或写入)事务都会在语句执行结束时自动提交(或取消)。应用程序不知道系统事务。它们没有处理系统事务的程序片段。它们将 SOL语句提交给 SOLite，在 ACID 属性方面由 SOLite 处理其余部分。应用程序从 SOLite 接收到 SOL语句执行的结果。</p>
<p>        应用程序可以在同一数据库连接上启动(相同或不同的)SELECT语句(也称为读事务)的并发执行，但只能在该数据库连接上启动一个非SELECT(也称为写事务)。这意味着在数据库连接上不能有两个并发写事务，但可以并发一个写事务和多个读事务;它们通常被合起来想象为单个事务。如何在数据库上执行这些事务将在下一段中解释。</p>
<p>        非选择性语句以原子方式执行;SOLite在启动非选择性语句处理时使用互斥锁，仅在语句执行完成后释放互斥锁。另一方面，选择性语句不是以原子方式从头到尾执行的;它在开始时使用互斥锁，但会为每一行结果暂停并释放互斥锁。因此，一个选择性语句的执行可以运行到其第一行，然后另一个选择性语句的执行可以运行，然后另一个，以此类推。因此，在任何时候，您可以在执行的不同阶段执行许多不同的选择语句。您也可以在暂停期间执行非选择语句。虽然读取和写入事务对于由此线程、进程或其他进程启动到同一数据库的其他连接的事务是不可分割的，但稍后我将向您解释，读取事务和写入事务不能同时操作同一表。因此，读取事务与并发写入事务是隔离的。</p>
<h3 id="412用户交易">4.1.2用户交易</h3>
<p>对于某些应用程序，特别是那些高写密集的应用程序，默认的自动提交模式可能代价高昂，因为SOLite需要为每个非选择语句执行重新打开、写入和关闭日志文件。此外，还有并发控制开销，因为应用程序需要为每个SQL语句执行重新获取和释放数据库文件上的锁。这种开销可能会导致显著的性能损失(特别是对于大型应用程序)，并且只能通过围绕多个SQL语句打开用户级事务来减少。该应用程序包含在“BEGINTRANSACTION”和COMMIT【或ROLLBACK】TRANSACTION”命令中的SOL语句序列。(关键字TRANSACTION是可选的。)begin-commit或begin-rollback对可以包含任意数量的SELECT和非SELECT语句。</p>
<p>        应用程序可以通过显式执行 BEGIN命令手动在库连接上启动新事务。该事务称为用户级或显式事务(或简单称为用户事务)。这实际上是在库连接上打开一个单独的用户事务。当完成此操作时，SOLite 会离开默认的自动提交模式;它不会在每个SOL语句执行结束时调用提交或取消。在库连接(任何数据库连接)上连续执行非选择SOL语句成为用户事务的一部分:但选择语句的执行被视为单独的读取事务。(你可以想象用户事务是唯一的写事务。)当应用程序在库连接上执行COMMIT(或ROLLBACK)命令时，SOLite会提交(或回滚)用户事务。如果用户事务提交，则写事务被提交，但是所有当前读事务都保持活动状态。如果用户事务被中止，写事务将被回滚，并且一些读取了由写事务更新的表的读事务也会被中止。在写事务完成时，SQLite会恢复到自动提交模式。(剩余的读事务在各自的SELECT语句执行结束时独立提交。)</p>
<p><strong>注意:</strong> SQLite仅支持平面事务。它没有嵌套事务的能力。在用户事务中执行begin命令是错误的。应用程序不能在库连接上同时打开多个用户事务。</p>
<h3 id="413保存点">4.1.3保存点</h3>
<p>SQLite支持用户事务的保存点功能。应用程序可以在用户事务内部或外部执行保存点命令。对于后者，SOLite首先打开一个用户事务，然后执行保存点命令，并在应用程序释放保存点时提交事务。保存点是事务执行中的个点，由应用程序建立。它建立了一个它认为良好的数据库状态。事务可以设置多个保存点。稍后，它可能会回滚到其中一个保存点，并重新建立保存点开始时的数据库状态。</p>
<h3 id="414报表子交易">4.1.4报表子交易</h3>
<p>用户事务比简单事务稍复杂一些。所有连续的非选择语句执行都放在该事务中。如前所述，选择语句单独处理。)事务中的每个非选择语句都在单独的语句级子事务中执行。在任何时间点，用户事务中最多只能有一个子事务。SOLite实际上使用隐式(也称为匿名)保存点来在子事务的未尾执行它，并在释放保存点时释放子事务。这个过程会一直持续，直到应用程序执行COMMIT或ABORT命令。1如果当前语句执行失败，SQLite不会中止包含的用户事务，除非冲突解决程序指示回滚(见本节未尾)。相反，它将数据库恢复到语句执行开始前的状态(通过恢复匿名保存点);用户事务从那里继续。失败的语句不会改变其他先前执行的SQL语句或新语句的结果，除非主用户事务自行中止。让我们在这里研究一个创建用户事务的简单SOLite应用程序。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    BEGIN TRANSACTION:
    INSERT INTO table1 values(100);
    INSERT INTO table2 <span style="color:#c34e00">values</span>(20,100);
    UPDATE table1 SET x=x+1 WHERE y&gt; 10:
    INSERT INTO table3 VALUES(1,2,3);
    COMMI TRANSACTION;
</code></pre></div><p>        假设数据库有三个表，即表1、表2和表3。应用程序通过执行begintransaction命令来打开用户事务。这四个语句中的每一个都在单独的子事务中执行，按上述顺序依次执行。例如，如果在UPDATE语句执行过程中发生约束违反错误，则更新执行之前修改的所有行将被恢复，但来自三个INSERT(在UPDATE周围)的更改将在应用程序执行提交事务命令时提交。</p>
<p><strong>冲突解决:</strong> 在插入或更新过程中发生约束违反时，语句有五种方式来解决冲突。回滚:与当前语句子事务一起中止包含事务。中止:取消当前语句子事务的更改并止它;包含事务保持活动状态。这是默认的解决方式。失败:接受当前语句子事务已做的更改，但停止其进一步进展;包含事务保持活动状态。忽略:导致约束违反的特定行不会被更改或插入;子事务保持活动状态并继续进行。替换:导致约束违反的行被删除;子事务保持活动状态并进一步发展。</p>
<h2 id="42锁管理">4.2锁管理</h2>
<p>        一个允许多个并发(冲突)事务的系统需要同步机制来隔离一个事务对其他事务的影响。文献中经常使用的与隔离相关的术语是并发控制、序列化和锁定。它们是不同的但密切相关的术语。Gray和Reuter[9]将术语关联如下:并发控制是待解决的问题，序列化是可处理问题属性的理论，而锁定是解决该问题的机制。通用术语是isolation，即ACID的“”。事务隔离有很多概念:已提交的读取、游标稳定、可重读取、可序列化。参见[9]对于这些术语的定义。序列化是最严格的隔离级别，SOLite实现了它。</p>
<p>        为了产生可序列化的事务执行，SOLite使用锁定机制来管理事务对数据库的访问请求。它不使用并发进程之间的共享内存。因此，它不能在用户空间中协调事务并发。相反，使用本机操作系统（实际上是文件系统）支持的文件锁定原语来实现此目的。</p>
<p>        SQLite通过严格限制事务并行的程度，简化了锁定逻辑的复杂性。它允许任意数量的读事务读取同一数据库，但最多允许一个写事务独占访问数据库。(你可能记得在同一数据库连接中，写事务和一次或多次读事务可以共存。)SQLite的锁定管理非常简单。目前，SQLite执行数据库级锁定，但不进行行级、页级或表级锁定:它对整个数据库文件设置锁定，而不是对文件中的特定数据项设置锁定。此外，为了生成可序列化的事务执行，它遵循严格的二阶段锁定协议，即在事务完成时释放锁定。在本节剩余部分中，我将讨论 SQLite 如何管理各种锁定以及在Linux 系统中的细微差别。注意:一个子事务通过容器用户事务获取锁定。无论子事务的结果如何，所有锁定都由用户事务持有，直到它提交或取消。</p>
<h3 id="421锁类型及其兼容性">4.2.1锁类型及其兼容性</h3>
<p>        从单个事务的角度来看，数据库文件可以处于以下五种锁定状态之一。您可能会注意到这些是 SOLite锁，而不是原生操作系统支持的锁。(我将在第105 页的 4.2.6 节中讨论 SOLite 锁和原生锁之间的映射。)</p>
<ol>
<li>NOLOCK:事务对数据库文件没有锁定任何类型。它既不能读取也不能写入数据库文件。其他事务可以读取或写入数据库，只要它们的锁定状态允许。Nolock是事务在数据库文件上启动时的默认状态。</li>
<li>共享锁:此锁仅允许从数据库文件读取。任何数量的事务可以同时持有文件上的共享锁，因此可以有多个同时的读取事务。当有一个或多个事务持有文件上的共享锁时，不允许任何事务写入数据库文件。</li>
<li>独家:这是唯一允许写入(和读取)数据库文件的锁定。文件上只允许一个排他性锁定，并且不允许任何其他类型的锁定与排他性锁定共存。</li>
<li>保留锁:这种锁允许从数据库文件中读取。但是，它比共享锁稍微复杂-些。保留锁通知其他事务，锁持有者计划将来写入数据库文件，但现在只是读取文件。文件上最多可以有一个保留锁，但锁可以与任意数量的共享锁共存。其他事务可以获取文件上的新共享锁，但不能获取任何其他类型的锁。</li>
<li>PENDING:此锁定允许从数据库文件中读取。一个待处理锁定意味着事务想要立即写入数据库。它是获取排他锁定过程中的中间锁定。事务正在等待当前所有共享锁的清除，然后才能获取排他锁。文件上最多只能有一个待处理锁定，但该锁定可以与任意数量的共享锁定共存，但有一个区别:其他事务可以保留其现有的共享锁定，但不能获取新的(共享或其他)锁定。(此锁类型是锁管理器内部的，客户端看不到。)</li>
</ol>
<p>        SQLite锁之间的兼容性矩阵如图4.1所示。行是事务持有的数据库上的现有锁模式，列是来自另一个事务的新请求。每个矩阵单元格标识两个锁之间的兼容性:Y表示新请求可以授予;N表示不能。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241216181135.png" alt="Figure 4.1: Lock compatibility matrix"></p>
<p><strong>讨*论:</strong> 像SQLite这样的数据库系统至少需要排他锁;其他锁模式仅用于增加事务并发。仅使用排他锁时，系统将串行执行所有(读和写)事务。使用共享和排他锁时系统可以并发执行许多读事务。在实践中，事务在共享锁下从数据库文件中读取数据项，本地修改该数据项，然后请求排他锁将(修改后的)数据项写回文件。如果两个事务同时这样做，就有可能形成死锁(见第104页4.2.4节)，在这种情况下，事务的执行无法取得进展。SOLite开发团队设计了保留和未决锁，以最大限度地减少这种死锁的形成。这两种锁还有助于提高并发性和减少众所周知的写者饥饿问题(读事务永远超过写事务)。这些锁与现有的共享锁兼容，但新的共享锁与未决锁不兼容。 Unix和Window实现提供了所有这五种锁定状态。</p>
<h3 id="422锁获取协议">4.2.2锁获取协议</h3>
<p>在从数据库文件读取或写入页面之前，事务(实际上是寻呼模块)获取对数据库文件的适当锁定，以确保两个事务不会以冲突的方式访问文件。当事务尝试访问文件时，获取适当类型的锁定是寻呼模块的责任。</p>
<p>        事务以非锁定状态开始。在从数据库文件读取第一个(任何)页面之前，事务获取共享锁，以表示其他事务打算从该文件中读取页面。我们说它已成为一个读取事务，它可以读取数据库文件中的任何页面。在对数据库(任何页面)进行任何更改之前，事务获取保留锁，以表示它打算在不久的将来写入。我们说它已成为(半)写事务，但其效果对其他事务(在事务的数据库连接之外)是不可见的。(与共享锁的其他事务可以继续读取文件，但其他事务不能获得文件的新保留锁、挂起锁或独占锁。这意味着系统可以有任意数量的读取事务，但数据库文件上没有其他半写或全写事务。)在数据库文件上保留锁后，一个(半写)事务可以对“在缓存”页面进行更改。在将修改后的页面写回数据库之前，它需要获得数据库文件的独占锁。此时它将成为一个完整的写事务，一旦开始写入文件，其效果将可见于数据库文件中。</p>
<p>        锁定状态转移图如图所示。4.2.(如前所述，待决锁是中间的内部锁，在锁管理器子系统之外不可见。)寻呼器不能要求锁管理器获取待决锁;锁管理器也不接受此类请求。悬而未决的锁总是通往专属锁的临时垫脚石。寻呼器总是请求专用锁，但锁管理器可以授予待定锁。待决锁定将通过后续的专属锁定请求升级为专属锁。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241217103155.png" alt="图4.2:锁定状态转移图。"></p>
<p>        对于读事务，正常的锁转换是从无锁到共享锁，再回到无锁。对于写事务，正常的锁转换是从无琐到共享锁到保留锁到挂起锁到排他锁(如图4.2中的粗箭头所示)，再回到无锁。只有在事务读取数据库时需要回滚日志的情况下，才会进行直接共享锁到挂起锁的转换。在这种情况下，没有其他事务可以从共享锁转换到保留锁（我将在第5.4.2.4节中重新讨论这个问题）。</p>
<p>        锁管理器实现了两个函数，即sqlite30sLock和sqlite30sUnlock，分别用于获取和释放打开数据库文件上的 SOLite锁。在 os unix.c文件中为 Unix 系统定义这两个函数。sqlite30sLock函数由 pager 调用以获取数据库文件上的新锁或升级现有锁，而 sqlite30sUnlock函数用于释放或降级文件上的锁。因此，通过执行sqlite30sLock函数，pager可以获得共享、保留或排他锁，并通过执行sqlite30sUnlock 可以将锁重置为共享或 nolock。当一个打开的数据库连接被关闭时，寻呼器会释放为数据库连接获得的所有锁。我在第112页的4.2.7节中讨论了这两个函数。</p>
<h3 id="423显式锁定">4.2.3显式锁定</h3>
<p>锁定在 SOLite 中是隐式的。系统(实际上是分页器模块)单独决定何时锁定数据库文件以及以何种模式锁定。应用程序可以通过执行两种变体的事务开始命令来显式地指示 SQLite 获取锁定。让我们研究一下以下稍微不同的 SQLite 应用程序，它打开了一个用户事务。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00f">BEGIN</span> <span style="color:#00f">EXCLUSIVE</span> <span style="color:#00f">TRANSACTION</span>;
<span style="color:#00f">INSERT</span> <span style="color:#00f">INTO</span> table1 <span style="color:#00f">values</span>(100);
<span style="color:#00f">INSERT</span> <span style="color:#00f">INTO</span> table2 <span style="color:#00f">values</span>(20,100);
<span style="color:#00f">UPDATE</span> tablel $ET x=x+1 <span style="color:#00f">WHERE</span> y&gt; 10;
<span style="color:#00f">INSERT</span> <span style="color:#00f">INTO</span> table3 <span style="color:#00f">VALUES</span>(1,2,3);
COMMI <span style="color:#00f">TRANSACTION</span>:
</code></pre></div><p>通过执行begin exclusive transaction命令，应用程序迫使SOLite立即对所有数据库文件(主文件和附加文件)获取排他性锁，而无需等待数据库文件被使用。这确保了一旦begin exclusive transaction命令执行成功，事务将对数据库文件具有排他性锁，并且在事务的生命周期内不会被其他事务阻塞。在事务完成之前，该线程和任何其他兄弟线程(通过其他数据库连接)或同一进程中的其他线程将不能发起任何对数据库文件的读写操作。</p>
<p>        除了独占事务，还有两种替代方案:(1)立即开始;(2)延迟开始。立即开始命令立即启动事务，对所有数据库文件(主文件和附加文件)进行保留锁定，而无需等待数据库文件被使用。成功执行立即开始命令后，可以保证没有其他兄弟线程或对等进程能够写入任何数据库文件或成功执行涉及其中一个数据库文件的立即开始或独占开始命令。然而，其他线程和进程可以继续从数据库中读取数据。begin deferred命令启动一个没有任何数据库文件锁的事务；锁的获取被延迟到文件被实际使用时：当文件被第一次读取时，在文件上获得共享锁，在下一次插入/更新/删除操作时，在文件上获得保留锁。当需要时，SQLite将其升级为排他锁（即，直到它实际写入数据库文件时）。因为锁的获取被推迟到需要时，另一个兄弟线程或对等进程可能会创建一个单独的事务，并在当前线程上引用的开始执行后写入数据库。当这个线程试图在事务中执行一些sql语句时，它可能会得到一个$QLITE BUSY错误代码。应用程序开发人员已经得到警告！如果应用程序执行begin transaction语句，默认的操作模式是‘deferred transaction’。您可能会注意到，延迟事务可能不会锁定所有数据库（主数据库和附加数据库）；它会根据需要锁定选择性数据库。</p>
<p>        非排他性开始事务命令允许存在至少可以读取数据库的其他事务。因此，尝试提交写事务可能会导致获得 SOLITE.BUSY错误代码。当以这种方式提交失败时，事务保持活动状态，可以在其他事务(即它们已清除共享锁)消失后稍后重试提交。</p>
<h3 id="424僵局和饥饿">4.2.4僵局和饥饿</h3>
<p>虽然锁定解决了并发控制问题，但它引入了另一个问题。假设两个事务对数据库文件持有共享锁，它们都请求文件上的保留锁。其中一个获得保留锁，另一个等待。一段时间后，持有保留锁的事务请求独占锁，并等待另一个事务清除共享锁。但是，由于持有共享锁的事务正在等待，因此共享锁永远不会被清除。这种情况称为死锁。</p>
<p>        死锁是一个棘手的问题。处理死锁问题有两种方法:(1)预防，和(2)检测和中断。SQLite可以防止死锁的形成。它总是在非阻塞模式下获取文件锁&ndash;要么锁管理器授予请求的锁，要么返回错误代码而不阻塞请求者。如果代表事务无法获取某些锁，它只会重试有限次数(重试次数可以在运行时由应用程序预置，默认为零，即不重试)。如果所有重试都失败，SQLite将向应用程序返回SQLITE_BUSY错误代码。应用程序可以放弃并稍后重试，或者中止事务。因此，系统中不存在死锁形成的可能性。然而，至少在理论上，存在一种可能性，即事务永远试图获得一些锁而没有成功。</p>
<h3 id="425-linux锁原语">4.2.5 Linux锁原语</h3>
<p>SQLite的锁定是通过原生文件锁定实现的。在这一小节中，我回顾了Linux系统支持的锁定机制。POSIX建议的锁定方案是SQLite的默认锁定机制。Linux只实现两种锁定模式，即读和写，用于锁定文件上的连续区域。为了避免术语混淆，我将使用读锁和写锁分别表示原生共享锁和独占锁。写锁排除了所有其他锁，包括读锁和写锁。虽然读锁和写锁可以同时存在于同一文件上，但位于不同的区域。-个进程只能在一个区域上持有一种类型的锁定。如果它对一个已经锁定的区域应用新的锁定，那么现有的锁定将被转换为新的锁定模式。(这种转换可能涉及拆分、缩小或与现有锁定合并，如果新锁定指定的字节范围与现有锁定的范围不完全一致。)</p>
<p><strong>注意:</strong> 文件上的锁定不是文件或其他文件的内容。它们只是内核维护的内存数据对象。锁定在系统故障后不会存在。如果应用程序崩溃或退出，内核会清理应用程序持有的所有锁定。</p>
<h3 id="426-sqlite锁的实现">4.2.6 SQLite锁的实现</h3>
<p>SOLite通过使用本地操作系统支持的文件锁定函数来实现自己的锁定机制(锁定实现取决于平台。我在本书中使用Linux向您展示SOLite如何锁定现在您知道Linux仅支持两种锁定模式，而SOLite有四种。SQLite使用两种本地Linux锁定模式来实现自己的四种锁定模式，用于不同的文件区域它通过调用fcntl系统调用来设置和释放区域上的本地锁定。本节讨论SOLite锁定和本地锁定之间的映射。</p>
<ul>
<li>通过在数据库文件的特定字节范围内设置读取锁，可以获得数据库文件的共享锁。[-2]</li>
<li>通过在指定范围内的所有字节设置写锁，可以获得排他锁。</li>
<li>预留锁是通过在文件的单个字节（位于共享字节范围之外）上设置写锁来获得的；它被指定为保留的锁字节。</li>
<li>一个PENDING锁是通过在一个指定的字节上设置一个写锁来获得的。保留的锁字节，在共享范围之外。</li>
</ul>
<hr>
<p>[-2] 某些版本的Windows只支持写锁。在这种情况下，要获得文件上的共享锁，需要对超出特定字节范围的单个字节进行写锁定。字节是从范围中随机选择的，以便多个读事务可以在那时访问文件，如果两个读事务选择相同的bvte来写锁，则只有一个成功。在这样的系统中，读并发性受到共享字节范围大小的限制。</p>
<p>图4.3显示了这种安排。SOLite保留510字节作为共享字节范围，定义为SHARED SIZE宏的值。范围从SHAREDFIRST宏偏移量开始。PENDINGBYTE宏(=0x40000000，超过1GB边界的第一字节定义了锁字节的开始)是设置PENDING锁的默认字节。RESERVEDBYTE宏设置为PENDINGBYTE之后的下一个字节，SHARED FIRST设置为PENDING BYTE之后的第个字节。所有锁字节将适合单个数据库页面，即使最小页面大小为512字节(见第84页上的第3.2节)。这些宏是在os.h源文件中定义的。[-3]获取这些锁的前提条件和步骤如下所示。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217105911.png" alt="Figure 4.3:File ofsets that are used to set POSlX locks"></p>
<h4 id="4261从sqlite锁到本机文件锁的转换">4.2.6.1从SQLite锁到本机文件锁的转换</h4>
<p>本小节描述SQLite如何设置数据库文件的锁。</p>
<ol>
<li>
<p>为了对数据库文件获取共享锁，一个进程首先在PENDING.BYTE上获取本地读锁，以确保没有其他进程对该文件持有PENDING锁。(您可能还记得第101页图4.1中的锁兼容性矩阵表，其中现有PENDING锁和新共锁是不兼容的。)如果此锁设置成功，则从SHARED FIRST字节开始的SHARED SIZE范围将被读锁，[-4]并最终释放PENDING BYTE上的读锁。</p>
</li>
<li>
<p>进程只有在获得了文件上的共享锁之后才能获得数据库文件上的保留锁。为了获得RESERVED锁，需要在RESERVED锁字节上获得写锁。您可能会注意到，进程不会释放文件上的共享锁。(这确保了另一个进程不能获得文件上的EXCLUSIVE锁。</p>
</li>
<li>
<p>一个进程只有在获得文件上的共享锁后，才能获取数据库文件的PENDING锁。要获取PENDING锁，需要在PENDING BYTE上获取写锁。(这确保了不能在文件上获取新的共享锁，但允许现有共享锁共存。)您可能会注意到，该进程没有释放其在文件上的共享锁。(这确保了另一个进程无法获取文件上的排他锁。</p>
<p><strong>注意:</strong> 在获取PENDING锁的过程中，进程不需要获取RESERVED锁。这个属性被SQLite用于在失败后将日志文件回滚。如果进程从共享到保留再到PENDING的路径，那么在设置PENDING锁时不会释放其他两个锁。</p>
</li>
<li>
<p>一个进程只有在获得文件上的挂起锁后才能获得数据库文件的独占锁。要获得独占锁，需要在整个“共享字节范围”上获得写锁。由于所有其他SOLite锁都需要在这个范围内的字节(至少一个)上获得读锁，这确保了当进程获得独占锁时，文件上不存在其他SOLite锁。(使用单个字节而不是“共享字节范围”的原因是因为某些版本的Windows不支持读锁。通过写锁定一个范围中的随机字节，即使使用的本机锁定基元始终是写锁定，也可能存在并发共享锁定。</p>
</li>
</ol>
<hr>
<p>[-3] 锁定Windows是强制性的；也就是说，对所有进程都强制执行锁，即使它们不是协作进程。锁定空间是由Windows操作系统预留的。由于这个原因，SQLite不能在锁定字节中存储实际数据。因此，分页器永远不会分配涉及锁定的页面。该页面也在其他平台中使用，以实现数据库的一致性和跨平台使用。PENDING BY&rsquo;E设置得很高，所以除了非常大的数据库之外，SQLite不需要分配未使用的页，在本书中它被称为锁字节页。</p>
<p>[-4]在某些Windows上，SHARED_SIZE范围内的随机字节被写锁定</p>
<p>        为了清楚地了解SQLite获取数据库文件原生锁的方式，原生锁状态转换在图4.4中进行了绘制。在图中，r-lock表示原生读锁，w-lock表示原生写锁。该图还揭示了SOLite锁和原生锁之间的关系。PENDING锁和EXCLUSIVE锁的表示有些别扭;根据SQLite设置这些锁的路线，它们可能在RESERVED BYTE上具有写锁或不具有写锁。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217111047.png" alt="Figure 4.4:Relationship between SQLite locks and native locks in Linux"></p>
<h4 id="4262-原生锁的工程问题">4.2.6.2 原生锁的工程问题</h4>
<p>上述定义的锁定方案中存在两个工程问题。第一个问题是由于Linux锁功能的特殊性引起的。第二个问题是 SOLite 特有的问题。数据库文件的本地锁由进程持有，而 SOLite锁由线程在进程地址空间内运行的事务持有(见4.5)。在图中，进程1有两个线程:线程1有一个事务，线程2通过三个不同的库连接持有同一数据库文件的两个事务。进程2有一个事务。(你可能记得，通过图书馆连接，一个进程可以在数据库上执行一个写事务和多个读事务同时进行。)在四个并发事务中，三个有共享锁，一个对数据库文件有保留锁。你可能注意到，事务对本地操作系统是不可见的，操作系统只看到进程和线程。我们需要一个机制，将事务持有的 SOLite 锁映射到进程持有的本地锁。如果一个进程只打开一次数据库文件，那么该进程和事务是同义词，没有问题(如图4.5中的进程2所示)。当进程打开多个并发事务，这些事务可能通过不同的库连接访问同一数据库文件时，就会出现问题，如图中进程1所示。进程1对数据库文件的三次事务持有哪些本地锁，当一次事务完成时会发生什么?我将在接下来的两个子小节中讨论这两个问题。唯一的好消息是，一个图书馆连接最多只能有一个打开的写事务，并且事务只打开一次数据库文件。(我的意思是，一个进程为了执行事务，会为事务打开一次数据库文件;但是，进程可以为其他事务打开同一个数据库文件
o
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241217111333.png" alt="Figure 4.5:Transaction to process assignment"></p>
<h4 id="4263-linux系统的问题">4.2.6.3 Linux系统的问题</h4>
<p>SQLite使用POSIX建议锁定方案，并通过fcntlAPI函数获取和释放文件锁定。如前所述，锁定是内存中的对象。我想在这里指出的第一点是，Linux系统将锁定与文件inode(表示实际文件)关联，而不是与文件名关联。在Linux系统中，两个或多个文件名可以通过符号链接和硬链接用于相同的inode，这可能会对通过不同文件名设置/释放锁产生一些奇怪的后果。第二件要注意的事情是，尽管锁是由fcntl函数通过打开文件描述符设置和释放的，但它们之间没有关系。如果一个进程（多次打开同一个文件）通过两个打开的文件描述符设置或清除同一个文件区域上的锁，第二个锁操作将不知不觉地覆盖第一个锁操作，因为两个描述符都指向同一个文件索引节点（这两个操作可以来自进程中相同或两个不同的兄弟线程）。</p>
<p>        让我们通过一个例子来进一步澄清上述观点。假设文件1和文件2是两个实际上相同的文件(因为一个是另一个的硬链接或符号链接)。假设一个进程以以下方式打开这两个文件进行读写。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">int</span> fd1 = open(<span style="color:#009c00">&#34;flel&#34;</span>, ..);
<span style="color:#00f">int</span> fd2 = open(<span style="color:#009c00">&#34;fle2&#34;</span>, ·.·);
</code></pre></div><p>假设线程T1首先通过fd1在文件区域上设置一个读锁，然后T1或另一个线程T2尝试通过fd2获取同一文件区域上的写锁。由于两个锁请求都来自同一进程，且位于同一inode上的同一区域，因此线程获得了写锁(覆盖了读锁)，这意味着当一个进程两次(同时)打开同一数据库文件，以便在两个不同的事务中执行两个不同的操作时，两个打开的数据库连接上的活动可能会相互干扰，尽管这是无意的，因为一个进程最多只能在一个文件区域上拥有一个本地锁。这意味着我们不能盲目地使用本地锁来控制事务并发。也就是说，虽然我们可以使用本地锁在不同进程之间同步事务并发，但我们不能直接使用本地锁来同步在两个或多个不同库连接(在同一或不同线程中)打开同一数据库文件的进程对同一数据库文件的访问。</p>
<p>        因此，为了解决上述问题，SOLite需要在内部跟踪应用程序进程的所有打开的数据库文件描述符，并在实际尝试获取或释放文件区域的本地读写锁之前，在内部管理锁。这在一个抽象层中实现。每当SOLite打开一个数据库文件(对于线程)时，它会找到数据库文件的特定inode(inode由fstat()原生API函数填充的stat结构中的st dev设备号和st inoinode号字段确定)，并在内部检查该inode是否已被其所有者进程持有。如何做到这一点将在本分节的其余部分讨论。</p>
<p>        当要在数据库文件的索引节点上获取锁时，SQLite查看进程的内部锁记录，以查看它之前是否在同一索引节点上设置了锁。对于每个打开的文件（inode）， $QLite维护一条信息（unixInodeInfo类型的对象）来跟踪进程持有的inode上的锁（见图4.6，它描述了第108页图4.5中进程1的锁定状态）。unixInodeInfo对象封装了当前索引节点上的外部锁定状态。在图中，进程在两个线程中打开了三次给定的数据库文件。（将在下一小节中讨论微妙的多线程问题。）它们通过一个unixInodeInfo对象跟踪文件上的锁。一个unixInodeInfo对象表示数据库文件（即inode）上的一个SQLite锁实例。一个进程不能为同一个文件拥有两个或多个unixinodeinfo对象实例（如图4.6所示）。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217112014.png" alt="Figure 4.6:$QLite lock management structures"></p>
<p>        所有 unixInodelnfo 对象(适用于所有文件)都存储在一个双重链接的列表(全局inodeList)中。设备号和inode号组合使用作为搜索关键字来搜索列表。列表最初是空的。对象可按需创建和删除。列表由(全局)线程互斥器保护。</p>
<p>        unixInodeInfo对象保存一个引用计数（nRef）来跟踪进程打开了多少次相同的文件，也就是说，有多少数据库连接正在共享这个对象。unixInodeInfo对象的eFileLock成员变量表示进程当前在数据库文件上持有的最高（最强）锁模式：NOLOCK。SHAREDRESERVED、未决或排斥。（进程发起的某些事务持有数据库文件上的这个issqlite锁。）nShared成员变量表示内部锁状态，如果nShared为0，表示文件未被进程锁定；如果nShared大于0，表示文件未被进程锁定。当一个线程试图锁定或解锁一个文件时，SQLite首先检查相应的unixInodeInfo对象。只有当两个SQLite锁模式之间的内部锁状态转换被指示时，才调用fcntl系统调用来设置或释放文件上的本机（读或写）锁。例如，如果进程持有文件上的RESERVED锁，而线程请求文件上的SHARED锁，那么fleSQLite将增加unixInodeInfo对象的nShared成员变量。但是，如果线程请求一个EXCLUSIVE锁，$QLite调用fcntl来获得文件上的写锁。</p>
<p>        SOLite维护一个unixFile类型的对象来跟踪数据库文件的一个打开实例的锁定状态。如图4.6所示，每个打开的数据库都有一个unixFile对象。对象是数据库连接的同义词。独立于本机操作系统支持的打开文件描述符的文件打开。（不同的本地操作系统定义了不同的unixfile结构。）对数据库文件的所有操作都使用对象作为句柄来执行。组件为打开的文件存储操作系统创建的文件描述符。h值用作文件上的读写、关闭和设置/重置锁的引用。unixFile对象有一个指向unixInodeInfcob对象的指针，通过该指针获取数据库文件上的SQLite锁。unixFileobject的eFileLock字段表示通过该unixFileobject持有的数据库文件的当前SOLite锁模式，即。对于此连接到数据库文件。由于一个数据库文件连接最多可以有一个打开的（读或写）事务，因此对应的unixFile对象中的eFileLock表示该事务通过该连接在数据库文件上的SQLite锁类型。在同一个数据库上，线程1上的事务1持有一个共享锁，线程2上的事务2持有一个共享锁，线程2上的事务3持有一个保留锁</p>
<p>        如果同-inode 被任何线程中的进程打开两次或更多次，那么就会有多个 unixFile 对象，并且所有这些对象都共享同一个 unixInodelnfo 对象。这种情况在图 4.6 中显示为 Thread 2，它有两个事务。如前所述，所有unixInodelnfo 对象都存储在共享列表中。当一个线程尝试锁定或解锁数据库文件时，SOLite 首先检查列表中文件inode的unixInodelnfo 对象是否存在。如果未找到，SQLite在列表中创建一个新的unixInodeInfo 对象此时，nRef成员变量被设置为1。如果找到一个，则nRef变量增加1。当文件不再被进程使用(即，当nRef变为0)时，unixInodelnfo对象将从列表中删除并销毁。</p>
<h4 id="4264多线程应用程序">4.2.6.4多线程应用程序</h4>
<p>SOLite应用程序的多线程会在支持LinuxThreads的Linux系统中导致一些额外的问题。在LinuxThreads下，一个线程对某个线程的锁操作不会覆盖其他兄弟线程对同一文件的锁。只是，所有者线程可以操纵其锁。因此，LinuxThreads不兼容BOX，由于这个问题，从SOLite3.7.0版本开始，SOLite开发团队就停止支持LinuxThreads。相反，它们支持NPTL(Native Posix线程库)，其中兄弟线程可以重写彼此的锁。</p>
<p>        在关闭文件时存在一个复杂的问题。当一个文件描述符(对于inode)被关闭时，Linux 系统会释放当前进程拥有的与该inode相关的所有锁，而不管是通过哪个文件描述符获取这些锁的。为了解决这个问题，我们需要跟踪该 inode 上的所有打开的文件描述符，直到最后一个文件描述符被关闭，当一个线程尝试关闭一个 Unix文件时，如果在同-inode 上还有其他正在持有锁的 Unix 文件，那么关闭该文件的调用将被延迟，直到所有锁都被清除。这被称为懒惰文件关闭。懒惰关闭可能会导致有价值的文件描述符资源被保留;但是，SOLite开发团队没有另一种可行的替代方法。unixlnodelnfo对象保持需要关闭的文件描述符(pUnused)的列表。最后关闭文件的线程会关闭所有这些延迟的文件描述符。</p>
<p><strong>注意:</strong> 当应用程序再次打开文件时，pUnused中的文件描述符也可以被SOLite回收</p>
<h3 id="427锁定api">4.2.7锁定API</h3>
<p>锁管理器实现了两个API函数，即sqlite30sLock和sqlite30sUnlock，分别用于获取或升级和释放或降级数据库上的SQLite锁。在以下两个子小节中，我将它们以算法步骤的形式呈现。</p>
<h4 id="4271-sqlite30slock-api">4.2.7.1 sqlite30sLock API</h4>
<p>AP|函数的签名如下:intsqlite30sLock(unixFile*id，intlocktype)，其中id 是一个 SQLite fle描述符，请求 1ocktype的 SQLite锁。对于Unix，这是在os unix.c源文件中作为unixLock函数实现的。您可能会注意到锁类型值不能是等待的。此功能只能按以下顺序增加锁的强度:无锁、共享、保留、等待和排他。sqlite30sUnlockAPI函数用于降低锁定强度。大致上，以下步骤由salite30sLock函数执行。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217114055.png" alt="">
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217114133.png" alt=""></p>
<h4 id="4272-sqlite30sunlock-apl">4.2.7.2 sqlite30sUnlock APl</h4>
<p>API 函数的签名如下:int sqlite30sUnlock(unixFile*id，intlocktype)，其中 id 是-个 SOLite fle 描述符，请求 locktype的 SOLite 锁。对于 Unix,这将被转换为os unix.c源文件中的posixUnlock函数。您可能会注意到锁类型只能是无锁或共享锁。为了增加当前锁的强度，我们需要使用sqlite30sLockAPI函数。以下步骤由sqlite30sUnlock函数执行。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217114336.png" alt=""></p>
<p>        日志是恢复信息的存储库，用于在中止事务、事务或语句子事务时恢复数据库，也用于在应用程序、系统或电源故障后恢复数据库。SQLite对每个数据库使用一个日志文件。（它不使用内存数据库的日志文件），它只保证事务的回滚（撤销，而不是重做），日志文件通常被称为回滚日志。日志文件总是与数据库文件位于相同的目录中，并且具有相同的名称，但附加了‘-journal ’。</p>
<p>        <strong>暂态日志vs日志保留：</strong> SOlite一次最多允许一个数据库文件写事务。在默认的操作模式下，它为每个写事务创建日志文件，并在事务完成时删除该文件。您可以通过日志模式pragma更改此行为，以截断，保留（但使标题无效），内存或关闭。使用memoryoption时，日志完全驻留在内存中，使用off选项时，不执行日志记录。我在249页的10.17节中谈到了日志记录。</p>
<p>        当前write- transaction中的更新操作（SQL插入、删除和更新）产生的日志记录被写入日志文件。当事务想要更改数据库文件时，SQLite在回滚日志中写入足够的信息，以便在需要时将数据库恢复到事务开始时的状态。数据库社区有许多已知的日志记录方案；它们取决于日志记录中存储的redo/undo信息。$QLite使用了所有已知类型中最简单的，但效率较低的。它在页面级粒度上使用旧的值日志技术，（SOLite在恢复数据库时不实现重做逻辑）。因此，它不会在日志记录中保存新值。)因此，在事务第一次修改数据库文件的任何页面之前，sqlite将整个页面的原始内容及其页码写入回滚日志。作为新稳定日志记录的一部分。（见第92页图3.8）</p>
<p>        一旦页面映像被复制到回滚日志中，该页将永远不会出现在新的日志记录中——即使当前事务多次更改该页。这种页面级undo日志的一个很好的特性是，可以通过盲目地将日志文件中的内容复制到数据库文件中来恢复页面，并且撤销操作是幂等的。undo操作的执行不产生任何补偿日志记录。$QLite不会在日志中保存由事务新添加（即追加）到数据库文件的页面，因为该页没有旧值。相反，日志文件在创建日志文件时，会在journalsegment头记录中记录数据库文件的初始大小（参见第91页的图3.7）。如果数据库被事务扩展，则文件可以在回滚时被截断回其原始大小。</p>
<p><strong>Journaled Page Tracking:SQLite</strong> 使用内存中的位映射数据结构来跟踪当前事务记录的页面。内存空间开销与事务更新的页面数量成正比。对于小事务，内存开销可以忽略不计。</p>
<p><strong>Log Optimization:</strong> 您可能还记得，自由列表“叶子”页面内容被视为垃圾。当重用这样的页面时，不会记录该页的日志，因为它没有任何有用的信息。</p>
<p>        如果一个事务处理和修改多个数据库（您可能还记得，通过执行ATTACH命令可以将多个数据库关联到一个库连接），则每个数据库都有自己的回滚日志，它们是独立的回滚日志，并且一个数据库不知道其他数据库。为了弥补这一差距，SQLite还维护了一个单独的aggregatejournal，称为主日志。主日志文件始终与主数据库文件位于相同的目录中，并且具有相同的名称，但在其后面附加‘-mi’。它是一个临时文件，它是由8个随机选择的4位十六进制数字创建的。事务尝试提交，并在提交处理完成时删除。它本身不包含任何用于回滚目的的日志记录。相反，它包含参与事务的所有单个回滚日志的名称，单个回滚日志的Bach还包含主日志的名称（参见第94页的图3.9）。如果没有附加的数据库（或者没有任何附加的数据库参与当前事务进行更新），则不会创建主日志，并且正常的回滚日志不包含有关主日志的任何信息。在本节的其余部分，我将讨论日志和提交协议</p>
<p><strong>No Database Aliasing:</strong> 不能对数据库文件使用不同的名称（硬链接或软链接）。如果不同的应用程序使用不同的名称，同一数据库将有不同的日志文件，具有不同的回滚和主日志名称，应用程序将错过彼此的日志文件，导致损坏的数据库文件。此外，您不应该重命名数据库文件而不重命名相应的日志文件。但是，如果日志是从主日志引用的，则仍然存在风险。你太严厉了
警告!</p>
<h3 id="431-logging-protocol">4.3.1 Logging protocol</h3>
<p>SOLite遵循写前日志(WAL)协议，以确保在应用程序、系统或电源故障发生时数据库的可恢复性。SOLite实现预图像日志，即它将数据库页(即将被修改)的原始未修改副本首先写入日志文件，然后再更改数据库文件中的页。在日志文件中写入日志记录是懒惰的:SQLite不会立即将它们刷到磁盘表面。但是，在写入数据库文件中的下一页(任何一页)之前，它会强制将所有日志记录写入磁盘。这被称为刷新日志。刷新日志是为了确保已写入日志的所有日志记录实际上都到达了磁盘表面。(如果本地操作系统的刷新操作不以这种方式工作，SQLite最终可能会损坏数据库。)在日志被刷新且日志内容成为持久性之前，就地修改数据库文件是不安全的。如果在日志被刷新之前对数据库进行修改，并且发生电源故障，未刷新的日志记录将丢失，SQLite将无法从数据库中完全回滚事务的影响，从而导致数据库损坏。</p>
<h3 id="432-commit-protocol">4.3.2 Commit protocol</h3>
<p>默认的提交逻辑既包括提交时刷新日志，也包括提交时刷新数据库。当应用程序提交事务时，SOLite确保回滚日志中的所有日志记录都在磁盘上。在提交结束时，回滚日志文件被最终化(即，根据操作式删除、截断或无效，事务完成。如果在达到该点之前系统失败，则事务提交失败，当数据库下次读取时将被回滚。然而，在最终确定回滚日志文件之前，所有对数据库文件的更改都会被写入磁盘。这样做是为了确保在日志最终确定之前，数据库已经接收到来自事务的所有更新。这是必要的，因为从SOLite3.7.8开始，在遗留/回滚日志模式中，SOLite没有重做逻辑。</p>
<p><strong>Asynchronous Transaction and Lazy Commit:</strong> 默认情况下，事务是同步的。sqlitessection 4.3.1)和提交协议（见Section 4.3.2）来处理这些事务。虽然不推荐使用，但SQLite也允许应用程序以延迟提交模式运行事务。这些被称为异步事务。它可以通过将同步编译变量设置为零来实现（参见第226页第10.1节）。对于异步事务，SQLite不会在提交或其他时间执行日志或数据库刷新。因此，数据库的写和提交都非常快。但是，当然存在风险，一旦发生故障，数据库可能无法恢复到一致状态（因为日志中丢失了日志记录）并损坏。异步事务开发人员已经收到警告！对于临时数据库，默认是异步的，因为我们不需要也不关心这些数据库的故障。</p>
<h2 id="44-subtransaction-management">4.4 Subtransaction Management</h2>
<p>一个语句子事务通过主用户事务获取锁。所有锁由该事务持有，直到它提交或取消。但是，SOLite使用一个单独的日志文件来存储语句子事务产生的日志记录。语句日志是一个临时文件，对于从事务取消的恢复或应用程序、系统和电源故障都不需要。SQLite在语句日志中写入一些日志记录，同时在主回滚日志中写入一些日志记录。只有当语句子事务执行开始之前主回滚日志中已写入相应页面或由先前子事务添加该页面时，才会在语句日志中写入日志记录。 SOLite从不将语句日志内容冲洗到磁盘，因为故障恢复不需要这些内容。</p>
<h2 id="summary">Summary</h2>
<p>        SQLite 在用户或系统事务中执行每个 SQL语句。默认操作模式是自动提交。在这种模式下，SQLite 创建一个读事务来执行SELECT语句，以及一个写事务来执行非 SELECT(即，插入、删除或更新)语句。在语句执行结束时，事务被提交或取消。</p>
<p>        应用程序通过执行开始命令创建用户事务来覆盖默认的自动提交模式。连续的未选择 SOL语句执行成为用户事务的一部分，直到应用程序提交或中止事务。在这一点上，SQLite会恢复到自动提交模式。SQLite还支持用户事务中的保存点。事务可以设置多个保存点，并将数据库状态恢复到任何保存点，然后从那里继续执行。在用户事务中，更新语句在子事务中依次执行。这些子事务通过匿名保存点执行。</p>
<p>        SQLite使用基于锁的并发控制机制来确保事务的可序列化执行。它使用数据库级锁定，也就是说，它在整个数据库上设置锁，并且没有细粒度锁。SQLite定义了五种锁类型：无锁、共享、独占、保留和挂起。（这些锁是在数据库文件的不同字节上使用本机读和写锁实现的。）读事务从nolock移到共享锁，然后再移回nolock。写事务从nolock到共享锁，再到保留锁，再到挂起锁，再到排他锁，然后再回到nolock。当数据库需要通过回滚日志文件来恢复时，这个锁转换是从nolock到共享锁，再到挂起锁，再到排他锁，再回到共享锁</p>
<p>        当一个应用程序通过执行开始事务命令来打开用户事务时，该事务在此时不会对数据库持有任何锁定。锁定获取被推迟到实际需要时。开始命令有两种变体，即开始独占和开始立即。在成功执行开始独占(或立即)命令后，SQLite立即在所有数据库(主数据库和附加数据库)上设置独占(或保留)锁定。</p>
<p>        SOLite实现了一种基于日志的日志方案，用于在事务中断、进程崩溃或系统/电源故障时恢复数据库。在这种情况下，SOLite通过一些简单的撤销操作从数据库中撤销事务的影响。当事务修改页面(第一次)时，SOLite将(整个)页面的旧值记录在撤销日志中。在从数据库中撤销事务的影响时，恢复旧页面映像。(恢复操作是幂等的。)在恢复过程的末尾，数据库文件被截断到事务开始时的大小;这是为了消除由事务添加的所有页面。为了执行“多数据库事务”，SOLite使用主日志(除了所有单独的回滚日志)来保存有关参与事务的数据库的信息;此外，每个单独的回滚日志都包含指向主日志的记录。</p>
<p>        在下一章中，我将介绍SQLite世界中名为Pager的事务管理器的内部工作。这里介绍的一些概念将在这里重复，以便使本章内容完整。</p>
<h1 id="第五章-pager-module">第五章 Pager Module</h1>
<p>阅读本章后，你应该能够解释/描述:</p>
<ul>
<li>什么是页面缓存，为什么需要它，以及谁在使用它</li>
<li>通用缓存管理技术</li>
<li>由SOLite执行的正常事务处理和恢复处理步骤</li>
</ul>
<p><strong>章节概要</strong></p>
<p>文件之上实现了，本章讨论了寻呼模块。该模块在普通的本地(字节导向)其中数据项是固定个面向页的数据库文件系统的抽象。它作为数据管理器，大小的页，并定义了一个从数据库文件中访问页的接口。它通过为数据库页面提供内存缓存来帮助树模块加速对数据库页的访问。它管理页面缓存，也是事务管理器，通过负责并发控制和故障恢复来实现事务的ACID属性。它使并发控制和恢复对树形和更高层次的模块完全透明。它也是锁和日志管理器。实质上，它实现了普通数据库管理系统的持久层。</p>
<h2 id="51-the-pager-module">5.1 The Pager Module</h2>
<p>        数据库（内存中的数据库除外）通常以普通本地文件的形式驻留在外部存储设备（如磁盘）上，SOLite不能有效地访问和操作磁盘上的数据。当它需要一个数据项时，它从数据库文件中将其读入主内存，操作内存，如果需要，将其写回数据库文件。通常，与可用的主内存相比，数据库非常大。只有一部分内存被保留来保存来自数据库文件的一小部分数据。这些预留的内存空间通常被称为数据库缓存或数据缓冲区；在SQLite术语中，它被称为页面缓存。缓存驻留在应用程序进程地址空间中，而不是操作系统空间中。(操作系统有自己的数据缓存。</p>
<p>        页面缓存管理器在SQLite中称为分页器。它查看随机访问的面向字节的普通本机文件，并将它们转换为随机访问的更高级别面向页面的文件，其中页面是由本机文件构建的固定大小的对象。不同的高级文件可以有不同的页面大小。分页器定义了一个“易于使用”（独立于原生文件系统）的接口，用于从数据库文件访问页面。直接位于pager模块顶部的tree模块总是使用pager提供的接口来访问数据库，从不直接访问任何数据库或日志文件。前者（树模块）通过提供页和引用页的数组indexnumber，将数据库视为（统一大小的）页和引用页的逻辑数组。</p>
<p>        SOLite为每个打开的数据库文件（也就是数据库连接）维护一个单独的页面缓存。当一个应用程序进程打开一个数据库文件时，分页器为这个文件创建并初始化一个新的页面缓存。如果进程打开同一个数据库文件两次或两次以上，在默认模式下，page会为这个文件创建并初始化这些单独的页面缓存（SQLite支持一个高级特性，即所有数据库连接到同一个数据库文件可以共享文件的相同页面缓存，该文件通过相同或不同的库连接多次打开，参见第10.13节）。内存数据库不引用任何外部存储设备：但是，它们也像普通的本机文件一样被处理，并且完全存储在缓存中。因此，树模块使用相同的接口来访问任意一种类型的数据库。</p>
<p>        分页器是SQLite中最底层的模块。它是唯一使用本地操作系统支持的I/0 api访问nativedatabase和iournal文件的模块。它直接读取和写入数据库文件（和日志文件）。它不理解数据库中的数据项是如何组织的，它既不解释数据库的内容，也不修改自己的内容。它只保证存储在数据库文件中的任何信息都可以在以后不做任何更改的情况下重复检索。从这个意义上说，寻呼机是一个被动的实体。（虽然它可能会修改数据库文件头记录中的一些信息，例如文件更改计数器。）它采用了通常的随机访问面向字节的文件系统，并将其抽象为一个基于随机访问页的文件系统，用于处理数据库文件。它定义了一个易于使用的、独立于系统的接口，用于从数据库文件中随机访问页面。</p>
<p>        对于每个数据库文件，在文件和（内存中的）缓存之间移动页面是分页器作为缓存管理器的基本功能。页面移动对树和上层模块是透明的，分页器是本地文件系统和上层模块之间的中介。它的主要目的是使数据库页在主存中可寻址，以便这些模块可以直接访问内存中的页内容。它还将写页面协调回数据库文件。它创建了一个抽象，使整个数据库文件看起来作为页面数组驻留在主内存中。这两个模块通过定义良好的页面访问协议一起工作。</p>
<p>        除了缓存管理工作外，分页器还实现了非典型数据库管理系统（DBMS）的许多其他功能。它提供了典型事务处理系统的核心服务：事务管理、数据管理、日志管理和时钟管理。作为事务管理器，它通过负责并发控制和恢复来实现事务性ACID属性，它负责事务的原子提交和回滚。作为数据管理器，它与缓存协调数据库文件中页面的读写，并进行文件空间管理工作；作为日志管理器，它决定日志记录在日志文件中的写入；作为锁管理器，它确保事务在访问数据库页面之前对数据库文件有适当的锁。从本质上说。对等模块实现存储持久性和事务原子性。寻呼机所有子模块之间的相互关系如图5.1所示。</p>
<p><img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217141609.png" alt="Figure 5.1:Interconnection of pager submodules."></p>
<h2 id="52-pager-interface">5.2 Pager Interface</h2>
<p>在本节中，我将介绍由分页模块公开的一些接口函数，树模块使用这些接口函数来访问数据库。在此之前，我首先讨论分页器和树模块之间的交互协议。</p>
<h3 id="521-pager-client-interaction-protoco">5.2.1 Pager-client interaction protoco)</h3>
<p>分页器上面的所有模块都与低级锁和日志管理机制完全隔离。实际上，它们并不知道锁定和日志记录活动。树模块从事务的角度看待一切，而不关心事务性ACID属性是如何由分页模块实现的。分页模块将事务的活动分为时钟、日志记录和数据库文件的读写。tree模块根据页码从寻呼机请求页面。反过来，分页器返回一个指向加载到页缓存中的页数据的指针。在修改页面之前，树模块通知分页器，以便它（分页器）可以保存足够的信息（在日志文件中）以备将来恢复时使用，并且可以获得数据库文件上的适当锁。tree模块最终会在它（tree模块）使用页面完成时通知寻呼者；如果页面被修改，分页器处理将页面写回数据库的操作。</p>
<h3 id="522-the-pager-interface-structure">5.2.2 The pager interface structure</h3>
<p>分页模块实现了一个名为pager的数据结构。每个打开的数据库文件都是通过一个单独的Pager对象来管理的（见图5.2），每个Pager对象都与一个且只有一个打开的数据库文件实例相关联。（在分页模块级别，对象是数据库文件的同义词。）为了使用数据库文件，tree模块首先创建一个新的Pager对象，然后使用该对象作为句柄在文件上应用所有分页级操作。分页模块使用句柄来跟踪文件锁、日志文件、数据库状态、日志状态等信息。您可能会注意到，一个进程可以为同一个数据库文件拥有多个Pager对象，每个连接一个到该文件；对象被视为独立的。而且彼此没有关系。（对于共享缓存模式的操作，每个数据库文件只有一个epager对象，由所有数据库连接共享。）也可以使用Pager对象作为句柄访问内存数据库。</p>
<p>        Pager对象的一些组件成员变量如图5.3所示。成员变量的用途将在图中讨论。如图所示，紧跟在Pager对象之后的是可变数量的内存空间，用于存储各种处理程序，例如页面缓存、数据库文件、日志文件、数据库文件名称和日志文件名。（我已经在第108页的4.2.6.3节和110页的图4.6中讨论过数据库文件句柄（Linux的unixFile）。）</p>
<p>        如前所述，SOLite在用户事务中执行每次更新(即：（SQL插入、删除或更新）保存点中的操作。应用程序还可以设置自己的保存点。可以同时有多个保存点，如图5.3中的保存点数组所示。：创建一个保存点，它将iHdrOffset设置为0。但是，如果它打开回滚日志并在保存点处于活动状态时写入（新的）段头记录，它将ildrOfset设置为紧跟在回滚日志中最后一个日志记录之后的字节偏移量，该日志记录位于段头之前。ioffset被设置为创建PagerSavepoint对象时回滚日志中的起始偏移量。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217142324.png" alt="Figure 5.2:Pager interface with a database fle."></p>
<h3 id="523-the-pager-interface-functions">5.2.3 The pager interface functions</h3>
<p>pager模块实现了一组接口函数（由树模块使用）。下面将简要讨论一些重要的接口函数（这些函数的描述将给你一些提示信息，这些信息对阅读本章的其余部分很有价值）。还有许多其他类似的函数。所有函数名的前缀都是salite3Pager， Thevare在page .c源文件中定义。它们严格地属于SQLite内部，SQLite应用程序开发人员不能在他们的应用程序中使用它们。</p>
<ol>
<li>sqlite3PagerOpen：这个函数创建一个新的Pager对象，打开一个给定的数据库文件。创建并初始化一个空页缓存，并返回指向Pager对象的指针。根据数据库文件的名称，它创建和/或打开一个适当的文件（参见第81页的3.1节）。数据库文件此时未被锁定；没有创建日志文件，也没有执行数据库恢复操作。(您可能会注意到，$QLite会延迟恢复，直到实际从数据库文件中读取页面。</li>
<li>salite3PagerClose：这个函数销毁一个Pager对象并关闭相关的opendatabase文件。如果是临时文件，寻呼机将删除该文件。如果该例程不是临时文件，并且在调用该例程时该文件上的事务正在进行中，则强制立即中止该事务，并从数据库文件回滚其更改。所有未完成的缓存页都无效，并且释放它们的内存（即从进程地址空间释放）。在此函数返回后，任何试图使用与此缓存关联的页面的尝试都可能导致coredump。（实际上，分配给pager对象的所有资源都被释放，包括对象本身。）
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241217142635.png" alt="Figure 5.3: The Pager structure."></li>
<li>sqlite3PagerGet：这个函数为调用者（也就是树模块）提供一个数据库页面的内存副本。调用方通过页码指定所需的页面。这个函数返回一个指向页面缓存副本的指针。为了不回收缓存空间，它固定了页面副本。它在第一次调用时获取数据库文件上的共享锁。（如果无法获得锁，它将返回SQLITE BUSY给调用者。）此时，它决定是否清除现有的页面缓存，如果数据库文件更改计数器（文件头偏移量24处的4字节整数）与先前访问缓存时不同，则清除缓存。此外，如果有需要（在存在热日志文件的情况下），可以从日志中恢复数据库。(我讨论热门新闻。和数据库恢复（见第146页的5.4.2.4节）。如果页面不存在，则该函数将所需的页面加载到缓存中。但是，如果数据库文件小于请求的页面，则不执行实际的文件读取，并且将页面的内存映像初始化为全零。(内存数据库没有文件访问。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217142820.png" alt="Figure 5.4:The PagerSavepoint structure."></li>
<li>sqlite3PagerWrite：这个函数使所请求的数据库页面对于调用来说是可写的（但是不把页面写到数据库文件中）。它必须在一个页面上被调用，在它的缓存图像被树模块改变之前，否则分页器可能不知道缓存的页面被改变了。（您可能会注意到，出于性能考虑，SQLite避免在分页器和树模块之间来回作用域页面，而树模块直接操作缓存页面中可用的内容。）如果在之前的某个函数调用中没有这样做，则分页器将获取数据库文件上的保留锁并创建回滚日志。也就是说，它创建了一个隐式写事务。（如果无法获得锁，它将返回SOLITE BUSY给调用者。）如果页面还不是日志记录的一部分，它会将页面的原始内容复制到回滚日志中。如果原始页面内容已经被写入回滚日志，这个函数除了将页面标记为脏之外是无操作的。如果当前查询处理发生在用户事务中，并且该页已经在主回滚日志中或者该页是由上一个语句子事务添加的，这个函数也可以在语句日志中写入语句日志记录。</li>
<li>sqlite3PagerLookup：如果被请求的数据库页面在缓存中，这个函数返回一个指向缓存内副本的指针。如果页面不在缓存中，则返回turnsnull。如果是前一种情况，则锁定页面。</li>
<li>sqlite3PagerRef：这个函数将页面上的引用计数加1。我们说这个页面被打电话的人固定住了。如果页面在缓存的自由列表中，该函数将从列表中删除该页。</li>
<li>sqlite3PagerUnref：这个函数将页面上的引用计数减1。当计数达到零时，该页被称为解除固定并被释放。（释放的页面可能仍然作为缓存的自由列表的一部分保存在缓存中。）当所有页面都被解除固定（即，在最后一次调用该函数时）时，数据库文件上的共享锁被释放，Pager对象被重置。</li>
<li>sqlite3PagerBegin：该函数在关联的数据库文件上启动显式写事务。如果数据库不是临时文件，它还打开回滚日志文件。（对于临时文件，日志文件的打开被推迟，直到有实际需要写入日志文件，）你可能会注意到一个隐式写事务是由ysqlite3pagerwrite启动的。因此，如果数据库已经预留用于写入，则此例程是无操作的。否则，它首先获得数据库文件上的保留锁，如果在输入参数中指出，那么它立即获得文件上的排他锁，而不是等到树模块试图写入数据库文件。</li>
<li>sqlite3PagerCommitPhase0ne：这个函数在数据库文件上提交当前事务：将内存更改计数器元数据加1，同步日志文件，同步所有更改（也就是从页面缓存中的脏页面）到数据库文件。</li>
<li>salite3PagerCommitPhaseTwo：这个函数结束（即，删除，无效或截断日志文件）。</li>
<li>sqlite3PagerRollback：这个函数终止数据库文件上的当前事务。回滚事务对数据库文件所做的所有更改，并将独占锁降级为共享锁，所有缓存内页面恢复为原始数据内容。日志文件已完成，此例程不能失败。</li>
<li>sqlite3PagerOpenSavepoint：这个函数创建一个新的保存点处理程序对象，为当前数据库状态建立一个保存点。</li>
<li>sqlite3PagerSavepoint：这个函数释放或回滚一个保存点。对于releaseoperation，它释放并销毁一个特定的保存点处理程序对象。对于回滚操作，它回滚自建立保存点以来对数据库所做的所有更改。并删除以下所有保存点</li>
</ol>
<h2 id="53-page-cache">5.3 Page Cache</h2>
<p>页面缓存驻留在应用程序进程的地址空间中。您可能会注意到，相同的页面可能由本机操作系统缓存。当应用程序从任何文件（驻留在块专用设备上）读取数据时，操作系统通常首先生成自己的数据副本，然后在应用程序中生成副本。我们对操作系统如何管理自己的缓存不感兴趣。SQLite的页面缓存组织和管理是独立于本地操作系统的。图5.5描述了一个典型的场景。在图中，两个进程（一个是多线程进程）访问同一个数据库文件。他们有自己的伤痛。即使一个线程打开同一个数据库文件两次或多次，在默认的操作模式下，SQLite也会为打开的数据库连接分配单独的缓存。这些缓存可以通过它们不同的所有者Pager对象来访问。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217143836.png" alt="Figure 5.5:A typical scenario where two processes read the same database flc"></p>
<h3 id="531-cache-state">5.3.1 Cache state</h3>
<p>页面缓存的状态（以及相应的所有者Pager对象的状态，参见第126页上的图5.3）决定了分页模块可以对缓存做什么。两个成员变量，即eState和eLock，控制寻呼机行为。页面缓存（和分页器）作为一个整体始终处于以下七种状态之一（pager . estate成员变量的值）。状态转换图如图5.6所示。</p>
<ol>
<li>PAGER_OPEN：当创建Pager对象时，这是初始状态。分页器当前没有通过这个pager对象读写数据库文件。内存中可能没有任何数据库页，也就是说，缓存是空的。数据库文件可能被锁定，也可能没有被锁定。数据库上没有打开的事务。</li>
<li>PAGER_READER：当一个Pager对象处于这种状态时，至少有一个读事务操作在数据库连接上，并且该Pager可以从相应的数据库中读取页面。(但是，在exclusive locking_mode下，读事务可能不会打开。</li>
<li>PAGER WRITER LOCKED：当一个PAGER对象处于这种状态时，一个写事务在数据库连接上打开。分页器可以从相应的数据库文件中读取页面，但它没有对缓存的页面或数据库文件进行任何更新。</li>
<li>PAGER_WRITER_CACHEMOD：当一个Pager对象处于这种状态时，该Pager已经授予了树模块更新缓存内页面的权限，并且树模块可能已经进行了一些更新。</li>
<li>PAGER_WRITER DBMOD：当Pager对象处于这种状态时，表示该Pager已经开始写入数据库文件。</li>
<li>PAGER WRITER FINISHED：当一个PAGER对象处于这种状态时，表示该PAGER对象已经完成了将当前写事务中所有修改过的页面写到数据库文件中的工作。写事务不能再进行任何更新，并准备提交。</li>
<li>PAGER_ERROR：当一个Pager对象处于这种状态时，该Pager已经看到了一些错误，例如无法执行I/O，没有可用的磁盘空间用于数据库或日志文件，不能分配ncmemory等。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241217144624.png" alt="Figure 5.6:Pager state transition diagram."></li>
</ol>
<p>根据eLock成员变量的值，Pager对象可以处于以下四种状态之一</p>
<ol>
<li>NO LOCK：分页器当前没有通过该Pagerobject读写数据库文件。</li>
<li>SHARED LOCK：分页器一直在从数据库中读取页（以任意顺序）。可以有多个读事务通过各自的Pager对象同时访问同一个数据库文件。不允许修改缓存内页面。</li>
<li>RESERVED_LOCK：分页器为写入保留了数据库文件，但尚未对该文件进行任何更改。一次只能有一个分页器可以保留给定的数据库文件。由于原始数据库文件未被修改，因此允许其他寻呼机读取该文件。</li>
<li>EXCLUSIVE LOCK：该分页已经将页面（以任意顺序）写回数据库文件，该文件访问是排他的，当该分页继续写文件时，没有其他分页可以读写该文件。</li>
</ol>
<p>页面缓存出现在NO_LOCK状态。当树模块第一次调用qlite3pagerget函数从数据库文件中读取任何页面时，分页器将转换到shashared LOCK状态。在tree模块通过执行sglite3pagerunrefunction释放所有页面之后，分页器将转回NO _LOCK状态。（此时，它可能不会清除页面缓存。）当树模块第一次在任何页面上调用sqlite3PagerWrite函数时，分页将转换到RESERVED LOCK状态。(你可能会注意到sqlite3PagerWrite函数只能在已经读取的页面上调用；这意味着分页在转换到RESERVED LOCK状态之前必须处于shared LOCK状态。)在实际将第一个（任何）页写入数据库之前，页切换到EXCLUSIVE LOCK状态。在执行sqlite3PagerRollback或sqlite3pagercommitphasttwo函数的过程中，页传呼会转回NO LOCK状态</p>
<p><strong>注意：</strong>
对于临时数据库和内存数据库，Pager。eLock总是被设置为EXCLUSIVE lock，因为它们不能被其他进程访问。</p>
<h3 id="532-cache-organization">5.3.2 Cache organization</h3>
<p>每个页面缓存都是通过一个PCache处理程序对象来管理的。page保存着对这个对象的引用（参见第126页的图5.3）。图5.7描述了一个PCache对象的几个成员变量。SQLite支持用户可以提供的可插拔缓存方案。它提供了自己的pluggablecache模块（在pcachel.c源文件中实现），我将在下面讨论这个模块。除非用户提供，否则这将成为默认的缓存管理器。PCache对象的最后一个组件，即PCache，持有对可插拔缓存模块对象的引用。</p>
<p>通常，为了加快搜索缓存的速度，当前保存在缓存中的项被很好地组织起来。缓存空间是用来存放数据项的。SQLite使用散列表来组织缓存的页面，并使用页面槽来保存表中的页面。缓存是完全关联的，即任何插槽都可以存储任何页面。哈希表最初是空的。随着对页的需求增加，分页器创建新的槽并将它们插入哈希表中。有一个最大限制（PCache . nmax值）或缓存可以拥有的插槽数量。主数据库和其他附加数据库的默认值是2000，临时数据库的默认值是500。（只要操作系统允许应用程序地址空间增长，内存数据库就没有这种限制。）
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241217145229.png" alt="Figure 5.7:The PCache structure."></p>
<p>        SQLite通过PgHdr类型的对象表示缓存中的每个页面。分页器理解这个对象，尽管可插拔缓存可以有自己的页头对象。图5.8描述了SQLite自己的可插拔缓存的布局，由一个PCache1对象表示。哈希表中的每个槽由PgHdr1类型的头对象表示。可插入组件理解这种类型，而分页器对它来说是不透明的。槽映像存储在PgHdr1对象的正前方；slot映像的大小由PCache1的值决定。szSize变量。slot映像保存PgHdr的一个对象、一个数据库页面映像和一个私有数据，tree模块使用这个私有数据来保存特定于页面的内存控制信息。(内存数据库没有日志。因此，它们的恢复信息记录在内存对象中。指向这些对象的指针仅供分页器使用。)这(additiona。存储在private部分之后：当分页器将页面带入或构造到cache中时，这些指针（如onpage）空间初始化为零。缓存中的所有页面都可以通过PCache1访问。apHash哈希数组；数组大小存储在PCache1中。变量，数组将根据需要调整大小。每个数组元素都指向一个槽的“桶”：每个桶中的槽被组织成一个无序的单链表。</p>
<p>        PgHdr对象只对分页模块可见，而对树和上层模块不可见。头文件有许多控制变量。pgno变量标识它所代表的数据库页面的页码。如果日志在将该页写入数据库文件之前需要刷新，则needSync flag为true。如果页面已被修改，并且新值尚未写入数据库文件，则脏标记为true。nRef变量是本页的引用计数。如果nRef值大于零，则该页处于活跃使用状态，我们说该页已被固定；否则，页面将被解除固定并释放。pDirtyNext和pDirtyPrevpointers用于将所有脏页面链接在一起。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241217145513.png" alt="Figure 5.8: Page cache"></p>
<p><strong>Cache Group:</strong> There is an option where SQLite puts all PCache1 objects in a single group. The cachescan recycle each other&rsquo;s unpinned pageslots when they are subjected to memory pressure.</p>
<h3 id="533-cache-read">5.3.3 Cache read</h3>
<p>您可能还记得，缓存不是直接可寻址的存储单元。缓存客户端不能通过提供缓存地址来引用单个缓存元素。实际上，它们可能不知道页面副本所在的缓存位置，也不知道它的缓存地址。缓存是一个内容可寻址的存储空间。它通过使用搜索键（在我们的示例中是页码）来引用。在缓存和数据库文件之间移动页面是分页器作为数据管理器的基本功能。它使用PCache1。通过缓存桶将页码转换为适当的缓存点的一个ash数组。最初，页面缓存是空的，但是页面会按需添加到缓存中。如前所述，要读取页面，客户端（即树模块）调用sqlite3PagerGet函数的页码。该函数对请求的页面P执行以下步骤。</p>
<ol>
<li>It searches the cache space.
<ul>
<li>它应用一个非常简单的哈希函数[-1]，在P上确定到apHash数组的索引：页码模取apHash数组的大小。</li>
<li>它使用到apHash数组的索引并获取哈希桶。</li>
<li>它通过追踪pNext指针来搜索存储桶。如果在那里找到P，我们就说发生了缓存命中。它固定页面（即增加PgHdr）。nRef值乘以1)，并将页面图像的基址返回给调用者。</li>
</ul>
</li>
<li>如果在缓存中没有找到P，则认为它是缓存缺失。该函数查找可用于加载所需页面的空闲插槽。(如果缓存没有达到PCache的最大限制nMax，它会创建一个新的空闲槽。</li>
<li>如果没有可用的或不能创建的空闲插槽，它将确定一个插槽，从该插槽中可以释放当前页面，以便将该插槽重新用于P，这称为受害插槽。（第135页第5.3.6节讨论了受害者的选择。）</li>
<li>如果受害者（或空闲槽）是脏的，它将页面写入数据库文件。遵循预写日志（write-ahead-log， WAL）协议，它也会对日志文件进行刷新。</li>
<li>两种情况。(a)如果P小于或等于当前文件中的最大页面，它从数据库文件中读取pageP到空闲槽，固定页面（即，它将PgHdr . nrefvalue设置为1），并将页面的地址返回给调用者。(b)如果P大于文件中当前的最大页面，它不读取该页，相反，它将该页初始化为零。在这两种情况下，无论是否从文件中读取该页，它也将底部私有部分初始化为零。它还设置PgHdr。nRef值为1。</li>
</ol>
<p>SQLite严格遵循按需获取策略，以保持页面获取逻辑非常简单。(SeeSection 5.3.5)。</p>
<p>        当缓存内页面的地址返回给客户端（也就是树模块）时，分页器并不知道客户端何时实际处理该页。SQLite对每个页面都遵循这个标准协议：客户端获取（又名，固定）页面，使用页面，然后释放（又名，解锁）页面。当页面地址返回给客户端时，该页面被锁定（PgHdr . nref大于零）。只有当客户端调用页面上的glite3pagerunref函数并且nRef变为零时，页面才会解除固定。固定页当前处于活动使用状态，缓存管理器无法回收它们。为了避免“缓存中的所有页面都被固定”的情况，$QLite需要缓存中的最小页面数，以便它总是有一些缓存插槽可以回收：最小值为10 （Lite 3.7.8版本）</p>
<hr>
<p>[-1]A hash function maps a larger set onto a smaller set</p>
<h3 id="534-cache-update">5.3.4 Cache update</h3>
<p>在获取页面后，客户端可以直接修改页面的内容，但是正如前面提到的，在进行任何修改之前，它必须调用页面上的sqlite3PagerWrite函数。阳离子。从调用返回后，客户端可以随时更新页面。</p>
<p>        当客户端第一次在页面上调用sqlite3PagerWrite函数时，分页器将页面的原始内容作为新日志记录的一部分写入回滚日志文件，并设置PgHdr . needsync标记。稍后，当日志记录被刷到磁盘表面时，分页器会清除needSync标记。（SQLite遵循WAL协议：在相应的needSync被清除之前，它不会将修改的pageback写入数据库文件。）每次在页面上调用glite3pagerwrite函数时，就会设置PgHdr .dirty标记；只有当分页器将页内容写回数据库文件时，才会清除该flag。由于分页器不知道客户端修改页面的时间，因此页面上的更新不会立即传播到数据库文件。因此，分页器遵循延迟写（也称为回写）页面更新策略。只有当分页器执行缓存刷新或有选择地回收脏页时，更新才会传播到数据库文件。</p>
<p><strong>注意：</strong> 事务对缓存页执行直接更新，缓存管理器对数据库文件执行延迟更新。直接缓存更新需要保存页面的旧值，以便在事务中止时恢复它们。延迟更新数据库文件会增加事务的内存使用。当内存使用超过上限时，缓存管理器执行缓存替换。</p>
<h3 id="535-cache-fetch-policy">5.3.5 Cache fetch policy</h3>
<p>缓存取策略决定何时将页放入缓存。按需取策略仅在客户端需要页面时才将页面放入缓存。你可能会注意到，在获取需求的过程中，客户端是停滞的，在从数据库文件中读取页面之前，它不能取得任何进展。许多缓存系统使用复杂的预取技术，提前将一些页面放入缓存，以减少延迟的频率。SOLite严格遵循按需取策略，并避免任何其他预取策略，以保持取逻辑非常简单，并检查SQLite库大小。此外，它每次从数据库文件中读取一个页面。</p>
<h3 id="536-cache-management">5.3.6 Cache management</h3>
<p>一般来说，页面缓存的大小是有限的，除非数据库非常小，否则它只能保存数据库中的少量页面。可能需要回收缓存空间，以便在不同时间保存来自数据库的不同页面。因此，必须非常小心地管理空间，才能从缓存中获得真正的性能。其基本思想是将缓存客户端立即需要的页面保存在缓存中。在设计缓存管理策略时，我们需要考虑三件事。(1)当缓存中有一个页面时，在数据库文件中也有一个该页面的主副本。当缓存副本更新时，主副本可能也需要更新，(2)对于不在缓存中的请求页面，主副本被引用，并且从主副本生成新的缓存副本。(3)如果缓存已满，又有一个新页面要放到缓存中，则调用替换算法从缓存中删除一些旧页面，为新页面腾出空间。</p>
<p>        由于缓存是一个有限大小的存储空间，我们将页面集合到少量的缓存槽中（见图5.9）。在图中，有26个母版页，我们需要通过回收槽将它们放入5个缓存槽中。因此，需要很好地管理空间，以便从缓存中获得真正的性能增益。缓存管理对于缓存性能和整个系统性能都非常关键。只要缓存中有可用的空闲槽用于新请求的页面，缓存管理器就不需要做任何艰苦的工作。当缓存满时，缓存管理变得很有挑战性。缓存管理器的职责是决定在缓存中保留哪些内容，以及当缓存满时将删除哪些内容。缓存的有效性是对在缓存中找到请求页面的频率的度量。我们需要一个命中率很高的缓存。因此，对于缓存替换，最关键的事情是确定要在缓存中保留哪些页面。如果决策不好，缓存会被非立即需要的、不重要的页面污染，现在讨论缓存替换。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241217153220.png" alt="Figure 5.9:A typical cache management scheme."></p>
<h4 id="5361-cache-replacement">5.3.6.1 Cache replacement</h4>
<p>缓存替换指的是当缓存满了，旧的页面被从缓存中移除为新页面腾出空间时发生的活动，正如第133页的5.3.3节所提到的，当请求的页面不在缓存中并且缓存中没有可用的空闲槽时。寻呼机占用了一个替换槽。选择受害者可能不是一个容易的决定，您可能还记得，页缓存是完全关联的，也就是说，任何插槽都适合新页。由于要考虑多个插槽进行替换，所选择的插槽由缓存替换策略决定。替换策略的主要目标是将这些页面保留在缓存中，这样就可以在不引用母版页的情况下从缓存中满足大部分请求，也就是说，缓存命中率应该非常高。如果缓存命中率很低，那么缓存就不值得用来加速页面访问。</p>
<p>        您可能会注意到，我们没有关于未来页面引用模式的知识。因此，缓存管理器必须根据一些启发式方法或有限的过去历史做出替换决策。因此，通常在实践中使用的替代方案偶尔会在选择受害者时犯错误，当受害者被客户立即召回时，这些替代方案很快就会失效。如果再次引用页p，并且在p被替换之后至少有一个缓存槽没有被引用，那么替换页p被认为是一个糟糕的选择。替换策略的目标是最大限度地减少错误和最大限度地缩短错误之间的时间。一个缓存替换策略与另一个缓存替换策略的不同之处在于如何选择替换的受害者槽。文献中提出了许多替代政策，并在各种情况下实施，先进先出，最近最少使用，最不经常使用。时钟方案在硬件和软件开发中广泛遵循缓存替换策略。sqlite使用一种最近最少使用（LRU）的替换方案。</p>
<h5 id="5362--lru-cache-replacement-scheme">5.3.6.2  LRU cache replacement scheme</h5>
<p>LRU是一种非常流行的替换政策。它及其变体已成功地应用于许多软硬件缓存开发领域。它利用了页面引用的时间局部性。（时间局部性是指在短时间内对同一页面的重复访问。）最近过去引用的局部性用于预测最近将来的引用，它的意思是，如果现在访问了一个页面，则假定该页面将很快再次访问。如果一个页面长时间未被访问，则假定该页面不会很快再次被访问。受害者是最久没有被接触过的人</p>
<h4 id="5363-sqlites-cache-replacement-scheme">5.3.6.3 SQLite&rsquo;s cache replacement scheme</h4>
<p>SQLite在逻辑队列中组织非活动页面。当分页被解除固定时，分页器将该页附加到队列的尾部。（队列尾部的页面始终是最近访问的页面，而队列头部的页面是过去访问得最远的页面。）受害者是从队列的头端选择的，但在纯IRU方案中可能并不总是队列上的头元素。SQLite尝试在队列的头部找到一个插槽，这样回收该插槽就不会涉及对日志文件进行刷新。(您可能还记得，按照WAL协议，在将脏页写入数据库文件之前，分页器会刷新日志文件。刷新是一个缓慢的操作，并且SQLite尝试尽可能长时间地延迟该操作，如果找到这样的受害者，那么队列上最前面的受害者将被回收。0 therwise。S（item）首先刷新日志文件，然后从队列中回收头槽。如果受害页面是脏的，则分页器在回收页面之前将该页写入数据库文件</p>
<h2 id="54-transaction-management">5.4 Transaction Management</h2>
<p>分页器也是SQLite中的事务管理器，它负责通过管理数据库文件上的锁和管理日志文件中的日志记录来确保transactionalACID属性。尽管SQLite锁管理器（在第4章中讨论）获取和释放文件上的锁，但分页器决定锁的模式以及获取和释放锁的时间。它遵循严格的两阶段锁定协议来生成可序列化的事务执行。它也决定了日志记录的内容，以及它们对日志文件的写入。</p>
<p>        像其他DBMS一样，SQLite的事务管理有两个组成部分：(1)正常处理和(2)恢复处理。在正常处理期间，分页器在日志文件中保存足够的恢复信息，并且在需要时使用保存的信息进行恢复处理。这两个处理组件的活动将在接下来的两个小节中介绍。事务管理的位和字节已经在前面的部分讨论过了。在这里，我以一种有凝聚力的方式巩固它们。</p>
<h3 id="541-normal-processing">5.4.1 Normal processing</h3>
<p>正常的处理包括从数据库文件中读取页面和将页面写入数据库文件，提交事务和语句子事务，以及设置和释放保存点。此外，作为正常处理工作的一部分，分页器选择性地回收页缓存槽或刷新页缓存。</p>
<h4 id="5411-read-operation">5.4.1.1 Read operation</h4>
<h2 id="要对数据库页面进行操作客户端也就是树模块需要对页码应用sqlite3pagerget函数客户端需要调用该函数即使该页面在数据库文件中不存在新页面将由分页器创建-如果在数据库文件上还没有获得共享锁或更强的锁则该函数将获得数据库文件上的共享锁如果无法获得共享锁-2则意味着其他事务持有不兼容的锁函数返回sqlite-busy错误码给调用者否则它执行读取缓存操作参见第533节并返回一个指向该页的指针如前所述缓存读取操作固定页面">要对数据库页面进行操作，客户端（也就是树模块）需要对页码应用sqlite3pagerget函数。客户端需要调用该函数，即使该页面在数据库文件中不存在：新页面将由分页器创建。 如果在数据库文件上还没有获得共享锁或更强的锁，则该函数将获得数据库文件上的共享锁如果无法获得共享锁，[-2]则意味着其他事务持有不兼容的锁，函数返回SQLITE BUSY错误码给调用者。否则，它执行读取缓存操作（参见第5.3.3节），并返回一个指向该页的指针。如前所述，缓存读取操作固定页面。</h2>
<p>[-2]当分页器第一次获得共享锁时，我们说它已经启动了一个隐式锁。</p>
<p>        你可能还记得第133页的图5.8，每个内存中的页面图像后面都有一个私有空间块。这个额外的空间总是在页面第一次从数据库文件（或创建并初始化）加载到主内存时初始化为零。这个空间稍后由tree模块重新初始化。</p>
<p>        您可能还记得，当分页器第一次获得数据库文件上的共享锁时，它会确定该文件是否需要恢复。它查找相应的日志文件是否存在。（我将在第146页的5.4.2.4节中讨论热日志和故障恢复的确定。）如果热日志文件确实存在，这意味着在数据库上的前一个事务执行过程中出现了失败，分页器回滚失败的事务并在从sqlite3PagerGet函数返回给调用者之前结束（即删除、截断或无效）日志文件。</p>
<p>        如前所述，请求的页面可能不在页面缓存中。在这种情况下，pager找到一个空闲的缓存槽，并以用户透明的方式从数据库文件中读取页面，获得一个空闲的缓存槽可能会导致一个（受害者）页面写入数据库文件，也就是说，需要一个cacheAush（参见章节5.4.1.3）。</p>
<h4 id="5412-write-operation">5.4.1.2 Write operation</h4>
<p>在修改页面之前，客户端（也就是树模块）必须已经固定了页面（通过在页面上应用sqlite3PagerGet函数）。它在页面上应用sqlite3PagerWritefunction，使页面可写。一旦页面变得可写，客户端就可以在不通知分页器的情况下更新页面。写页面不会导致缓存刷新。不过，分页器可能需要获取数据库上的保留锁。第一次在（任何）页上调用sqlite3PagerWrite函数时，该页获取数据库文件上的保留锁。保留锁表示在不久的将来写入数据库的意图。一次只有一个事务可以持有保留锁。如果分页器无法获得锁，则意味着另一个事务已经对该文件具有保留的或更强的锁。在这种情况下，写尝试失败，寻呼机返回$QLITE BUSY错误码给调用者。</p>
<p>        当分页器第一次获得预留锁时，我们说它将读事务升级为写事务。（您可能会注意到，这是系统事务或用户事务。）此时，分页器创建并打开回滚日志。（回滚日志创建在数据库文件所在的同一目录中，并且具有相同的名称，但附加了‘-journal ’。）初始化第一个段头记录（参见第91页的图3.7），记下该记录中数据库文件的原始大小，并将该记录写入日志文件。</p>
<p>        为了使页面可写，分页器将该页的原始内容（在新的日志记录中）写入回滚日志。（您可能会注意到，新创建的页面不会被记录，因为这些页面没有旧值。）一个页最多只能写入回滚日志文件一次。对页面的更改不会立即写入数据库文件。对页面的更改首先保存在缓存中。数据库文件保持不变，这意味着其他事务可以继续从该文件读取。</p>
<p><strong>扇区日志：</strong> 如果存储设备中的扇区可以存储多个数据库页面，SQLite记录整个扇区，而不是更新的页面。</p>
<p><strong>页面日志策略：</strong> 一旦页面映像被复制到回滚日志中，该页将永远不会出现在新的日志记录中，即使当前事务多次调用该页上的sqlite3PagerWrite函数。这种日志记录的一个很好的特性是，可以通过从日志中盲复制内容来恢复页面。因此，撤销操作是幂等的，它不会产生任何补偿日志记录。SQLite从来不会在日志中保存一个新的页面（由当前事务添加，即追加到数据库文件中），因为没有旧的pace值，相反，当创建日志文件时，数据库文件的初始大小存储在日志段头记录中（参见第91页的图3.7）。如果数据库文件被事务扩展，文件将在回滚时被截断为其原始大小。</p>
<h4 id="5413-cache-fush">5.4.1.3 Cache fush</h4>
<p>缓存刷新是寻呼机模块的内部操作；客户端（也就是树模块）永远不能直接加入缓存刷新。当分页器想要从页面缓存中刷新页面时，有两种情况：(1)缓存已经填满，并且需要替换缓存。或者(2)事务已准备好提交其更改。分页器将部分或全部修改过的页面写回数据库文件。在写入之前，分页器必须确保没有其他事务正在读取数据库文件。SQLite遵循WAL协议编写数据库文件。这意味着回滚日志内容可能需要被刷新到磁盘上，以便在将页面写入数据库时发生故障时回滚事务。寻呼机执行以下步骤：</p>
<ol>
<li>它确定是否需要刷新日志文件。如果事务是同步的，并且在日志文件中写入了新数据，并且数据库不是临时文件。[-3]然后传呼机需要做一个日志刷新。在这种情况下，它对日志进行fsync系统调用。他需要确保到目前为止写入的所有日志记录都实际到达磁盘表面。在fsync的这个时候，分页器不写入当前日志段头中的日志记录数（nRec）值。nRec值是回滚操作的宝贵资源。当形成这些段头时，对于同步事务，该数字被设置为0，并被设置为-1。也就是异步的0xFFFFFFFF。)在日志被刷新后，分页器将rec值写入当前日志段标头中，并再次对文件进行fsync。[-4]由于磁盘写入不是原子的，它将不再重写nRec字段。分页器将为新的传入日志记录创建一个新的日志段。在这些场景中，SQLite使用多段日志文件。</li>
</ol>
<hr>
<p>[-3] 对于临时数据库，我们不关心是否能够在系统或电源故障后进行回滚，因此不会发生日志刷新。</p>
<p>[-4] 日志文件被刷刷两次。第二次刷新导致覆盖存储nrecfield的磁盘块。如果这种覆盖是原子的，那么我们就可以保证日志在写入时不会被破坏，否则，我们就会有一些小的风险</p>
<ol start="2">
<li>它试图获取数据库文件上的EXCLUSIVE锁。(寻呼机永远不会无条件地等待锁授予。它在非阻塞模式下尝试锁定。如果其他事务仍然持有SHARED锁，则锁尝试失败，并将SQLITE BUSYerror代码返回给调用者。事务没有中止。</li>
<li>它将所有修改过的页面（当前保存在页面缓存中）或选择性页面写入数据库文件。页面写入是就地完成的。它将这些页面的缓存副本标记为干净。(此时它不会将数据库文件推送到磁盘。</li>
</ol>
<p>        如果写入数据库文件的原因是因为页面缓存已满，则分页器不会立即提交事务。相反，事务可能会继续对其他页面进行更改。在将后续更改写入数据库文件之前，分页器将再次重复这三个步骤。</p>
<p><strong>注意：</strong> 在事务完成之前，分页器获得的写数据库文件的EXCLUSIVE锁将一直保持。这意味着这个进程（通过不同的库连接）和其他应用程序进程将无法在数据库上打开另一个（读或写）事务，从分页器第一次写入数据库文件开始，直到事务提交或终止。对于短事务，更新保存在缓存中，并且在提交期间只有在提交时才会获得排他锁。但是，长事务会导致其他读事务的性能下降</p>
<h4 id="5414-commit-operation">5.4.1.4 Commit operation</h4>
<p>根据提交事务是修改单个数据库还是多个数据库，SQLite遵循的提交协议略有不同。</p>
<p><strong>单一数据库情况：</strong> 当树模块准备提交事务时。它首先调用sqlite3PagerCommitPhaseOne函数（参见下面列表中的前两项），然后调用sqlite3PagerCommitPhaseTwo函数（下面列表中的最后两项）。提交读事务很容易。分页器从数据库文件中释放共享锁（如果数据库上没有其他读或写事务）并返回到NO lock状态：它不需要清除页面缓存。（下一个事务从一个热页缓存开始。）为了提交写事务，分页器按照列出的顺序执行以下步骤：</p>
<ol>
<li>它获取数据库文件上的EXCLUSIVE锁。(如果锁获取失败，它将返回SQLITE BUSY给sqlite3PagerCommitPhaseOne函数的调用者。它现在不能提交事务，因为来自其他数据库连接的其他事务仍在读取数据库。它增加了数据库元数据动态更改计数器。它按照5.4.13节的算法步骤1-3将所有修改过的（缓存中的）页面写回数据库文件，这被称为“提交时刷新日志”，这样做是为了在回滚日志中保存重要信息，以消除整个事务的影响。</li>
<li>许多操作系统（如Linux）将这些写操作缓存在操作系统空间的内存中，并且可能不会立即将它们发送到磁盘。为了克服这种情况，寻呼机对数据库文件进行fsync系统调用，将文件推送到磁盘。这被称为在提交时刷新数据库，这样做是为了消除系统重启时的重做逻辑。</li>
<li>然后完成（即……）删除、截断或使日志文件无效。</li>
<li>最后，它从数据库文件中释放EXCLUSIVE锁。如果有concurrentselect操作执行（即读事务），则返回SHARED LOCK状态：否则返回NO_LOCK状态；它不需要清除页面缓存。</li>
</ol>
<p><strong>提交点：</strong> 事务提交点发生在回滚日志文件完成的瞬间。在此之前，如果发生电源故障或系统崩溃，则认为事务在提交处理期间失败。下次SQLite读取数据库时，它将从数据库回滚事务的影响。SOLite假定本机操作系统的日志终结是一个原子操作。</p>
<p><strong>多数据库情况：</strong> 提交协议有点复杂，它类似于分布式数据库系统中的事务提交。VM模块（VdbeCommit函数）实际上作为提交协调器驱动提交协议。每个数据库的分页器在其数据库上执行自己的“本地”提交部分。对于只修改单个数据库文件（不计算临时数据库）的读事务或写事务，协议对涉及的每个数据库执行正常的提交。如果事务修改了多个数据库文件。执行的提交协议如下：[-5]</p>
<hr>
<p>[-5] 如果主数据库是“:memory:”， $QLite不保证多数据库事务的原子性。相反，它遵循对单个数据库文件的简单提交</p>
<ol>
<li>释放那些事务没有更新的数据库的共享锁（如果其他读取事务在这个线程中没有活动）.</li>
<li>在事务已更新的数据库上获取EXCLUSIVE锁。增加数据库文件的文件更改计数器元数据。</li>
<li>创建一个新的主日志文件。(主日志总是在与主数据库相同的目录中，并且具有相同的名称，但后面附加了‘-mj’，后跟八个随机选择的4位十六进制数字。即使提交事务没有修改主数据库，也会发生这种情况。用所有个人的名字填充主日志。回滚日志文件，并将主日志和日志目录刷新到磁盘。（临时数据库名称不包含在主日志中。）</li>
<li>将主日志文件的名称写入主日志记录中的所有回滚日志中（参见第94页的图3.9），并刷新回滚日志。直到事务提交时，分页器才知道它已经是多数据库事务的一部分。只有在这一点上，它才知道它是多数据库事务的一部分。)</li>
<li>刷新单个数据库文件。</li>
<li>删除主日志文件并刷新日志目录。</li>
<li>完成（删除或截断）所有单独的回滚日志文件。</li>
<li>从所有数据库对象中释放EXCLUSIVE锁。所有分页返回SHARED LOCK或NO LOCK状态。寻呼机不需要清除它们的页面缓存。</li>
</ol>
<p><strong>提交点：</strong> 当主日志文件被删除时，事务被认为已经提交。在此之前，如果发生电源故障或系统崩溃，则在提交处理期间将事务视为失败。当SQLite下次读取这些数据库时，它会将它们恢复到事务开始之前的各自状态。</p>
<p><strong>回滚日志结束：</strong> 当日志模式为持久化时，日志文件被截断为零大小，而不是使日志头失效。</p>
<p><strong>警告!</strong> 如果主数据库是临时文件（或内存中），SQLite不保证多数据库事务的原子性。也就是说，全球复苏可能是不可能的。它不创建主日志。VM模块遵循单个数据库文件的简单提交，一个接一个。因此，可以保证事务在每个单独的数据库文件中都是本地原子的。因此，在发生故障时，其中一些数据库可能会获得事务的更新，而另一些可能不会。</p>
<p><strong>提交失败：</strong> 用户级事务由执行COM的应用程序本身提交。MIT命令和SQLite尝试完成事务。如前所述，由于锁冲突，执行COMMIT命令的尝试可能会失败，并可能导致SQLITE BUSY返回代码。这表明另一个事务持有数据库上的共享锁，从而阻止COMMIT成功。当COMMIT以这种方式失败时，事务保持活动状态，并且在其他事务有机会清除它们的共享锁之后，应用程序可以稍后重试COMMIT。SQLite不会自动重试提交。应用程序必须自己完成</p>
<h4 id="5415-statement-operations">5.4.1.5 Statement operations</h4>
<p>语句子事务实现为匿名保存点，在子事务结束时释放。语句子事务级别的正常操作是读、写和提交。下面将讨论这些问题。</p>
<p><strong>读取操作：</strong> 语句子事务通过包含的用户事务读取页面。所有规则都遵循与用户事务相同的规则。</p>
<p><strong>写操作：</strong> 写操作包括两个部分：锁定和记录。语句子事务通过包含的用户事务获取锁。但是语句日志略有不同，它是通过使用一个单独的临时语句日志文件来处理的。（语句日志是一个任意命名的临时文件，前缀为etills_。）分页器将一些日志记录写入语句日志，一些日志记录写入主回滚日志。当子事务试图通过sqlite3PagerWrite操作使页面可写时，它执行以下两种可选操作之一：</p>
<ol>
<li>如果页尚未在回滚日志中，则分页器将向回滚日志添加新的日志记录。（但是，新添加的页面不会被记录）</li>
<li>如果页不在该日志中，则分页器将向语句日志中添加新的日志记录。分页器在语句子事务时创建语句日志文件
写入文件中的第一条日志记录</li>
</ol>
<p>分页器从不刷新语句日志，因为故障恢复从不需要这样做。如果发生系统故障或断电，主回滚日志将负责数据库恢复。您可能会注意到，当一个页面同时属于回滚日志和语句日志时。回滚日志具有最旧的页面映像。</p>
<p><strong>提交操作：</strong> 语句提交非常简单。分页器删除语句日志文件，（但是，请参见下面的子小节。）</p>
<h4 id="5416设置保存点">5.4.1.6设置保存点</h4>
<p>当用户事务建立保存点时，SQLite进入保存点模式。在这种模式下，在提交语句时，SQLite不再删除语句日志。它保留日志，直到事务释放所有保存点，或者提交或中止自己。在保存点模式下，日志记录略有不同：如果一个页面是由前一个语句添加的，那么该页将再次添加到当前语句日志中。因此，语句日志可以对同一个数据库页有多个日志记录。</p>
<h4 id="5417-releasing-savepoints">5.4.1.7 Releasing savepoints</h4>
<p>当应用程序执行释放sp命令时，SQLite会销毁相应的PagerSavepoint对象以及在sp保存点建立之后创建的对象。应用程序不能再引用这些保存点。</p>
<h3 id="542-recovery-processing">5.4.2 Recovery processing</h3>
<p>大多数事务和语句子事务提交自己。但偶尔，一些事务或语句会自行终止。在极少数情况下，会出现应用程序和系统故障。无论哪种情况，SQLite都可能需要通过执行一些回滚操作来将数据库恢复到可接受的一致状态。在前两种情况下（语句和事务终止），内存中的可靠信息可能在恢复时可用。在后一种情况下（失败），数据库可能已经损坏，并且内存中没有任何信息。存在一种中间情况，即事务恢复到以前的保存点。我将在以下四个小节中讨论这四种情况。</p>
<h4 id="5421-transaction-abort">5.4.2.1 Transaction abort</h4>
<p>在SQLite中，从abort中恢复非常简单。分页器可能需要也可能不需要从数据库文件中删除事务的效果。如果事务在数据库上只持有一个RESERVED或PENDING锁，则可以保证文件不被修改；分页器将完成日志文件，并从页面缓存中丢弃所有脏页。否则，事务将持有数据库文件上的排他锁，并且事务可能已将某些页面写回数据库文件，分页器将执行以下回滚操作。</p>
<p>        分页器从回滚日志文件中逐条读取日志记录，并从这些记录中恢复页面映像。（您可能还记得，事务最多记录一个数据库页一次，日志记录存储该页之前的映像。）因此，在日志扫描结束时，数据库将恢复到事务开始之前的原始状态。如果事务扩展了数据库，则分页器将数据库截断为原始大小。然后，它（分页器）首先刷新数据库文件，然后完成回滚日志文件。它释放排他锁，并清除页面缓存。</p>
<h4 id="5422-statement-subtransaction-abort">5.4.2.2 Statement subtransaction abort</h4>
<p>如第5.4.1.5节所述。语句子事务可以同时向回滚日志和语句日志添加日志记录。SOLite需要回滚语句日志中的所有日志记录，以及回滚日志中的一些日志记录。如前所述，每个语句都被视为一个匿名保存点。因此，语句中止相当于恢复匿名保存点。我将在下一小节中讨论它。</p>
<h4 id="5423-reverting-to-savepoints">5.4.2.3 Reverting to savepoints</h4>
<p>如第145页5.4.1.6节所述，当处于保存点模式时，事务不会删除语句日志。当事务执行回滚到sp命令时，SQLite还播放sp点建立后生成的语句日志中的日志记录。PagerSavepoint对象对应的三个成员变量ioffset、iHdrOffset和iSubRec起着至关重要的作用。它首先播放主回滚日志中的所有日志记录，从iOffset处开始，直到日志文件的末尾。然后，它播放从iSubRec开始的语句日志中的所有日志记录，直到文件末尾用于恢复保存点。但是，在前一种情况下，如果iHdrOffset不为零，则从回滚日志播放日志记录分两步完成：(1)从ioffset到iHdrOfset，(2)所有后续的日志段。在恢复过程中，分页器会记录回滚哪些页面，并确保不会对某个页面进行多次回滚。寻呼机。dbsize被恢复为保存点（PagerSavepoint.nOrig）开始时的大小。对于恢复整个事务，只使用回滚日志。SQLite销毁sp保存点之后创建的所有PagerSavepoint对象，但不包括它的保存点。应用程序无法再访问这些保存点。</p>
<h4 id="5424-recovery-from-failure">5.4.2.4 Recovery from failure</h4>
<p>当没有应用程序更新数据库，但存在回滚日志文件时，这意味着之前的事务可能已经失败，SQLite可能需要从失败事务的影响中恢复数据库，然后才能将数据库用于正常业务。如果相应的数据库文件被解锁或共享锁定，则回滚日志文件称为热文件。当一个写事务正在完成时，一个失败阻止了完成，日志就会变热。但是，如果回滚日志是由多数据库事务产生的，并且没有主日志文件，则回滚日志不热；这意味着在发生故障时提交事务。热日志意味着需要回滚以恢复数据库的一致性。</p>
<p><strong>热度测定：</strong> 有两种情况。(1)不涉及主日志，即回滚日志文件中没有主日志记录。如果回滚日志存在并且有效（即，日志头格式良好且不为零），并且数据库文件没有预留强锁并且数据库不是空的（size = 0），则回滚日志是热的(您可能还记得带有保留锁的事务创建回滚日志文件；(2)回滚日志中出现主日志名。如果主日志存在并具有对该回滚日志的引用，并且对应的数据库文件上没有保留或更强的锁，则回滚日志为热点。</p>
<p>        在大多数dbms中，当数据库启动时，事务管理器会立即启动对数据库的恢复操作，而SOLite执行延迟恢复。如5.4.1.1节所述，当第一次读取数据库中的（任何）页时，只有当回滚日志是热的时候，分页器才会经过恢复逻辑并恢复数据库</p>
<p><strong>警告!：</strong> 如果当前应用程序对数据库文件只有读权限，并且对文件和包含目录没有每任务写权限，则恢复失败，应用程序将从SQLite库获得一个意想不到的错误代码。</p>
<p>        当分页器第一次想要从数据库文件中读取数据时，它在实际从文件中读取页面之前执行以下恢复步骤序列。</p>
<ol>
<li>
<p>它获取数据库文件上的共享锁。(如果它不能获得锁，它将向应用程序返回SQLITE_BUSY错误代码。</p>
</li>
<li>
<p>它检查数据库是否有热日志。如果数据库没有热日志。恢复操作完成。如果存在热日志，则按照以下步骤回滚日志。</p>
</li>
<li>
<p>它获取数据库文件上的EXCLUSIVE锁。(寻呼机没有获得re - serve锁，因为这会使其他寻呼机认为日志不再是热的，他们会读取数据库。它需要一个排他锁，因为作为恢复工作的一部分，它即将写入数据库文件。如果它未能获得锁，则意味着另一个分页器已经在尝试回滚，在这种情况下，它释放所有锁并将SQLITE_BUSY返回给应用程序。</p>
</li>
<li>
<p>它从回滚日志文件中读取所有日志记录并撤消它们。此步骤将数据库恢复到崩溃事务开始之前的原始状态，因此，数据库现在处于一致状态。如果需要，它将数据库文件截断到失败事务开始时的大小。</p>
</li>
<li>
<p>它刷新数据库文件。这样可以在发生另一次电源故障或崩溃时保护数据库的完整性。</p>
</li>
<li>
<p>它结束（即删除、截断或使回滚日志文件无效）。</p>
</li>
<li>
<p>它删除主日志文件，如果这样做是安全的。(这一步是可选的。下面讨论)。</p>
</li>
<li>
<p>它将锁强度降低为SHARED。（这是因为分页器在sqlite3PagerGet函数中执行恢复）。</p>
</li>
</ol>
<p>在上述算法成功终止后，数据库文件被保证已恢复到失败事务开始时的状态，现在可以安全地从文件中读取。</p>
<p><strong>过期主日志：</strong> 如果不再有单独的回滚日志引用该主日志，则认为该主日志已过期。分页器首先读取主日志并获取所有回滚日志的名称。然后，它单独检查每个回滚日志，如果它们中的任何一个存在并指向主日志，则主日志没有过期。如果所有回滚日志都丢失，或者它们引用其他主日志，或者根本没有引用主日志，则主日志失效，分页器将删除主日志。不要求删除陈旧的主日志。这样做的唯一原因是释放它们占用的磁盘空间。</p>
<h3 id="543-other-management-issues">5.4.3 Other management issues</h3>
<p>本小节简要讨论其他与数据库相关的问题。</p>
<h4 id="5431-checkpoint">5.4.3.1 Checkpoint</h4>
<p>为了减少故障恢复时的工作负载，大多数dbms会定期在数据库上执行检查点。您可能还记得，SQLite一次最多只能在一个数据库文件上有一个写事务，日志文件只包含来自该事务的日志记录，因此SQLite删除（或截断或无效）日志
文件，当事务完成时。不会永远累积日志，不需要执行检查点，也没有嵌入任何检查点逻辑。当事务提交时，SQLite确保所有来自事务的更新在日志文件结束（即删除，截断或无效）之前都在数据库文件中。(在SQLite 3.7.0版本中，SQLite开发团队引入了WAL日志记录功能。在这种日志模式下，执行检查点。我在249页的10.17节中讨论了这个日志。)</p>
<h4 id="5432-space-constraint约束">5.4.3.2 Space constraint（约束）</h4>
<p>在一些dbms中，最麻烦的问题是日志空间不足。也就是说，文件系统没有足够的空间来增加日志文件以写入新的日志记录。在某些dbms中，中止事务会在撤消某些更新的同时产生（补偿）日志记录，从而使情况进一步恶化。缺少日志空间可能会在这些系统中造成事务中止和系统重启的问题。SQLite没有日志空间问题，因为终止事务不会产生任何新的日志记录。系统重新启动可能是一个问题，但只有在以下极端情况下才会出现：事务缩小了数据库文件，而释放的空间已经被本机文件系统分配给了其他用途。在这种情况下，恢复将失败，因为SQLite无法将数据库恢复到原来的大小，并且数据库将停止运行，直到数据库文件恢复到原来的大小所需的可用空间。</p>
<p>        还有另一个相关的问题：没有空间让数据库文件增长。在这种情况下，分页器将SQLITE_FULL错误代码返回给可能中止事务的应用程序。所以这在SQLite中也不会造成问题。</p>
<h2 id="summary-1">Summary</h2>
<p>这一章详细介绍了最重要的模块，分页器直接访问数据库和日志文件，管理数据库文件上的SQLite锁获取和释放。（SQLite中没有其他模块可以绕过分页模块直接访问这些资源。）总的来说，它实现了ACID属性。</p>
<p>        分页器使用进程地址空间中的少量空间（实际上是在进程堆空间中）来保存部分数据库文件。这个空间在SQLite世界中被称为页缓存。这个空间是分槽的，每个槽可以精确地保存一个数据库页和一些控制信息。页面缓存抽象简化了树模块对数据库文件的访问，而不管它访问的是哪种类型的数据库。</p>
<p>        页面缓存管理非常灵活。缓存方案是一个可插拔模块，用户可以提供他们自己的缓存模块，尽管SQLite提供了一个默认的缓存模块。它使用可扩展/可收缩哈希数组将缓存槽组织到桶中。使用页码作为搜索关键字，SQLite使用一种LRU缓存替换方案。它维护一个未固定页面队列，其中最近访问次数最少的页面位于标题端。被害人可能不是头部元素。SQLite尝试找到第一个不会导致日志刷新的槽位。如果发现该槽位，则使用该槽位进行更换。否则，更换头槽。</p>
<p>        本章还描述了实现ACID属性的各种事务处理相关（内部）步骤。内部处理分为正常处理和恢复处理两部分。正常的处理包括读取页面、写入页面、刷新页面缓存以及提交事务或子事务。在用户事务中。SQLite在一个匿名保存点的抽象中执行每个SOL语句。恢复处理，包括子事务或事务中止、保存点恢复和处理系统故障。</p>
<h1 id="chapter-6-the-tree-module">Chapter 6 The Tree Module</h1>
<p>读完这一章，你应该能够解释/描述：</p>
<ul>
<li>SQLite如何将表组织成单独的B+树</li>
<li>如何在数据库文件中构造树，元和组分别插入和删除树</li>
<li>B和B+树结构和操作它们的算法</li>
<li>内部页、页和溢出页的结构</li>
</ul>
<p><strong>Chapter synopsis</strong>
数据库文件中的数据可以以多种方式组织，例如条目顺序、相对顺序、散列、ker顺序。SQLite使用B+树来组织表的内容，使用B-树来组织表的索引。它们是关键序列数据，结构。本章讨论B/B+树的实现，通常用于在其他dbms的外部（基于磁盘的）数据库上实现有序索引。在SQLite中实现的算法是Donald E. Knuthin在他的著名著作《计算机编程的艺术》第3卷中提出的：“排序和搜索”。</p>
<h2 id="61-preview">6.1 Preview</h2>
<p>在前一章中，我讨论了分页模块如何在本机面向字节的文件之上实现面向页面的文件抽象。在本章中，我将讨论tree模块如何在面向页面的文件之上实现面向元组（也就是行）的文件抽象。元组的最终用户（也就是数据库文件）是VM模块，它通过树模块提供的接口访问元组。VM将数据库视为（键排序的）面向元组的文件。</p>
<p>        本章介绍了SQLite的元组管理方案。您可能还记得，每个关系都是一组元组。数据库中所有关系的元组都存储在同一个数据库中。虚拟机必须有一种方法来集群和组织一个关系的元组，并将它们与其他关系的元组分开。此外，VM必须能够有效地存储、检索和操作元组。树模块帮助VM这样做；tree模块负责元组到页面的转换。</p>
<p>        关系的元组可以以多种方式组织，例如条目顺序、相对顺序。哈希，键序列。每个组织都有自己的机制，可以根据（关系的）某些属性值在关系中插入新的元组，以及从关系中检索和删除元组。在VM看来，它是一种可内容寻址的基于元组的存储组织。不同的关系可以有不同的元组组织。SQLite使用一个B+树来组织一个关系的所有元组，不同的关系使用不同的元组。它将索引的内容视为一种关联，并将内容存储在b树中，并将不同的索引存储在不同的b树中。它不使用任何其他元组组织技术。因此，SQLite数据库是B树和B+树的集合。所有这些树都存储在单个文件中，它们分布在数据库页面中，并且可以穿插。但是，没有数据库页面存储来自两个或多个关系或索引的元组。tree模块的职责是组织树的页面，以便有效地存储和检索元组。模块查看面向页面的文件，并将其转换为面向树的文件（元组）。</p>
<p>        B-树和B+树是类似的键序列数据结构。在本章的其余部分中，我主要限制自己使用B+树。出于一般目的，我将使用B+树。tree模块实现了从树中读取、插入和删除单个元组的原语，当然还有创建和删除树的原语。就元组的内部结构而言，它是一个被动模块，它将元组视为可变长度的字节字符串。关系名称或索引名称到树（实际上是树的根）的映射信息保存在sqlite_master（或sqlite_temp master）目录中，该目录存储在预定的B+树中。</p>
<h2 id="62-the-tree-interface-functions">6.2 The Tree Interface Functions</h2>
<p>tree模块实现了一组接口函数（由VM模块使用）。下面将简要讨论一些重要的函数，还有更多这样的函数，它们严格地属于SQLite内部，SQLite应用程序开发人员不能在他们的应用程序中使用它们。它们在btree.c源文件中定义。所有函数名都以sqlite3Btree作为前缀。</p>
<ol>
<li>sqlite3BtreeDpen：这个函数打开到数据库文件的连接，而不是数据库中的单个树或B+树。它最终调用sqlite3PagerOpen分页函数来打开文件。通过这样做，它在应用程序和文件之间建立了一个新的连接。它创建并返回一个指向Btree类型对象（参见第6.5.1.1节）的指针，该指针被VM用作其他树接口函数的句柄。</li>
<li>sqlitebtreclose：这个函数关闭先前打开的数据库连接并销毁Btree对象的历史。它最终调用sqlite3PagerClose分页函数来销毁它的分页对象。但是，在此之前，它回滚所有挂起的事务，关闭并释放所有游标（请参阅此列表中的下一项），并释放分配给Btree对象的其他资源。</li>
<li>sqlite3BtreeCursor：这个函数在一个特定的树上创建一个新的游标，也就是说，它打开树来读写它。（该树由其根页面标识。）游标可以是读游标，也可以是写游标，但不能两者都是。在同一棵树上可以有许多打开的游标，每个游标都是通过单独调用sqlite3BtreeCursor函数创建的。但是，读游标和写游标不能在同一棵树上共存。（您可能会注意到，SQLite有一个限制，即一个事务不能同时使用不同的游标读写同一棵树。）在创建第一个游标时，该函数获得数据库文件上的共享锁（通过它的分页器）。</li>
<li>sqlite3BtreeCloseCursor：这个函数关闭先前打开的游标。当最后一个游标（可以在任何树上）关闭时，数据库文件上的共享时钟将被释放。</li>
<li>sqlite3BtreeClearCursor：这个函数基本上使游标无效。</li>
<li>sqlite3BtreeFirst：这个函数将光标移动到树中的第一个元素，即到树的最左边的后代节点。</li>
<li>sqlite3BtreeLast：该函数将光标移动到树中的最后一个元素，即到树的最右边的后代节点。</li>
<li>sqlite3BtreeNext: This function moves a cursor to the next element after the one it is currently pointing to.</li>
<li>sqlite3BtreePrevious: This function moves a cursor to the previous element before the one it is currently pointing to.</li>
<li>sqlite3BtreeMovetoUnpacked：这个函数将光标移动到与作为参数传递的键值匹配的元素上。如果没有找到精确匹配，则游标总是指向叶子页，如果存在该条目，则叶子页将保存该条目，游标可能指向键之前或之后的条目。</li>
<li>sqlite3BtreeBeginTrans：这个函数在数据库文件上启动一个新的事务。如果在参数中指明，则启动写事务；否则，它将启动一个读事务。调用者可以请求排他性事务，这意味着不允许其他进程或线程访问数据库。</li>
<li>sqlite3BtreeCommitPhaseOne：这个函数执行SQLite两阶段提交的第一阶段。它为提交事务做了所有的事情，比如刷新回滚日志、刷新数据库文件，但它不完成回滚日志，也不释放锁。</li>
<li>salite3BtreeCommitPhaseTwo：该函数实际提交数据库文件上当前正在进行的事务。它完成回滚日志文件，并将排他锁降级为数据库文件上的共享锁，如果没有活动游标，它还释放共享锁。</li>
<li>sqlite3BtreeRollback：这个函数回滚当前的写事务。当前写事务访问的所有游标都将被此函数失效。以后任何使用这些游标的尝试都会导致错误。（该函数将数据库文件上的排他锁降级为共享锁，如果没有活动游标，它也会释放共享锁。）</li>
<li>salite3BtreeBeginStmt：该函数启动语句子事务，（VM模块必须在启动子事务之前启动一个事务）。一次只能有一个子事务处于活动状态。如果另一个子事务已经处于活动状态，则尝试启动新的子事务是错误的。每个语句子事务都是一个匿名保存点</li>
<li>sqlite3BtreeCreateTable：这个函数在数据库文件中创建一个新的空树，树的类型（B或B+）由输入参数决定。在SQLite 3.7.8版本中，只允许两个可选值：BTREE INTKEY（用于SQL表，新的B+树具有整数键和任意大小的数据）或BTREE BLOBKEY（用于SQL索引，新的B+树具有任意大小的键和没有数据）。在此函数调用时，数据库上必须没有打开的游标；否则返回错误码。</li>
<li>sqlite3btreeddroptable：这个函数销毁B-或B+树，并释放它的所有页面。但是，它永远不会释放驻留在Page 1的根节点</li>
<li>salite3BtreeClearTable：该函数从现有的B树或B树中删除所有数据，但保留树本身。它释放所有相应的树页面和溢出页面，除了根页面。从这个函数返回时，树的根页是空的，就像刚刚创建树一样。</li>
<li>sqlite3BtreeDelete：这个函数删除游标当前指向的条目。删除后，光标将指向一个随机位置。</li>
<li>sqlite3BtreeInsert：这个函数通过游标在B-或B+树的适当位置插入一个新元素。密钥由一对（pKey, nKey）给出，数据由一对（pData, nData）给出。对于B+树（即SQL表），只使用密钥对的nKey值：忽略pKey。对于b树（即SQL索引），pData和nData都被忽略。游标仅用于定义条目应该插入到哪个表中。在插入之后，光标将指向一个随机位置</li>
<li>sqlite3BtreeKeySize：这个函数返回给定游标所指向的条目键的字节数。如果游标没有指向有效的条目，则返回0</li>
<li>sqlite3BtreeKey：这个函数返回给定游标所指向的条目的键
来</li>
<li>sqlite3BtreeDataSize：这个函数返回给定游标所指向的条目数据中的字节数。如果游标没有指向有效的条目，则返回0</li>
<li>sqlite3BtreeData：这个函数返回给定游标所指向的条目的数据。</li>
<li>sqlite3BtreeGetMeta：这个函数返回数据库设置参数的值。元数据。这个函数必须在读或写事务中调用。</li>
</ol>
<h2 id="63-b-tree-structure">6.3 B+-tree Structure</h2>
<p>B-tree，其中“B”代表“balanced”，是迄今为止我所知道的许多基于外部存储的dbms中最重要的索引结构。它是一种按键排序的方式来组织类似数据记录的集合。（排序顺序是键的总顺序。）同一数据库中的不同b树可以具有不同的排序顺序。B-tree是一种特殊的高度平衡的n层树，所有的叶节点都在同一层。条目[-1]和搜索信息(即…键值)存储在内部节点和叶节点中，B-tree在整个树操作范围（即插入，删除）中提供了最佳性能。搜索。然后搜索下一步。</p>
<hr>
<p>[-1] 为了避免混淆，我在这里使用术语“条目”来表示元组或数据项。条目由键和其他可选数据组成。</p>
<p>        B+树是B树的一种变体，其中所有条目都位于叶节点中。条目是（键值，数据值）对；它们是按键值排序的。内部节点只包含搜索信息（键值）和子指针。内部节点中的键按排序顺序存储，用于将搜索定向到适当的子节点。</p>
<p>        对于任何一种树，内部节点都可以在预设范围内拥有可变数量的子指针。对于特定的实现，内部节点可以拥有的子指针数量有上限和下限。下界通常等于或大于上界的一半。根节点可能违反此规则；它可以有任意数量的子指针（从0到上限）。所有叶节点都在同一最低层。在一些实现中，它们被链接在一个有序的链中，根节点总是B+树的内部节点。</p>
<p>        对于给定的上限n+ 1，n &gt; 1，在n+ 1元的B+树中，每个内部节点最多包含n个键和最多n+ 1个子指针。键和子指针的逻辑组织如图6.1所示。对于任何内部节点，以下条件成立：
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218113739.png" alt="Figure 6.1: $tructure of a B+-tree internal node."></p>
<ul>
<li>Ptr(0)所指向的子树最左边的所有键值小于或等于Key(0)；</li>
<li>Ptr(1)所指向的子树上的所有键值大于Key(0)且小于或等于Key(1)，以此类推；</li>
<li>Ptr(n)所指向的子树最右边的所有键值都大于Key（n -1）。</li>
</ul>
<p>内部节点中的键值仅用于搜索路由。查找给定键值的特定条目需要遍历O（log m）个节点，其中m是树中数据项的总数。</p>
<h3 id="631-operations-on-b-tree">6.3.1 Operations on B+-tree</h3>
<p>在接下来的小节中，我将介绍四种操作，即搜索、下一步搜索、插入和删除。我将在下面简要讨论它们；关于它们的详细信息可以在任何关于数据结构和算法的教科书中找到，尤其是Knuth[14]的那本。你可能会注意到，在SQLite中，所有的B+树都是唯一的键值，不重复；它也不会将叶节点连接在一起。在下面的小节中，我将使用图6.2中的B+树样本作为参考示例。我将树的每个节点关联到一个名称，该名称打印在节点的顶部：NO-N8。这些名称仅用于以下子小节中的参考目的。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218114324.png" alt="Figure 6.2:A typical text book example of a B+-tree"></p>
<h4 id="6311-search">6.3.1.1 Search</h4>
<p>考虑一个键值k的搜索操作。搜索从根节点开始，到叶节点结束。根节点总是一个内部节点。假设有n个键，Key(0)，…，键（n -1）和n + 1指针Ptr(0)，…， Ptr(n)，在节点上。键和指针的逻辑结构如图6.1所示。若k&gt; Key(n-1)，则在以Ptr(n)为根的子树继续搜索；若存在j=0，…，n-1，使得Key(j-1)&lt;k&lt; Key(j)，则在以Ptr(j)为根的子树继续搜索。（我假设这里Key(-1)&lt; k，对于任意k）如果子树的根是内部节点，则对内部节点应用相同的过程。最终，搜索到达一个叶节点。在叶节点中搜索键值为k的条目是否存在。solite在实体上使用标准的二进制搜索技术，在单个叶节点上进行本地搜索。</p>
<p>        假设您在图6.2的参考B+树中搜索93。从根节点（N0）开始搜索，取左指针，因为93 &lt; 100，即从节点N1重新开始搜索。搜索从最右边的指针开始，因为93 bb0 90，搜索从节点N5重新开始。n5是叶节点，搜索在这里成功结束。如果你在树中搜索94，搜索将在N5处失败而终止。</p>
<h4 id="6312下一步搜索">6.3.1.2下一步搜索</h4>
<p>这个操作在SQLite中比较复杂，因为它不把叶子节点链接在一起。假设之前的搜索在叶节点N的索引i处停止。如果i不是该节点上的最后一个索引。返回n中的第i+ 1个条目，否则，我们需要移动到另一个叶节点，该节点在逻辑上是n的下一个叶节点。移动是一个简单的树遍历逻辑。如果N是树的最后一个节点。那么树中就没有要搜索的条目了，它返回EOT（树尾）。假设N不是树的最右边后代结点。我们从结点N开始追父结点，直到到达结点N&rsquo;它不是父结点最右边的子结点。假设N是P，它的父结点P的子结点，搜索移动到P的最左边的子代结点（a叶节点），P的子树+1，它返回该叶节点的第一个条目。</p>
<p>        假设在最后一小节的示例示例中，前面的搜索在节点N5的键93处终止。下一个搜索从N5开始。在N5处没有大于93的条目，并且节点是其父节点（N1）的最右边的子节点。N1不是其父节点（NO）最右边的子节点。所以，搜索移动到N0的最右边子树的最左边的后代。这是。在N6处重新开始搜索，并返回N6中的第一个条目（110）。如果我们再次调用search-next，它将返回N6中的下一个条目（120）。</p>
<h4 id="6313插入">6.3.1.3插入</h4>
<p>假设我们想在B+树中插入一个键k（和数据）。首先，我们调用常规搜索来查找k可能驻留的叶子，如果k已经在那里，我们拒绝插入操作，因为我们有一个唯一的B+树。假设k不在这里。如果叶节点上有空间，我们将键和数据插入到所需排序位置的节点上。如果叶节点上没有空间，我们将把驻留在叶节点上的现有条目和正在插入的新条目分成相等的两部分：下半部和上半部。（上半部分的键严格大于下半部分的键。）我们分配一个新的叶节点，并将上半部分移动到新节点中。现在我们需要将新节点添加到树中。我们加上一对（K，P）其中K是分裂节点上的最大键，P是指向新节点的指针，指向被分裂的原始叶节点的父节点。如果父节点有存储新pair的空间，则将新pair存储在那里，并在此时终止插入。否则，父节点以同样的方式分裂。分割会一直传播，直到我们找到一些有足够空间容纳新对的祖先，或者根被分割。</p>
<p>        拆分根需要格外小心，因为没有更高级别的节点可以插入拆分对。此外，B+树的根页永远不会被重新定位。根分裂通常采用如下方式：设N为根节点。首先分配两个节点，比如L和R。将N的下半部分移到L中，上半部分移到R中，此时N为空。在N中加上（L， K， R），其中K是L中的最大键，页N仍然是根。请注意，树的深度增加了1，但新树保持高度平衡，没有违反任何B+树的属性</p>
<p>        假设我们在图6.2的B+树中插入200。我们首先搜索可以插入条目的叶节点。搜索在节点N8处终止。节点已满。因此，我们分配一个新节点，比如N9，并将180从N8转移到N9，并在N9中插入200。然后，我们将（170,N9）插入到有空间存储对的N2中。最终配置如图6.3所示。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218140729.png" alt="Figure 6.3: The confguration of the B+-tree of Figure 6.2 after the insertion of 200"></p>
<h4 id="6314-delete">6.3.1.4 Delete</h4>
<p>假设我们要从B+树中删除键值为k的项。首先，我们调用常规搜索例程来查找k可能所在的叶节点。如果在叶子上没有找到键值，则删除操作立即终止。假设键值在那里，i是对应条目的索引。所有索引大于i的项都下移一个元素。如果剩余条目的数量不低于页面占用的下限，则删除将立即终止。假设叶占用率低于下界。我们需要从这个节点开始自下而上地重组树（通过合并兄弟节点）。我们将进行以下工作，直到重组过程结束。</p>
<p>        假设节点N正在重构过程中。我们重新分配N上的条目，最多两个N的兄弟节点，这样所有节点都有相同数量的空闲空间。通常在N的两边各有一个兄弟结点用于平衡动作，尽管只有当N是父结点的最左子结点或最右子结点时，兄弟结点才会来自其中一边。如果N的兄弟节点少于两个（只有当N是根页面或根页面的子页面时才会发生这种情况），那么所有可用的兄弟节点都将参与重构过程。</p>
<p>        为了保持节点（几乎）满，N的兄弟节点的数量可能会减少一个或两个。根节点是特殊的，允许（几乎）为空。如果N是根节点，那么树的深度可能会根据需要减少1，以防止根节点过满。在平衡N的兄弟节点的过程中，N的父节点可能会变得不够满。如果发生这种情况，则在父节点上递归地调用重构，直到我们重构根节点。</p>
<h3 id="632-btree-in-sqlite">6.3.2 B+tree in SQLite</h3>
<p>通过分配根页面来创建树，根页面不会重新定位。每棵树都由它的根页码标识。该编号存储在主编目表中，其根始终位于第1页。</p>
<p>        SQLite将树节点（包括内部节点和叶子节点）存储在单独的页面中，一个页面存储一个节点（见图6.4）。因此，这些页分别称为内页和叶页。实际数据、条目部分驻留在叶页上，部分驻留在溢出页上。tree模块可能无法理解数据或键的内部结构。它以原始字节串及其大小存储数据和键。对于每个节点，任何条目的键和数据被组合在一起形成有效负载。固定的预设负载量直接存储在页面上。该模块试图将尽可能多的有效载荷放在单个页上。如果有效负载大于该量，则模块将剩余字节溢出到一个或多个溢出页中：多余的有效负载依次存储在溢出页的单个链接列表中。内部页面（虽然没有在图中显示）也可以有溢出页。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241218142024.png" alt="Figure 6.4:A typical B+tree."></p>
<h2 id="64-page-structure">6.4 Page Structure</h2>
<p>您可能还记得，每个数据库文件都被划分为固定大小的页面。树模块管理所有这些页面。每个页要么是一个树页（内部页、叶子页或溢出页），要么是一个自由页。（例外是锁字节和指针映射页。）第89页上的图3.5描述了空闲页面是如何组织到单个trunk列表中的。在本节中，我将介绍内部页、页和溢出页的结构。</p>
<p>        除了数据库文件的第一页（page 1）始终是包含根节点的B+树内部页外，任何数据库页都可以用于任何目的。但是，第一页的前100个字节包含一个特殊的头（称为“文件头”），它描述了flex的属性。图3.4在第86页展示了文件头的结构。页面上的剩余空间用于B+树的根节点。所有其他数据库页都被完全用于存储单个树节点或溢出内容</p>
<h3 id="641-tree-page-structure">6.4.1 Tree page structure</h3>
<p>每个内部/叶页的逻辑内容被划分为所谓的单元。例如，对于B+树内部节点，单元格由键值和键前面的子指针组成；对于叶节点，单元格包含（一部分）有效负载，没有子指针。我将在163页的6.4.1.3节中讨论细胞。单元是树页面上空间分配和回收的单位。为了对每个内页或页的空间进行管理，将其分为四个部分，如图6.5所示：</p>
<ol>
<li>页眉，</li>
<li>单元格内容区，</li>
<li>单元格指针数组，以及</li>
<li>未分配的空间。</li>
</ol>
<p>您可能还记得Page 1也有一个位于页头之前的100字节的文件头。单元格指针数组和单元格内容区彼此增长（通过中间未分配空间），就像两个堆栈彼此相对放置一样。单元格指针数组充当页面重目录，帮助将逻辑单元格顺序映射到它们在单元格内容区的物理单元格存储。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241218143053.png" alt="Figure 6.5: $tructure of a tree page."></p>
<h4 id="6411-structure-of-page-header">6.4.1.1 Structure of page header</h4>
<p>页头只包含该页的管理信息，页头总是存储在页的开头（低地址）页1是个例外：前100个字节包含文件头。页眉的结构如图6.6所示。前两列以字节为单位；多字节整数以大端字节格式存储。偏移量0处的标记定义了页面的格式（也就是树页面的类型）。有四种可能性：(1)表B+树内部页，(2)表B+树叶子页，(3)索引B-树内部页，(4)索引B-树叶子页。对于内部页，页头也包含偏移量为8的最右边的子指针。标题的其他组件将在下一小节中解释
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218143747.png" alt="Figure 6.6:Structure of tree page header"></p>
<h4 id="6412-structure-of-storage-area">6.4.1.2 Structure of storage area</h4>
<p>单元存储在页面的最末尾（高地址），它们向页面的开头生长。单元格指针数组从页标头后的第一个字节开始，它包含零个或多个单元格指针。见图6.7。数组中的元素数存储在页头偏移量3处（见图6.6）。每个单元格指针都是一个2字节的整数，表示单元格内容区域内到实际单元格的偏移量（从页面开始）。单元格指针按排序顺序存储（按对应的键值），即使单元格可能是无序存储的。左边项的键值比右边项的键值小。单元格不一定是连续的或按顺序排列的。SOLite努力在最后一个单元格指针之后保持空闲空间，以便可以轻松添加新单元格，而不必对页面进行碎片整理。</p>
<p>        由于在页面上随机插入和删除单元格，因此页面可能会散布单元格和空闲空间（在单元格内容区域内）。单元格内容区域内未使用的空间被收集到一个自由块的单链表中。列表中的块按其地址升序排列。指向列表的头指针（一个2字节的集合）起源于偏移量1的页头（见图6.6）。每个空闲块的大小至少为4字节。每个空闲块的前4个字节存储控制信息：前2个字节是指向下一个空闲块的指针（0值表示没有下一个空闲块），另外2个字节是这个空闲块的大小（包括leader）。由于空闲块的大小必须至少为4字节，因此单元格内容区域中任何少于3个未使用字节的组（称为片段）都不能存在于空闲块链上。所有片段的累积大小记录在页头偏移量7处（见图6.6）（大小最多可为255）。在达到最大值之前，SQLite对页面进行碎片整理。)单元格内容区域的第一个字节记录在页头偏移量5处（见图6.6）：如果该值为0（它被视为偏移量65,536）。该值充当单元格内容区域和未分配空间之间的边界。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241218145141.png" alt="Figure 6.7:Location of cell pointer array in a page"></p>
<h4 id="6413-structure-of-a-cell">6.4.1.3 Structure of a cell</h4>
<p>cell是可变长度的字节字符串，cell存储（一部分）单个负载，它是键和可选数据的组合。单元格的结构在图6.8的表格中给出。size列的单位是字节。size列中的var条目是一个可变长度的整数，用1到9个字节表示：它将被称为变体
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218145432.png" alt="Figure 6.8: Structure of a cell."></p>
<p>        对于内部页，每个单元格包含一个4字节的子指针；对于叶页，单元格没有子指针。接下来是数据图像中的字节数和天空图像中的字节数。(内部表树页面上不存在数据和键图像，键长度字节存储的是整型键值。索引树不存在数据映像。)因此(1)细胞在桌子上左子树的内部节点有一个4字节的页码和rowid yalue变体:(2)细胞atable树的叶子:节点有一个变种,总长度的表行记录,rowid价值的变体,行记录的一部分,和一个4字节溢出页码(3)细胞索引树的内部节点上有一个4字节的左子页面数,总长度的变异的关键值,一个关键的一部分,和一个4字节溢出页码;(4)索引树叶节点上的单元格，键值的总长度的变体，键的一部分，以及4字节的溢出页码。图6.9描述了单元的格式：单元的部分(a)结构，有效载荷的部分(b)结构。有效负载中可能没有键或数据，或者两者都没有。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241218152456.png" alt="Figure 6.9:Cell organization."></p>
<p><strong>Variant Integer Number</strong> 如图6.8所示，SQLite使用可变长度的整数来表示整数大小（和整数键值）。可变长度整数是1-9字节长，其中低7位。的每个字节用于整数值计算。该整数由所有设置了8位的连续字节和第一个清除8位的字节组成。整数的最高位字节首先出现。可变长度整数的长度不超过9个字节，作为特殊情况，第9个字节的8位全部用于确定值。这种表示允许SQLite在最多9个字节内编码64位整数。它被称为霍夫曼密码，发明于1952年。比起固定长度的64位编码，SQLite更喜欢可变长度的Huffman编码，因为存储最常见的情况只需要一个或两个字节，但如果需要，最多可以编码64位信息（9个字节）</p>
<p>        您可能还记得，SQLite对在树页面上存储有效负载有限制。即使页面上有足够的可用空间，有效负载也可能不会全部存储在页面上。最大嵌入有效负载分数是一个页面中可以被一个内部页面的单个单元消耗的总可用空间量。这个值在数据库文件头偏移量21处可用（参见第86页的图3.4）。如果内部页面上单元格的有效负载大于允许的最大大小，SQLite将额外的有效负载溢出到溢出页面链中。一旦分配了溢出页，就会将尽可能多的字节移动到溢出页中，同时不让单元格大小低于最小嵌入负载分数值（在数据库文件头偏移量22处）。最小叶有效载荷分数（在文件头偏移量23处）类似于最小嵌入有效载荷分数，不同之处在于它适用于叶页。叶子页的最大有效负载分数始终是100%，并且它没有在标题中指定</p>
<p><strong>溢出计算</strong> 设p为有效负载大小，u为页面上的可用面积
Leaf table-tree page: if (p &lt; (u - 36)), then put the entire payload on the leaf;  otherwise, let M = (((u2)*32/255)-23);  store min{u-35, (M+(p-M)%(u-4))} bytes on the page and rest on overflow pages.  Internal table-tree page: has no payload and no overflow;</p>
<p>Leaf/internal index-tree page: if (p&lt;(((u- 12)*64/255)- 22)), then put the entire payload on the page;  otherwise, let M=(((u-12)*32/255)-23);  store min{(M +(p- M)%(u-4)),(((u-12)*64/255)-23)bytes on the page and rest on overflow pages.</p>
<h3 id="642-overflow-page-structure">6.4.2 Overflow page structure</h3>
<p>多个小条目可以放在一个树页面上，但是一个大条目可以跨越多个溢出页面。溢出页面（对于有效负载）形成一个单链表。每个溢出页（最后一个页除外）都被长度等于可用空间减去四个字节的数据完全填充：前四个字节存储下一个溢出页码。最后一个溢出页可能只有一个字节的数据。（页面上的剩余空间是内部碎片。）溢出页面从不存储来自两个有效负载的内容。</p>
<h2 id="65-the-tree-module-functionalities">6.5 The Tree module Functionalities</h2>
<p>tree模块帮助VM将所有表和索引组织到B-树和B+树中：每个表一个B+树，每个索引一个B-树。每个树由一个或多个数据库页面组成，虚拟机可以存储和检索任何树中的可变长度记录。它可以随时从树中删除记录。树模块对插入和删除进行自平衡，并自动回收和重用空闲空间。对于包含m个元组的树，该模块为VM提供0（logm）个限时查找、插入和删除记录，以及O(1)个平摊的双向遍历记录</p>
<h3 id="651-control-data-structures">6.5.1 Control data structures</h3>
<p>tree模块是一个被动实体，因为它不解释存储在B-树和B+树中的记录（键和/或元组图像）。VM是记录的唯一解释器。tree模块通过分页模块访问每个数据库页面。它创建了四种数据结构（Btree、BtShared、MemPage和BtCursor）的许多内存控制对象来管理数据库页面的内存副本。这四种数据结构将在接下来的四个子小节中讨论</p>
<h4 id="6511-btree-structure">6.5.1.1 Btree structure</h4>
<p>当VM通过调用sqlite3BtreeOpen函数打开数据库文件时，该函数将创建一个Btreetype对象，以便在树模块层对文件应用进一步的操作。VM使用对象作为句柄来操作文件。虚拟机需要知道的关于文件的所有信息都汇总在对象中。该对象是虚拟机的数据库连接的同义词。该对象具有以下成员变量：(1)db：指向库连接持有的指针；这个Btree对象，(2)pBt：指向一个BtShared对象的指针，通过这个BtShared对象，tree模块访问数据库文件的页面；这个对象持有一个Pager对象（参见第6.5.1.2节）；(3) inTrans：表示一个事务是否正在通过这个数据库连接在数据库文件上进行；(4)许多其他控制变量，inTrans的值决定了b树对象的状态；它可以处于以下三种状态之一：TRANS_NONE， TRANS READ和TRANS WRITE，表示当前通过Btree对象在数据库文件上进行的事务类型。</p>
<h4 id="6512-btshared-structure">6.5.1.2 BtShared structure</h4>
<p>在树模块层，BtShared对象的实例表示单个数据库文件的状态。该对象有以下成员变量：(1)pPager：它指向一个管理数据库和日志文件的Pager对象；(3) pageSize：表示每个页面上的总字节数；(4)nTransaction：打开（读和写）事务的数量；(5)in’transaction：事务状态；(6) pSchema：指向模式缓存的指针（模式对象）；db：指向当前正在使用该对象的库连接的指针；(8) pPagel：指向数据库页面1的MemPage对象的内存副本的指针；(9)互斥锁：访问同步器；（10）许多其他控制变量。当共享缓存功能被禁用时，每个BtShared对象由单个Btree对象拥有。当这个特性被启用时，一个BtShared对象可以被多个Btree对象拥有，我将在第241页的10.13节中讨论共享页面缓存</p>
<h4 id="6513-mempage-structure">6.5.1.3 MemPage structure</h4>
<p>如图5.8第133页所示，对于页面缓存中的每个页面图像，分页器会在页面正下方分配额外的空间。tree模块使用这个空间来存储特定于页面的控件信息。分页器在将页放入缓存时将空间初始化为零。树模块根据需要重新初始化空间。这个空间包含一个MemPage类型的对象。图6.10给出了MemPage的一些关键成员变量。这些变量是不言自明的。MemPage对象存储从原始文件页面内容解码的页面信息。parent变量指向父页的缓存内副本。这个变量允许我们从任何节点到树的根遍历树，aData指向缓存中页面副本的开始。
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218160916.png" alt="Figure 6.10:Structure of MemPage obiect"></p>
<h4 id="6514-btcursor-structure">6.5.1.4 BtCursor structure</h4>
<p>要对数据库中的特定树进行操作，VM必须首先通过在树上创建游标的方式（通过调用sqlite3BtreeCursor函数）“打开”树。游标（许多作者称之为扫描）是对树应用操作的抽象。游标充当指向树中特定条目的逻辑指针。对于每个打开的树，树模块创建一个BtCursor类型的对象，该对象用作从树中读取、插入或删除元组的句柄。这里的游标是在单个树上执行单个SQL语句的一种表示，BtCursor对象不能被多个数据库连接（即b树对象）共享。</p>
<p>图6.11给出了btcursor的一些关键成员变量。变量是自解释的。apppage是一个MemPage对象数组。这些对象包含从根目录到当前页面的所有页面；游标当前指向的条目。aiIdx[]包含这些页面上单元格指针数组的相应索引。eState是游标的状态：valid（指向一个有效的条目）、invalid（没有指向一个有效的条目）、requireseek（树被其他人修改了）或fault（一些错误，比如没有发生内存）。</p>
<p>        虚拟机可以在同一棵树上打开多个游标。游标可以是读游标，也可以是写游标，但不能两者都是。我们只能通过读游标读单元格，但可以通过写游标读和写。（读游标的输出是按自然树顺序排序的元组。）读游标和写游标不能在同一树中共存。（读写事务不能通过两个不同的游标并发地读写同一棵树。）因此，读游标保证具有可重复读属性，读游标是树上的一种“读锁”。（这与数据库连接是否对数据库文件具有排他锁无关。）这允许读游标对树进行顺序扫描，而不必担心在扫描期间条目被插入或从树中删除。只有当VM打算在树上执行范围搜索查询时，才会打开读游标。所有其他游标都是写游标，既可以读也可以写树。</p>
<p>        您可能会注意到，树可以有自己的键比较函数。对于同一树上的每个游标，比较函数在逻辑上必须相同。默认的比较函数是表B+树的整数比较和索引B-树的本机memcmp API</p>
<h4 id="6515-integrated-control-structures">6.5.1.5 Integrated control structures</h4>
<p>以上四种数据结构与第5章定义的数据结构之间的联系如图6.12所示。b树对象及其相关的控制结构总结了V通过该b树对象看到的一个数据库文件的当前状态。(许多Btree对象可以共享同一个BtShared对象。我在第241页的10.13节中讨论了这一点。)
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218162442.png" alt="Figure 6.12:Integration of control structures"></p>
<h3 id="652-space-management">6.5.2 Space management</h3>
<p>tree模块从VM模块随机接收负载插入和删除请求。插入操作需要在树（和溢出）页中分配空间。删除操作从树（和溢出）页面中释放占用的空间。管理每个页面上的空闲空间对于有效利用分配给数据库的空间非常重要。这些将在本小节的其余部分进行讨论</p>
<h4 id="6521-management-of-free-pages">6.5.2.1 Management of free pages</h4>
<p>当从树中删除一个页面时，该页面将被添加到文件自由列表中以供以后重用。（自由列表起源于文件头偏移量32处：参见第86页的图3.4。）当树需要扩展时，从自由列表中取出一个页面并添加到树中。如果自由列表为空，则从本机文件系统获取一个页面。（从本机文件系统获取的页面总是附加在数据库文件的末尾。）</p>
<p>        vacuum命令用于清空文件自由列表。该命令通过压缩文件来适当地收缩数据库文件，在‘autovacuum’模式下创建的数据库将在每次COMMIT时自动收缩数据库，而不是保留数据库本身的空闲页面（如果有的话），我在235页的10.8节中讨论了autovacuum特性</p>
<h4 id="6522-management-of-page-space">6.5.2.2 Management of page space</h4>
<p>在树页面上有三个可用空间分区：</p>
<ol>
<li>单元格指针数组与单元格内容区域顶部之间的空格。最高值存储在页头偏移量5处（参见第162页图6.6）。</li>
<li>单元格内容区域内的空闲块。这些块链接在一起，链接头指针存储在页头偏移量1处。这些块通过增加它们的地址来排序。</li>
<li>单元格内容区域中分散的片段。总碎片空间量存储在页头偏移量7处。</li>
</ol>
<p>空间分配是从前两个分区开始的。在每次分配或重新分配时，相应的受影响分区都会相应地更新。空间管理器的一个职责是确保单元格指针数组和单元格内容区域不重叠，分配和释放步骤将在下面讨论。</p>
<p><strong>Cell allocation</strong>
空间分配器不分配少于4字节的空间；这样的请求被四舍五入到4字节。假设一个新的请求nRequired， nRequired &gt; = 4， bytes出现在一个页面上，而该页总共有nFree字节。nRequired &gt; nFree表示请求失败。假设nRequired &lt; nFree。分配器执行以下步骤来满足请求：</p>
<ol>
<li>
<p>它遍历空闲块列表，看看是否有足够大的块来满足请求。这是第一次匹配搜索。如果找到一个合适的块，它将执行以下操作之一</p>
<ul>
<li>
<p>如果块大小小于nRequired+ 4，则从满足请求的空闲块列表中从块开始移除该块，并将剩余空间（&lt; 3bytes）放入片段分区中。</p>
</li>
<li>
<p>否则，它满足块底部的请求，并减少块的大小nRequired字节。</p>
</li>
</ul>
</li>
<li>
<p>否则，没有足够大的空闲块来满足请求。如果中间未分配的分区中没有多少空间，或者碎片太多，空间分配器会首先对页面进行碎片整理。它在页面上运行压缩算法，以合并中间的整个空闲空间。在压缩过程中，它将现有的单元一个接一个地转移到页面的底部</p>
</li>
<li>
<p>它从空闲空间区域的底部分配nRequired字节，并将顶部值增加nRequired字节。</p>
</li>
</ol>
<p><strong>Cell deallocation（回收）</strong>
假设一个请求来释放之前由分配器分配的nfree（&gt;= 4）字节。分配器创建一个大小为nFree字节的新空闲块，并将该块插入到空闲块列表的适当位置。然后，它尝试合并释放块附近的空闲块。如果在两个相邻的空闲块之间有一个片段，它也会将片段与块合并。如果在顶部指针上有一个空闲块，它会将该块与中间未分配分区中的空间合并，并增加top的值。</p>
<h2 id="summary-2">Summary</h2>
<p>        tree模块从分页模块获取服务，并实现面向元组文件系统的抽象，供V模块使用。每个表或索引都被认为是一组经过排序的元组。这些元组分别被组织成B+树或B-树。每个活动数据库页作为内部、叶子或溢出节点属于树。（锁字节和指针映射页面除外）任何页面都不能存储来自多个树的信息。</p>
<p>        tree模块实现了树的创建和删除功能，以及树中单个元组的读取、插入和删除功能。该模块不会改变元组的内部结构，并将其视为二进制字符串。</p>
<p>所有树的根页面信息都存储在sglite master（或sqlite_temp_master）目录中。它是一个B+树，就像另一个表树一样。在为文件头留下前100字节后，它存储在第一个数据库页上。</p>
<p>        SQLite中使用的B+树算法在Knuth的著名著作《计算机编程的艺术》第3卷中有描述：“排序和搜索”。内部节点存储搜索导航信息和叶节点元组。内部节点可以拥有的条目数有一个上限和一个下限。本章概述了如何在B+树上执行点查找、下一步搜索、插入和删除操作。</p>
<h1 id="chapater-7-the-virtual-machine-module">Chapater 7 The Virtual Machine Module</h1>
<p>读完这一章，你应该能够解释/描述：</p>
<ul>
<li>五种存储数据类型及其表示</li>
<li>已编译SQL语句的内部表示形式</li>
<li>数据如何在SQL类型和C类型之间转换</li>
<li>表和索引记录的逻辑结构</li>
<li>清单类型在编码数据值方面的优点</li>
</ul>
<p><strong>本章简介</strong>
本章讨论SQLite虚拟机（VM）如何解释用内部字节码编程语言编写的应用程序，VM是存储在数据库文件中的数据的最终操纵器。它支持五种基本数据类型，即NULL、整数、real、字符串和blob，以表示文件和内存中的基本数据项。用户数据和内部表示之间的转换完全由VM完成。这一章讨论了虚拟机是如何工作的，以及在将索引和表记录存储到B-树和B+树之前，它是如何格式化索引和表记录的。</p>
<h2 id="71-virtual-machine">7.1 Virtual Machine</h2>
<p>后端最顶层的模块通常被称为虚拟数据库引擎，或者在SQLite术语中称为虚拟机（VM）。VM是SQLite的核心，是前端和后端之间的接口。核心信息（算术和逻辑）处理只发生在这个模块，因为就存储的信息而言，较低的模块是被动的。VM模块在面向元组的文件系统之上实现了一个新机器的抽象，并执行用SQLite内部字节码程序编写的应用程序。明的语言。这种编程语言专门用于搜索、读取和修改树中的元组。虚拟机接受字节码程序（由前端生成），并执行这些程序。（您可能还记得，字节码程序是SQLite中的预处理语句。）VM使用tree模块提供的基础结构来执行字节码程序并生成程序执行的输出。</p>
<p>        SQLite开发团队认为，在SQLite中使用VM对库的开发和调试有很大的好处。VM在前端（解析SOL语句并生成VM应用程序的部分）和后端（执行字节码应用程序并计算结果的部分）之间提供了良好定义的粘合剂。字节码程序比解释集成数据对象的复杂网格更容易读懂。VM还帮助SQLite引擎开发人员清楚地看到引擎试图对它编译的每个SQL语句做什么</p>
<p><strong>字节码执行跟踪:</strong> 对于普通人来说，读取字节码程序比解释数据结构值更容易。根据SQLite源代码的编译方式，它还具有跟踪的能力，每个VM应用程序的程序执行，打印每个字节码指令和执行演变的结果。</p>
<p>        字节码应用程序由sqlite3_stmt类型的内存对象表示（内部称为vdbe），可以在对象上应用以下SQLite API函数，将输入值与SOL参数关联起来，执行字节码程序，并检索程序产生的输出。关于这些函数的详细信息可以在第51页的2.2.2节中找到</p>
<ol>
<li>sqlite3_bind_*：它们为SQL参数赋值，这些参数将成为字节码程序的输入。</li>
<li>sqlite3 _step：它将字节码程序的执行推进到下一个断点，或停止点。</li>
<li>sqlite3_reset：它将程序执行倒回开始，并使相同的程序准备好使用相同的有界参数值进行新的执行</li>
<li>sqlite3_column_*：它们从程序产生的当前输出行逐列提取结果。</li>
<li>sqlite3 finalize：它连同字节码程序一起销毁sqlite3_stmt对象</li>
</ol>
<p>Vdbe对象的内部状态(也称为。预备声明)包括以下内容：</p>
<ul>
<li>a bytecode program</li>
<li>names and datatypes for al result columns.</li>
<li>values bound to input parameters,</li>
<li>ea program counter</li>
<li>an arbitrary amount of “numbered&quot; memory cells (referred to as register locations).</li>
<li>other run-time state information (such as open Btree objects, sorters, lists, sets)</li>
</ul>
<p>虚拟机不做任何查询优化。它盲目地执行字节码程序，在这样做时，它根据需要将数据从一种格式转换为另一种格式。实时数据转换是VM的主要任务：其他一切都由它执行的字节码程序控制。本章的主要部分介绍数据转换和操作任务。在此之前，我将在下一节中概述字节码编程语言、字节码程序和程序执行逻辑</p>
<h2 id="72-bytecode-programming-language">7.2 Bytecode Programming Language</h2>
<p>SQLite定义了一种内部编程语言来准备字节码程序。该语言类似于物理机和虚拟机（如Java）使用的汇编语言：它定义字节码指令。每个字节码指令做少量的信息处理工作或进行逻辑决策。字节码程序由一个或多个字节码指令组成，在一个线性指令序列中。一个字节码指令最多可以有5个操作数，其形式为（opcode, P1, P2, P3, P4, P5），其中opcode标识一个特定的字节码操作，P1, P2, P3， P4和P5保存该操作数的操作数或包含操作数的寄存器名。P1, P2， P3操作数为32位有符号整数。在任何可能导致跳转的操作中，P2操作数始终是跳转目的地的地址。它也用于其他目的。P4操作数是一个32/64位带符号整数或64位浮点数，或指向以空结尾的字符串、blob、排序比较函数、SQL函数等的指针。P5操作数是一个无符号字符。有些操作码使用所有五个操作数，有些通常忽略一个或两个操作数，有些则忽略所有五个操作数</p>
<p><strong>注意：</strong> 操作码是内部VM操作名称，它们不是SQLite接口规范的一部分。因此，它们本身或它们的操作语义可能会在不同的版本之间发生变化。SQLite开发团队不鼓励SQLite用户自己编写字节码程序。字节码编程语言严格限于内部使用。</p>
<p>        图7.1显示了一个典型的字节码程序，它相当于这个SQL查询语句。SELECT * FROM t1。表t1有两列，分别是x和y。(您可能注意到图中最上面的一行不是程序的一部分。每隔一行是一个字节码指令。示例中有14个字节码指令。)字节码程序的执行从地址0处的指令开始，一直持续到执行了一个暂停指令或程序执行控制超出了最后一条指令
<img src="http://shanks.link/img/db/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241218174922.png" alt="Figure 7.1:A typical bytecode program."></p>
<h3 id="721-bytecode-instructions">7.2.1 Bytecode instructions</h3>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/db-sqlite" rel="tag" title="db， sqlite">#db， sqlite#</a>
    
    <a href="http://shanks.link/tags/c" rel="tag" title="c">#c#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2022/04/10/%E7%86%B5%E5%A2%9E%E5%AE%9A%E5%BE%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%86%B5%E5%A2%9E%E7%90%86%E8%AE%BA%E8%AE%A9%E5%A5%BD%E5%A4%9A%E4%BA%BA%E4%B8%80%E4%B8%8B%E5%AD%90%E9%A1%BF%E6%82%9F%E4%BA%86/" rel="next" title="熵增定律：为什么熵增理论让好多人一下子顿悟了">
        <i class="fa fa-chevron-left"></i> 熵增定律：为什么熵增理论让好多人一下子顿悟了
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2024/12/03/linux-%E4%B8%8B%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8Bcpu%E4%BD%BF%E7%94%A8%E7%8E%87/" rel="prev" title="linux 下监控进程CPU使用率">
        linux 下监控进程CPU使用率 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2024</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>