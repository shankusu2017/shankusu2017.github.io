<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>OpenVPN的广播问题以及tun和tap设备的深层次挖掘 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="OpenVPN的广播问题以及tun和tap设备的深层次挖掘">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="OpenVPN的广播问题以及tun和tap设备的深层次挖掘 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2022/07/11/openvpn%E7%9A%84%E5%B9%BF%E6%92%AD%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Atun%E5%92%8Ctap%E8%AE%BE%E5%A4%87%E7%9A%84%E6%B7%B1%E5%B1%82%E6%AC%A1%E6%8C%96%E6%8E%98/" itemprop="url">
        OpenVPN的广播问题以及tun和tap设备的深层次挖掘
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-07-11">
    2022-07-11
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/openvpn" itemprop="url" rel="index">
        <span itemprop="name">openvpn</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5314 字 ~11分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>​		广播到底通过还是不通过OpenVPN呢？tap处理二层，tun处理三层，虽然tun两端ip是同一个子网，但是其二层却不是，广播是无法进行的，但是tap可以传输广播；由于windows的虚拟网卡驱动的特殊性，为了让windows也能进入vpn，OpenVPN和虚拟网卡驱动作了特殊且复杂的处理。本文详述之(注意，本文不介绍OpenVPN的各种专业术语，比如路由模式和桥接模式之类，需要的话请参考OpenVPN的文档或者FAQ)。</p>
<p>​		怎么理解tun设备建立的是“点对点”链路，因为tun隧道是三层隧道，没有二层链路，更不必说二层广播链路了，我们知道数据链路层有两种通信方式，一种是点对点的方式，比如ppp协议，另一种是广播的方式，比如以太网，tun设备建立的隧道只有两个端点，隧道中封装的是IP数据报，虽然也需要arp协议来定位隧道对端tun设备的mac，然而如果有n台机器同时连接进一个虚拟网络并且属于同一个网段的话，其它机器是不会收到这个arp报文的，因为根本就没有二层链路帮忙广播转发这个arp报文</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> <span style="color:#c34e00">mroute_extract_addr_from_packet</span> (<span style="color:#00f">struct</span> mroute_addr *src,
                 <span style="color:#00f">struct</span> mroute_addr *dest,
                 <span style="color:#00f">struct</span> mroute_addr *esrc,
                 <span style="color:#00f">struct</span> mroute_addr *edest,
                 <span style="color:#00f">const</span> <span style="color:#00f">struct</span> buffer *buf,
                 <span style="color:#00f">int</span> tunnel_type)
{
...
  <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> ret = 0;
  verify_align_4 (buf);
  <span style="color:#00f">if</span> (tunnel_type == DEV_TYPE_TUN) <span style="color:#f00;font-style:italic">//如果是tun模式，那么直接处理ipv4包头，不再处理广播的情况，但是可以处理ip多播
</span><span style="color:#f00;font-style:italic"></span>    ret = mroute_extract_addr_ipv4 (src, dest, buf);
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (tunnel_type == DEV_TYPE_TAP)  <span style="color:#f00;font-style:italic">//只有在tap的情况下才解析二层地址。
</span><span style="color:#f00;font-style:italic"></span>    ret = mroute_extract_addr_ether (src, dest, esrc, edest, buf);
  <span style="color:#00f">return</span> ret;
}
</code></pre></div><p>在XXX_addr_ether中会调用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">if</span> (is_mac_mcast_addr (eth-&gt;dest))
    ret |= MROUTE_EXTRACT_BCAST;
</code></pre></div><p>​		在以后的代码中通过这个MROUTE_EXTRACT_BCAST来判断，进而进行广播。需要注意的是，是在OpenVPN中而不是在tun/tap驱动中进行广播的，可以把tap模式下的OpenVPN进程当成一个二层交换机，而SSL出入口和tap设备出入口是交换机上的物理接口，广播数据的一种行进方向是从SSL_read(虽然OpenVPN并不调用OpenSSL的libssl的接口)中将以太帧读出并解密，然后进入OpenVPN进行广播，同时将数据交给自己一份，就是说往自己的tap设备中写入一份，广播给别的机器的数据还是要经过隧道的方式进行的，就是说将数据经过SSL协议封装然后通过socket发送。这个发送过程是通过multi_bcast来处理的，实际上multi_bcast并不是真正要发送数据，而是将待发送的数据连同其目的地信息先放入到一个容器中，然后等到时机成熟时统一处理这个容器。所谓时机成熟就是在multi_process_outgoing_link被调用时：multi_process_outgoing_link&ndash;&gt;multi_get_queue，正如multi_get_queue的注释所说，这种容器不但存放广播数据，还存放client-to-client数据以及多播数据，既然说到这里了，那么就说说client-to-client的一些话题。首先下面是一段错误的论述：</p>
<p>client-to-client实际上目前是通过server来充当路由器的，所有的client-to-client的连接都要通过server进行中转，中转数据包到达server之后首先通过ethX到达应用层并且解除ssl封装，然后server将此裸ip封装后的数据包写入tun0，通过路由之后，发现目的ip地址是到一个vpn的虚拟私有网段的一个ip地址，此时就又将数据从tun0发送出去从而又被openvpn接收，此时server查看自己是否设置了client-to-client，如果没有设置的话，并且刚刚查到的虚拟私有的ip地址不是自己的话，那么就说明这是一次client到client的通信，丢弃该数据包，反之就将之写入目的虚拟私有ip对应的真实ip的ssl连接，这个连接怎么查询得到呢？毕竟一个server可以拥有很多的client，其实有两种方式，一种是通过为每一个客户端配置一个tun虚拟网卡的方式，然后通过路由来实现区分，另一种方式就是在openvpn中解决，当数据从虚拟网卡发送时，实际上出去的是一个带有标准ip头的数据报，openvpn通过字符设备读取的就是这个数据报，它自己显然可以通过读取ip头得到目的地址，然后得知对应的真实ssl连接是哪一个。对比两种方式，第一种对效率影响很小，可以实现高速转发，但是管理复杂，第二种方式单点决策，管理简单又安全，但是在应用层解析数据对性能影响很大，可以考虑并发。</p>
<p>​		以上的论述错就错在OpenVPN是不可能如此复杂地实现client-to-client的，看了OpenVPN的源代码之后，总的来说OpenVPN的实现很简单，基本就是个转发器，看一下下面的流程：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">while</span> (true) {
...
    multi_process_io_udp (&amp;multi);
...
}
<span style="color:#00f">static</span> <span style="color:#00f">void</span> multi_process_io_udp (<span style="color:#00f">struct</span> multi_context *m)
{
...
    <span style="color:#00f">if</span> (status &amp; SOCKET_WRITE) <span style="color:#f00;font-style:italic">//写入socket
</span><span style="color:#f00;font-style:italic"></span>              multi_process_outgoing_link (m, mpp_flags);
      <span style="color:#00f">else</span> <span style="color:#c34e00">if</span> (status &amp; TUN_WRITE) <span style="color:#f00;font-style:italic">//写入虚拟网卡字符设备
</span><span style="color:#f00;font-style:italic"></span>              multi_process_outgoing_tun (m, mpp_flags);
      <span style="color:#00f">else</span> <span style="color:#c34e00">if</span> (status &amp; SOCKET_READ) { <span style="color:#f00;font-style:italic">//读取socket
</span><span style="color:#f00;font-style:italic"></span>              read_incoming_link (&amp;m-&gt;top);
              multi_release_io_lock (m);
              <span style="color:#00f">if</span> (!IS_SIG (&amp;m-&gt;top))
            multi_process_incoming_link (m, NULL, mpp_flags);
        }
      <span style="color:#00f">else</span> <span style="color:#c34e00">if</span> (status &amp; TUN_READ) { <span style="color:#f00;font-style:italic">//读取虚拟网卡字符设备
</span><span style="color:#f00;font-style:italic"></span>        read_incoming_tun (&amp;m-&gt;top);
        multi_release_io_lock (m);
        <span style="color:#00f">if</span> (!IS_SIG (&amp;m-&gt;top))
            multi_process_incoming_tun (m, mpp_flags);
        }
}
</code></pre></div><p>​		其中multi_process_outgoing_link是写socket的操作，当然在真正写入之前要做SSL封装，如果顺着往该函数里面看，就会发现写往socket的数据源自于一个队列，就是multi_get_queue中处理的队列，于是问题就是谁将数据放入了队列，由于OpenVPN的逻辑就是上面的multi_process_io_udp，因此很显然是multi_process_incoming_tun将数据放入了队列，multi_process_incoming_tun最终调用了mroute_extract_addr_from_packet，这也就和本文的最开始的广播问题联系了起来。总的来说OpenVPN在multi_process_io_udp中首先形成了下面两个通道：</p>
<ol>
<li>from tun/tap&ndash;&gt;to socket</li>
<li>from socket&ndash;&gt;to tun/tap 如果仅仅是这两个通道的话，client-to-client通信正如上面所说的那样，可是OpenVPN中还提供了另外的通道，那就是：</li>
<li>from socket&ndash;&gt;to socket 正如下面的调用路径所示：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">multi_process_incoming_link：
<span style="color:#00f">if</span> (BLEN (&amp;c-&gt;c2.buf) &gt; 0){
    process_incoming_link (c); 
</code></pre></div><p>//SSL解封装，内部将c-&gt;c2.to_tun.len设置为需要写入tun/tap的数据长度，也就是说默认是要写入到虚拟网卡设备的，但是在下面的逻辑中可能将c-&gt;c2.to_tun.len重新设置为0，什么情况呢？那就是数据已经处理过了的情况，比如这是一个client-to-client的通信，就没有必要往虚拟网卡设备写入了，也证实了上面那段话的错误。既然有to_tun，那么肯定有c-&gt;c2.to_link了，只是那是将从tun/tap读出的数据写往link也就是socket的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#00f">if</span> (TUNNEL_TYPE (m-&gt;top.c1.tuntap) == DEV_TYPE_TUN) {
        mroute_flags = mroute_extract_addr_from_packet (...);
...
        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (m-&gt;enable_c2c) { <span style="color:#f00;font-style:italic">//如果c2c启用的话
</span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">if</span> (mroute_flags &amp; MROUTE_EXTRACT_MCAST) ...<span style="color:#f00;font-style:italic">//组播
</span><span style="color:#f00;font-style:italic"></span>              <span style="color:#00f">else</span> {
                      mi = multi_get_instance_by_virtual_addr (m, &amp;dest, true); <span style="color:#f00;font-style:italic">//server作为“路由器”找到目的client的socket
</span><span style="color:#f00;font-style:italic"></span>                  <span style="color:#00f">if</span> (mi) {
                multi_unicast (m, &amp;c-&gt;c2.to_tun, mi);  <span style="color:#f00;font-style:italic">//单播发送，实际上就是放入了队列，中转源client到目的client的通信
</span><span style="color:#f00;font-style:italic"></span>                register_activity (c, BLEN(&amp;c-&gt;c2.to_tun));
                  c-&gt;c2.to_tun.len = 0; <span style="color:#f00;font-style:italic">//凡是有这个语句的表示数据已经处理过了，不需要to-tun了，或者数据出错
</span><span style="color:#f00;font-style:italic"></span>            }
            }
        }
...
</code></pre></div><p>如是说，在process_incoming_link就处理了client-to-client，根本就不需要再写入tun/tap设备，然后靠路由再写入tun/tap。同时从上述调用路径继续跟踪也可以看到基于tun的隧道是不支持广播的，因为MROUTE_EXTRACT_BCAST标志只在mroute_extract_addr_ether中被设置，而后者只有在tap模式中才会被调用，同时也只有在tap模式下调用mroute_extract_addr_ether的时候才会处理arp，并且只在一个packet filter预编译宏启用时才被启用，该宏不启用的时候在tap设备模式下arp通过正常的tap隧道被传送，而arp正是一种链路层广播。那么问题又来了，如果是tun设备模式的话，怎样找到对端地址呢？这还要看linux kernel的tun驱动程序：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">tun_net_init</span>(<span style="color:#00f">struct</span> net_device *dev)
{
    <span style="color:#00f">struct</span> tun_struct *tun = netdev_priv(dev);
    <span style="color:#00f">switch</span> (tun-&gt;flags &amp; TUN_TYPE_MASK) {
    <span style="color:#00f">case</span> TUN_TUN_DEV:  <span style="color:#f00;font-style:italic">//下面设置tun设备的点对点模式
</span><span style="color:#f00;font-style:italic"></span>        dev-&gt;hard_header_len = 0;
        dev-&gt;addr_len = 0;
        dev-&gt;mtu = 1500;
        dev-&gt;type = ARPHRD_NONE; <span style="color:#f00;font-style:italic">//没有arp，就是一个点对点的连接，路由时直接从出口发出，不再arp
</span><span style="color:#f00;font-style:italic"></span>        dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
        dev-&gt;tx_queue_len = 10;
        <span style="color:#00f">break</span>;
    <span style="color:#00f">case</span> TUN_TAP_DEV:
        dev-&gt;set_multicast_list = tun_net_mclist;
        *(u16 *)dev-&gt;dev_addr = htons(0x00FF);
        get_random_bytes(dev-&gt;dev_addr + <span style="color:#00f">sizeof</span>(u16), 4);
        ether_setup(dev);
        <span style="color:#00f">break</span>;
    }
}
</code></pre></div><p>最终就回到了最初的问题，tun设备没有链路层，它是点对点的，client到server的寻址是靠隧道进行，虽然是在一个ip网段，它们也不是靠arp来寻址的，毕竟arp寻的是链路层地址，对于没有链路层的隧道两端来讲，它还寻找什么呢？可是windows的tap设备的行为是不一样的，windows的tap驱动并不会像linux的tun驱动那样按照tun或者tap模式的不同分别设置网卡，于是就必须设置一个实际上不存在的ip地址代表对端，然后以此不存在的地址作为网关发送数据，事实上发往该网关的数据全部经由虚拟网卡发送，于是就是就走上了隧道上匝道，于是就有了net30的模式。</p>
<p>windows的tap-win32驱动始终将带有以太头的帧发出(可以抓包，看代码确认)，因此tap-win32驱动并不真的支持点对点的ip连接，真正的点对点连接一般用于专用线路上，比如SLIP协议(很简单的串行链路协议，类似HDLC)，这种点对点链路其实也并不是没有链路层，而是链路层特别简单，当然了肯定没有arp/广播等机制支持多点寻址了，windows机器一般用于个人电脑，而个人电脑一般使用以太网，根本没有个人电脑使用点对点链路的，于是windows的虚拟网卡基本就是一个以太网的虚拟适配器，这从它的名称tap-win32上也能看得出来。我们看一下tap-win32驱动的IO完成：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">CompleteIRP：
<span style="color:#00f">if</span> (p_PacketBuffer-&gt;m_SizeFlags &amp; TP_TUN) { <span style="color:#f00;font-style:italic">//如果是tun设备模式的话就不将以太头传输给用户空间
</span><span style="color:#f00;font-style:italic"></span>      offset = ETHERNET_HEADER_SIZE;
      len = (<span style="color:#00f">int</span>) (p_PacketBuffer-&gt;m_SizeFlags &amp; TP_SIZE_MASK) - ETHERNET_HEADER_SIZE;
} <span style="color:#00f">else</span> {
      offset = 0;
      len = (p_PacketBuffer-&gt;m_SizeFlags &amp; TP_SIZE_MASK);
}
</code></pre></div><p>可以看出，windows上目前的虚拟网卡并没有直接的点对点链路的概念(不知道今后有没有人去开发)，基本还是按照老一套机制来的，发送arp来进行以太网的寻址，而对于非windows的系统上运行OpenVPN的tun设备模式来讲，arp是不需要的，也是永远不会被发送的。对于windows来说，其arp是有人回应的，那么是谁回应的呢，既然事情是由tap-win32的驱动引起的，那么就不要在OpenVPN的代码中寻找这个arp回应了，还是在tap-win32驱动本身寻找吧，再次重申，OpenVPN本来在tun设备模式下不支持链路层，为了兼容windows才定制出net30的拓扑来模拟链路层的，tun模式虽然在ip层看来所有的ip处于一个网段，但是这同一个网段的ip之间的通信靠的却不是链路层(比如以太网的arp)，而是各个客户端和服务器的点对点链路，如果是tap模式，那很显然是有链路层的，并且就是以太网，arp会在client和server之间传送。回到tap-win32驱动的问题，arp是怎么发送又是怎么接收的呢？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">DriverEntry：
l_Properties-&gt;SendHandler = AdapterTransmit;
NDIS_STATUS
<span style="color:#c34e00">AdapterTransmit</span> (IN NDIS_HANDLE p_AdapterContext,
         IN PNDIS_PACKET p_Packet,
         IN UINT p_Flags)
{
...            
    <span style="color:#00f">if</span> (l_Adapter-&gt;m_tun) {
        ETH_HEADER *e;
        <span style="color:#00f">if</span> (l_PacketLength &lt; ETHERNET_HEADER_SIZE)
              <span style="color:#00f">goto</span> no_queue;

        e = (ETH_HEADER *) l_PacketBuffer-&gt;m_Data;
        <span style="color:#00f">switch</span> (ntohs (e-&gt;proto)) {
          <span style="color:#00f">case</span> ETH_P_ARP:
...   <span style="color:#f00;font-style:italic">//由于tap-win32必然要实现以太网卡的标准，实际上它就是一个以太网卡，从而arp也是必须要处理的，然而tun模式下的arp是没有意义的，于是tap-win32不得不采用一种自问自答的方式来自圆其说。
</span><span style="color:#f00;font-style:italic"></span>                ProcessARP (l_Adapter, 
                (PARP_PACKET) l_PacketBuffer-&gt;m_Data,
                l_Adapter-&gt;m_localIP,
                l_Adapter-&gt;m_remoteNetwork,
                l_Adapter-&gt;m_remoteNetmask,
                l_Adapter-&gt;m_TapToUser.dest); <span style="color:#f00;font-style:italic">//此处自答自己发出的arp请求。
</span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">default</span>: 
                <span style="color:#00f">goto</span> no_queue;
          <span style="color:#00f">case</span> ETH_P_IP:
...
          }
    <span style="color:#00f">if</span> (IS_UP (l_Adapter)) <span style="color:#f00;font-style:italic">//以下将数据包push到一个读队列，以便从用户空间ReadFile读取
</span><span style="color:#f00;font-style:italic"></span>              result = QueuePush (l_Adapter-&gt;m_Extension.m_PacketQueue, l_PacketBuffer);
...
}
BOOLEAN
ProcessARP (TapAdapterPointer p_Adapter,
        <span style="color:#00f">const</span> PARP_PACKET src,
        <span style="color:#00f">const</span> IPADDR adapter_ip,
        <span style="color:#00f">const</span> IPADDR ip_network,
        <span style="color:#00f">const</span> IPADDR ip_netmask,
        <span style="color:#00f">const</span> MACADDR mac)
{
  <span style="color:#00f">if</span> (src-&gt;m_Proto == htons (ETH_P_ARP)
      &amp;&amp; MAC_EQUAL (src-&gt;m_MAC_Source, p_Adapter-&gt;m_MAC)
      ...<span style="color:#f00;font-style:italic">//检查确认这个arp是发送给自己的
</span><span style="color:#f00;font-style:italic"></span>      &amp;&amp; src-&gt;m_ARP_IP_Destination != adapter_ip) {
      ARP_PACKET *arp = (ARP_PACKET *) MemAlloc (<span style="color:#00f">sizeof</span> (ARP_PACKET), TRUE);
      <span style="color:#00f">if</span> (arp) {
      <span style="color:#f00;font-style:italic">// Initialize ARP reply fields
</span><span style="color:#f00;font-style:italic"></span>      arp-&gt;m_Proto = htons (ETH_P_ARP);
      arp-&gt;m_MAC_AddressType = htons (MAC_ADDR_TYPE);
      arp-&gt;m_PROTO_AddressType = htons (ETH_P_IP);
      arp-&gt;m_MAC_AddressSize = <span style="color:#00f">sizeof</span> (MACADDR);
      arp-&gt;m_PROTO_AddressSize = <span style="color:#00f">sizeof</span> (IPADDR);
      arp-&gt;m_ARP_Operation = htons (ARP_REPLY);
      <span style="color:#f00;font-style:italic">// ARP addresses 
</span><span style="color:#f00;font-style:italic"></span>      COPY_MAC (arp-&gt;m_MAC_Source, mac);  <span style="color:#f00;font-style:italic">//mac实际上第3个字节比p_Adapter-&gt;m_MAC要大1，这里谎称mac是从“远端”过来的
</span><span style="color:#f00;font-style:italic"></span>      COPY_MAC (arp-&gt;m_MAC_Destination, p_Adapter-&gt;m_MAC); <span style="color:#f00;font-style:italic">//“远道而来”的arp-reply的目的地显然是p_Adapter-&gt;m_MAC，也就是自己
</span><span style="color:#f00;font-style:italic"></span>      COPY_MAC (arp-&gt;m_ARP_MAC_Source, mac);
      COPY_MAC (arp-&gt;m_ARP_MAC_Destination, p_Adapter-&gt;m_MAC);
      arp-&gt;m_ARP_IP_Source = src-&gt;m_ARP_IP_Destination;
      arp-&gt;m_ARP_IP_Destination = adapter_ip;
      InjectPacket (p_Adapter, (UCHAR *) arp, <span style="color:#00f">sizeof</span> (ARP_PACKET)); <span style="color:#f00;font-style:italic">//模拟接收arp-reply数据帧
</span><span style="color:#f00;font-style:italic"></span>      MemFree (arp, <span style="color:#00f">sizeof</span> (ARP_PACKET));
    }
      <span style="color:#00f">return</span> TRUE;
    }
  <span style="color:#00f">else</span>
    <span style="color:#00f">return</span> FALSE;
}
</code></pre></div><p>​		最终的InjectPacket调用NdisMEthIndicateReceive和NdisMEthIndicateReceiveComplete来使得虚拟网卡自己以为从物理链路收到了数据。最后总结的就是，tun模式下，linux系统或者unix系统从来不发送arp，windows发送的arp也不会到达OpenVPN进程，直接在tap-win32中模拟，也正是基于此，有了诸如net30之类的网络拓扑，至于广播的问题，严格说来tun模式没有广播，即使windows的tap-win32驱动也没有将arp广播呈现到用户空间的OpenVPN，最后，OpenVPN的体系是简单的，实现是很对称的，基本就是一个tun和link之间的转发器。</p>
<p><a href="https://juejin.cn/post/6844903737241124877">以上内容转载自笑叶林的blog</a></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/openvpn" rel="tag" title="openvpn">#openvpn#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2022/07/11/openvpn%E4%B8%AD%E8%99%9A%E6%8B%9Fip%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E9%85%8D/" rel="next" title="OpenVPN中虚拟ip地址的分配">
        <i class="fa fa-chevron-left"></i> OpenVPN中虚拟ip地址的分配
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2022/07/11/openvpn%E9%81%87%E5%88%B0%E7%9A%84secondary%E5%9C%B0%E5%9D%80%E9%97%AE%E9%A2%98/" rel="prev" title="OpenVPN遇到的Secondary地址问题">
        OpenVPN遇到的Secondary地址问题 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">569</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">45</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">50</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>