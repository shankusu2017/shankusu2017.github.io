<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>OpenVPN协议概要 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="OpenVPN协议概要">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="OpenVPN协议概要 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2022/07/07/openvpn%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%A6%81/" itemprop="url">
        OpenVPN协议概要
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-07-07">
    2022-07-07
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/openvpn" itemprop="url" rel="index">
        <span itemprop="name">openvpn</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5801 字 ~12分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="openvpn-wire-protocol-work-in-progress">OpenVPN Wire Protocol (work in progress)</h2>
<p>​		OpenVPN is an open source SSL/TLS based VPN solution which had its first release in May 2001.  This document describes the wire protocol OpenVPN makes use of for establishing end-to-end-connections.  Even though OpenVPN bases its communication on SSL/TLS, it is not a traditional SSL/TLS protocol which utilizes only TCP.  OpenVPN supports some enhanced security features as well as providing SSL/TLS connections both over TCP as well as UDP.</p>
<p>​		This document focuses on the modern/current variant of the OpenVPN protocol. Some of the features used in older variants of the protocol are not documented.</p>
<h3 id="work-in-progress">WORK IN PROGRESS</h3>
<p>​		Please not that this document is work in progress and should not considered a complete or correct documentation of the OpenVPN protocol yet. Please check the current implementations.</p>
<h3 id="introduction">Introduction</h3>
<p>​		OpenVPN is an open source SSL/TLS based VPN solution which was first released in 2001.  The communication between OpenVPN instances are based on SSL/TLS but it has added several additional features on top of the standard SSL/TLS protocol. The wire protocol this document describes will go into the depths of how OpenVPN processes communicates with each other.</p>
<p>​		The wire protocol is dynamic, which means it will be slightly different depending on which features the OpenVPN processes have been configured to use.  New implementations SHOULD implement all features.</p>
<h3 id="the-openvpn-wire-protocol">The OpenVPN Wire Protocol</h3>
<p>​		Since OpenVPN can work both in a traditional server-client setupas well as a peer-to-peer setup, this document tries to avoid the  concept of server and clients.  It will refer to these as either the local or remote sites. In a peer-to-peer setup only a single tunnel can be established, while in a server-client setup several clients can connect to a single server at the same time.</p>
<p>​		If the terms server and client are used these are almost always synonymous with the peer&rsquo;s role as either TLS server or TLS client.</p>
<h3 id="tcp-and-udp-transport-modes">TCP and UDP transport modes</h3>
<p>​		OpenVPN is capable of using both UDP and TCP for transporting SSL/TLS traffic.  The SSL/TLS protocol is strictly written for TCP but OpenVPN makes that possible through encapsulating the SSL/TLS packets and adding a reliability layer to avoid issues when packets get resent.</p>
<h3 id="basic-openvpn-packet-format">Basic OpenVPN packet format</h3>
<p>​		The wire packet identical for both UDP and TCP transport modes with one exception.  For UDP packets the size of a payload packet is derived from UDP packet length. Since TCP present a stream of bytes to the application, TCP payloads carry a 16 bits packet length indicator of the size of the payload. Splitting too large payload and combining multiple payload into packets is done by the TCP/IP stack of the operating system.</p>
<p>​		The basic OpenVPN packet format that is common to both control and data channel is that the first byte (after the length in TCP mode) in a packet consists of an opcode (highest 5 bits) that determines the packet type and a key id (low 3 bit).</p>
<h3 id="static-key-mode-and-tls-operational-modes">Static-key mode and TLS operational modes</h3>
<h4 id="static-key-mode">Static-key mode</h4>
<p>​		The OpenVPN protocol has a mode where it does not use dynamic key derivation but instead uses static keys. The mode does not make use of any TLS features, so it is called static key mode.  In this mode there is no control channel and all the data on the wire is plain encrypted packets transported over a standard UDP or TCP connection.</p>
<p>​		Peer-to-peer mode also depends on a shared secret key between both ends of the VPN tunnel.  Again, as there are no SSL/TLShandshakes between either side, this method does not have any possibilities to enable Perfect Forward Secrecy (PFS).  The data channel is encrypted solely by the shared static secret. This mode does not negotiate any ephemeral session keys for the tunneled data.</p>
<p>​		Using pre-shared secrets also significantly weakens the guarantees for no IV reuse, so modern ciphers like AES in GCM mode are not available in this mode.</p>
<p>​		This mode is deprecated and this document does not provide documentation for it.</p>
<h4 id="tls-mode">TLS mode</h4>
<p>​		With TLS mode the control channel gets activated and this requires both sides to make use of private keys and X.509  Certificates.  These requirements are due to this operational mode utilizing the  TLS/SSL protocol. This mode is also the only operational mode which uses the client-server terminology in OpenVPN.</p>
<p>​		The use of X.509 certificates on the client side is OPTIONAL and is REQUIRED on the server side.  It is highly RECOMMENDED to always enable user/password authentication when X.509  client certificates are not used.</p>
<p>​		It is highly RECOMMENDED to enforce certificate authentication against a locally controlled Certificate Authority (CA) certificate. The use of public Certification Authorities will reduce the security of the tunnel dramatically, as it can easily enable man-in-the-middle attacks where the client cannot verify the true identity of a server, or a server cannot verify the true identity of a client.</p>
<p>​		The TLS mode will use the same communication channel for both TLS handshakes and the tunnel data.  The TLS handshakesare referred to as the control channel and tunnel data is referred to as the data channel.  Each packet in TLS mode contains an OPCODE which defines if the following payload is a control channel or data channel packet.</p>
<h4 id="hmac-authentication-of-control-channel-packets">HMAC authentication of control channel packets</h4>
<p>​		HMAC authentication enables an additional authentication on the packet level.  HMAC authentication is only possible with TLS mode and will only impact the control channel.  The data channel is already protected by HMAC authentication embedded in the SSL/TLS payload.</p>
<p>​		This authentication can strengthen the overall security on both client and server side as OpenVPN will validate the HMAC signature before it is sent to the SSL/TLS layer for decryption. This can protect server and client from SSL/TLS protocol issues from all users not having access to a valid HMAC key.</p>
<p>​		The keys used for HMAC signatures are static and shared between server and all clients.  The default hashing algorithm is HMAC-SHA1 but any hashing algorithms supported by the SSL/TLS protocol can be used as long as the clients and server use the same algorithm. The choice of hashing algorithms defines the length of the HMAC field in the control packet.  HMAC-SHA1 uses 20 bytes, HMAC-SHA512 uses 64 bytes.</p>
<h4 id="hmac-authentication-subkeys">HMAC authentication subkeys</h4>
<p>​		HMAC packet authentication uses two independent pre-shared static keys for the authentication.  One key  is used for signing packets and the other key is used to verify signatures from the remote side.  The OpenVPN terminology for this is key-direction.  The key-direction defines which set of keys is used for signing and for  verification.  All clients MUST use the same  key-direction while the server MUST use the opposite key-direction.</p>
<h3 id="encrypting-control-channel-packets">Encrypting control channel packets</h3>
<p>​		With OpenVPN v2.4 and later, the client and server MAY use TLS  control channel encryption instead of HMAC authentication.  This  operational mode will encrypt the control packet channel payload  with a static key.  The static keying material is the same which  HMAC authentication uses, but the key-direction is fixed according to the local process' role (server or client).</p>
<p>​		This feature is called tls-crypt, which uses a pre-shared static key (like  the tls-auth method) to encrypt control channel packets.</p>
<p>​		Encrypting control channel packets has three main advantages:</p>
<p>​				It provides more privacy by hiding the certificate used for the TLS connection.
​        		It is harder to identify OpenVPN traffic as such.
​        		It provides &ldquo;poor-man&rsquo;s&rdquo; post-quantum security, against attackers who will never know the pre-shared key (i.e. no forward secrecy).</p>
<h4 id="control-channel-packet-encryption">Control channel packet encryption</h4>
<p>​		The following encryption method is used, based on the SIV construction , to achieve nonce misuse-resistant authenticated encryption:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">	msg        = control channel plaintext
	header     = opcode (1 byte) || session_id (8 bytes) || packet_id (8 bytes)
	Ka         = authentication key (256 bits)
	Ke         = encryption key (256 bits)
			(Ka and Ke are pre-shared keys, like with --tls-auth)

	auth_tag   = HMAC-SHA256(Ka, header || msg)
	IV         = 128 most-significant bits of auth_tag
	ciph       = AES256-CTR(Ke, IV, msg)

	output     = Header || Tag || Ciph

	This boils down to the following on-the-wire packet format:

		-opcode- || -session_id- || -packet_id- || auth_tag || * payload *
Where
		&lt;tt&gt;-XXX-&lt;/tt&gt; means authenticated, and 

		&lt;tt&gt;* XXX *&lt;/tt&gt; means authenticated and encrypted. 
</code></pre></div><p>​		Which is very similar to the current tls-auth packet format, and has the same overhead as &ldquo;&ndash;tls-auth&rdquo; with &ldquo;&ndash;auth SHA256&rdquo;.</p>
<p>​		The use of a nonce misuse-resistant authenticated encryption scheme allows us to worry less about the risks of nonce collisions.  This is  important, because in contrast with the data channel in TLS mode, we will not be able to rotate tls-crypt keys often or fully guarantee nonce  uniqueness.  For non misuse-resistant modes such as GCM , the data channel in TLS mode only has to ensure that the packet counter  never rolls over, while tls-crypt would have to provide nonce uniqueness  over all control channel packets sent by all clients, for the lifetime of the tls-crypt key.</p>
<p>​		Unlike with tls-auth, no &ndash;key-direction has to be specified for tls-crypt.  TLS servers always use key direction 1, and TLS clients always use key direction 2, which means that client-&gt;server traffic and  server-&gt;client traffic always use different keys, without requiring  configuration.</p>
<p>​		Using fixed, secure, encryption and authentication algorithms makes both  implementation and configuration easier.  If we ever want to, we can  extend this to support other crypto primitives.  Since tls-crypt should provide privacy as well as DoS protection, these should not be made negotiable.</p>
<h4 id="tls-crypt-security-considerations">tls-crypt Security considerations</h4>
<p>​		tls-crypt is a best-effort mechanism that aims to provide as much privacy and security as possible, while staying as simple as possible.  The following are some security considerations for this scheme.</p>
<p>​		The same tls-crypt key is potentially shared by a lot of peers, so it is quite likely to get compromised.  Once an attacker acquires the  tls-crypt key, this mechanism no longer provides any security against  the attacker.</p>
<p>​		Since many peers potentially use the tls-crypt key for a long time, a lot of data might be encrypted under the tls-crypt key.  This leads to two potential problems:</p>
<p>​				The <!-- raw HTML omitted -->opcode || session id || packet id<!-- raw HTML omitted --> combination might collide.
​    			This might happen in larger setups, because the session id contains just 64 bits of random.  Using the uniqueness requirement from the GCM spec  (a collision probability of less than 2^(-32)),  uniqueness is achieved when using the tls-crypt key for at most  2^16 (65536) connections per process start.  (The packet id includes the daemon start time in the packet ID, which should be  different after stopping and restarting OpenVPN.)</p>
<p>​				And if a collision happens, an attacker can <em>only</em> learn whether colliding packets contain the same plaintext.  Attackers will not be able to learn anything else about the plaintext (unless the  attacker knows the plaintext of one of these packets, of course). Since the impact is limited, we consider this an acceptable remaining risk.</p>
<p>​				The IVs used in encryption might collide.  When two IVs collide, an attacker can learn the xor of the two plaintexts by xor-ing the  ciphertexts.  This is a serious loss of confidentiality.  The IVs   are 128-bit, so when HMAC-SHA256 is a secure PRF (an assumption  that must also hold for TLS), and we use the same uniqueness  requirement from ,   this limits the total amount of control channel messages for all peers in the setup to 2^48.  Assuming a  large setup of 2^16 (65536) clients, and a (conservative) number of  2^16 control channel packets per connection on average, this means   that clients may set up 2^16 connections on average.  We think these   numbers are reasonable.</p>
<h4 id="client-specific-tls-crypt-keys-tls-crypt-v2">Client-specific tls-crypt keys (tls-crypt-v2)</h4>
<p>​		This section describes configuring OpenVPN to use client-specific tls-crypt keys.</p>
<h5 id="rationale">Rationale</h5>
<p>​		<code>--tls-auth</code> and <code>tls-crypt</code> use a pre-shared group key,  which is shared among all clients and servers in an OpenVPN deployment.  If any client or server is compromised, the attacker will have access to this shared key, and it  will no longer provide any security.  To reduce the risk of  losing pre-shared keys, <code>tls-crypt-v2</code> adds the ability to  supply each client with a unique tls-crypt key.  This allows  large organizations and VPN providers to profit from the same  DoS and TLS stack protection that small deployments can already achieve using <code>tls-auth</code> or <code>tls-crypt</code>.</p>
<p>​		Also, for <code>tls-crypt</code>, even if all these peers succeed in  keeping the key secret, the key lifetime is limited to roughly   8000 years, divided by the number of clients (see the  <code>--tls-crypt</code> section of the man page).   [FIXME/flichtenheld: either include or remove reference]  Using client-specific   keys, we lift this lifetime requirement to roughly 8000 years  for each client key (which &ldquo;Should Be Enough For Everybody (tm)&quot;).</p>
<h5 id="introduction-1">Introduction</h5>
<p>​	<code>tls-crypt-v2</code> uses an encrypted cookie mechanism to introduce  client-specific tls-crypt keys without introducing a lot of server-side state.  The client-specific key is encrypted using a server key.  The server key is the   same for all servers in a group.  When a client connects, it first sends the  encrypted key to the server, such that the server can decrypt the key and all  messages can thereafter be encrypted using the client-specific key.</p>
<p>​		A wrapped (encrypted and authenticated) client-specific key can also contain  metadata.  The metadata is wrapped together with the key, and can be used to   allow servers to identify clients and/or key validity.  This allows the server   to abort the connection immediately after receiving the first packet, rather   than performing an entire TLS handshake.  Aborting the connection this early greatly improves the DoS resilience and reduces attack surface against   malicious clients that have the <code>tls-crypt</code> or <code>tls-auth</code> key.  This is particularly relevant for large deployments (think lost key or disgruntled employee) and VPN providers (clients are not trusted).</p>
<p>​		To allow for a smooth transition, <code>tls-crypt-v2</code> is designed such that a server can enable both <code>tls-crypt-v2</code> and either <code>tls-crypt</code> or  <code>tls-auth</code>.  This is achieved by introducing a CONTROL_HARD_RESET_CLIENT_V3  opcode, that indicates that the client wants to use <code>tls-crypt-v2</code> for the  current connection.</p>
<h5 id="implementation">Implementation</h5>
<p>​		When setting up a tls-crypt-v2 group (similar to generating a tls-crypt or tls-auth key previously):</p>
<p>​				Generate a tls-crypt-v2 server key using OpenVPN&rsquo;s <code>--genkey tls-crypt-v2-server</code>. This key contains 2 512-bit keys, of which we use:</p>
<p>​						the first 256 bits of key 1 as AES-256-CTR encryption key <code>Ke</code></p>
<p>​						the first 256 bits of key 2 as HMAC-SHA-256 authentication key <code>Ka</code></p>
<p>​				This format is similar to the format for regular <code>tls-crypt</code>/<code>tls-auth</code>and data channel keys, which allows us to reuse code.</p>
<p>​	 			Add the tls-crypt-v2 server key to all server configs  (<code>tls-crypt-v2 /path/to/server.key</code>)</p>
<p>​		When provisioning a client, create a client-specific tls-crypt key:</p>
<p>​		Generate 2048 bits client-specific key <code>Kc</code> using OpenVPN&rsquo;s <code>--genkey tls-crypt-v2-client</code></p>
<p>​		Optionally generate metadata.</p>
<p>​		The first byte of the metadata determines the type.  The initial implementation supports the following types:</p>
<p>​				0x00 (USER): User-defined free-form data.
​            	0x01 (TIMESTAMP): 64-bit network order unix timestamp of key generation.</p>
<p>​		The timestamp can be used to reject too-old tls-crypt-v2 client keys.</p>
<p>​		User metadata could for example contain the users certificate serial, such that the incoming connection can be verified against a CRL.</p>
<p>​		If no metadata is supplied during key generation, OpenVPN defaults to the  TIMESTAMP metadata type.</p>
<p>​		Create a wrapped client key <code>WKc</code>, using the same nonce-misuse-resistant SIV construction we use for tls-crypt:</p>
<p>​				len = len(WKc) (16 bit, network byte order)</p>
<p>​				T = HMAC-SHA256(Ka, len || Kc || metadata)</p>
<p>​				IV = 128 most significant bits of T</p>
<p>​				WKc = T || AES-256-CTR(Ke, IV, Kc || metadata) || len</p>
<p>​		Note that the length of <code>WKc</code> can be computed before composing <code>WKc</code>, because the length of each component is known (and AES-256-CTR does not add any padding).</p>
<p>​		Create a tls-crypt-v2 client key: PEM-encode <code>Kc || WKc</code> and store in a   file, using the header <!-- raw HTML omitted -->&mdash;&ndash;BEGIN OpenVPN tls-crypt-v2 client key&mdash;&ndash;<!-- raw HTML omitted --> and the footer <!-- raw HTML omitted -->&mdash;&ndash;END OpenVPN tls-crypt-v2 client key&mdash;&ndash;<!-- raw HTML omitted -->.  (The PEM   format is simple, and following PEM allows us to use the crypto library functions  for en/decoding.)</p>
<p>​		Add the tls-crypt-v2 client key to the client config  (<code>tls-crypt-v2 /path/to/client-specific.key</code>)</p>
<p>When setting up the OpenVPN connection:</p>
<p>​		The client reads the tls-crypt-v2 key from its config, and:</p>
<p>​				loads <code>Kc</code> as its tls-crypt key,</p>
<p>​				stores <code>WKc</code> in memory for sending to the server.</p>
<p>​		To start the connection, the client creates a P_CONTROL_HARD_RESET_CLIENT_V3  message, wraps it with tls-crypt using <code>Kc</code> as the key, and appends  <code>WKc</code>.  (<code>WKc</code> must not be encrypted, to prevent a chicken-and-egg problem.)</p>
<p>​		The server receives the P_CONTROL_HARD_RESET_CLIENT_V3 message, and</p>
<p>​		reads the WKc length field from the end of the message, and extracts WKc  from the message unwraps <code>WKc</code></p>
<p>​		uses unwrapped <code>Kc</code> to verify the remaining   P_CONTROL_HARD_RESET_CLIENT_V3 message&rsquo;s (encryption and) authentication.</p>
<p>​		The message is dropped and no error response is sent when any of these steps fails (DoS protection).</p>
<p>​		Server optionally checks metadata using a &ndash;tls-crypt-v2-verify script</p>
<p>​		This allows early abort of connection, <em>before</em> we expose any of the notoriously dangerous TLS, X.509 and ASN.1 parsers and thereby reduces the attack surface of the server.</p>
<p>​		The metadata is checked <em>after</em> the OpenVPN three-way handshake has completed, to prevent DoS attacks.  (That is, once the client has proved to the server that it possesses Kc, by authenticating a packet that contains the session ID picked by the server.)</p>
<p>​		A server should not send back any error messages if metadata verification fails, to reduce attack surface and maximize DoS resilience.</p>
<p>Client and server use <code>Kc</code> for (un)wrapping any following control channel  messages. Setting up connection with cookie support</p>
<p>​				To avoid exhaustion attack and keeping state for connections that fail to complete the three way handshake, the OpenVPN server will use its own session  id as challenge that the client must repeat in the third packet of the  handshake. This introduces a problem. If the server does not keep the wrapped client key from the initial packet, the server cannot decode the third packet. Therefore, tls-crypt-v2 allows resending the wrapped key in the third  packet of the handshake with the P_CONTROL_WKC_V1 message. The modified handshake is as follows (the rest of the handshake is unmodified):</p>
<p>​				The client creates the P_CONTROL_HARD_RESET_CLIENT_V3 message as before    but to indicate that it supports resending the wrapped key by setting 	the   packet id of the replay id to 0x0f000000 where the first byte indicates the  early negotiation support and the next byte the flags. All tls-crypt-v2   implementations that support early negotiation, MUST  also support resending the wrapped key. The flags byte is therefore empty.</p>
<p>​				The server responds with a P_CONTROL_HARD_RESET_V2 message. Instead of having an empty payload like normally, the payload consists of TLV (type (uint16),  length (uint16), value) packets. TLV was chosen  to allow extensibility in the future. Currently only the following TLV is  defined:</p>
<p>​					flags - type 0x01, length 2.</p>
<p>​		Bit 1 indicates that the client needs to resend the WKC in the third packet.</p>
<p>​		Instead of normal P_ACK_V1 or P_CONTROL_V1 packet, the client will send a P_CONTROL_WKC_V1 packet. The P_CONTROL_WKC_V1 is identical to a normal   P_CONTROL_V1 packet but with the WKc appended.</p>
<p>​		Normally the first message of the client is either P_ACK_V1, directly   followed by a P_CONTROL_V1 message that contains the TLS Client Hello or  just a P_CONTROL_V1 message. Instead of a P_ACK_V1 message the client should  send a P_CONTROL_WKC_V1 message with an empty payload. This message must  also include an ACK for the P_CONTROL_HARD_RESET_V2 message.</p>
<p>​		When directly sending the TLS Client Hello message in the P_CONTROL_WKC_V1  message, the client must ensure that the resulting P_CONTROL_WKC_V1 message  with the appended WKc does not extend the control message length.</p>
<h5 id="considerations">Considerations</h5>
<p>​		To allow for a smooth transition, the server implementation allows  <code>tls-crypt</code> or <code>tls-auth</code> to be used simultaneously with <code>tls-crypt-v2</code>.  This specification does not allow simultaneously using <code>tls-crypt-v2</code> and   connections without any control channel wrapping, because that would break DoS resilience.</p>
<p>​	WKc includes a length field, so we leave the option for future extension of the  P_CONTROL_HEAD_RESET_CLIENT_V3 message open.  (E.g. add payload to the reset to  indicate low-level protocol features.)</p>
<p>​		<code>tls-crypt-v2</code> uses fixed crypto algorithms, because:</p>
<p>​			The crypto is used before we can do any negotiation, so the algorithms have to be predefined.</p>
<p>​			The crypto primitives are chosen conservatively, making problems with these primitives unlikely.</p>
<p>​			Making anything configurable adds complexity, both in implementation and  usage.  We should not add any more complexity than is absolutely necessary.</p>
<p>​		Potential <code>tls-crypt-v2</code> risks:</p>
<p>​				Slightly more work on first connection (<code>WKc</code> unwrap + hard reset unwrap) than with <code>tls-crypt</code> (hard reset unwrap) or <code>tls-auth</code> (hard reset auth).</p>
<p>​				Flexible metadata allow mistakes (So we should make it easy to do it right.  Provide tooling to create client keys based on cert serial + CA fingerprint, provide script that uses CRL (if available) to drop revoked keys.)</p>
<h3 id="pushing-configuration-options-and-occ">Pushing configuration options and OCC</h3>
<p>​	TBD</p>
<h3 id="control-channel">Control channel</h3>
<p>​		OpenVPN communicates over two channels which are multiplexed over the same connection; control channel and data channel.  The control channel is used for passing configuration and environment data between each side of the tunnel, including encryption session keys.  The data  channel carries the encrypted tunnel data.  The OPCODE determines which channel the packet belongs to.</p>
<h4 id="overview-of-opcodes">Overview of OPCODEs</h4>
<p>​		Each packet MUST contain an OPCODE.  This is located within the first byte in each UDP packet and the third byte in TCP packets.  The high 5  bits contains the OPCODE and the lower 3 bits defines a key-id.  The  OPCODE defines the contents of the following payload.</p>
<p>​	OPCODE			CHANNAL							SHORT NAME					    	PAYLOAD					STATUS</p>
<p>​         1						Control      		CONTROL_HARD_RESET_CLIENT_V1											Obsolete</p>
<p>​	     2						Control      		CONTROL_HARD_RESET_SERVER_V1											Obsolete</p>
<p>​	 	3						Control      		     CONTROL_SOFT_RESET_V1					   -		   				   Obsolete</p>
<p>​		 4						Control      						CONTROL_V1									X							  Current</p>
<p>​		 5						Control      							  ACK_V1										X 							 Current</p>
<p>​		 6						Data           							DATA_V1										X							  Current</p>
<p>​		 7						Control      		CONTROL_HARD_RESET_CLIENT_V2			 -							   Current</p>
<p>​		 8						Control             CONTROL_HARD_RESET_SERVER_V2		     -   							Current</p>
<p>​		 9						Data      		     					DATA_V2										X							  Current</p>
<p>​		10						Control      		CONTROL_HARD_RESET_CLIENT_V3			X							 Current</p>
<p>​	    11						Control      				CONTROL_WKC_V1								 X							 Current</p>
<h4 id="the-control-channel">The Control Channel</h4>
<p>​		The control channel is used to pass configuration and environment information in addition to handle the SSL/TLS handshake process between the server and client.</p>
<h5 id="control-channel-wire-packet-structure">Control channel wire packet structure</h5>
<p>​		The following table lists all fields found in control channel  packets.  The fields arrive in the order they are listed in the  table.</p>
<p>​		The TLS auth column indicates fields used when additional HMAC authentication data is added to the control channel packets.</p>
<p>​			   Field name							Length (bits)						TLS auth					Comment</p>
<p>​         		  pkt_len      			                 16																	Packet length (TCP only)</p>
<p>​	       		OPCODE      			                5</p>
<p>​	 			  key_id      		     				   3											X</p>
<p>​		 		  own session_id      		       64										  X</p>
<p>​					HMAC      							128-512								  X 					Algorithm defines length</p>
<p>​					replay_packet_id      			64										  X 					ID used for replay protection.</p>
<p>​					acked_pktid_len      			  8										   X</p>
<p>​					acked_pktid_list      			32 * n								    X 					List length defined by acked_pktid_len.</p>
<p>​					peer session id      			   64										 X 					Session ID of the remote peer. Present if acked_pktid_len &gt;= 1</p>
<p>​					packet_id      						  32										X 					ID of the control channel packet. ACK packets lack a packet_id</p>
<p>​					payload      							(var)									 X 					Can be empty</p>
<p>​</p>
<h5 id="field-pkt_len">Field: pkt_len</h5>
<p>​		This field is only present when TCP is used as the transport protocol.  This value should be the number of bytes being transported in this packet, excluding the pkt_len field.</p>
<h5 id="field-opcode">Field: OPCODE</h5>
<p>​		The OPCODE field is described in detail in the  <!-- raw HTML omitted -->Control Channel OPCODEs<!-- raw HTML omitted --> section.</p>
<h5 id="field-key_id">Field: key_id</h5>
<p>​		This is used to indicate which keys to use when  processing the payload.  This has a range from 0 to    7. All new sessions starts with key_id 0. After a key renegotiation the key_id will increase by one. After  key_id 7, the key_id wraps to 1.</p>
<p>​		OpenVPN uses 256 byte of key material for encryption/decryption of the data channel. The format of this key material is the following:</p>
<p>​			struct datakeys {
​    				uint8_t key_c2s[64];
​    				uint8_t auth_c2s[64];
​    				uint8_t key_s2c[64];
​    				uint8_t auth_s2c[64];
​			}</p>
<p>​        All these keys provide more than enough material to provide encryption keys for all encryption and authentication algorithms. E.g. when 128 bit are required for an encryption cipher, only the first 16 bytes are used.</p>
<p>​		key_c2s and auth_c2s are used to encrypt/authenticate data from client to server and key_s2c and auth_s2c are used to encrypt/authenticate from server to client.</p>
<p>​		This key structure is normally generated by using <!-- raw HTML omitted -->RFC 5705 key material exporter<!-- raw HTML omitted --> from the Control Channel session with the label <!-- raw HTML omitted -->EXPORTER-OpenVPN-datakeys<!-- raw HTML omitted --> and using the 256 bytes length of the structure.</p>
<p>​		Older clients use the mechanism described in the section OpenVPN data channel PRF.</p>
<h4 id="peer-id">Peer-ID</h4>
<p>​		The purpose of this feature is to allow a client to float between various client IP addresses and UDP ports.  When a client floats it means that the established encryption and session keys will be reused when the client&rsquo;s source IP address or source port changes.  Reasons for such changes can be NAT firewalls interrupting longer lasting established connections, mobile devices moving from WLAN to a mobile data carrier (such as GPRS, 3G,
LTE, etc) and similar scenarios.</p>
<h5 id="requirements">Requirements</h5>
<p>​			Each client implementing Peer-ID support MUST indicate its support with the IV_PROTO=2 <!-- raw HTML omitted -->peerinfo<!-- raw HTML omitted --> variable.  By sending IV_PROTO=2 to the server, it means  the client will be able to use the DATA_V2 packet format.  When  the server acknowledges that the client supports IV_PROTO=2/DATA_V2   it SHOULD assign an unique Peer-ID to the client.  The server is responsible of keeping track of which Peer-ID is related to which  active session and MUST ensure no active clients share the same Peer-ID.</p>
<p>​		Clients MUST accept the peer-id option being passed to it via a  PUSH_REPLY message and MUST use this value as the Peer-ID in all  DATA_V2 packets.  Clients MUST provide a valid Peer-ID in all   DATA_V2 packets, but it can be the ID used to indicate Peer-ID being disabled.</p>
<p>​		Server implementations MUST support the IV_PROTO=2 and the DATA_V2 packet format and MUST evaluate the response from the client before assigning and push ing a peer-id option to the client.  The server  SHOULD use the DATA_V2 packet formats when communicating  with the clients.</p>
<p>​		The client is not expected to parse the Peer-ID in DATA_V2 packets.  The server should send the same Peer-ID provided in packets from the  server to client.</p>
<p>​		The Peer-ID is included protected in the HMAC signature/AEAD tag of DATA_V2 packets.</p>
<h5 id="allowing-floating-clients">Allowing floating clients</h5>
<p>​		The server MUST ensure the packet integrity is intact, through checking HMAC or GCM authentication tags, replay protection, etc</p>
<p>of the DATA_V2 packet.</p>
<p>​		In addition the server MUST ensure the float does not clobber a pre-existing client, such as a client floating to a source IP address used by a different client unless it can be verified that the pre-existing client is a previous instance of the floating client.</p>
<h5 id="replay-protection">Replay protection</h5>
<p>​		The replay protection in OpenVPN uses a fairly standard approach with a sliding window with a number of packets n and a timeout t</p>
<p>​				If a packet arrives that has a higher sequence number than the highest packet sequence seen so far, it is accepted</p>
<p>​				If a packet arrives out of order, it will only be accepted if the difference between its sequence number and the highest sequence number received so far is less than n.</p>
<p>​				If a packet arrives out of order, it will only be accepted if it arrives no later than t seconds after any packet containing a higher sequence number.</p>
<p>​				A packet will be rejected if it is a replay</p>
<p>​		This means that a client needs to keep track of the highest received sequence number and the n sequence ids lower than the highest received sequence number.</p>
<p>​		Old OpenVPN peers before 2.4 will enforce a strict packet ordering when using TCP that does not allow reordering.</p>
<h4 id="aead-encrypted-data-channel-packet">AEAD encrypted data channel packet</h4>
<pre><code>		struct aead_packet {
				int opcode:5;
				int key_id:3;
				int peer_id:24;
				uint32_t packet_id;
				uint8_t[16] authentication_tag;
				uint8_t* encrypted_payload;
		}
</code></pre>
<p>​		The packet_id together with the implicit IV forms the IV for decryption. The packet_id is also used for the replay protection.</p>
<p>​				IV = packet_id | implicit_iv;</p>
<p>​		The implicit part of IV is filled by first bytes of the auth_c2s/auth_s2c of the data channel key. For the current implemented AEAD ciphers Chacha20-Poly1305 and AES-GCM the IV length is 96 bits, 32 bits are from packet_id and the remaining 64 bits (the implicit IV part) are  taken from the data channel key.</p>
<p>​		For DATA_V2 packets the authenticated data <!-- raw HTML omitted -->includes<!-- raw HTML omitted --> opcode,  key_id and peer_id. For DATA_V1 packets the authenticated data starts  on the first byte of packet_id, not including opcode and key_id.</p>
<p>​		authenticated_data_v1 = packet_id | payload
​		authenticated_data_v2 = opcode| key_id | peer_id | packet_id | payload</p>
<p>​	The tag size is always 128 bit (16 bytes). (Same size as in TLS)</p>
<h4 id="cbcofbctr-encrypted-packet">CBC/OFB/CTR encrypted packet</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">struct data_packet_cbc {
			int opcode:5;
    	int key_id:3;
    	int peer_id:24;
    	uint8_t[HMAC_LEN] hmac;
    	uint8_t[IV_LEN] iv;
    	uint32_t encrypted_packet_id;
    	uint8_t* encrypted_payload
}
struct data_packet_xfb {
    	int opcode:5;
    	int key_id:3;
    	int peer_id:24;
    	uint8_t[HMAC_LEN] hmac;
    	uint8_t[IV_LEN] iv;
    	uint8_t* encrypted_payload
}
</code></pre></div><p>​		HMAC_LEN depends on the length of the HMAC being used, e.g. 20 bytes for SHA1, 32 for SHA256. If no authentication is used (DEPRECATED) then the  length of the field is 0.</p>
<p>​		The HMAC is computed over the complete remainder of the packet. opcode, key_id, and peer_id are NOT included in the HMAC calculation. If HMAC verification fails decryption of the packet MUST NOT be attempted. OpenVPN implements the  encrypt-then-MAC approach.</p>
<p>​	IV_LEN depends on the IV of used cipher. For AES in CBC, CFB and OFB this is 128 bits (IV_LEN=8), for Blowfish in CBC mode (DEPRECATED) 64 bits (IV_LEN=4). For generating   the IV use best practices. OpenVPN generates the CBC IV as random bytes with an PRNG. For OFB and CFB the IV has the following format:</p>
<p>​		IV = 64 bit packet ID | IV_remainder</p>
<p>​		The IV_remainder SHOULD be random bytes. OpenVPN 2.x uses all zeros instead.</p>
<p>​		The packet ID in CBC mode is encrypted and included before the payload. In contrast to that, the packet ID in OFB and CFB mode are the first 64 bit of the IV.</p>
<p>​		For unencrypted data packets the same format as CBC without IV is used.</p>
<h3 id="control-channel-messages">Control channel messages</h3>
<h4 id="message-format">Message format</h4>
<p>​		After the control channel has been established the format switch from the binary format of the key exchange message to a text based format. The message are sent in plain text. The current implementation does not allow a message to span more than one TLS record.</p>
<h4 id="push_request">PUSH_REQUEST</h4>
<p>​		Format: PUSH_REQUEST</p>
<p>​		This message is sent from the client to the server and instructs the server that the client is ready to receive a <!-- raw HTML omitted -->PUSH_REPLY<!-- raw HTML omitted --> message. The message is periodically repeated  until the <!-- raw HTML omitted -->PUSH_REPLY<!-- raw HTML omitted --> is received for compatibility with old OpenVPN servers and to act as  a keepalive.</p>
<h4 id="push_reply">PUSH_REPLY</h4>
<p>​		Format: PUSH_REPLY [comma separated options]</p>
<p>​		This message is sent from the server to the client and has dynamic configuration for the client. See the section &ldquo;dynamic configuration option&rdquo; for a detailed description of the options. [FIXME/flichtenheld: proper reference]</p>
<p>​		If the client has set the IV_PROTO_REQUEST_PUSH bit in the IV_PROTO peerinfo  client variable the server MAY send a <!-- raw HTML omitted -->PUSH_REPLY<!-- raw HTML omitted -->  without waiting for the <!-- raw HTML omitted -->PUSH_REQUEST<!-- raw HTML omitted --> from the client.</p>
<h4 id="auth_pending">AUTH_PENDING</h4>
<p>​	Format:
​		AUTH_PENDING</p>
<p>or</p>
<p>​		AUTH_PENDING,flags</p>
<p>​		This message is sent from the server to the client to indicate that a multi factor authentication is in use and the authentication is not completed. The authentication can continue inband or out-of-band.</p>
<p>​		<!-- raw HTML omitted -->flags<!-- raw HTML omitted --> is a comma separate key-value list. Currently <!-- raw HTML omitted -->timeout time<!-- raw HTML omitted --> is defined and defines the maximum time the server expects the client to stay in the pending auth state.</p>
<p>​		The client indicates if the extended format with flags is supported by setting the IV_PROTO_AUTH_PENDING_KW bit in the IV_PROTO  peerinfo  client variable. All new clients MUST support the extended format.</p>
<h4 id="restart-and-halt">RESTART and HALT</h4>
<p>​		Format:</p>
<p>​			RESTART[,message]</p>
<p>​			HALT[,message]</p>
<p>​		and</p>
<p>​			RESTART,[[flags]]message</p>
<p>​		These message are sent from the server to the client and the client to  terminate a session. With <!-- raw HTML omitted -->HALT<!-- raw HTML omitted --> the client is expected to also not try to try reconnect. With <!-- raw HTML omitted -->RESTART<!-- raw HTML omitted --> the client is expected to reconnect. <!-- raw HTML omitted -->flags<!-- raw HTML omitted --> is  a list of characters that must follow directly after the comma and is  enclosed in <!-- raw HTML omitted -->[<!-- raw HTML omitted --> and <!-- raw HTML omitted -->]<!-- raw HTML omitted -->. The client SHOULD purge username and password before  reconnecting if flags contains <!-- raw HTML omitted -->P<!-- raw HTML omitted --> and reconnect to the next server unless  <!-- raw HTML omitted -->N<!-- raw HTML omitted --> is in flags in which case it should reconnect to the same server. E.g.   when the client receives a <!-- raw HTML omitted -->RESTART[PN]<!-- raw HTML omitted --> message it should reconnect to same   server with the same username and password.</p>
<p>​			The optional <!-- raw HTML omitted -->message<!-- raw HTML omitted --> indicates a message that can relayed to the user.</p>
<h4 id="auth_failed">AUTH_FAILED</h4>
<p>​		Format:</p>
<p>​				AUTH_FAILED[,message]</p>
<p>​				AUTH_FAILED,SESSION:message</p>
<p>​				AUTH_FAILED,TEMP[keywords]:message
​				AUTH_FAILED,TEMP:message</p>
<p>​		This message indicates to a client that an authentication attempt was unsuccessful. This message is mostly send in response to a <!-- raw HTML omitted -->PULL_REQUEST<!-- raw HTML omitted --> or when a client attempts to   renegotiates a TLS session.</p>
<p>​		The optional message can be relayed to the user. If the message starts with <!-- raw HTML omitted -->SESSION<!-- raw HTML omitted -->, this  indicates that current credentials are longer valid. This is mostly used to indicate that   the temporary session credentials that were pushed with &ldquo;auth-token&rdquo; and &ldquo;auth-token-user&rdquo;    should be purged and the client should reconnect in the same way as a new connection.</p>
<p>​		The <!-- raw HTML omitted -->AUTH_FAILED,TEMP<!-- raw HTML omitted --> message indicates that the authentication temporarily failed and should  the client continue to retry to connect. The server can optionally give a user readable message   and hint the client a behavior how to proceed. The keywords of <!-- raw HTML omitted -->AUTH_FAILED,TEMP<!-- raw HTML omitted --> are comma separated keys/values. Currently defined are:</p>
<p>​				<!-- raw HTML omitted -->backoff s<!-- raw HTML omitted --> - instructs the client to wait at least s seconds before the next connection attempt. If  the client has already a higher delay before reconnecting, the delay should NOT be shortened.
​        		<!-- raw HTML omitted -->advance addr<!-- raw HTML omitted --> - Instructs the client to reconnect to the (IP) address of the current server.
​         		<!-- raw HTML omitted -->advance remote<!-- raw HTML omitted --> - Instructs the client to skip the remaining IP addresses of the current server and instead
connect to the next server specified in the configuration file
​        		<!-- raw HTML omitted -->advance no<!-- raw HTML omitted --> - Instructs the client to retry connecting to the same server again.</p>
<p>​		For example a server that might send <!-- raw HTML omitted -->AUTH_FAILED,TEMP[backoff 42,advance no]: No free IP addresses<!-- raw HTML omitted --> to indicate that the VPN connection can currently not succeed and instructs the client to retry in 42 seconds again.</p>
<p>​		The client will announce the capability of understanding <!-- raw HTML omitted -->AUTH_FAILED,TEMP<!-- raw HTML omitted --> message by setting the  IV_PROTO_AUTH_FAILED_TEMP bit in the IV_PROTO <!-- raw HTML omitted -->peerinfo<!-- raw HTML omitted --> client variable. A client that does not understand the <!-- raw HTML omitted -->AUTH_FAILED,TEMP<!-- raw HTML omitted --> message  will treat this recoverable error as a non-recoverable error.</p>
<h4 id="cr_response">CR_RESPONSE</h4>
<p>​		 Format: 	CR_RESPONSE,base64reply</p>
<p>​		This message indicates a reply to prior challenge/response request. The response is specific to the challenge response and is encoded with base64.</p>
<h4 id="info_pre-and-info">INFO_PRE and INFO</h4>
<p>​	 Format:</p>
<p>​		INFO_PRE,EXTRA</p>
<p>​		INFO,EXTRA</p>
<p>​		This message is used to send pending auth parameters. See the section on pending auth for more details   on the format of the <!-- raw HTML omitted -->EXTRA<!-- raw HTML omitted --> parameter. [FIXME/flichtenheld: proper reference]</p>
<h3 id="cipher-negotiation">Cipher negotiation</h3>
<p>​		TBD</p>
<h3 id="tls-mode-and-pki">TLS mode and PKI</h3>
<p>​	TBD</p>
<h3 id="user-authentication">User authentication</h3>
<h4 id="userpassword-authentication">User/password authentication</h4>
<p>​		TBD</p>
<h4 id="challenge-response-authentication">Challenge-Response authentication</h4>
<p>​		TBD</p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/openvpn" rel="tag" title="openvpn">#openvpn#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2022/07/07/openvpn%E5%8D%8F%E8%AE%AE%E4%B9%8Bcontrol-packet-wire-format/" rel="next" title="OpenVPN协议之Control packet wire format">
        <i class="fa fa-chevron-left"></i> OpenVPN协议之Control packet wire format
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2022/07/06/vpn%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%B9%8B%E9%9A%A7%E9%81%93%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0/" rel="prev" title="VPN原理及实现之隧道的一种实现">
        VPN原理及实现之隧道的一种实现 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">541</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">42</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">47</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>