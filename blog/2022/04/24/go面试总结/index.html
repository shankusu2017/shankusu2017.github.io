<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Go面试总结 - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="Go面试总结">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="Go面试总结 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2022/04/24/go%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" itemprop="url">
        Go面试总结
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2022-04-24">
    2022-04-24
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/%E9%9D%A2%E8%AF%95" itemprop="url" rel="index">
        <span itemprop="name">面试</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4669 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://www.modb.pro/db/247446">原文链接</a></p>
<h1 id="相比较于其他语言-go-有什么优势或者特点">相比较于其他语言, Go 有什么优势或者特点？</h1>
<ul>
<li>Go 允许跨平台编译，编译出来的是二进制的可执行文件，直接部署在对应系统上即可运行。</li>
<li>Go 在语言层次上天生支持高并发，通过 goroutine 和 channel 实现。channel 的理论依据是 CSP 并发模型， 即所谓的<code>通过通信来共享内存</code>
；Go 在 runtime 运行时里实现了属于自己的调度机制：GPM，降低了内核态和用户态的切换成本。</li>
<li>Go 的代码风格是强制性的统一，如果没有按照规定来，会编译不通过。</li>
</ul>
<h1 id="golang-里的-gpm-模型">Golang 里的 GPM 模型？</h1>
<p>GPM 模型是 golang 自己的一个调度模型，它抽象出了下面三个结构：</p>
<ul>
<li><code>G：</code>
也就是协程 goroutine，由 Go runtime 管理。我们可以认为它是用户级别的线程。</li>
<li><code>P：</code>
processor 处理器。每当有 goroutine 要创建时，会被添加到 P 上的 goroutine 本地队列上，如果 P 的本地队列已满，则会维护到全局队列里。</li>
<li><code>M：</code>
系统线程。在 M 上有调度函数，它是真正的调度执行者，M 需要跟 P 绑定，并且会让 P 按下面的原则挑出个 goroutine 来执行：</li>
</ul>
<p>优先从 P 的本地队列获取 goroutine 来执行；如果本地队列没有，会从其他的 P 上偷取 goroutine；如果其他 P 上也没有，则会从全局队列上获取 goroutine。</p>
<h1 id="goroutine-的协程有什么特点和线程相比">goroutine 的协程有什么特点，和线程相比？</h1>
<p>goroutine 非常的<strong>轻量</strong>，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。</p>
<p>而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。</p>
<h1 id="go-的垃圾回收机制">Go 的垃圾回收机制？</h1>
<p>Go 采用的是三色标记法，将内存里的对象分为了三种：</p>
<ul>
<li>白色对象：未被使用的对象；</li>
<li>灰色对象：当前对象有引用对象，但是还没有对引用对象继续扫描过；</li>
<li>黑色对象，对上面提到的灰色对象的引用对象已经全部扫描过了，下次不用再扫描它了。</li>
</ul>
<p>当垃圾回收开始时，Go 会把根对象标记为灰色，其他对象标记为白色，然后从根对象遍历搜索，按照上面的定义去不断的对灰色对象进行扫描标记。当没有灰色对象时，表示所有对象已扫描过，然后就可以开始清除白色对象了。</p>
<h1 id="go-的内存分配是怎么样的">go 的内存分配是怎么样的？</h1>
<p>Go 的内存分配借鉴了 Google 的 TCMalloc 分配算法，其核心思想是<strong>内存池 + 多级对象管理</strong>。内存池主要是预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan、arenas、mcentral、mcache。它们以 mspan 作为基本分配单位。具体的分配逻辑如下：</p>
<ul>
<li>当要分配大于 32K 的对象时，从 mheap 分配。</li>
<li>当要分配的对象小于等于 32K 大于 16B 时，从 P 上的 mcache 分配，如果 mcache 没有内存，则从 mcentral 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则从操作系统申请内存。</li>
<li>当要分配的对象小于等于 16B 时，从 mcache 上的微型分配器上分配。</li>
</ul>
<h1 id="channel-的内部实现是怎么样的">channel 的内部实现是怎么样的？</h1>
<p>channel 内部维护了两个 goroutine 队列，一个是待发送数据的 goroutine 队列，另一个是待读取数据的 goroutine 队列。</p>
<p>每当对 channel 的读写操作超过了可缓冲的 goroutine 数量，那么当前的 goroutine 就会被挂到对应的队列上，直到有其他 goroutine 执行了与之相反的读写操作，将它重新唤起。</p>
<h1 id="对已经关闭的-channel-进行读写会怎么样">对已经关闭的 channel 进行读写，会怎么样？</h1>
<p>当 channel 被关闭后，如果继续往里面写数据，程序会直接 <strong>panic</strong> 退出。如果是读取关闭后的 channel，不会产生 pannic，还可以读到数据。但关闭后的 channel 没有数据可读取时，将得到零值，即对应类型的默认值。</p>
<p>为了能知道当前 channel 是否被关闭，可以使用下面的写法来判断。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span> <span style="color:#00f">if</span> v, ok := &lt;-ch; !ok {
</span></span><span style="display:flex;"><span>  fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;channel 已关闭，读取不到数据&#34;</span>)
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>还可以使用下面的写法不断的获取 channel 里的数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span> <span style="color:#00f">for</span> data := <span style="color:#00f">range</span> ch {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">// get data dosomething
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> }
</span></span></code></pre></div><p>这种用法会在读取完 channel 里的数据后就结束 for 循环，执行后面的代码。</p>
<h1 id="map-为什么是不安全的">map 为什么是不安全的？</h1>
<p>map 在扩缩容时，需要进行数据迁移，迁移的过程并没有采用锁机制防止并发操作，而是会对某个标识位标记为 1，表示此时正在迁移数据。如果有其他 goroutine 对 map 也进行写操作，当它检测到标识位为 1 时，将会直接 panic。</p>
<p>如果我们想要并发安全的 map，则需要使用 sync.map。</p>
<h1 id="map-的-key-为什么得是可比较类型的">map 的 key 为什么得是可比较类型的？</h1>
<p>map 的 key、value 是存在 buckets 数组里的，每个 bucket 又可以容纳 8 个 key 和 8 个 value。当要插入一个新的 key - value 时，会对 key 进行 hash 运算得到一个 hash 值，然后根据 hash 值 的低几位(取几位取决于桶的数量，比如一开始桶的数量是 5，则取低 5 位)来决定命中哪个 bucket。</p>
<p>在命中某个 bucket 后，又会根据 hash 值的高 8 位来决定是 8 个 key 里的哪个位置。如果不巧，发生了 hash 冲突，即该位置上已经有<strong>其他 key</strong> 存在了，则会去其他空位置寻找插入。如果全都满了，则使用 overflow 指针指向一个新的 bucket，重复刚刚的寻找步骤。</p>
<p>从上面的流程可以看出，在判断 hash 冲突，即该位置是否已有<strong>其他 key</strong> 时，肯定是要进行比较的，所以 key 必须得是可比较类型的。像 slice、map、function 就不能作为 key。</p>
<h1 id="mutex-的正常模式饥饿模式自旋">mutex 的正常模式、饥饿模式、自旋？</h1>
<h2 id="正常模式">正常模式</h2>
<p>当 mutex 调用 Unlock() 方法释放锁资源时，如果发现有正在阻塞并等待唤起的 Goroutine 队列时，则会将队头的 Goroutine 唤起。队头的 goroutine 被唤起后，会采用 CAS 这种乐观锁的方式去修改占有标识位，如果修改成功，则表示占有锁资源成功了，当前占有成功的 goroutine 就可以继续往下执行了。</p>
<h2 id="饥饿模式">饥饿模式</h2>
<p>由于上面的 Goroutine 唤起后并不是直接的占用资源，而是使用 CAS 方法去尝试性占有锁资源。如果此时有新来的 Goroutine，那么它也会调用 CAS 方法去尝试性的占有资源。对于 Go 的并发调度机制来讲，会比较偏向于 CPU 占有时间较短的 Goroutine 先运行，即新来的 Goroutine 比较容易占有资源，而队头的 Goroutine 一直占用不到，导致饿死。</p>
<p>针对这种情况，Go 采用了饥饿模式。即通过判断队头 Goroutine 在超过一定时间后还是得不到资源时，会在 Unlock 释放锁资源时，直接将锁资源交给队头 Goroutine，并且将当前状态改为饥饿模式。</p>
<p>后面如果有新来的 Goroutine 发现是饥饿模式时， 则会直接添加到等待队列的队尾。</p>
<h2 id="自旋">自旋</h2>
<p>如果 Goroutine 占用锁资源的时间比较短，那么每次释放资源后，都调用信号量来唤起正在阻塞等候的 goroutine，将会很浪费资源。</p>
<p>因此在符合一定条件后，mutex 会让等候的 Goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终才加入到等待队列里。</p>
<h1 id="go-的逃逸行为是指">Go 的逃逸行为是指？</h1>
<p>在传统的编程语言里，会根据程序员指定的方式来决定变量内存分配是在栈还是堆上，比如声明的变量是值类型，则会分配到栈上，或者 new 一个对象则会分配到堆上。</p>
<p>在 Go 里变量的内存分配方式则是由编译器来决定的。如果变量在作用域（比如函数范围）之外，还会被引用的话，那么称之为发生了逃逸行为，此时将会把对象放到堆上，即使声明为值类型；如果没有发生逃逸行为的话，则会被分配到栈上，即使 new 了一个对象。</p>
<h1 id="context-使用场景及注意事项">context 使用场景及注意事项</h1>
<p>Go 里的 context 有 cancelCtx 、timerCtx、valueCtx。它们分别是用来通知取消、通知超时、存储 key - value 值。context 的 注意事项如下：</p>
<ul>
<li>context 的 Done() 方法往往需要配合 select {} 使用，以监听退出。</li>
<li>尽量通过函数参数来暴露 context，不要在自定义结构体里包含它。</li>
<li>WithValue 类型的 context 应该尽量存储一些全局的 data，而不要存储一些可有可无的局部 data。</li>
<li>context 是并发安全的。</li>
<li>一旦 context 执行取消动作，所有派生的 context 都会触发取消。</li>
</ul>
<h1 id="context-是如何一层一层通知子-context">context 是如何一层一层通知子 context</h1>
<p>当 <code>ctx, cancel := context.WithCancel(父Context)</code>
时，会将当前的 ctx 挂到父 context 下，然后开个 goroutine 协程去监控父 context 的 channel 事件，一旦有 channel 通知，则自身也会触发自己的 channel 去通知它的子 context， 关键代码如下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#00f">select</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#00f">case</span> &lt;-parent.<span style="color:#c34e00">Done</span>():
</span></span><span style="display:flex;"><span>    child.<span style="color:#c34e00">cancel</span>(<span style="color:#00f">false</span>, parent.<span style="color:#c34e00">Err</span>())
</span></span><span style="display:flex;"><span>   <span style="color:#00f">case</span> &lt;-child.<span style="color:#c34e00">Done</span>():
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span> }()
</span></span></code></pre></div><h1 id="waitgroup-原理">waitgroup 原理</h1>
<p>waitgroup 内部维护了一个计数器，当调用 <code>wg.Add(1)</code>
方法时，就会增加对应的数量；当调用 <code>wg.Done()</code>
时，计数器就会减一。直到计数器的数量减到 0 时，就会调用 runtime_Semrelease 唤起之前因为 <code>wg.Wait()</code>
而阻塞住的 goroutine。</p>
<h1 id="synconce-原理">sync.Once 原理</h1>
<p>内部维护了一个标识位，当它 == 0 时表示还没执行过函数，此时会加锁修改标识位，然后执行对应函数。后续再执行时发现标识位 != 0，则不会再执行后续动作了。关键代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">type</span> Once <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span> done <span style="color:#00f">uint32</span>
</span></span><span style="display:flex;"><span> m    Mutex
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (o *Once) <span style="color:#c34e00">Do</span>(f <span style="color:#00f">func</span>()) {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// 原子加载标识值，判断是否已被执行过
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> <span style="color:#00f">if</span> atomic.<span style="color:#c34e00">LoadUint32</span>(&amp;o.done) == 0 {
</span></span><span style="display:flex;"><span>  o.<span style="color:#c34e00">doSlow</span>(f)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> (o *Once) <span style="color:#c34e00">doSlow</span>(f <span style="color:#00f">func</span>()) { <span style="color:#f00;font-style:italic">// 还没执行过函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> o.m.<span style="color:#c34e00">Lock</span>()
</span></span><span style="display:flex;"><span> <span style="color:#00f">defer</span> o.m.<span style="color:#c34e00">Unlock</span>()
</span></span><span style="display:flex;"><span> <span style="color:#00f">if</span> o.done == 0 { <span style="color:#f00;font-style:italic">// 再次判断下是否已被执行过函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  <span style="color:#00f">defer</span> atomic.<span style="color:#c34e00">StoreUint32</span>(&amp;o.done, 1) <span style="color:#f00;font-style:italic">// 原子操作：修改标识值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  <span style="color:#c34e00">f</span>() <span style="color:#f00;font-style:italic">// 执行函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="定时器原理">定时器原理</h1>
<p>一开始，timer 会被分配到一个全局的 timersBucket 时间桶。每当有 timer 被创建出来时，就会被分配到对应的时间桶里了。</p>
<p>为了不让所有的 timer 都集中到一个时间桶里，Go 会创建 64 个这样的时间桶，然后根据 当前 timer 所在的 Goroutine 的 P 的 id 去哈希到某个桶上：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// assignBucket 将创建好的 timer 关联到某个桶上
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> (t *timer) <span style="color:#c34e00">assignBucket</span>() *timersBucket {
</span></span><span style="display:flex;"><span> id := uint8(<span style="color:#c34e00">getg</span>().m.p.<span style="color:#c34e00">ptr</span>().id) % timersLen
</span></span><span style="display:flex;"><span> t.tb = &amp;timers[id].timersBucket
</span></span><span style="display:flex;"><span> <span style="color:#00f">return</span> t.tb
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着 timersBucket 时间桶将会对这些 timer 进行一个最小堆的维护，每次会挑选出时间最快要达到的 timer。如果挑选出来的 timer 时间还没到，那就会进行 sleep 休眠；如果 timer 的时间到了，则执行 timer 上的函数，并且往 timer 的 channel 字段发送数据，以此来通知 timer 所在的 goroutine。</p>
<h1 id="gorouinte-泄漏有哪些场景">gorouinte 泄漏有哪些场景</h1>
<p>gorouinte 里有关于 channel 的操作，如果没有正确处理 channel 的读取，会导致 channel 一直阻塞住, goroutine 不能正常结束</p>
<h1 id="slice-注意点">Slice 注意点</h1>
<h2 id="slice-的扩容机制">Slice 的扩容机制</h2>
<p>如果 Slice 要扩容的容量大于 2 倍当前的容量，则直接按想要扩容的容量来 new 一个新的 Slice，否则继续判断当前的长度 len，如果 len 小于 1024，则直接按 2 倍容量来扩容，否则一直循环新增 1/4，直到大于想要扩容的容量。主要代码如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>newcap := old.cap
</span></span><span style="display:flex;"><span>doublecap := newcap + newcap
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> cap &gt; doublecap {
</span></span><span style="display:flex;"><span>    newcap = cap
</span></span><span style="display:flex;"><span>} <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> old.len &lt; 1024 {
</span></span><span style="display:flex;"><span>        newcap = doublecap
</span></span><span style="display:flex;"><span>    } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> newcap &lt; cap {
</span></span><span style="display:flex;"><span>            newcap += newcap / 4
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>除此之外，还会根据 slice 的类型做一些内存对齐的调整，以确定最终要扩容的容量大小。</p>
<h2 id="slice-的一些注意写法">Slice 的一些注意写法</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// =========== 第一种
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>a := make([]<span style="color:#00f">string</span>, 5)
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(a), cap(a))   <span style="color:#f00;font-style:italic">//  输出5   5
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>a = append(a, <span style="color:#009c00">&#34;aaa&#34;</span>)
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(a), cap(a))   <span style="color:#f00;font-style:italic">// 输出6  10
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// 总结： 由于make([]string, 5) 则默认会初始化5个 空的&#34;&#34;, 因此后面 append 时，则需要2倍了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// =========== 第二种
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>a:=[]<span style="color:#00f">string</span>{}
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(a), cap(a))   <span style="color:#f00;font-style:italic">//  输出0   0
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>a = append(a, <span style="color:#009c00">&#34;aaa&#34;</span>)
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(a), cap(a))   <span style="color:#f00;font-style:italic">// 输出1  1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// 总结：由于[]string{}, 没有其他元素， 所以append 按 需要扩容的 cap 来
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// =========== 第三种
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>a := make([]<span style="color:#00f">string</span>, 0, 5)
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(a), cap(a))   <span style="color:#f00;font-style:italic">//  输出0   5
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>a = append(a, <span style="color:#009c00">&#34;aaa&#34;</span>)
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(a), cap(a))   <span style="color:#f00;font-style:italic">// 输出1  5
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// 总结：注意和第一种的区别，这里不会默认初始化5个，所以后面的append容量是够的，不用扩容
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// =========== 第四种
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>b := make([]<span style="color:#00f">int</span>, 1, 3)
</span></span><span style="display:flex;"><span>a := []<span style="color:#00f">int</span>{1, 2, 3}
</span></span><span style="display:flex;"><span>copy(b, a)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fmt.<span style="color:#c34e00">Println</span>(len(b))  <span style="color:#f00;font-style:italic">// 输出1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// 总结：copy 取决于较短 slice 的 len, 一旦最小的len结束了，也就不再复制了
</span></span></span></code></pre></div><h2 id="range-slice">range slice</h2>
<p>以下代码的执行是不会一直循环下去的，原因在于 range 的时候会 copy 这个 slice 上的 len 属性到一个新的变量上，然后根据这个 copy 值去遍历 slice，因此遍历期间即使 slice 添加了元素，也不会改变这个变量的值了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>v := []<span style="color:#00f">int</span>{1, 2, 3}
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i := <span style="color:#00f">range</span> v {
</span></span><span style="display:flex;"><span> v = append(v, i)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外，range 一个 slice 的时候是进行一个值拷贝的，如果 slice 里存储的是指针集合，那在 遍历里修改是有效的，如果 slice 存储的是值类型的集合，那么就是在 copy 它们的副本，期间的修改也只是在修改这个副本，跟原来的 slice 里的元素是没有关系的。</p>
<h2 id="slice-入参注意点">slice 入参注意点</h2>
<p>如果 slice 作为函数的入参，通常希望对 slice 的操作可以影响到底层数据，但是如果在函数内部 append 数据超过了 cap，导致重新分配底层数组，这时修改的 slice 将不再是原来入参的那个 slice 了。因此通常不建议在函数内部对 slice 有 append 操作，若有需要则显示的 return 这个 slice。</p>
<h1 id="make-和-new-的区别">make 和 new 的区别</h1>
<p>new 是返回某个类型的指针，将会申请某个类型的内存。而 make 只能用于 slice, map, channel 这种 golang 内部的数据结构，它们可以只声明不初始化，或者初始化时指定一些特定的参数，比如 slice 的长度、容量；map 的长度；channel 的缓冲数量等。</p>
<h1 id="deferpanicrecover-三者的用法">defer、panic、recover 三者的用法</h1>
<p>defer 函数调用的顺序是后进先出，当产生 panic 的时候，会先执行 panic 前面的 defer 函数后才真的抛出异常。一般的，recover 会在 defer 函数里执行并捕获异常，防止程序崩溃。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> <span style="color:#009c00">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> <span style="color:#00f">func</span>(){
</span></span><span style="display:flex;"><span>       fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;b&#34;</span>)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">defer</span> <span style="color:#00f">func</span>() {
</span></span><span style="display:flex;"><span>       <span style="color:#00f">if</span> err := recover(); err != <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;捕获异常:&#34;</span>, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    panic(<span style="color:#009c00">&#34;a&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// 输出
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// 捕获异常: a
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// b
</span></span></span></code></pre></div><h1 id="slice-和-array-的区别">slice 和 array 的区别</h1>
<p>array 是固定长度的数组，并且是值类型的，也就是说是拷贝复制的， slice 是一个引用类型，指向了一个动态数组的指针，会进行动态扩容。</p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
    <a href="http://shanks.link/tags/%e9%9d%a2%e8%af%95" rel="tag" title="面试">#面试#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="next" title="计算机网络面试知识点">
        <i class="fa fa-chevron-left"></i> 计算机网络面试知识点
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2022/04/16/%E6%83%B3%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/" rel="prev" title="想写点什么">
        想写点什么 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">512</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">32</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>