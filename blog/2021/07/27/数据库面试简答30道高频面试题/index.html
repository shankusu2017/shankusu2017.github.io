<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>数据库面试简答、30道高频面试题 - 愿星光伴你左右</title>
    <meta name="keywords" content="Lua,lua,Golang,go">
    
    <meta property="og:title" content="数据库面试简答、30道高频面试题">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="数据库面试简答、30道高频面试题 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%9430%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">
        数据库面试简答、30道高频面试题
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-07-27">
    2021-07-27
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/cs" itemprop="url" rel="index">
        <span itemprop="name">cs</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/db" itemprop="url" rel="index">
        <span itemprop="name">db</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/%E9%9D%A2%E8%AF%95" itemprop="url" rel="index">
        <span itemprop="name">面试</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">12677 字 ~26分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://www.cnblogs.com/ZhuChangwu/"><img src="https://www.cnblogs.com/skins/custom/images/logo.gif" alt="返回主页"></a></p>
<h1 id="数据库面试简答30道高频面试题shankusumee8818ce59cbae695b0e68daee5ba93e99da2e8af95e7ae80e7ad9430e98193e9ab98e9a291e99da2e8af95e9a298more"><a href="shankusu.me/%E8%81%8C%E5%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%9430%E9%81%93%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/#more">数据库面试简答、30道高频面试题</a></h1>
<h3 id="一mysql问答">一、MySQL问答</h3>
<h4 id="1数据库sql语句查询跨表查询有哪几种方式">1、数据库sql语句查询，跨表查询有哪几种方式</h4>
<p>内连接(inner可以不写)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> e.name e.age p.product_name p.saled
<span style="color:#66d9ef">from</span> employee e<span style="color:#960050;background-color:#1e0010">，</span>product p 
<span style="color:#66d9ef">where</span> e.id <span style="color:#f92672">=</span> p.id

<span style="color:#66d9ef">select</span> e.name e.age p.product_name p.saled
<span style="color:#66d9ef">from</span> employee <span style="color:#66d9ef">inner</span> 
<span style="color:#66d9ef">join</span> e<span style="color:#960050;background-color:#1e0010">，</span>product p <span style="color:#66d9ef">on</span> e.id <span style="color:#f92672">=</span> p.id
</code></pre></div><p>这就是内连接，它要求数据必须On条件必须百分百匹配才会符合条件并返回。当不满足时，他会返回空。</p>
<p>外连接是用左\右侧的数据去关联另一侧的数据，即使关联不上任何数据也得把左\右侧的数据返回回来。</p>
<p>外连接分（左外连接）和（右外连接）</p>
<p>左外连接（ left join）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> g2.Name<span style="color:#960050;background-color:#1e0010">，</span>Price<span style="color:#960050;background-color:#1e0010">，</span>ProductionDate<span style="color:#960050;background-color:#1e0010">，</span>Amount<span style="color:#960050;background-color:#1e0010">，</span>g1.name
<span style="color:#66d9ef">FROM</span> Goods G1
<span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> GoodsType G2 <span style="color:#66d9ef">on</span> G1.Typeld<span style="color:#f92672">=</span>G2.IO
</code></pre></div><p>右外连接（right join&ndash;空值的会显示出来）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> g2.Name<span style="color:#960050;background-color:#1e0010">，</span>Price<span style="color:#960050;background-color:#1e0010">，</span>ProductionDate<span style="color:#960050;background-color:#1e0010">，</span>Amount<span style="color:#960050;background-color:#1e0010">，</span>g1.name
<span style="color:#66d9ef">FROM</span> Goods G1 <span style="color:#66d9ef">right</span> <span style="color:#66d9ef">join</span> GoodsType G2 <span style="color:#66d9ef">on</span> G1.Typeld<span style="color:#f92672">=</span>G2.IO
</code></pre></div><p>全外连接（full outer(可以不写) join&ndash;空值的会显示出来）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> g1.name<span style="color:#960050;background-color:#1e0010">，</span>g2.Name<span style="color:#960050;background-color:#1e0010">，</span>price<span style="color:#960050;background-color:#1e0010">，</span>productiondate<span style="color:#960050;background-color:#1e0010">，</span>g2.Amount
<span style="color:#66d9ef">FROM</span> GoodsType g1 <span style="color:#66d9ef">full</span> <span style="color:#66d9ef">outer</span> <span style="color:#66d9ef">join</span> Goods g2 <span style="color:#66d9ef">on</span> g1.IO<span style="color:#f92672">=</span>g2.Typeld
</code></pre></div><p>交叉连接（笛卡尔积)查询所有的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> g1.name<span style="color:#960050;background-color:#1e0010">，</span>g2.Name<span style="color:#960050;background-color:#1e0010">，</span>price<span style="color:#960050;background-color:#1e0010">，</span>productiondate<span style="color:#960050;background-color:#1e0010">，</span>g2.Amount
<span style="color:#66d9ef">FROM</span> GoodsType g1 <span style="color:#66d9ef">cross</span> <span style="color:#66d9ef">join</span> Goods g2 <span style="color:#66d9ef">where</span> g1.IO<span style="color:#f92672">=</span>g2.Typeld
</code></pre></div><h4 id="2数据库的索引用到的是什么数据结构">2、数据库的索引用到的是什么数据结构？</h4>
<p>答：B+树</p>
<p>问：那么B+树的特点是什么？为什么要用这个数据结构？</p>
<p>B+树是B树的变种，他们可以是 23树，234树，2345树等等，当单个节点允许伸出1200节点时，三层就可以有17亿，因此它体型扁平。。。有利益磁盘IO</p>
<p>B+树非叶子结点不存储数据，B树存储数据，所以相同大小数据块，能存更多B+索引</p>
<p>B+树叶子结点上有双向链表串联，有利于进行范围搜索</p>
<p>B+树为什么有利于磁盘IO？</p>
<p>首先了解一下计算机的空间局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p>
<p>使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。</p>
<p>B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p>
<p>B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。</p>
<p>比B树更适合作为索引的结构是B+树。MySQL中也是使用B+树作为索引。它是B树的变种，因此是基于B树来改进的。为什么B+树会比B树更加优秀呢？</p>
<p>B树：有序数组+平衡多叉树。</p>
<p>B+树：有序数组链表+平衡多叉树。</p>
<p>B+树的关键字全部存放在叶子节点中，这样非叶子结点就能在相同的空间存储更多的信息，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。</p>
<h4 id="3mylsaminnodb的区别">3、mylsam、innodb的区别</h4>
<p>1.InnoDB和MyISAM都是B+数的结构。</p>
<p>2.InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPETABLE READ （可重复读），并且通过间隙锁策略防止幻读的出现。</p>
<p>3.InnoDB表是基于聚簇索引建立的。</p>
<p>4.InnoDB支持事务。</p>
<p>5.InnoDB具有自动崩溃恢复功能。</p>
<p>6.InnoDB支持外键。</p>
<p>MyISAM</p>
<p>1.MyISAM 不支持事务和行级锁。</p>
<p>2.崩溃后无法安全恢复。</p>
<p>3.对于只读的数据，或者表比较小，可以忍受修复操作的可以使用。</p>
<p>4.MyISAM会将表存储在两个文件中，数据文件和索引文件，分别以.MYD和.MYI为扩展名。</p>
<p>5.MyISAM 支持全文索引。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>MyISAM</strong></th>
<th><strong>Innodb</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据.MYD，索引.MYI</td>
<td>数据和索引是集中存储的，.ibd</td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td></td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam 是堆表</td>
<td>B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h4 id="4mysql的gtid复制原理是什么">4、MySQL的Gtid复制原理是什么？</h4>
<p>mysql主从复制原理就是主库创建一个专门用于给从库拉取binlog的账号，并且给这个账号授权，让他可以拉取哪个DB的那个表的binlog，具体的授权SQL是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">grant</span> repliacation slave <span style="color:#66d9ef">on</span> xx.xx <span style="color:#66d9ef">to</span> username<span style="color:#f92672">@</span>ip identify <span style="color:#66d9ef">by</span> <span style="color:#e6db74">&#39;password&#39;</span>
</code></pre></div><p>这样从库就能登陆主库拉取binlog，那拉取binlog就得知道从哪个binlog的哪个位点拉取，现有的有两个方案：fileName + position 还有就是通过gtid自动找点。</p>
<p>什么是GTID？原理？</p>
<p><a href="https://www.cnblogs.com/ZhuChangwu/p/13040214.html">https://www.cnblogs.com/ZhuChangwu/p/13040214.html</a></p>
<h4 id="5同步半同步异步复制原理是什么">5、同步、半同步、异步复制原理是什么？</h4>
<p>同步、半同步、异步复制说的是 从库在主库上拉取binlog日志的模式。</p>
<p>同步：</p>
<p>主库写redolog 事物处于prepare状态、主库写binlog，然后从库拉取binlog去回放，从库回放成功后返回给主库ack确认，所有的从库都完成回放后主库提交事物。这样是可以保证主从数据一致的但是缺点就是速度太慢了。</p>
<p>半同步：</p>
<p>主库写redolog 事物处于prepare状态、主库写binlog，然后从库拉取binlog后返回给主库ack，在众多从库中只要收到一个ack主库就提交事物</p>
<p>异步复制：</p>
<p>主库根本不管从库有没有拉取回放binlog，直接写redo、binlog、然后提交事物</p>
<p>首先不允许出现主从数据不一致的情况：如果主从不一致对业务来说是有损的，一旦发生主从数据不一致的情况，从库就会出现断开连接的可能。</p>
<h4 id="6说说你了解的mysql慢查询">6、说说你了解的MySQL慢查询？</h4>
<p>MySQL有监控项：slow query ， MySQL会将所有执行时间超过阈值的SQL记录到慢查日志中</p>
<p>我们的监控系统可以监控： 当检测到有慢查时触发报警</p>
<p>通常出现慢查到情况如下：</p>
<p>1、表中的数据量很大，而且SQL的执行没有走索引</p>
<p>2、数据量太大了，即使走了索引依然超过了阈值</p>
<p>3、大量的慢查占据MySQL连接，导致正常的SQL得不到连接执行从而变成慢查SQL</p>
<p>4、优化器选错了索引</p>
<p>查看慢查时间阈值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mysql&gt; show global variables like <span style="color:#e6db74">&#39;%long_query_time%&#39;</span>;

+-----------------+-----------+

| Variable_name  | Value   |

+-----------------+-----------+

| long_query_time | 10.000000 |

+-----------------+-----------+

<span style="color:#ae81ff">1</span> row inset <span style="color:#f92672">(</span>0.00 sec<span style="color:#f92672">)</span>
</code></pre></div><p>查看执行时间最长的10条SQL</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mysqldumpslow -s a1 -n <span style="color:#ae81ff">10</span> mysql.slow_log
</code></pre></div><p>推荐阅读：https://mp.weixin.qq.com/s/tXTLMCiVpEnnmhUclYR19Q</p>
<h4 id="7说说mysql的执行计划">7、说说MySQL的执行计划</h4>
<p>什么是执行计划</p>
<p>每次提交一个SQL到MySQL，MySQL内核的查询优化器会针对这个SQL的语意生成一个执行计划，这个执行计划就代表了他会查哪些表？用哪些索引，如何做排序和分组</p>
<p>执行不同的sql有哪几种情况</p>
<p>单表查询举例：</p>
<p>示例1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere id <span style="color:#f92672">=</span> x ;
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere name <span style="color:#f92672">=</span> x ;
</code></pre></div><p>id是主键、name是唯一索引像这种可以直接根据聚簇索引或者二级索引+回表就能查询到我们想要的数据的方式在执行计划中称为 const</p>
<p>要求二级索引必须是唯一索引，才属于const</p>
<p>示例2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere name <span style="color:#f92672">=</span> x ;
</code></pre></div><p>name是普通索引查询的过程是：从name这个B+树中查询出一条记录后，得到记录的主键id，然后去聚簇索引中回表，这种查询方式速度也很快，在执行计划中叫：ref</p>
<p>示例3:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere name <span style="color:#f92672">=</span> x <span style="color:#66d9ef">and</span> age <span style="color:#f92672">=</span> y <span style="color:#66d9ef">and</span> xx<span style="color:#f92672">=</span>yy ;
</code></pre></div><p>name、age、xx为普通索引这种sql要求where条件之后的SQL全得是等值比较，在执行计划中才算做是ref</p>
<p>示例4:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere name <span style="color:#f92672">=</span> x <span style="color:#66d9ef">and</span> name <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">NULL</span> ;
</code></pre></div><p>name为普通索引这种sql就是在二级索引中同时搜索name = x和name = null的值，然后去主库中回表。这种在执行计划中被称为ref_or_null</p>
<p>示例5:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere age <span style="color:#f92672">&gt;=</span>x <span style="color:#66d9ef">and</span> age <span style="color:#f92672">&lt;=</span>y
</code></pre></div><p>age是普通索引像这样使用普通索引做范围查询，在执行计划中称为 range</p>
<p>示例6：index方式</p>
<p>index方式并不是说执行计划使用了索引，从聚簇索引中一路二分往下走。</p>
<p>假设有联合索引：<code>key(x1，x2，x3)</code></p>
<p>查询语句如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> x1<span style="color:#960050;background-color:#1e0010">，</span>x2<span style="color:#960050;background-color:#1e0010">，</span>x3 fromtablewhere x2<span style="color:#f92672">=</span>xxx;
</code></pre></div><p>想使用联合索引得遵循左前缀原则，但是上面直接使用x2，很显然不符合左前缀原则，所以就用不上联合索引，但是他查询的x1、x2、x3其实对应联合索引中的x1、x2、x3所以他会去扫描 联合索引：key(x1，x2，x3)形成的B+树，而不是全表扫描，在执行计划中这就做 index</p>
<p>所以说，index其实是去遍历二级索引，故他的效率肯定比ref，const、ref_or_null慢，但是比全表扫描快一些</p>
<p>示例7：all</p>
<p>比如你去查找数据但是不加where条件，就会进行全表扫描</p>
<p>示例8:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere x1 <span style="color:#f92672">=</span> xxx <span style="color:#66d9ef">or</span> x2 <span style="color:#f92672">&gt;=</span> yy ;
</code></pre></div><p>然后你的联合索引是 <code>key1(x1，x3) key2(x2，x4)</code>这时查询优化器只能在key1和key2中二选一使用，具体选哪一个就看使用哪个索引扫描行数少</p>
<p>比如使用x1扫描行数少，就先拿着x1去过滤一部分数据出来（ref的方式）然后去聚簇索引中回表查询所有的数据在内存中根据第二个条件x2 &gt; yy 再过滤一次</p>
<p>示例9:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere x1 <span style="color:#f92672">=</span> xxx <span style="color:#66d9ef">and</span> c1<span style="color:#f92672">=</span>xxx <span style="color:#66d9ef">and</span> c2 <span style="color:#f92672">&gt;=</span> yy <span style="color:#66d9ef">and</span> c3 <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">null</span>;
</code></pre></div><p>只有c1有索引查询优化器会根据x1，通过ref的方式查找到一批数据，然后去聚簇索引中回表，将所有符合条件的数据加载进内存，然后在内存中根据剩下的条件继续过滤。</p>
<p>示例10:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> fromtablewhere x1 <span style="color:#f92672">=</span> xxx <span style="color:#66d9ef">and</span> x2<span style="color:#f92672">=</span>xxx;
</code></pre></div><p>x1和x2都有普通索引情况1: 查询优化器使用x1索引在二级索引中查询中一批数据，然后将这些数据放到聚簇索引中回表，将数据所有字段查询出来，然后在内存中根据x2=xxx再过滤。</p>
<p>情况2:查询优化器使用x1索引在二级索引中查询中一批数据A，再使用x2索引在二级索引中查询中一批数据B，两者做交集，再去聚簇索引中回表，这样的效率会更高。</p>
<p>多表:</p>
<p>示例1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1<span style="color:#960050;background-color:#1e0010">，</span>t2 <span style="color:#66d9ef">where</span> t1.x1 <span style="color:#f92672">=</span> xxx <span style="color:#66d9ef">and</span> t1.x2 <span style="color:#f92672">=</span> t2.x2and t2.x3 <span style="color:#f92672">=</span> yyy;
</code></pre></div><p>第一步：查询优化器会根据t1.x1 = xxx这个条件查询出一部分数据，具体通过ref、index、conf、all根据你索引的情况而定。</p>
<p>假设第一步拿出来了两条记录，然后拿着这两条记录的x2值和x3值去t2表中去匹配有没有一样的，有的话就关联起来返回，其中t1叫做驱动表，t2叫做被驱动表。</p>
<p>示例2:</p>
<p>嵌套循环查询：简单来说就是从驱动表中查询一批数据，然后遍历这批数据挨个去被驱动表中查询。</p>
<p>这时如果被驱动表中的使用的该字段没有加索引，每次查询都是all，就会导致连表查询速度很慢，因此最好两者都建立索引。</p>
<p>explain时你会关注哪几个字段？</p>
<p>答：6个，如下</p>
<p>id：每一个selct语句都有有一个id，复杂的SQL有多个select，就会对应有多个id</p>
<p>select_type: 当前sql的查询类型</p>
<p>type：ref、index、all、const</p>
<p>possible_keys 可以使用的索引都会放在这里</p>
<p>rows：扫描的行数</p>
<p>table：查询的哪张表</p>
<h4 id="8说说mysql支持的数据类型">8、说说MySQL支持的数据类型</h4>
<p>INT(6)，6即是其宽度指示器，该宽度指示器并不会影响int列存储字段的大小，也就是说，超过6位它不会自动截取，依然会存储，只有超过它本身的存储范围才会截取;此处宽度指示器的作用在于该字段是否有zerofill，如果有就未满足6位的部分就会用0来填充)，</p>
<p>CHAR 类型用于定长字符串，并且必须在圆括号内用一个大小修饰符来定义。这个大小修饰符的范围从 0-255。比指定长度大的值将被截短，而比指定长度小的值将会用空格作填补。</p>
<p>CHAR 类型的一个变体是 VARCHAR 类型。它是一种可变长度的字符串类型，并且也必须带有一个范围指示器。</p>
<p>CHAR 和 VARCHGAR 不同之处在于 MYSQL 数据库处理这个指示器的方式：CHAR 把这个大小视为值的大小，不长度不足的情况下就用空格补足。而 VARCHAR 类型把它视为最大值并且只使用存储字符串实际需要的长度（增加一个额外字节来存储字符串本身的长度）来存储值。所以短于指示器长度的 VARCHAR 类型不会被空格填补，但长于指示器的值仍然会被截短。</p>
<p><a href="https://www.cnblogs.com/liangxiaofeng/p/5806874.html">https://www.cnblogs.com/liangxiaofeng/p/5806874.html</a></p>
<h4 id="9-了解数据库如何备份吗">9. 了解数据库如何备份吗</h4>
<p>参考: <a href="https://www.cnblogs.com/yourblog/p/10381962.html">https://www.cnblogs.com/yourblog/p/10381962.html</a></p>
<p>备份整个数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$&gt; mysqldump -u root -h host -p dbname &gt; backdb.sql
</code></pre></div><p>备份数据库中的某个表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$&gt; mysqldump -u root -h host -p dbname tbname1， tbname2 &gt; backdb.sql
</code></pre></div><p>备份多个数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$&gt; mysqldump -u root -h host -p --databases dbname1， dbname2 &gt; backdb.sql
</code></pre></div><p>备份系统中所有数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$&gt; mysqldump -u root -h host -p --all-databases &gt; backdb.sql
</code></pre></div><h4 id="10-oracle和mysql的区别">10. Oracle和Mysql的区别</h4>
<p>宏观上:</p>
<ol>
<li>Mysql是小型数据库， 开源， 免费， Oracle收费</li>
<li>Oracle支持大并发， 大访问量</li>
<li>MySql中安装后占用的内存小， Oracle不仅占用内存大， 而且越用越大</li>
</ol>
<p>微观上:</p>
<ol>
<li>
<p>Mysql对事务默认不支持， 但是它的存储引擎 InnoDB支持事务， Oracle对事务完全支持</p>
</li>
<li>
<p>并发性: MySQL早期的数据引擎MyISAM是支持表级锁， 后来的InnoDB才支持行级锁， Oracle支持行级锁</p>
</li>
<li>
<p>Oracle会将提交的sql写入连接日志中， 然后写入磁盘， 保证不会丢失数据， MySql在执行更新的操作时可能会丢失数据</p>
</li>
<li>
<p>隔离级别不同:</p>
<p>a. Oracle默认使用 read commited 读已经提交</p>
<p>b. MySQL默认使用的是 repeatable read 可重复读</p>
</li>
<li>
<p>提交方式</p>
<p>a. Oracle 默认不会自动提交事务</p>
<p>b. MySQL默认自动提交事务</p>
</li>
<li>
<p>逻辑备份</p>
<p>a. Mysql 的数据备份会锁定数据， 影响正常的DML</p>
<p>b. Oracle在数据备份时， 不会锁定任何数据</p>
</li>
<li>
<p>数据插入</p>
<p>a. Mysql会更加灵活一点， 比如limit分页， insert插入多行数据</p>
<p>b. Oracle的分页使用伪列+子查询实现 ， 插入数据也只能一行行插入</p>
</li>
<li>
<p>权限控制:</p>
<p>a. Oracle的权限控制是中规中矩的， 和系统用户无关</p>
<p>b. MySQL的权限控制和主机相关， 感觉没啥意义</p>
</li>
<li>
<p>性能诊断</p>
<p>a. Oracle 有大量的性能诊断工具， 可以实现自动分析</p>
<p>b. Mysql性能诊断方法很少， 主要就是通过通过慢查询日志去排查</p>
</li>
<li>
<p>分区表和分区索引</p>
<p>a. Oracle的分区表和分区索引相对来说比较成熟</p>
<p>b. Mysql 分区表和分区索引就不成熟</p>
</li>
<li>
<p>数据复制</p>
<p>a. 在搭建的主从复制的模式中， 主库出现了问题， 可能会导致从库有一定数据的丢失， 需要手动的切换的到主库</p>
<p>b. Oracle 则更强大， 既有传统的推/拉式的数据复制， 同时也有 dataguard双机或者多机的容灾机制， 而且主库出现问题， 自动切换到备库， 但是配置相对复杂</p>
</li>
</ol>
<h4 id="11-事务的四种特性">11. 事务的四种特性</h4>
<p>ACID：</p>
<ol>
<li>Atomic 原子性: 事务不能被分割， 要么都做， 要么都不做。</li>
<li>Consistency 一致性: 可以用转账的例子解释一致性。</li>
<li>Isolation 隔离性 : 不同的事务， 彼此隔离， 互不干扰。</li>
<li>Durability 持久性: 也叫做用就行， 事务一旦被提交， 对数据库做出的修改将被持久化 。</li>
</ol>
<h4 id="12-四种隔离级别以及什么是脏读幻读不可重复读">12. 四种隔离级别以及什么是脏读，幻读，不可重复读</h4>
<ol>
<li>read uncommitted 读未提交: 在事务A中读取到了事务B中未提交的数据， 也叫做脏读。</li>
<li>read commited 读已提交: Oracle默认使用的隔离级别， 读已提交， 说白了， 事务A先开启， 然后事务B再开启， 然后事务Bcommit一个事务操作， 修改数据 ， 那么这个修改是能被事务A读取到的， 这就叫做读已提交， 也是所谓的不可重复读，(因为重复读之后， 数据可能会发生变化)。</li>
<li>repeatable read : 可重复读， 这也是Mysql默认的事务隔离级别， 事务A开启后， 无论读取多少次， 得到的结果都和第一次得到的结果是一样的， 但是如果事务B在事务A第一次读取的范围内插入了一条数据的话， 会发生幻读， 两次读取结果又不一致了， Mysql的InnoDB引擎通过多版本并发控制MVCC解决了这个问题。</li>
<li>serializable : 可串行化， 最高的事务隔离级别， 到是也是效率最低的事务隔离级别。</li>
</ol>
<h4 id="13-mysql中-主键索引普通索引唯一索引的区别">13. MySQL中 主键索引、普通索引、唯一索引的区别</h4>
<p>主键索引 primary key:</p>
<ul>
<li>一个表只能有一个主键索引。</li>
<li>主键索引不能为空。</li>
<li>主键索引可以做外键。</li>
</ul>
<p>唯一索引unique key:</p>
<ul>
<li>一张表可以存在多个唯一索引。</li>
<li>唯一索引可以是一列或者多列。</li>
<li>唯一索引不可重复的。</li>
<li>因为这个原因， 限制唯一索引做多有一个null。</li>
</ul>
<p>普通索引 normal key :</p>
<ul>
<li>普通一般是为了加快数据的访问速度而建立的。</li>
<li>针对那些经常被查询， 或者经常被排序的字段建立。</li>
<li>被索引的数据允许出现重复的值。</li>
</ul>
<h4 id="14-数据库三大范式">14. 数据库三大范式</h4>
<p>第一大范式:</p>
<p>关系模式R中的所有属性都不能再分解， 称关系模式R 满足第一范式， 比如 address 字段就可以继续拆分成 省市区， 我们就可以认为address不满足第一范式。</p>
<p>第二大范式:</p>
<p>在满足第一范式的基础上更进一步， 它要求所有的非主属性都必须完全依赖于第一范式中确定下来的主属性， 换句话说， 比如联合主键就不符合第二范式， 因为很有可能这个表中的一部分非主属性和联合主键中的一部分列是有依赖关系的， 而和另外一部分并没有依赖关系。</p>
<p>第三大范式:</p>
<p>在第一范式R的基础上， 更进一步， 要求所有的字段都可主键直接相关而不能间接相关， 比如用户表里面不要出现订单表中的订单信息。</p>
<h4 id="15-sql语句各种条件的执行顺序如select-where-order-by-group-by">15. sql语句各种条件的执行顺序，如select， where， order by， group by</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">from</span> <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">having</span> <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">limit</span> <span style="color:#66d9ef">select</span> 
</code></pre></div><h4 id="16-求表的size或做数据统计可用什么存储引擎">16. 求表的size，或做数据统计可用什么存储引擎</h4>
<p>查询数据表所占的容量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">sum</span>(DATA_LENGTH) <span style="color:#f92672">+</span> <span style="color:#66d9ef">sum</span>(INDEX_LENGTH) <span style="color:#66d9ef">from</span> information_schema.tables <span style="color:#66d9ef">where</span> table_schema <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;数据库名
</span></code></pre></div><p><img src="https://img2020.cnblogs.com/blog/1496926/202101/1496926-20210105230922585-487678443.png" alt="img"></p>
<p>查询所有数据的大小， 用兆的方式输出结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> concat(round(<span style="color:#66d9ef">sum</span>(DATA_LENGTH<span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span>)<span style="color:#960050;background-color:#1e0010">，</span><span style="color:#ae81ff">2</span>)<span style="color:#960050;background-color:#1e0010">，</span><span style="color:#e6db74">&#39;MB&#39;</span>) asdata
<span style="color:#66d9ef">from</span> information_schema.tables
<span style="color:#66d9ef">where</span> table_schema<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blog&#39;</span>andtable_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;catalog&#39;</span>
</code></pre></div><h4 id="17-读多写少可用什么引擎">17. 读多写少可用什么引擎</h4>
<p>MyISAM 它在设计之时就考虑到 数据库被查询的次数要远大于更新的次数。因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。</p>
<p>所以， 如果系统中的写操作真的很少，并且不使用mysql的事务等高级操作的话， 建议使用MYISAM。</p>
<h4 id="18-假如要统计多个表应该用什么引擎">18. 假如要统计多个表应该用什么引擎</h4>
<p>考虑报表引擎</p>
<h4 id="19mysql-explain各字段意思">19.MySQL Explain各字段意思</h4>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>选择标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>表示查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>输出结果集的表</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>ref</td>
<td>列与索引的比较</td>
</tr>
<tr>
<td>rows</td>
<td>扫描出的行数(估算的行数)</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤的行百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>执行情况的描述和说明</td>
</tr>
</tbody>
</table>
<h4 id="20索引设计的原则">20.索引设计的原则？</h4>
<ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引。</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间。</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h4 id="21-mysql有关权限的表有哪几个">21. MySQL有关权限的表有哪几个？</h4>
<table>
<thead>
<tr>
<th>表名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>user权限表</td>
<td>记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</td>
</tr>
<tr>
<td>db权限表</td>
<td>记录各个帐号在各个数据库上的操作权限。</td>
</tr>
<tr>
<td>table_priv权限表</td>
<td>记录数据表级的操作权限。</td>
</tr>
<tr>
<td>columns_priv权限表</td>
<td>记录数据列级的操作权限。</td>
</tr>
<tr>
<td>host权限表</td>
<td>配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</td>
</tr>
</tbody>
</table>
<h3 id="二白日梦的mysql专题">二、白日梦的MySQL专题</h3>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483722&amp;idx=1&amp;sn=4d1e1eb5e4f97c8a91898195823eb26b&amp;chksm=ec1841efdb6fc8f9429609c18270fd421c61e442ebc893c4fa00ea29df12c73748e1f64ed54e&amp;scene=21#wechat_redirect">1、谈谈MySQL中基数是什么？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483764&amp;idx=1&amp;sn=332b5b05d931b06a64ab07982bfab794&amp;chksm=ec1841d1db6fc8c732c1c78fce4f9027305fd2590871038817f8386b5fc0b4a3e296b4970d30&amp;scene=21#wechat_redirect">2、聊聊什么是慢查？如何监控？如何排查？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483766&amp;idx=1&amp;sn=0f53c86b270183e24134b8b3eac71cd6&amp;chksm=ec1841d3db6fc8c553e882d33c2cfc83bc8fc7d5046fbc7ee147bfff3403ec36a1c24094067a&amp;scene=21#wechat_redirect">3、对Not Null字段插入Null值有啥现象？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483802&amp;idx=1&amp;sn=0714dea1bf86ea9f1e44b0eb377b1d1e&amp;chksm=ec18413fdb6fc829fb1285d9142f8f8daccc35b4cb5de47c0f9ef2d5efb5fc8db1bc8f6d5a08&amp;scene=21#wechat_redirect">4、能谈谈year、date、datetime、time、timestamp的区别吗？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483817&amp;idx=1&amp;sn=d19e5ce05cd9520d1becd7b6afa5e0be&amp;chksm=ec18410cdb6fc81a2bc86184427536832c8f8aff1daae1d1966afa0ff1af667d292ffe43a310&amp;scene=21#wechat_redirect">5、你有没有搞混查询缓存和Buffer Pool？谈谈看！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483875&amp;idx=1&amp;sn=60744026b460f40e95871b0ddb0b8eab&amp;chksm=ec184146db6fc85009bf60c6561e6d09086a2ca901f6e808a7525d6f2ed441bbc20aaeeab1a4&amp;scene=21#wechat_redirect">6、你知道数据库缓冲池中的LRU-List吗？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483877&amp;idx=1&amp;sn=55af9ab7e9a92891bc5c79d80f4d70f8&amp;chksm=ec184140db6fc856cfdf5f9b4eaed27503f91da810d0c39f27b84ec122d770d85af3fb64c84e&amp;scene=21#wechat_redirect">7、了解InnoDB的FreeList吗？谈谈看！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483881&amp;idx=1&amp;sn=f9a8a9d140b49278dfa8dd0d6b56ee91&amp;chksm=ec18414cdb6fc85aca7c705267ca5a660e7efd0540cdaa1045b50e0532521f38b9896fcc60a2&amp;scene=21#wechat_redirect">8、了解Flush-List吗？顺便说一下脏页的落盘机制！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483905&amp;idx=1&amp;sn=ecabed40aa39b065f1d54149a85ab998&amp;chksm=ec1842a4db6fcbb296f1dc3990607621e7f44d33591ae5b6857a8ccd0ee75db93c6d18017516&amp;scene=21#wechat_redirect">9、用 11 张图讲清楚，当你CRUD时BufferPool中发生了什么！以及BufferPool的优化！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483930&amp;idx=1&amp;sn=0eb06217c049f116ad78ab179e6be19a&amp;chksm=ec1842bfdb6fcba9ac413a89572844a29685627123c96602d6311497834d6deb20889e8e014d&amp;scene=21#wechat_redirect">10、了解 MySQL的表空间 和 数据表吗？谈谈看！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483988&amp;idx=1&amp;sn=b8808e88d713aa79193dd54a55670426&amp;chksm=ec1842f1db6fcbe717b1b4fd78a2cb94161556064d5a9792cbbb1ed6feb25a4cb919fac7bce0&amp;scene=21#wechat_redirect">11、了解 MySQL的数据行吗？行溢出机制呢？谈谈看！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483989&amp;idx=1&amp;sn=cffab3e55a82e37e1707eb386c79e70d&amp;chksm=ec1842f0db6fcbe65a5b4d176a4cb36be8e07b4952b70a0d6c8a0d1e8503a0728a9bb6a75016&amp;scene=21#wechat_redirect">12、了解MySQL数据页吗？说说什么是页分裂吧！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247483991&amp;idx=1&amp;sn=4e85ec6a3609c804a0b5ee1801345a14&amp;chksm=ec1842f2db6fcbe449c79be104af0bc832cce17ead4bf3b8edb460e488ad5c5a328f1b94f0a9&amp;scene=21#wechat_redirect">13、用一分钟了解fsync这个系统调用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247484018&amp;idx=1&amp;sn=bc5f775c11fc998138da587760b64f99&amp;chksm=ec1842d7db6fcbc10cdcb31bf867161fc8c0397b664b96e7bb29c18e29bc20970a1656de7a90&amp;scene=21#wechat_redirect">14、简述undo log、truncate、以及undo log如何帮你回滚事务？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247484048&amp;idx=1&amp;sn=4d651758ef5268f4d0f2aacd8f917f33&amp;chksm=ec184235db6fcb234566ea9756c268a1ea53efee1b5e13e495635a54b5e8272801fc962cc9da&amp;scene=21#wechat_redirect">15、我劝！这位年轻人不讲MVCC，耗子尾汁！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247484219&amp;idx=1&amp;sn=118f3c5aa5975d6ad2c7431c7ef010ce&amp;chksm=ec18439edb6fca885e73c21add15232fc4d98bf9ecc2780b1e8eb31a389df203d4e3c5d75ad1&amp;scene=21#wechat_redirect">16、传说中的MySQL的redo log是什么？谈谈看！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247484244&amp;idx=1&amp;sn=c98a9e431c49988cc11404027f48f365&amp;chksm=ec1843f1db6fcae7eabc2f0dfc5bdb2fa49a5bfeba85b99139746c4396bd8fa52fc97f5e7b6d&amp;scene=21#wechat_redirect">17、LSN、Checkpoint？谈谈MYSQL的崩溃恢复是怎么回事！</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247484266&amp;idx=1&amp;sn=09f7a4f59575f9f2b2d6767b845f1eae&amp;chksm=ec1843cfdb6fcad9451930ee09b47bd369fa880a00752ad7e99b63e4168ee27d2cea39a1bb17&amp;scene=21#wechat_redirect">18、MySQL的 bin log有啥用？在哪里？谁写的？怎么配置？</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI5MDg4ODEzOA==&amp;mid=2247484316&amp;idx=1&amp;sn=c1d8fed59e3a352f3960ce803983bb17&amp;chksm=ec184339db6fca2f94c31d361bd133e7029ce579010e4ccf92f1796a0effad773eebb3f4ed67&amp;scene=21#wechat_redirect">19、bin log有哪些格式？有啥区别？优缺点？线上用哪种格式？</a></p>
<p><a href="https://mp.weixin.qq.com/s/c7KLGRNd5FT4xVoeJ4tvag">20、MySQL的修仙之路，图文谈谈如何学MySQL、如何进阶！</a></p>
<p>文章公众号首发，连载中，欢迎关注白日梦，一起冲鸭！</p>
<p>文章公众号首发，连载中，欢迎关注白日梦，一起冲鸭！</p>
<p>文章公众号首发，连载中，欢迎关注白日梦，一起冲鸭！</p>
<h3 id="三redis问答">三、Redis问答</h3>
<h4 id="1-redis能存哪些类型">1. redis能存哪些类型</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">string <span style="color:#f92672">==</span> Map<span style="color:#f92672">&lt;</span>String<span style="color:#960050;background-color:#1e0010">，</span>String<span style="color:#f92672">&gt;</span>
map    <span style="color:#f92672">==</span> Map<span style="color:#f92672">&lt;</span>String<span style="color:#960050;background-color:#1e0010">，</span>Map<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>
list   <span style="color:#f92672">==</span> Map<span style="color:#f92672">&lt;</span>String <span style="color:#960050;background-color:#1e0010">，</span> List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>
set    <span style="color:#f92672">==</span> Map<span style="color:#f92672">&lt;</span>String<span style="color:#960050;background-color:#1e0010">，</span>Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>
zset   <span style="color:#f92672">==</span> Map<span style="color:#f92672">&lt;</span>String<span style="color:#960050;background-color:#1e0010">，</span>ZSet<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>
</code></pre></div><h4 id="2redis为什么这么快-高并发如何处理的">2、redis为什么这么快？ 高并发如何处理的？</h4>
<p>高并发的原因：</p>
<p>1.redis是基于内存的，内存的读写速度非常快；</p>
<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>
<p>3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>
<p>为什么Redis是单线程的：</p>
<p>官方答案： 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>不需要各种锁的性能消耗</p>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除</p>
<p>一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p>
<p>总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<p>CPU消耗：</p>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>
<p>但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p>
<p>可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。</p>
<h4 id="3过期键的删除策略">3.过期键的删除策略</h4>
<p>我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p>过期策略通常有以下三种：</p>
<ol>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ol>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h4 id="4redis的内存淘汰策略有哪些">4.Redis的内存淘汰策略有哪些</h4>
<p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是<strong>最常用</strong>的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h4 id="5-redlock">5. RedLock</h4>
<p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁。</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区。</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务。</li>
</ol>
<h4 id="6-redis缓存异常--缓存雪崩">6. Redis缓存异常&ndash;缓存雪崩</h4>
<p><strong>缓存雪崩</strong>是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案</strong></p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li>
</ol>
<h4 id="7-redis缓存异常--缓存穿透">7. Redis缓存异常&ndash;缓存穿透</h4>
<p><strong>缓存穿透</strong>是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>解决方案</p>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li>
</ol>
<p>附加</p>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。</p>
<p>Bitmap： 典型的就是哈希表</p>
<p>缺点是：Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p>布隆过滤器（推荐）</p>
<p>就是引入了<code>k(k&gt;1)k(k&gt;1)</code>个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h4 id="8-redis缓存异常--缓存击穿">8. Redis缓存异常&ndash;缓存击穿</h4>
<p><strong>缓存击穿</strong>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<p>解决方案</p>
<ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁。</li>
</ol>
<h4 id="9-缓存预热">9. 缓存预热</h4>
<p><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决方案</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作一下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
<h4 id="10如何保证数据库和缓存双写一致性">10.如何保证数据库和缓存双写一致性</h4>
<p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<p>还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是<strong>先更新数据库，然后再删除缓存。</strong></p>
<table>
<thead>
<tr>
<th><strong>问题场景</strong></th>
<th><strong>描述</strong></th>
<th><strong>解决</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>先写缓存，再写数据库，缓存写成功，数据库写失败</td>
<td>缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读</td>
<td>这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存</td>
</tr>
<tr>
<td>先写数据库，再写缓存，数据库写成功，缓存写失败</td>
<td>写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据</td>
<td>缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现</td>
</tr>
<tr>
<td>需要缓存异步刷新</td>
<td>指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候</td>
<td>确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔</td>
</tr>
</tbody>
</table>
<h4 id="11假如redis里面有1亿个key其中有10w个key是以某个固定的已知的前缀开头的如果将它们全部找出来">11.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h4>
<p>使用keys指令可以扫出指定模式的key列表。</p>
<p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p>
<p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/cs" rel="tag" title="cs">#cs#</a>
    
    <a href="http://shanks.link/tags/db" rel="tag" title="db">#db#</a>
    
    <a href="http://shanks.link/tags/%e9%9d%a2%e8%af%95" rel="tag" title="面试">#面试#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E8%87%AA%E7%A0%94%E4%B8%87%E4%BA%BF%E7%BA%A7%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/" rel="next" title="字节跳动自研万亿级图数据库 &amp; 图计算实践">
        <i class="fa fa-chevron-left"></i> 字节跳动自研万亿级图数据库 &amp; 图计算实践
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/07/27/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/" rel="prev" title="字节跳动混沌工程实践总结">
        字节跳动混沌工程实践总结 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">412</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">24</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">30</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.92.1</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>