<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>golang 的channels 行为 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="golang 的channels 行为">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="golang 的channels 行为 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/07/19/golang-%E7%9A%84channels-%E8%A1%8C%E4%B8%BA/" itemprop="url">
        golang 的channels 行为
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-07-19">
    2021-07-19
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/%E9%9D%A2%E8%AF%95" itemprop="url" rel="index">
        <span itemprop="name">面试</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6585 字 ~14分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="简介">简介</h2>
<p>当我第一次使用 Go 的 channels 工作的时候，我犯了一个错误，把 channels 考虑为一个数据结构。我把 channels 看作为 goroutines 之间提供自动同步访问的队列。这种结构上的理解导致我写了很多不好且结构复杂的并发代码。</p>
<p>随着时间的推移，我认识到最好的方式是忘记 channels 是数据结构，转而关注它的行为。所以现在谈论到 channels，我只考虑一件事情：signaling（信号）。一个 channel 允许一个 goroutine 给另外一个发特定事件的信号。信号是使用 channel 做一切事情的核心。将 channel 看作是一种信号机制，可以让你写出明确定义和精确行为的更好代码。</p>
<p>为了理解信号怎样工作，我们必须理解以下三个特性：</p>
<ul>
<li>交付保证</li>
<li>状态</li>
<li>有数据或无数据</li>
</ul>
<p>这三个特性共同构成了围绕信号的设计哲学，在讨论这些特性之后，我将提供一系列代码示例，这些示例将演示使用这些属性的信号。</p>
<h2 id="交付保证">交付保证</h2>
<p>交付保证基于一个问题：“我是否需要保证由特定的 goroutine 发送的信号已经被接收？”</p>
<p>换句话说，我们可以给出清单1的示例：</p>
<p><strong>清单1</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
02     p := &lt;-ch <span style="color:#f00;font-style:italic">// Receive
</span><span style="color:#f00;font-style:italic"></span>03 }()
04
05 ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span> <span style="color:#f00;font-style:italic">// Send
</span></code></pre></div><p>发送的 goroutine 是否需要保证在第五行中发送给 channel 的 paper，在继续执行前， 会被第二行的 goroutine 接收。</p>
<p>基于这个问题的答案，你将知道使用两种类型的 channels 中的哪种：<strong>无缓冲</strong>或<strong>有缓冲</strong>。每个channel围绕交付保证提供不同的行为。</p>
<p><strong>图1</strong></p>
<p><img src="http://shanks.link/img/golang%E7%9A%84channels%E8%A1%8C%E4%B8%BA/1.png" alt="img"></p>
<p>保证很重要，并且如果你不这样认为，我有很多东西兜售给你。当然，我想开个玩笑，当你的生活没有保障的时候你不会害怕吗？在编写并发代码时，对是否需要一项保证有很强的理解是至关重要的。随着继续，你将学会如何做决策。</p>
<h2 id="状态">状态</h2>
<p>一个 channel 的行为直接被它当前的状态所影响。一个channel 的状态是：<strong>nil</strong>，<strong>open</strong> 或 <strong>closed</strong>。</p>
<p>下面的清单2展示了怎样声明或把一个 channel放进这三个状态。</p>
<p><strong>清单2</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f00;font-style:italic">// ** nil channel
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">// A channel is in a nil state when it is declared to its zero value
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">var</span> ch <span style="color:#00f">chan</span> <span style="color:#00f">string</span>

<span style="color:#f00;font-style:italic">// A channel can be placed in a nil state by explicitly setting it to nil.
</span><span style="color:#f00;font-style:italic"></span>ch = <span style="color:#00f">nil</span>


<span style="color:#f00;font-style:italic">// ** open channel
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">// A channel is in a open state when it’s made using the built-in function make.
</span><span style="color:#f00;font-style:italic"></span>ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>)  


<span style="color:#f00;font-style:italic">// ** closed channel
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">// A channel is in a closed state when it’s closed using the built-in function close.
</span><span style="color:#f00;font-style:italic"></span>close(ch)
</code></pre></div><p>状态决定了怎样<strong>send</strong>（发送）和<strong>receive</strong>（接收）操作行为。</p>
<p>信号通过一个 channel 发送和接收。不要说读和写，因为 channels 不执行 I/O。</p>
<p><strong>图2</strong></p>
<p><img src="http://shanks.link/img/golang%E7%9A%84channels%E8%A1%8C%E4%B8%BA/2.png" alt="img"></p>
<p>当一个 channel 是 <strong>nil</strong> 状态，任何试图在 channel 的发送或接收都将会被阻塞。当一个 channel 是在 <strong>open</strong> 状态，信号可以被发送和接收。当一个 channel 被置为 <strong>closed</strong> 状态，信号将不在被发送，但是依然可以接收信号。</p>
<p>这些状态将在你遭遇不同的情况的时候可以提供不同的行为。当结合<strong>状态</strong>和<strong>交付保证</strong>，作为你设计选择的结果，你可以分析你承担的成本/收益。你也可以仅仅通过读代码快速发现错误，因为你懂得 channel 将表现出什么行为。</p>
<h2 id="有数据和无数据">有数据和无数据</h2>
<p>最后的信号特性需要考虑你是否需要信号有数据或者无数据。</p>
<p>在一个 channel 中有数据的信号被执行一个发送。</p>
<p><strong>清单3</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>
</code></pre></div><p>当你的信号有数据，它通常是因为：</p>
<ul>
<li>一个 goroutine 被要求启动一个新的 task。</li>
<li>一个 goroutine 传达一个结果。</li>
</ul>
<p>无数据信号通过关闭一个 channel。</p>
<p><strong>清单4</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 close(ch)
</code></pre></div><p>当信号没有数据的时候，它通常是因为：</p>
<ul>
<li>一个 goroutine 被告知停止它正在做的事情。</li>
<li>一个 goroutine 报告它们已经完成，没有结果。</li>
<li>一个 goroutine 报告它已经完成处理并且关闭。</li>
</ul>
<p>这些规则也有例外，但这些都是主要的用例，并且我们将在本文中重点讨论这些问题。我认为这些规则例外的情况是最初的代码味道。</p>
<p>无数据信号的一个好处是一个单独的 goroutine 可以立刻给很多 goroutines 信号。有数据的信号通常是在 goroutines 之间一对一的交换数据。</p>
<h2 id="有数据信号">有数据信号</h2>
<p>当你使用有数据信号的时候，依赖于你需要保证的类型，有三个channel配置选项可以选择。</p>
<p><strong>图3：有数据信号</strong></p>
<p><img src="http://shanks.link/img/golang%E7%9A%84channels%E8%A1%8C%E4%B8%BA/3.png" alt="img"></p>
<p>这三个 channel 选项是：<strong>Unbuffered</strong>, <strong>Buffered &gt;1</strong> 或 <strong>Buffered =1</strong>。</p>
<ul>
<li><strong>有保证</strong>
<ul>
<li>一个<strong>无缓冲</strong>的channel给你保证被发送的信号已经被接收。
<ul>
<li>因为信号接收发生在信号发送完成之前。</li>
</ul>
</li>
</ul>
</li>
<li><strong>无保证</strong>
<ul>
<li>一个 <code>size &gt; 1 </code>的有缓冲的 channel 不会保证发送的信号已经被接收。
<ul>
<li>因为信号发送发生在信号接送完成之前。</li>
</ul>
</li>
</ul>
</li>
<li><strong>延迟保证</strong>
<ul>
<li>一个 <code>size = 1</code> 的有缓冲 channel 提供延迟保证。它可以保证先前发送的信号已经被接收。
<ul>
<li>因为第一个接收信号，发生在第二个完成的发送信号之前。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>缓冲大小绝对不能是一个随机数字，它必须是为一些定义好的约束而计算出来的。在计算中没有无穷大，无论是空间还是时间，所有的东西都必须要有良好的定义约束。</p>
<h2 id="无数据信号">无数据信号</h2>
<p>无数据信号主要用于取消，它允许一个 goroutine 发送信号给另外一个来取消它们正在做的事情。取消可以被有缓冲和无缓冲的channels实现，但是在没有数据发送的情况下使用缓冲 channel 会更好。</p>
<p><strong>图4：无数据信号</strong></p>
<p><img src="http://shanks.link/img/golang%E7%9A%84channels%E8%A1%8C%E4%B8%BA/4.png" alt="img"></p>
<p>内建的函数 <code>close</code> 被用于无数据信号。正如上面<strong>状态</strong>章节所解释的那样，你依然可以在channel关闭的时候接收信号。实际上，在一个关闭的channel上的任何接收都不会被阻塞，并且接收操作将一直返回。</p>
<p>在大多数情况下，你想使用标准的库 <code>context</code> 包来实现无数据信号。<code>context</code> 包使用一个无缓冲channel传递信号以及内建函数 <code>close</code>发送无数据信号。</p>
<p>如果你选择使用你自己的 channel 而不是 <code>context</code>包来取消，你的channel 应该是 <code>chan struct{}</code> 类型，这是一种零空间的惯用方式，用来表示一个信号仅仅用于信号传递。</p>
<h2 id="场景">场景</h2>
<p>有了这些特性，更进一步理解它们在实践中怎样工作的最好方式就是运行一系列的代码场景。当我在读写 channel 基础代码的时候，我喜欢把goroutines想像成人。这个形象对我非常有帮助，我将把它用作下面的辅助工具。</p>
<h3 id="有数据信号---保证---无缓冲-channels">有数据信号 - 保证 - 无缓冲 Channels</h3>
<p>当你需要知道一个被发送的信号已经被接收的时候，有两种情况需要考虑。它们是 <strong>等待任务</strong>和<strong>等待结果</strong>。</p>
<h4 id="场景1---等待任务">场景1 - 等待任务</h4>
<p>考虑一下作为一名经理，需要雇佣一名新员工。在本场景中，你想你的新员工执行一个任务，但是他们需要等待直到你准备好。这是因为在他们开始前你需要递给他们一份报告。</p>
<p><strong>清单5</strong></p>
<p><a href="https://link.segmentfault.com/?url=https%3A%2F%2Fplay.golang.org%2Fp%2FBnVEHRCcdh">在线演示地址</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">waitForTask</span>() {
    ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>)
    <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
        p := &lt;-ch
        <span style="color:#f00;font-style:italic">// Employee performs work here.
</span><span style="color:#f00;font-style:italic"></span>        <span style="color:#f00;font-style:italic">// Employee is done and free to go.
</span><span style="color:#f00;font-style:italic"></span>    }()
    time.<span style="color:#c34e00">Sleep</span>(time.<span style="color:#c34e00">Duration</span>(rand.<span style="color:#c34e00">Intn</span>(500)) * time.Millisecond)
    ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>
}
</code></pre></div><p>在清单5的第2行，一个带有属性的无缓冲channel被创建，<code>string</code> 数据将与信号一起被发送。在第4行，一名员工被雇佣并在开始工作前，被告诉等待你的信号【在第5行】。第5行是一个 channel 接收，引起员工阻塞直到等到你发送的报告。一旦报告被员工接收，员工将执行工作并在完成的时候可以离开。</p>
<p>你作为经理正在并发的与你的员工工作。因此在第4行你雇佣员工之后，你发现你自己需要做什么来解锁并且发信号给员工（第12行）。值得注意的是，不知道要花费多长的时间来准备这份报告（paper）。</p>
<p>最终你准备好给员工发信号，在第14行，你执行一个有数据信号，数据就是那份报告。由于一个无缓冲的channel被使用，你得到一个保证就是一旦你操作完成，员工就已经接收到了这份报告。接收发生在发送之前。</p>
<p>技术上你所知道的一切就是在你的channel发送操作完成的同时员工接收到了这份报告。在两个channel操作之后，调度器可以选择执行它想要执行的任何语句。下一行被执行的代码是被你还是员工是不确定的。这意味着使用print语句会欺骗你关于事件的执行顺序。</p>
<h4 id="场景2---等待结果">场景2 - 等待结果</h4>
<p>在下一个场景中，事情是相反的。这时你想你的员工一被雇佣就立即执行他们的任务。然后你需要等待他们工作的结果。你需要等待是因为在你继续前你需要他们发来的报告。</p>
<p><strong>清单6</strong>
<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fplay.golang.org%2Fp%2FVFAWHxIQTP">在线演示地址</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">waitForResult</span>() {
    ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>)
    <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
        time.<span style="color:#c34e00">Sleep</span>(time.<span style="color:#c34e00">Duration</span>(rand.<span style="color:#c34e00">Intn</span>(500)) * time.Millisecond)
        ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>
        <span style="color:#f00;font-style:italic">// Employee is done and free to go.
</span><span style="color:#f00;font-style:italic"></span>    }()
    p := &lt;-ch
}
</code></pre></div><h4 id="成本收益">成本/收益</h4>
<p>无缓冲 channel 提供了信号被发送就会被接收的保证，这很好，但是没有任何东西是没有代价的。这个成本就是保证是未知的延迟。在<strong>等待任务</strong>场景中，员工不知道你要花费多长时间发送你的报告。在<strong>等待结果</strong>场景中，你不知道员工会花费多长时间把报告发送给你。</p>
<p>在以上两个场景中，未知的延迟是我们必须面对的，因为它需要保证。没有这种保证行为，逻辑就不会起作用。</p>
<h3 id="有数据信号---无保证---缓冲-channels--1">有数据信号 - 无保证 - 缓冲 Channels &gt; 1</h3>
<h4 id="场景1---扇出fan-out">场景1 - 扇出（Fan Out）</h4>
<p>扇出模式允许你抛出明确定义数量的员工在同时工作的问题上。由于你每个任务都有一个员工，你很明确的知道你会接收多少个报告。你可能需要确保你的盒子有适量的空间来接收所有的报告。这就是你员工的收益，不需要等待你来提交他们的报告。但是他们确实需要轮流把报告放进你的盒子，如果他们几乎同一时间到达盒子。</p>
<p>再次假设你是经理，但是这次你雇佣一个团队的员工，你有一个单独的任务，你想每个员工都执行它。作为每个单独的员工完成他们的任务，他们需要给你提供一张报告放进你桌子上的盒子里面。</p>
<p><strong>清单7</strong>
<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fplay.golang.org%2Fp%2F8HIt2sabs_">演示地址</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">func</span> <span style="color:#c34e00">fanOut</span>() {
02     emps := 20
03     ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>, emps)
04
05     <span style="color:#00f">for</span> e := 0; e &lt; emps; e++ {
06         <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
07             time.<span style="color:#c34e00">Sleep</span>(time.<span style="color:#c34e00">Duration</span>(rand.<span style="color:#c34e00">Intn</span>(200)) * time.Millisecond)
08             ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>
09         }()
10     }
11
12     <span style="color:#00f">for</span> emps &gt; 0 {
13         p := &lt;-ch
14         fmt.<span style="color:#c34e00">Println</span>(p)
15         emps--
16     }
17 }
</code></pre></div><p>在清单7的第3行，一个带有属性的有缓冲channel被创建，<code>string</code> 数据将与信号一起被发送。这时，由于在第2行声明的 <code>emps</code> 变量，将创建有 20个缓冲的 channel。</p>
<p>在第5行和第10行之间，20 个员工被雇佣，并且他们立即开始工作。在第7行你不知道每个员工将花费多长时间。这时在第8行，员工发送他们的报告，但这一次发送不会阻塞等待接收。因为在盒子里为每位员工准备的空间，在 channel 上的发送仅仅与其他在同一时间想发送他们报告的员工竞争。</p>
<p>在 12 行和16行之间的代码全部是你的操作。在这里你等待20个员工来完成他们的工作并且发送报告。在12行，你在一个循环中，在 13 行你被阻塞在一个 channel 等待接收你的报告。一旦报告接收完成，报告在14被打印，并且本地的计数器变量被消耗来表明一个员工意见完成了他的工作。</p>
<h4 id="场景2---drop">场景2 - Drop</h4>
<p>Drop模式允许你在你的员工在满负荷的时候丢掉工作。这有利于继续接受客户端的工作，并且从不施加压力或者是这项工作可接受的延迟。这里的关键是知道你什么时候是满负荷的，因此你不承担或过度承诺你将尝试完成的工作量。通常集成测试或度量可以帮助你确定这个数字。</p>
<p>假设你是经理，你雇佣了单个员工来完成工作。你有一个单独的任务想员工去执行。当员工完成他们任务时，你不在乎知道他们已经完成了。最重要的是你能或不能把新工作放入盒子。如果你不能执行发送，这时你知道你的盒子满了并且员工是满负荷的。这时候，新工作需要丢弃以便让事情继续进行。</p>
<p><strong>清单8</strong>
<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fplay.golang.org%2Fp%2FPhFUN5itiv">演示地址</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">func</span> <span style="color:#c34e00">selectDrop</span>() {
02     <span style="color:#00f">const</span> cap = 5
03     ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>, cap)
04
05     <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
06         <span style="color:#00f">for</span> p := <span style="color:#00f">range</span> ch {
07             fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;employee : received :&#34;</span>, p)
08         }
09     }()
10
11     <span style="color:#00f">const</span> work = 20
12     <span style="color:#00f">for</span> w := 0; w &lt; work; w++ {
13         <span style="color:#00f">select</span> {
14             <span style="color:#00f">case</span> ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>:
15                 fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;manager : send ack&#34;</span>)
16             <span style="color:#00f">default</span>:
17                 fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;manager : drop&#34;</span>)
18         }
19     }
20
21     close(ch)
22 }
</code></pre></div><p>在清单8的第3行，一个有属性的有缓冲 channel 被创建，<code>string</code> 数据将与信号一起被发送。由于在第2行声明的 <code>cap</code> 常量，这时创建了有5个缓冲的 channel。</p>
<p>从第5行到第9行，一个单独的员工被雇佣来处理工作，一个 <code>for range</code>被用于循环处理 channel 的接收。每次一份报告被接收，在第7行被处理。</p>
<p>在第11行和19行之间，你尝试发送20分报告给你的员工。这时一个 <code>select</code>语句在第14行的第一个 <code>case</code>被用于执行发送。因为 <code>default</code>从句被用于第16行的 <code>select</code>语句。如果发送被堵塞，是因为缓冲中没有多余的空间，通过执行第17行发送被丢弃。</p>
<p>最后在第21行，内建函数 <code>close</code>被调用来关闭channel。这将发送没有数据的信号给员工表明他们已经完成，并且一旦他们完成分派给他们的工作可以立即离开。</p>
<h4 id="成本收益-1">成本/收益</h4>
<p>有缓冲的 channel 缓冲大于1提供无保证发送的信号被接收到。离开保证是有好处的，在两个goroutine之间通信可以降低或者是没有延迟。在<strong>扇出</strong>场景，这有一个有缓冲的空间用于存放员工将被发送的报告。在<strong>Drop</strong>场景，缓冲是测量能力的，如果容量满，工作被丢弃以便工作继续。</p>
<p>在两个选择中，这种缺乏保证是我们必须面对的，因为延迟降低非常重要。0到最小延迟的要求不会给系统的整体逻辑造成问题。</p>
<h3 id="有数据信号---延迟保证--缓冲1的channel">有数据信号 - 延迟保证- 缓冲1的channel</h3>
<h4 id="场景1---等待任务-1">场景1 - 等待任务</h4>
<p><strong>清单9</strong>
<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fplay.golang.org%2Fp%2F4pcuKCcAK3">演示地址</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">func</span> <span style="color:#c34e00">waitForTasks</span>() {
02     ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>, 1)
03
04     <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
05         <span style="color:#00f">for</span> p := <span style="color:#00f">range</span> ch {
06             fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;employee : working :&#34;</span>, p)
07         }
08     }()
09
10     <span style="color:#00f">const</span> work = 10
11     <span style="color:#00f">for</span> w := 0; w &lt; work; w++ {
12         ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>
13     }
14
15     close(ch)
16 }
</code></pre></div><p>在清单9的第2行，一个带有属性的一个缓冲大小的 channel 被创建，<code>string</code> 数据将与信号一起被发送。在第4行和第8行之间，一个员工被雇佣来处理工作。<code>for range</code>被用于循环处理 channel 的接收。在第6行每次一份报告被接收就被处理。</p>
<p>在第10行和13行之间，你开始发送你的任务给员工。如果你的员工可以跑的和你发送的一样快，你们之间的延迟会降低。但是每次发送你成功执行，你需要保证你提交的最后一份工作正在被进行。</p>
<p>在最后的第15行，内建函数 <code>close </code>被调用关闭channel，这将会发送无数据信号给员工告知他们工作已经完成，可以离开了。尽管如此，你提交的最后一份工作将在 <code>for range</code>中断前被接收。</p>
<h3 id="无数据信号---context">无数据信号 - Context</h3>
<p>在最后这个场景中，你将看到从 <code>Context</code> 包中使用 <code>Context </code>值怎样取消一个正在运行的goroutine。这所有的工作是通过改变一个已经关闭的无缓冲channel来执行一个无数据信号。</p>
<p>最后一次你是经理，你雇佣了一个单独的员工来完成工作，这次你不会等待员工未知的时间完成他的工作。你分配了一个截止时间，如果你的员工没有按时完成工作，你将不会等待。</p>
<p><strong>清单10</strong>
<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fplay.golang.org%2Fp%2F6GQbN5Z7vC">演示地址</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">func</span> <span style="color:#c34e00">withTimeout</span>() {
02     duration := 50 * time.Millisecond
03
04     ctx, cancel := context.<span style="color:#c34e00">WithTimeout</span>(context.<span style="color:#c34e00">Background</span>(), duration)
05     <span style="color:#00f">defer</span> <span style="color:#c34e00">cancel</span>()
06
07     ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>, 1)
08
09     <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
10         time.<span style="color:#c34e00">Sleep</span>(time.<span style="color:#c34e00">Duration</span>(rand.<span style="color:#c34e00">Intn</span>(100)) * time.Millisecond)
11         ch &lt;- <span style="color:#009c00">&#34;paper&#34;</span>
12     }()
13
14     <span style="color:#00f">select</span> {
15     <span style="color:#00f">case</span> p := &lt;-ch:
16         fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;work complete&#34;</span>, p)
17
18     <span style="color:#00f">case</span> &lt;-ctx.<span style="color:#c34e00">Done</span>():
19         fmt.<span style="color:#c34e00">Println</span>(<span style="color:#009c00">&#34;moving on&#34;</span>)
20     }
21 }
</code></pre></div><p>在清单10的第2行，一个时间值被声明，它代表了员工将花费多长时间完成他们的工作。这个值被用在第4行来创建一个50毫秒超时的 <code>context.Context </code>值。<code>context </code>包的 <code>WithTimeout</code>函数返回一个 <code>Context</code> 值和一个取消函数。</p>
<p><code>context</code>包创建一个goroutine，一旦时间值到期，将关闭与 <code>Context </code>值关联的无缓冲channels。不管事情如何发生，你需要负责调用 <code>cancel </code>函数。这将清理被 <code>Context</code>创建的东西。<code>cancel</code>被调用不止一次是可以的。</p>
<p>在第5行，一旦函数中断，<code>cancel</code>函数被 deferred 执行。在第7行，1个缓冲的channels被创建，它被用于被员工发送他们工作的结果给你。在第09行和12行，员工被雇佣兵立即投入工作，你不需要指定员工花费多长时间完成他们的工作。</p>
<p>在第14行和20行之间，你使用 <code>select </code>语句来在两个channels接收。在第15行的接收，你等待员工发送他们的结果。在第18行的接收，你等待看 <code>context </code>包是否正在发送信号50毫秒的时间到了。无论你首先收到哪个信号，都将有一个被处理。</p>
<p>这个算法的一个重要方面是使用一个缓冲的channels。如果员工没有按时完成，你将离开而不会给员工任何通知。对于员工而言，在第11行他将一直发送他的报告，你在或者不在那里接收，他都是盲目的。如果你使用一个无缓冲channels，如果你离开，员工将一直阻塞在那尝试你给发送报告。这会引起goroutine泄漏。因此一个缓冲的channels用来防止这个问题发生。</p>
<h2 id="总结">总结</h2>
<p>当使用 channels（或并发） 时，在保证，channel状态和发送过程中信号属性是非常重要的。它们将帮助你实现你并发程序需要的更好的行为以及你写的算法。它们将帮助你找出bug和闻出潜在的坏代码。</p>
<p>在本文中，我分享了一些程序示例来展示信号属性工作在不同的场景中。凡事都有例外，但是这些模式是非常良好的开端。</p>
<p>作为总结回顾下这些要点，何时，如何有效地思考和使用channels：</p>
<h3 id="语言机制">语言机制</h3>
<ul>
<li>使用 channels 来编排和协作 goroutines：
<ul>
<li>关注信号属性而不是数据共享</li>
<li>有数据信号和无数据信号</li>
<li>询问它们用于同步访问共享数据的用途
<ul>
<li>有些情况下，对于这个问题，通道可以更简单一些，但是最初的问题是。</li>
</ul>
</li>
</ul>
</li>
<li>无缓冲 channels：
<ul>
<li>接收发生在发送之前</li>
<li>收益：100%保证信号被接收</li>
<li>成本：未知的延迟，不知道信号什么时候将被接收。</li>
</ul>
</li>
<li>有缓冲 channels：
<ul>
<li>发送发生在接收之前。</li>
<li>收益：降低信号之间的阻塞延迟。</li>
<li>成本：不保证信号什么时候被接收。
<ul>
<li>缓冲越大，保证越少。</li>
<li>缓冲为1可以给你一个延迟发送保证。</li>
</ul>
</li>
</ul>
</li>
<li>关闭的 channels：
<ul>
<li>关闭发生在接收之前（像缓冲）。</li>
<li>无数据信号。</li>
<li>完美的信号取消或截止。</li>
</ul>
</li>
<li>nil channels：
<ul>
<li>发送和接收都阻塞。</li>
<li>关闭信号。</li>
<li>完美的速度限制或短时停工。</li>
</ul>
</li>
</ul>
<h3 id="设计哲学">设计哲学</h3>
<ul>
<li>如果在 channel上任何给定的发送能引起发送 goroutine 阻塞：
<ul>
<li>不允许使用大于1的缓冲channels。
<ul>
<li>缓冲大于1必须有原因/测量。</li>
</ul>
</li>
<li>必须知道当发送 goroutine阻塞的时候发生了什么。</li>
</ul>
</li>
<li>如果在 channel 上任何给定的发送不会引起发送阻塞：
<ul>
<li>每个发送必须有确切的缓冲数字。
<ul>
<li>扇出模式。</li>
</ul>
</li>
<li>有缓冲测量最大的容量。
<ul>
<li>Drop 模式。</li>
</ul>
</li>
</ul>
</li>
<li>对于缓冲而言，少即是多。
<ul>
<li>当考虑缓冲的时候，不要考虑性能。</li>
<li>缓冲可以帮助降低信号之间的阻塞延迟。
<ul>
<li>降低阻塞延迟到0并不一定意味着更好的吞吐量。</li>
<li>如果一个缓冲可以给你足够的吞吐量，那就保持它。</li>
<li>缓冲大于1的问题需要测量大小。</li>
<li>尽可能找到提供足够吞吐量的最小缓冲</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
    <a href="http://shanks.link/tags/%e9%9d%a2%e8%af%95" rel="tag" title="面试">#面试#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/07/19/leader%E6%80%BB%E8%AE%A9%E6%88%91%E5%B9%B2%E6%9D%82%E6%B4%BB%E6%88%91%E5%BE%88%E4%B8%8D%E6%BB%A1%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/" rel="next" title="leader总让我干杂活，我很不满，该怎么办？">
        <i class="fa fa-chevron-left"></i> leader总让我干杂活，我很不满，该怎么办？
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/07/19/go-%E5%BC%80%E5%8F%91%E8%80%85%E5%AF%B9-go-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/" rel="prev" title="GO 开发者对 GO 初学者的建议">
        GO 开发者对 GO 初学者的建议 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">561</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">43</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">48</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>