<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>常见的10种排序算法 - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="常见的10种排序算法">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="常见的10种排序算法 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/08/12/%E5%B8%B8%E8%A7%81%E7%9A%8410%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url">
        常见的10种排序算法
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-08-12">
    2021-08-12
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/algorithm" itemprop="url" rel="index">
        <span itemprop="name">algorithm</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">7552 字 ~16分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="常见的排序算法常见的10种排序">[常见的排序算法——常见的10种排序]</h1>
<h2 id="常见算法可以分为两大类">常见算法可以分为两大类：</h2>
<p>　　非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p>
<p>　　线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。
<img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190711231258717-1334457150.png" alt="图片"></p>
<p>算法复杂度：</p>
<p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190709231552258-1256281704.png" alt="图片"></p>
<p><strong>1、冒泡排序</strong>
思路：外层循环从1到n-1，内循环从当前外层的元素的下一个位置开始，依次和外层的元素比较，出现逆序就交换，通过与相邻元素的比较和交换来把小的数交换到最前面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#00f">for</span>(<span style="color:#00f">int</span> i=0;i&lt;arr.length-1;i++){<span style="color:#f00;font-style:italic">//外层循环控制排序趟数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> 　　　　　　<span style="color:#00f">for</span>(<span style="color:#00f">int</span> j=0;j&lt;arr.length-1-i;j++){<span style="color:#f00;font-style:italic">//内层循环控制每一趟排序多少次
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> 　　　　　　　　<span style="color:#00f">if</span>(arr[j]&gt;arr[j+1]){
</span></span><span style="display:flex;"><span> 　　　　　　　　　　<span style="color:#00f">int</span> temp=arr[j];
</span></span><span style="display:flex;"><span> 　　　　　　　　　　arr[j]=arr[j+1];
</span></span><span style="display:flex;"><span> 　　　　　　　　　　arr[j+1]=temp;
</span></span><span style="display:flex;"><span> 　　　　　　　　}
</span></span><span style="display:flex;"><span> 　　　　　　}
</span></span><span style="display:flex;"><span> 　　　　} 
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190709233249402-580041311.gif" alt="图片"></p>
<p><strong>2、选择排序</strong>
思路：冒泡排序是通过相邻的比较和交换，每次找个最小值。选择排序是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> n = array.length;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; n-1; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> min = i;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> j = i+1; j &lt; n; j++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (array[j] &lt; array[min]){<span style="color:#f00;font-style:italic">//寻找最小数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    min = j;                      <span style="color:#f00;font-style:italic">//将最小数的索引赋值
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                 }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> temp = array[i];
</span></span><span style="display:flex;"><span>            array[i] = array[min];
</span></span><span style="display:flex;"><span>            array[min] = temp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }                   
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190709234546406-1933756989.gif" alt="图片"></p>
<p><strong>3、插入排序</strong>
思路：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。可以理解为玩扑克牌时的理牌；</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> n = array.length;
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    *从第二位数字开始，每一个数字都试图跟它的前一个比较并交换，并重复；直到前一个数字不存在或者比它小或相等时停下来
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    **/</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 1; i &lt; n; i++) {<span style="color:#f00;font-style:italic">//从第二个数开始
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">int</span> key = array[i];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> j = i -1;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">while</span> (j &gt;= 0 &amp;&amp; array[j]&gt;key) {
</span></span><span style="display:flex;"><span>                array[j + 1] = array[j];     <span style="color:#f00;font-style:italic">//交换
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                j--;                                <span style="color:#f00;font-style:italic">//下标向前移动
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            array[j+1] = key;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190709235607059-17861797.gif" alt="图片"></p>
<p>4、希尔排序
思路：希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。
问题：增量的序列取法？
　　关于取法，没有统一标准，但最后一步必须是1；因为不同的取法涉及时间复杂度不一样，具体了解可以参考《数据结构与算法分析》；一般以length/2为算法。（再此以gap=gap*3+1为公式）
问题2:为什么不一开始就直接采用插入排序对整个数组排一次呢?
插入排序在数据无规律时，复杂度高，先分组排序后，后面进行插入排序时，元素已经相对有序了,此时插入排序效率会高很多
<a href="https://www.bilibili.com/video/BV1rE411g7rW?from=search&amp;seid=5903469482207930913">相关视频</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> n = array.length;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> h = 1;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (h&lt;n/3) { <span style="color:#f00;font-style:italic">//动态定义间隔序列
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>              h = 3*h +1;
</span></span><span style="display:flex;"><span>                 }
</span></span><span style="display:flex;"><span>         <span style="color:#00f">while</span> (h &gt;= 1) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = h; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">for</span> (<span style="color:#00f">int</span> j = i; j &gt;= h &amp;&amp; (array[j] &lt; array[j - h]); j -= h) {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">int</span> temp = array[j];
</span></span><span style="display:flex;"><span>                    array[j] = array[j - h];
</span></span><span style="display:flex;"><span>                    array[j-h]= temp;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            h /=3;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190710000924754-469368076.gif" alt="图片"></p>
<p>5、归并排序
思路：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。它使用了递归分治的思想；相当于：左半边用尽，则取右半边元素；右半边用尽，则取左半边元素；右半边的当前元素小于左半边的当前元素，则取右半边元素；右半边的当前元素大于左半边的当前元素，则取左半边的元素。
　　自顶向下：
<a href="https://www.bilibili.com/video/BV1tJ411U7uG">相关视频</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">mergeSort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] aux = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[array.length];
</span></span><span style="display:flex;"><span>        sort(array, aux, 0, array.length - 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span>[] aux, <span style="color:#00f">int</span> lo, <span style="color:#00f">int</span> hi) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (hi&lt;=lo) <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> mid = lo + (hi - lo)/2;
</span></span><span style="display:flex;"><span>        sort(array, aux, lo, mid);
</span></span><span style="display:flex;"><span>        sort(array, aux, mid + 1, hi);
</span></span><span style="display:flex;"><span>        merge(array, aux, lo, mid, hi);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">merge</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span>[] aux, <span style="color:#00f">int</span> lo, <span style="color:#00f">int</span> mid, <span style="color:#00f">int</span> hi) {
</span></span><span style="display:flex;"><span>        System.arraycopy(array,0,aux,0,array.length);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> i = lo, j = mid + 1;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> k = lo; k &lt;= hi; k++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (i&gt;mid) array[k] = aux[j++];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span> <span style="color:#00f">if</span> (j &gt; hi) array[k] = aux[i++];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span> <span style="color:#00f">if</span> (aux[j]&lt;aux[i]) array[k] = aux[j++];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span> array[k] = aux[i++];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>　　自底向上：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> N = a.length;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] aux = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[N];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> n = 1; n &lt; N; n = n+n) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; N-n; i += n+n) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">int</span> lo = i;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">int</span> m  = i+n-1;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">int</span> hi = Math.min(i+n+n-1, N-1);
</span></span><span style="display:flex;"><span>                merge(array, aux, lo, m, hi);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">merge</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span>[] aux, <span style="color:#00f">int</span> lo, <span style="color:#00f">int</span> mid, <span style="color:#00f">int</span> hi) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> k = lo; k &lt;= hi; k++) {
</span></span><span style="display:flex;"><span>            aux[k] = array[k];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// merge back to a[]
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span> i = lo, j = mid+1;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> k = lo; k &lt;= hi; k++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span>      (i &gt; mid)              array[k] = aux[j++];  <span style="color:#f00;font-style:italic">// this copying is unneccessary
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">else</span> <span style="color:#00f">if</span> (j &gt; hi)               array[k] = aux[i++];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span> <span style="color:#00f">if</span> (aux[j]&lt;aux[i]) array[k] = aux[j++];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span>                           array[k] = aux[i++];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>缺点：因为是Out-place sort，因此相比快排，需要很多额外的空间。</p>
<p>为什么归并排序比快速排序慢？</p>
<p>　　答：虽然渐近复杂度一样，但是归并排序的系数比快排大。</p>
<p>对于归并排序有什么改进？</p>
<p>　　答：就是在数组长度为k时，用插入排序，因为插入排序适合对小数组排序。在算法导论思考题2-1中介绍了。复杂度为O(nk+nlg(n/k)) ，当k=O(lgn)时，复杂度为O(nlgn)</p>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span> mark = 0;
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * 归并排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span>[] <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span> low, <span style="color:#00f">int</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> mid = (low + high) / 2;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (low &lt; high) {
</span></span><span style="display:flex;"><span>          mark++;
</span></span><span style="display:flex;"><span>          System.out.println(<span style="color:#009c00">&#34;正在进行第&#34;</span> + mark + <span style="color:#009c00">&#34;次分隔，得到&#34;</span>);
</span></span><span style="display:flex;"><span>          System.out.println(<span style="color:#009c00">&#34;[&#34;</span> + low + <span style="color:#009c00">&#34;-&#34;</span> + mid + <span style="color:#009c00">&#34;] [&#34;</span> + (mid + 1) + <span style="color:#009c00">&#34;-&#34;</span> + high + <span style="color:#009c00">&#34;]&#34;</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 左边数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          sort(array, low, mid);
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 右边数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          sort(array, mid + 1, high);
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 左右归并
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          merge(array, low, mid, high);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> array;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * 对数组进行归并
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param array
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param low
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param mid
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param high
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">merge</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span> low, <span style="color:#00f">int</span> mid, <span style="color:#00f">int</span> high) {
</span></span><span style="display:flex;"><span>        System.out.println(<span style="color:#009c00">&#34;合并:[&#34;</span> + low + <span style="color:#009c00">&#34;-&#34;</span> + mid + <span style="color:#009c00">&#34;] 和 [&#34;</span> + (mid + 1) + <span style="color:#009c00">&#34;-&#34;</span> + high + <span style="color:#009c00">&#34;]&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] temp = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[high - low + 1];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> i = low;<span style="color:#f00;font-style:italic">// 左指针
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span> j = mid + 1;<span style="color:#f00;font-style:italic">// 右指针
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span> k = 0;
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 把较小的数先移到新数组中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (array[i] &lt; array[j]) {
</span></span><span style="display:flex;"><span>            temp[k++] = array[i++];
</span></span><span style="display:flex;"><span>          } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            temp[k++] = array[j++];
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 两个数组之一可能存在剩余的元素
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#f00;font-style:italic">// 把左边剩余的数移入数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">while</span> (i &lt;= mid) {
</span></span><span style="display:flex;"><span>          temp[k++] = array[i++];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 把右边边剩余的数移入数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">while</span> (j &lt;= high) {
</span></span><span style="display:flex;"><span>          temp[k++] = array[j++];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 把新数组中的数覆盖array数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> m = 0; m &lt; temp.length; m++) {
</span></span><span style="display:flex;"><span>          array[m + low] = temp[m];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * 归并排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span>[] <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> sort(array, 0, array.length - 1);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] array = { 3, 5, 2, 6, 2 };
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] sorted = sort(array);
</span></span><span style="display:flex;"><span>        System.out.println(<span style="color:#009c00">&#34;最终结果&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i : sorted) {
</span></span><span style="display:flex;"><span>          System.out.print(i + <span style="color:#009c00">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span></code></pre></div><p>6、快速排序
思路：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        shuffle(array);
</span></span><span style="display:flex;"><span>        sort(array, 0, array.length - 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span> lo, <span style="color:#00f">int</span> hi) {
</span></span><span style="display:flex;"><span>       <span style="color:#00f">if</span>(hi&lt;=lo+M) {
</span></span><span style="display:flex;"><span>        Insert.sort(a,lo,hi);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> lt = lo, gt = hi;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> v = array[lo];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> i = lo;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (i &lt;= gt) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span>      (array[i]&lt;v) exch(array, lt++, i++);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span> <span style="color:#00f">if</span> (array[i]&gt;v) exch(array, i, gt--);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">else</span>              i++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi].
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        sort(array, lo, lt-1);
</span></span><span style="display:flex;"><span>        sort(array, gt+1, hi);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">exch</span>(<span style="color:#00f">int</span>[] a, <span style="color:#00f">int</span> i, <span style="color:#00f">int</span> j) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> swap = a[i];
</span></span><span style="display:flex;"><span>        a[i] = a[j];
</span></span><span style="display:flex;"><span>        a[j] = swap;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     *打乱数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">shuffle</span>(<span style="color:#00f">int</span>[] array) {
</span></span><span style="display:flex;"><span>        Random random = <span style="color:#00f">new</span> Random(System.currentTimeMillis());
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (array == <span style="color:#00f">null</span>) <span style="color:#00f">throw</span> <span style="color:#00f">new</span> NullPointerException(<span style="color:#009c00">&#34;argument array is null&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> n = array.length;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> r = i + random.nextInt(n-i);     <span style="color:#f00;font-style:italic">// between i and n-1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">int</span> temp = array[i];
</span></span><span style="display:flex;"><span>            array[i] = array[r];
</span></span><span style="display:flex;"><span>            array[r] = temp;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    代码例子：
</span></span><span style="display:flex;"><span><span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">class</span> <span style="color:#007575">s</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span>[] arr = { 5,2,4,9,7 };
</span></span><span style="display:flex;"><span>            sort(arr, 0, arr.length - 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span> arr[], <span style="color:#00f">int</span> low, <span style="color:#00f">int</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> l = low;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> h = high;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> k = arr[low];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">while</span> (l &lt; h) {
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// 从后往前比较
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#00f">while</span> (l &lt; h &amp;&amp; arr[h] &gt;= k ){ <span style="color:#f00;font-style:italic">// 如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    h--;<span style="color:#f00;font-style:italic">// h=6
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (l &lt; h) {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">int</span> temp = arr[h];
</span></span><span style="display:flex;"><span>                    arr[h] = arr[l];
</span></span><span style="display:flex;"><span>                    arr[l] = temp;
</span></span><span style="display:flex;"><span>                    <span style="color:#f00;font-style:italic">//进行过一次替换后，没必要将替换后的两值再次比较，所以i++直接下一位与k对比
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    l++;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// 从前往后比较
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#00f">while</span> (l &lt; h &amp;&amp; arr[l] &lt;= k) { <span style="color:#f00;font-style:italic">// 如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    l++;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (l &lt; h) {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">int</span> temp = arr[h];
</span></span><span style="display:flex;"><span>                    arr[h] = arr[l];
</span></span><span style="display:flex;"><span>                    arr[l] = temp;
</span></span><span style="display:flex;"><span>                    h--;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// 此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            print(arr);
</span></span><span style="display:flex;"><span>            System.out.print(<span style="color:#009c00">&#34;l=&#34;</span> + (l + 1) + <span style="color:#009c00">&#34;h=&#34;</span> + (h + 1) + <span style="color:#009c00">&#34;k=&#34;</span> + k + <span style="color:#009c00">&#34;\n&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">// 递归
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">if</span> (l &gt; low)<span style="color:#f00;font-style:italic">//先判断l&gt;low再次经行左边排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                sort(arr, low, l - 1);<span style="color:#f00;font-style:italic">// 左边序列。第一个索引位置到关键值索引-1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">if</span> (h &lt; high)<span style="color:#f00;font-style:italic">//左边依次排序执行完递归后，弹栈进行右边排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                sort(arr, l + 1, high);<span style="color:#f00;font-style:italic">// 右边序列。从关键值索引+1到最后一个
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 打印数组的方法
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">print</span>(<span style="color:#00f">int</span>[] arr) {
</span></span><span style="display:flex;"><span>            System.out.print(<span style="color:#009c00">&#34;[&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; arr.length; i++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (i != (arr.length - 1)) {
</span></span><span style="display:flex;"><span>                    System.out.print(arr[i] + <span style="color:#009c00">&#34;,&#34;</span>);
</span></span><span style="display:flex;"><span>                } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>                    System.out.print(arr[i] + <span style="color:#009c00">&#34;]&#34;</span>);
</span></span><span style="display:flex;"><span>                    System.out.println();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">class</span> <span style="color:#007575">s</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span>[] arr = { 5,2,4,9,7 };
</span></span><span style="display:flex;"><span>            sort(arr, 0, arr.length - 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span> arr[], <span style="color:#00f">int</span> low, <span style="color:#00f">int</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> l = low;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> h = high;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> k = arr[low];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">while</span> (l &lt; h) {
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// 从后往前比较
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#00f">while</span> (l &lt; h &amp;&amp; arr[h] &gt;= k ){ <span style="color:#f00;font-style:italic">// 如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    h--;<span style="color:#f00;font-style:italic">// h=6
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (l &lt; h) {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">int</span> temp = arr[h];
</span></span><span style="display:flex;"><span>                    arr[h] = arr[l];
</span></span><span style="display:flex;"><span>                    arr[l] = temp;
</span></span><span style="display:flex;"><span>                    <span style="color:#f00;font-style:italic">//进行过一次替换后，没必要将替换后的两值再次比较，所以i++直接下一位与k对比
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    l++;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// 从前往后比较
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#00f">while</span> (l &lt; h &amp;&amp; arr[l] &lt;= k) { <span style="color:#f00;font-style:italic">// 如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    l++;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (l &lt; h) {
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">int</span> temp = arr[h];
</span></span><span style="display:flex;"><span>                    arr[h] = arr[l];
</span></span><span style="display:flex;"><span>                    arr[l] = temp;
</span></span><span style="display:flex;"><span>                    h--;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// 此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            print(arr);
</span></span><span style="display:flex;"><span>            System.out.print(<span style="color:#009c00">&#34;l=&#34;</span> + (l + 1) + <span style="color:#009c00">&#34;h=&#34;</span> + (h + 1) + <span style="color:#009c00">&#34;k=&#34;</span> + k + <span style="color:#009c00">&#34;\n&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">// 递归
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">if</span> (l &gt; low)<span style="color:#f00;font-style:italic">//先判断l&gt;low再次经行左边排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                sort(arr, low, l - 1);<span style="color:#f00;font-style:italic">// 左边序列。第一个索引位置到关键值索引-1
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">if</span> (h &lt; high)<span style="color:#f00;font-style:italic">//左边依次排序执行完递归后，弹栈进行右边排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                sort(arr, l + 1, high);<span style="color:#f00;font-style:italic">// 右边序列。从关键值索引+1到最后一个
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 打印数组的方法
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">print</span>(<span style="color:#00f">int</span>[] arr) {
</span></span><span style="display:flex;"><span>            System.out.print(<span style="color:#009c00">&#34;[&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; arr.length; i++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (i != (arr.length - 1)) {
</span></span><span style="display:flex;"><span>                    System.out.print(arr[i] + <span style="color:#009c00">&#34;,&#34;</span>);
</span></span><span style="display:flex;"><span>                } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>                    System.out.print(arr[i] + <span style="color:#009c00">&#34;]&#34;</span>);
</span></span><span style="display:flex;"><span>                    System.out.println();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>7、堆排序
思路：堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] a){
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> N = a.length;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] keys = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[N+1];
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//注意，堆的数据结构是从1开始的，0不用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 1; i &lt; keys.length; i++) {
</span></span><span style="display:flex;"><span>            keys[i] = a[i-1];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//      //构造堆,使得堆是有序的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span>(<span style="color:#00f">int</span> k = N/2;k&gt;=1;k--) sink(keys,k,N);
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//排序，相当于毁掉堆
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">while</span>(N&gt;1){
</span></span><span style="display:flex;"><span>            exch(keys,1,N--);
</span></span><span style="display:flex;"><span>            sink(keys,1,N);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//重新写回数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; a.length; i++) {
</span></span><span style="display:flex;"><span>            a[i] = keys[i+1];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sink</span>(<span style="color:#00f">int</span>[] a, <span style="color:#00f">int</span> k, <span style="color:#00f">int</span> N) {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// TODO Auto-generated method stub
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">while</span>(2*k&lt;=N){
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> j = 2*k;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (j &lt; N &amp;&amp; less(a[j], a[j+1])) j++;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (less(a[j], a[k])) <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>            exch(a, k, j);
</span></span><span style="display:flex;"><span>            k = j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">boolean</span> <span style="color:#c34e00">less</span>(<span style="color:#00f">int</span> k, <span style="color:#00f">int</span> j) {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// TODO Auto-generated method stub
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">return</span> k &lt; j;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">exch</span>(<span style="color:#00f">int</span>[] a, <span style="color:#00f">int</span> i, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// TODO Auto-generated method stub
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span> temp = a[i];
</span></span><span style="display:flex;"><span>        a[i] = a[n];
</span></span><span style="display:flex;"><span>        a[n] = temp;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>代码例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">class</span> <span style="color:#007575">dui</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * 调整为小顶堆（排序后结果为从大到小）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param array是待调整的堆数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param s是待调整的数组元素的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param length是数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">heapAdjustS</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span> s, <span style="color:#00f">int</span> length) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> tmp = array[s];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> child = 2 * s + 1;<span style="color:#f00;font-style:italic">// 左孩子结点的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        System.out.println(<span style="color:#009c00">&#34;待调整结点为：array[&#34;</span> + s + <span style="color:#009c00">&#34;] = &#34;</span> + tmp);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (child &lt; length) {
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// child + 1 是当前调整结点的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#f00;font-style:italic">// 如果有右孩子且小于左孩子，使用右孩子与结点进行比较，否则使用左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">if</span> (child + 1 &lt; length &amp;&amp; array[child] &gt; array[child + 1]) {
</span></span><span style="display:flex;"><span>            child++;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          System.out.println(<span style="color:#009c00">&#34;将与子孩子 array[&#34;</span> + child + <span style="color:#009c00">&#34;] = &#34;</span> + array[child] + <span style="color:#009c00">&#34; 进行比较&#34;</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 如果较小的子孩子比此结点小
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">if</span> (array[s] &gt; array[child]) {
</span></span><span style="display:flex;"><span>            System.out.println(<span style="color:#009c00">&#34;子孩子比其小，交换位置&#34;</span>);
</span></span><span style="display:flex;"><span>            array[s] = array[child];<span style="color:#f00;font-style:italic">// 把较小的子孩子向上移动，替换当前待调整结点
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            s = child;<span style="color:#f00;font-style:italic">// 待调整结点移动到较小子孩子原来的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            array[child] = tmp;
</span></span><span style="display:flex;"><span>            child = 2 * s + 1;<span style="color:#f00;font-style:italic">// 继续判断待调整结点是否需要继续调整
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (child &gt;= length) {
</span></span><span style="display:flex;"><span>              System.out.println(<span style="color:#009c00">&#34;没有子孩子了，调整结束&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>              System.out.println(<span style="color:#009c00">&#34;继续与新的子孩子进行比较&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">// continue;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            System.out.println(<span style="color:#009c00">&#34;子孩子均比其大，调整结束&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;<span style="color:#f00;font-style:italic">// 当前待调整结点小于它的左右孩子，不需调整，直接退出
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * 调整为大顶堆（排序后结果为从小到大）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param array是待调整的堆数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param s是待调整的数组元素的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param length是数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">heapAdjustB</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">int</span> s, <span style="color:#00f">int</span> length) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> tmp = array[s];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> child = 2 * s + 1;<span style="color:#f00;font-style:italic">// 左孩子结点的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        System.out.println(<span style="color:#009c00">&#34;待调整结点为：array[&#34;</span> + s + <span style="color:#009c00">&#34;] = &#34;</span> + tmp);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (child &lt; length) {
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// child + 1 是当前调整结点的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#f00;font-style:italic">// 如果有右孩子且大于左孩子，使用右孩子与结点进行比较，否则使用左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">if</span> (child + 1 &lt; length &amp;&amp; array[child] &lt; array[child + 1]) {
</span></span><span style="display:flex;"><span>            child++;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          System.out.println(<span style="color:#009c00">&#34;将与子孩子 array[&#34;</span> + child + <span style="color:#009c00">&#34;] = &#34;</span> + array[child] + <span style="color:#009c00">&#34; 进行比较&#34;</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 如果较大的子孩子比此结点大
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">if</span> (array[s] &lt; array[child]) {
</span></span><span style="display:flex;"><span>            System.out.println(<span style="color:#009c00">&#34;子孩子比其大，交换位置&#34;</span>);
</span></span><span style="display:flex;"><span>            array[s] = array[child];<span style="color:#f00;font-style:italic">// 把较大的子孩子向上移动，替换当前待调整结点
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            s = child;<span style="color:#f00;font-style:italic">// 待调整结点移动到较大子孩子原来的位置
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            array[child] = tmp;
</span></span><span style="display:flex;"><span>            child = 2 * s + 1;<span style="color:#f00;font-style:italic">// 继续判断待调整结点是否需要继续调整
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (child &gt;= length) {
</span></span><span style="display:flex;"><span>              System.out.println(<span style="color:#009c00">&#34;没有子孩子了，调整结束&#34;</span>);
</span></span><span style="display:flex;"><span>            } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>              System.out.println(<span style="color:#009c00">&#34;继续与新的子孩子进行比较&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">// continue;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            System.out.println(<span style="color:#009c00">&#34;子孩子均比其小，调整结束&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;<span style="color:#f00;font-style:italic">// 当前待调整结点大于它的左右孩子，不需调整，直接退出
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * 堆排序算法
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param array
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       * @param inverse true 为倒序排列，false 为正序排列
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">       */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">heapSort</span>(<span style="color:#00f">int</span>[] array, <span style="color:#00f">boolean</span> inverse) {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 初始堆
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#f00;font-style:italic">// 最后一个有孩子的结点位置 i = (length - 1) / 2, 以此向上调整各结点使其符合堆
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        System.out.println(<span style="color:#009c00">&#34;初始堆开始&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = (array.length - 1) / 2; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (inverse) {
</span></span><span style="display:flex;"><span>            heapAdjustS(array, i, array.length);
</span></span><span style="display:flex;"><span>          } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            heapAdjustB(array, i, array.length);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.out.println(<span style="color:#009c00">&#34;初始堆结束&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = array.length - 1; i &gt; 0; i--) {
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 交换堆顶元素H[0]和堆中最后一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">int</span> tmp = array[i];
</span></span><span style="display:flex;"><span>          array[i] = array[0];
</span></span><span style="display:flex;"><span>          array[0] = tmp;
</span></span><span style="display:flex;"><span>          <span style="color:#f00;font-style:italic">// 每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          <span style="color:#00f">if</span> (inverse) {
</span></span><span style="display:flex;"><span>            heapAdjustS(array, 0, i);
</span></span><span style="display:flex;"><span>          } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>            heapAdjustB(array, 0, i);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] array = { 49, 38, 65, 97, 76, 13, 27, 49 };
</span></span><span style="display:flex;"><span>        heapSort(array, <span style="color:#00f">false</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i : array) {
</span></span><span style="display:flex;"><span>          System.out.print(i + <span style="color:#009c00">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190710003052018-245302424.gif" alt="图片"></p>
<p>8、计数排序
思路：将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>　　找出待排序的数组中最大和最小的元素；
　　统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
　　对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
　　反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * 输入数组的元素都是介于0..k之间的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * @param data 待排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * @param k 最大元素
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * @return 排序结果
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span>[] <span style="color:#c34e00">sort</span>(<span style="color:#00f">int</span>[] data, <span style="color:#00f">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 存放临时数据的数组tmp，初始元素都是0；k为数组中最大元素
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span>[] tmp = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[k + 1];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 计算数组中每个元素i出现的次数，存入数组tmp中的第i项，即原数组中的元素值为tmp数组中的下标
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt;= data.length - 1; i++) {
</span></span><span style="display:flex;"><span>            tmp[data[i]]++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 计算数组中小于等于每个元素的个数,即从tmp中的第一个元素开始，每一项和前一项相加
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> j = 1; j &lt;= k; j++) {
</span></span><span style="display:flex;"><span>            tmp[j] = tmp[j] + tmp[j - 1];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// result数组用来来存放排序结果
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">int</span>[] result = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[data.length];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = data.length - 1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>            result[tmp[data[i]] - 1] = data[i];
</span></span><span style="display:flex;"><span>            tmp[data[i]]--;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>代码例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">class</span> <span style="color:#007575">jishu</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span>[] <span style="color:#c34e00">countingSort</span>(<span style="color:#00f">int</span>[] theArray) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] lastArray = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[theArray.length];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span>(<span style="color:#00f">int</span> i = 0; i &lt; theArray.length; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> count = 0;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span>(<span style="color:#00f">int</span> j = 0; j &lt; theArray.length; j++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span>(theArray[i] &gt; theArray[j]) {
</span></span><span style="display:flex;"><span>                    count++;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            lastArray[count] = theArray[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> lastArray;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> []theArray = {6, 4, 5, 1, 8, 7, 2, 3};
</span></span><span style="display:flex;"><span>        System.out.print(<span style="color:#009c00">&#34;之前的排序：&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span>(<span style="color:#00f">int</span> i = 0; i &lt; theArray.length; i++) {
</span></span><span style="display:flex;"><span>            System.out.print(theArray[i] + <span style="color:#009c00">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> []resultArray = countingSort(theArray);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.out.print(<span style="color:#009c00">&#34;计数排序：&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span>(<span style="color:#00f">int</span> i = 0; i &lt; resultArray.length; i++) {
</span></span><span style="display:flex;"><span>            System.out.print(resultArray[i] + <span style="color:#009c00">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190710003454192-626409910.gif" alt="图片"></p>
<p>9、桶排序
思路：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p>　　设置一个定量的数组当作空桶；
　　遍历输入数据，并且把数据一个一个放到对应的桶里去；
　　对每个不是空的桶进行排序；
　　从不是空的桶里把排好序的数据拼接起来。
<a href="https://www.bilibili.com/video/BV1A4411N7cG?from=search&amp;seid=1169656331578506796">视频介绍</a></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">bucketSort</span>(<span style="color:#00f">double</span> array[]) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> length = array.length;
</span></span><span style="display:flex;"><span>        ArrayList arrList[] = <span style="color:#00f">new</span> ArrayList[length];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; length; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">//0.7到0.79放在第8个桶里,编号7；第一个桶放0到0.09
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            <span style="color:#00f">int</span> temp = (<span style="color:#00f">int</span>) Math.floor(10 * array[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (<span style="color:#00f">null</span> == arrList[temp])
</span></span><span style="display:flex;"><span>                arrList[temp] = <span style="color:#00f">new</span> ArrayList();
</span></span><span style="display:flex;"><span>            arrList[temp].add(array[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">// 对每个桶中的数进行插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; length; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (<span style="color:#00f">null</span> != arrList[i]) {
</span></span><span style="display:flex;"><span>                Collections.sort(arrList[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> count = 0;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; length; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (<span style="color:#00f">null</span> != arrList[i]) {
</span></span><span style="display:flex;"><span>                Iterator iter = arrList[i].iterator();
</span></span><span style="display:flex;"><span>                <span style="color:#00f">while</span> (iter.hasNext()) {
</span></span><span style="display:flex;"><span>                    Double d = (Double) iter.next();
</span></span><span style="display:flex;"><span>                    array[count] = d;
</span></span><span style="display:flex;"><span>                    count++;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>代码例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">public</span> <span style="color:#00f">class</span> <span style="color:#007575">tong</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">private</span> <span style="color:#00f">int</span>[] buckets;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">private</span> <span style="color:#00f">int</span>[] array;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#c34e00">tong</span>(<span style="color:#00f">int</span> range,<span style="color:#00f">int</span>[] array){
</span></span><span style="display:flex;"><span>        <span style="color:#00f">this</span>.buckets = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[range];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">this</span>.array = array;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/*排序*/</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sort</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span>(array!=<span style="color:#00f">null</span> &amp;&amp; array.length&gt;1){
</span></span><span style="display:flex;"><span>          <span style="color:#00f">for</span>(<span style="color:#00f">int</span> i=0;i&lt;array.length;i++){
</span></span><span style="display:flex;"><span>            buckets[array[i]]++;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">/*排序输出*/</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">void</span> <span style="color:#c34e00">sortOut</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//倒序输出数据
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i=buckets.length-1; i&gt;=0; i--){
</span></span><span style="display:flex;"><span>          <span style="color:#00f">for</span>(<span style="color:#00f">int</span> j=0;j&lt;buckets[i];j++){
</span></span><span style="display:flex;"><span>            System.out.print(i+<span style="color:#009c00">&#34;\t&#34;</span>);
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>            testBucketsSort();
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">testBucketsSort</span>(){
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span>[] array = {5,7,3,5,4,8,6,4,1,2};
</span></span><span style="display:flex;"><span>            tong bs = <span style="color:#00f">new</span> tong(10, array);
</span></span><span style="display:flex;"><span>            bs.sort();
</span></span><span style="display:flex;"><span>            bs.sortOut();<span style="color:#f00;font-style:italic">//输出打印排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>          }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190710003853619-1629727895.png" alt="图片"></p>
<p>10、基数排序
思路：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>　　取得数组中的最大数，并取得位数；
　　arr为原始数组，从最低位开始取每个位组成radix数组；
　　对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#00f">private</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">radixSort</span>(<span style="color:#00f">int</span>[] array,<span style="color:#00f">int</span> radix, <span style="color:#00f">int</span> distance) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> length = array.length;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] temp = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[length];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span>[] count = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[radix];
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> divide = 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; distance; i++) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            System.arraycopy(array, 0,temp, 0, length);
</span></span><span style="display:flex;"><span>            Arrays.fill(count, 0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> j = 0; j &lt; length; j++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">int</span> tempKey = (temp[j]/divide)%radix;
</span></span><span style="display:flex;"><span>                count[tempKey]++;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> j = 1; j &lt; radix; j++) {
</span></span><span style="display:flex;"><span>                count [j] = count[j] + count[j-1];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> j = length - 1; j &gt;= 0; j--) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">int</span> tempKey = (temp[j]/divide)%radix;
</span></span><span style="display:flex;"><span>                count[tempKey]--;
</span></span><span style="display:flex;"><span>                array[count[tempKey]] = temp[j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            divide = divide * radix;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>代码例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  <span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span><span style="color:#00f">package</span> test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * 基数排序
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * 平均O(d(n+r)),最好O(d(n+r)),最坏O(d(n+r));空间复杂度O(n+r);稳定;较复杂
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     * d为位数,r为分配后链表的个数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     *
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">public</span> <span style="color:#00f">class</span> <span style="color:#007575">ji_shu</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//pos=1表示个位，pos=2表示十位
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">getNumInPos</span>(<span style="color:#00f">int</span> num, <span style="color:#00f">int</span> pos) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> tmp = 1;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; pos - 1; i++) {
</span></span><span style="display:flex;"><span>                tmp *= 10;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> (num / tmp) % 10;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//求得最大位数d
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">getMaxWeishu</span>(<span style="color:#00f">int</span>[] a) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> max = a[0];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; a.length; i++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (a[i] &gt; max)
</span></span><span style="display:flex;"><span>                        max = a[i];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span> tmp = 1, d = 1;
</span></span><span style="display:flex;"><span>            <span style="color:#00f">while</span> (<span style="color:#00f">true</span>) {
</span></span><span style="display:flex;"><span>                tmp *= 10;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (max / tmp != 0) {
</span></span><span style="display:flex;"><span>                    d++;
</span></span><span style="display:flex;"><span>                } <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> d;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">radixSort</span>(<span style="color:#00f">int</span>[] a, <span style="color:#00f">int</span> d) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span>[][] array = <span style="color:#00f">new</span> <span style="color:#00f">int</span>[10][a.length + 1];
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>                array[i][0] = 0;
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// array[i][0]记录第i行数据的个数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> pos = 1; pos &lt;= d; pos++) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i = 0; i &lt; a.length; i++) {
</span></span><span style="display:flex;"><span>                    <span style="color:#f00;font-style:italic">// 分配过程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    <span style="color:#00f">int</span> row = getNumInPos(a[i], pos);
</span></span><span style="display:flex;"><span>                    <span style="color:#00f">int</span> col = ++array[row][0];
</span></span><span style="display:flex;"><span>                    array[row][col] = a[i];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#00f">for</span> (<span style="color:#00f">int</span> row = 0, i = 0; row &lt; 10; row++) {
</span></span><span style="display:flex;"><span>                    <span style="color:#f00;font-style:italic">// 收集过程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                    <span style="color:#00f">for</span> (<span style="color:#00f">int</span> col = 1; col &lt;= array[row][0]; col++) {
</span></span><span style="display:flex;"><span>                        a[i++] = array[row][col];
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    array[row][0] = 0;
</span></span><span style="display:flex;"><span>                    <span style="color:#f00;font-style:italic">// 复位，下一个pos时还需使用
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">public</span> <span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">main</span>(String[] args) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">int</span>[] a = { 49, 38, 65, 197, 76, 213, 27, 50 };
</span></span><span style="display:flex;"><span>            radixSort(a, getMaxWeishu(a));
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (<span style="color:#00f">int</span> i : a)
</span></span><span style="display:flex;"><span>                  System.out.print(i + <span style="color:#009c00">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p><img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190710004213327-335264969.gif" alt="图片">
小结
　　排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。
　　下面就总结一下排序算法的各自的使用场景和适用场合。
<img src="http://shanks.link/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1730367-20190710004544503-260041480.png" alt="图片"></p>
<ol>
<li>
<p>从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</p>
</li>
<li>
<p>上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</p>
</li>
<li>
<p>基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。</p>
</li>
<li>
<p>从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</p>
</li>
<li>
<p>上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。</p>
</li>
</ol>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/%e9%9d%a2%e8%af%95" rel="tag" title="面试">#面试#</a>
    
    <a href="http://shanks.link/tags/%e6%8e%92%e5%ba%8f" rel="tag" title="排序">#排序#</a>
    
    <a href="http://shanks.link/tags/%e7%ae%97%e6%b3%95" rel="tag" title="算法">#算法#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/08/13/%E4%B8%80%E9%94%AE%E6%90%9E%E5%AE%9A-vscode-%E4%B8%8B%E7%9A%84-c/c-%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="next" title="一键搞定 VSCode 下的 C/C&#43;&#43;基本开发环境配置">
        <i class="fa fa-chevron-left"></i> 一键搞定 VSCode 下的 C/C&#43;&#43;基本开发环境配置
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/08/12/%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99%E9%83%BD%E8%A6%81%E4%BF%9D%E6%8C%81%E5%86%B7%E9%9D%99/" rel="prev" title="任何时候都要保持冷静">
        任何时候都要保持冷静 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">506</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">32</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>