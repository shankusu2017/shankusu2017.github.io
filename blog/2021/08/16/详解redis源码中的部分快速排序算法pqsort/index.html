<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>详解Redis源码中的部分快速排序算法pqsort - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="详解Redis源码中的部分快速排序算法pqsort">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="详解Redis源码中的部分快速排序算法pqsort - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/08/16/%E8%AF%A6%E8%A7%A3redis%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95pqsort/" itemprop="url">
        详解Redis源码中的部分快速排序算法pqsort
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-08-16">
    2021-08-16
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/redis" itemprop="url" rel="index">
        <span itemprop="name">redis</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5775 字 ~12分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h1 id="详解redis源码中的部分快速排序算法pqsortc">详解Redis源码中的部分快速排序算法（pqsort.c）</h1>
<p><a href="https://blog.csdn.net/guodongxiaren">转载自果冻虾仁</a> 2015-06-07 19:08:39</p>
<hr>
<p>　　看标题，你可能会疑惑：咦？你这家伙，怎么不讲解完整的快排，只讲一部分快排……<code>-。-</code> 哎，冤枉。“部分快排”是算法的名字，实际上本文相当详细呢。本文几乎与普通快排无异。看懂了本文，你对普通的快排也会有更深的认识了。</p>
<blockquote>
<p>　　快速排序算法（qsort）的原理我们大都应该了解。本文介绍的是<strong>部分快速排序算法</strong>。其实其算法本质是一样的，只不过限定了排序的左右区间，也就是只对一个数字序列的一部分进行排序，故称为“部分快速排序算法”，简称：<code>pqsort</code></p>
</blockquote>
<p>　　<code>Redis</code>项目中的<code>pqsort.c</code> 文件实现了<code>pqsort()</code>函数，其源码见本文最后一节 <a href="https://blog.csdn.net/guodongxiaren/article/details/45567291#t25">pqsort.c源码</a> 。 另外补充一句：长文慎入 <code>:-)</code></p>
<hr>
<h1 id="导读">导读</h1>
<h2 id="外部资料httpzhwikipediaorgwiki快速排序">外部资料http://zh.wikipedia.org/wiki/快速排序)</h2>
<h3 id="论文">论文</h3>
<p>　　实际上<code>pqsort.c</code>的快排流程是改编自一个经典实现，该实现被许多<strong>库</strong>的实现所使用。请参考<code>Bentley &amp; McIlroy</code>所著论文<a href="https://blog.csdn.net/guodongxiaren/article/details/ESF"> “Engineering a Sort Function”</a></p>
<h2 id="源码结构">源码结构</h2>
<table>
<thead>
<tr>
<th>主要函数</th>
<th>pqsort()</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态函数</td>
<td>_pqsort()、swapfuc()、med3()</td>
</tr>
<tr>
<td>宏函数</td>
<td>min()、swap()、swapcode()、vecswap()、SWAPINIT()</td>
</tr>
</tbody>
</table>
<p>　　总体来说，pqsort.c文件对外只提供了一个函数—— <strong>pqsort()</strong> ，但它的算法逻辑其实是由**_pqsort()**实现的，其他的静态（<em>static</em>）函数和宏也都是为了该函数服务的。
　　接下来的介绍中，我会简单介绍宏函数和几个静态函数，把重点放在静态函数<a href="https://blog.csdn.net/guodongxiaren/article/details/45567291#t17"><strong>_pqsort()</strong></a>上。它才是整个算法的核心部分。</p>
<h2 id="pqsort与qsort">pqsort()与qsort()</h2>
<p>　　<code>C标准库</code>中有一个快排的函数<code>qsort()</code>，它与本文介绍的<code>pqsort()</code>所提供的编程接口极为相似，请看两者声明：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">qsort</span> (<span style="color:#00f">void</span> *a, size_t n, size_t es, <span style="color:#00f">int</span> (*cmp)(<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *));
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">pqsort</span>(<span style="color:#00f">void</span> *a, size_t n, size_t es, <span style="color:#00f">int</span> (*cmp)(<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), 
</span></span><span style="display:flex;"><span>            size_t lrange, size_t rrange);123
</span></span></code></pre></div><h3 id="参数解读">参数解读</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>待排序数组的首地址</td>
</tr>
<tr>
<td>n</td>
<td>待排序元素的个数</td>
</tr>
<tr>
<td>es</td>
<td><code>element size</code>：每个元素的字节大小</td>
</tr>
<tr>
<td>cmp</td>
<td>回调函数，定义了比较的规则，直接影响排序结果是递增排序或递减排序，并支持非标准类型的排序</td>
</tr>
<tr>
<td>lrange</td>
<td>待排序的左边界</td>
</tr>
<tr>
<td>rrange</td>
<td>待排序的右边界</td>
</tr>
</tbody>
</table>
<h2 id="pqsort与_pqsort">pqsort()与_pqsort()</h2>
<h3 id="pqsort源码">pqsort()源码</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span><span style="color:#c34e00">pqsort</span>(<span style="color:#00f">void</span> *a, size_t n, size_t es,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*cmp) (<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), size_t lrange, size_t rrange)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _pqsort(a,n,es,cmp,((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+(lrange*es),
</span></span><span style="display:flex;"><span>                       ((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+((rrange+1)*es)-1);
</span></span><span style="display:flex;"><span>}1234567
</span></span></code></pre></div><p>　　可以看出我们的**qpsort()**其实是在调用<a href="https://blog.csdn.net/guodongxiaren/article/details/45567291#t17"><strong>_pqsort()</strong></a>来完成排序功能的。这两个函数很像，差别在于参数上。</p>
<p>看一下两者的函数原型：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">void</span> 
</span></span><span style="display:flex;"><span><span style="color:#c34e00">pqsort</span> (<span style="color:#00f">void</span> *a, size_t n, size_t es, <span style="color:#00f">int</span> (*cmp)(<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), 
</span></span><span style="display:flex;"><span>        size_t lrange, size_t rrange);
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span>_pqsort(<span style="color:#00f">void</span> *a, size_t n, size_t es, <span style="color:#00f">int</span> (*cmp)(<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), 
</span></span><span style="display:flex;"><span>        <span style="color:#00f">void</span> *lrange, <span style="color:#00f">void</span> *rrange)123456
</span></span></code></pre></div><p>差异的关键在于：</p>
<ul>
<li>pqsort() 的参数中的左右边界值，其含义值下标</li>
<li>_pqsort()的参数中的左右边界值，其含义是指针</li>
</ul>
<p>这样pqsort()源码就不足为奇了。所以我前面说该文件的核心部分是**_pqsort()**</p>
<h1 id="预备知识">预备知识</h1>
<p>　　看一下除了<a href="https://blog.csdn.net/guodongxiaren/article/details/45567291#t17"><strong>_pqsort()</strong></a>之外的源码部分，这些都是<a href="https://blog.csdn.net/guodongxiaren/article/details/45567291#t17"><strong>_pqsort()</strong></a>函数实现的辅助。</p>
<h2 id="med3">med3</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">char</span> *
</span></span><span style="display:flex;"><span><span style="color:#c34e00">med3</span>(<span style="color:#00f">char</span> *a, <span style="color:#00f">char</span> *b, <span style="color:#00f">char</span> *c,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*cmp) (<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> cmp(a, b) &lt; 0 ?
</span></span><span style="display:flex;"><span>           (cmp(b, c) &lt; 0 ? b : (cmp(a, c) &lt; 0 ? c : a ))
</span></span><span style="display:flex;"><span>              :(cmp(b, c) &gt; 0 ? b : (cmp(a, c) &lt; 0 ? a : c ));
</span></span><span style="display:flex;"><span>}123456789
</span></span></code></pre></div><p>　　根据回调函数<code>cmp</code>指定的比较规则，则求出变量a，b，c中处于中间大小的变量。换句话说：就是在求 <strong>中位数</strong>。</p>
<h2 id="min">min</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define min(a, b)   (a) &lt; (b) ? a : b1
</span></span></span></code></pre></div><p>　　这是个简单的宏，看一眼就呵呵就行了。</p>
<h2 id="swapinit">SWAPINIT</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;12
</span></span></span></code></pre></div><p>　　该宏的目的在于，给swaptype赋值，它有如下几种取值：</p>
<table>
<thead>
<tr>
<th>swaptype</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>数组a中每个元素的大小是<code>sizeof(long)</code></td>
</tr>
<tr>
<td>1</td>
<td>数组a中每个元素的大小是<code>sizeof(long)</code>的倍数，但不等于<code>sizeof(long)</code></td>
</tr>
<tr>
<td>2</td>
<td>数组a中每个元素的大小不是<code>sizeof(long)</code>的倍数</td>
</tr>
<tr>
<td>其他</td>
<td>数组a的首地址不是<code>sizeof(long)</code>的倍数，即不是总线字节对齐</td>
</tr>
</tbody>
</table>
<p>　　swaptype等于0、1、2的时候，数组a的首地址都是<code>sizeof(long)</code>字节对齐的。</p>
<blockquote>
<p><strong>题外话：</strong>
　　我们常说8字节对齐，指的是64位机器中要满足8字节对齐（首地址是8的倍数），则数据的读取效率会更高。而32位系统应满足的是4字节对齐。具体大小是和<strong>机器字长</strong>相关的，机器字长指的是计算机一次能读取的二进制位数。一般机器字长和long类型的大小相同，所以可以说要满足**sizeof(long)**字节对齐。</p>
</blockquote>
<hr>
<blockquote>
<p>下面首先介绍的是几个与交换操作相关的函数（或宏），这里我假定<strong>A → B</strong>表示A函数会调用B函数（宏）。
<img src="http://shanks.link/img/redis/3.png" alt="img"></p>
</blockquote>
<p>　　我们从右向左解读</p>
<h2 id="swapcode">swapcode</h2>
<p>　　这是个<strong>宏函数</strong> 。其功能是将以<code>parmi</code>和<code>parmj</code>为首地址的n个字节进行交换。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define swapcode(TYPE, parmi, parmj, n) {       \1
</span></span></span></code></pre></div><ul>
<li>形参<code>TYPE</code> 就是指的类型，阅读后面代码，可知其<strong>实参</strong>是<code>char</code>和<code>long</code>这两种。</li>
<li>形参<code>n</code> 指定的是待交换字节数。</li>
</ul>
<blockquote>
<p>请允许我在<strong>宏</strong>这里，使用了术语：<strong>形参</strong>、<strong>实参</strong>。虽然可能不搭，但目的是便于读者理解。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    size_t i = (n) / <span style="color:#00f">sizeof</span> (TYPE);         \
</span></span><span style="display:flex;"><span>    TYPE *pi = (TYPE *)(<span style="color:#00f">void</span> *)(parmi);         \
</span></span><span style="display:flex;"><span>    TYPE *pj = (TYPE *)(<span style="color:#00f">void</span> *)(parmj);         \123
</span></span></code></pre></div><p>　　<code>i</code>就是指定类型（char或long）的元素的个数。然后将参数<code>parmi</code>和<code>parmj</code>转换成指定的类型的指针<code>pi</code>和<code>pj</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#00f">do</span> {                        \
</span></span><span style="display:flex;"><span>        TYPE    t = *pi;            \
</span></span><span style="display:flex;"><span>        *pi++ = *pj;                \      <span style="color:#f00;font-style:italic">//等价于*pi = *pj; pi++;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        *pj++ = t;              \
</span></span><span style="display:flex;"><span>        } <span style="color:#00f">while</span> (--i &gt; 0);              \
</span></span><span style="display:flex;"><span>}                                          <span style="color:#f00;font-style:italic">//end of #define123456
</span></span></span></code></pre></div><p>　　一个<code>do-while</code>循环，内部执行了交换操作。</p>
<h2 id="swapfunc">swapfunc</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span><span style="color:#c34e00">swapfunc</span>(<span style="color:#00f">char</span> *a, <span style="color:#00f">char</span> *b, size_t n, <span style="color:#00f">int</span> swaptype)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (swaptype &lt;= 1)
</span></span><span style="display:flex;"><span>        swapcode(<span style="color:#00f">long</span>, a, b, n)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>        swapcode(<span style="color:#00f">char</span>, a, b, n)
</span></span><span style="display:flex;"><span>}123456789
</span></span></code></pre></div><p>　　简单的<code>if</code>条件语句。如果<code>swaptype &lt;= 1</code>*（swaptype为0或1，即元素类型为sizeof(long)的倍数）*则按long类型的大小来进行交换。否则就按char类型的大小来进行交换。
这样做的目的主要是提高交互操作的效率。</p>
<h2 id="swap">swap</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define swap(a, b)                      \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    if (swaptype == 0) {                    \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        long t = *(long *)(void *)(a);          \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        *(long *)(void *)(a) = *(long *)(void *)(b);    \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        *(long *)(void *)(b) = t;           \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    } else                          \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        swapfunc(a, b, es, swaptype)1234567
</span></span></span></code></pre></div><p>　　前面已经说过了，<code>swaptype</code>为0的时候，表示数组元素的大小等于long类型的大小。所以这里进行了这样的交互操作。</p>
<h2 id="vecswap">vecswap</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define vecswap(a, b, n) if ((n) &gt; 0) swapfunc((a), (b), (size_t)(n), swaptype)1
</span></span></span></code></pre></div><p>　　该宏和<code>swap(a, b)</code>其实很像，都是在调用<code>swapfunc</code>来完成交互操作。但而二者的不同之处是：<code>vecswap(a, b, n)</code>进行的是n*2个元素的交换，而<code>swap(a, b)</code>仅仅进行两个元素之间的交换。</p>
<blockquote>
<p><strong>vecswap</strong>是vector swap的缩写。vector即向量，表示多个元素</p>
</blockquote>
<p>　　好了，言归正传，前面说了这么多，其实都是基础先修课，接下来才是真正的核心代码呦。</p>
<h1 id="_pqsort">_pqsort</h1>
<p>回顾一下声明部分：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span><span style="color:#c34e00">_pqsort</span>(<span style="color:#00f">void</span> *a, size_t n, size_t es,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*cmp) (<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), <span style="color:#00f">void</span> *lrange, <span style="color:#00f">void</span> *rrange);123
</span></span></code></pre></div><p>　　因为a是带排序数字序列的首地址，所以我下面希望能用数组的写法来简化我的描述。
比如<code>&amp;a[1] = (char *) a + es</code>，<code>&amp;a[n-1] = (char *) a + (n-1)*es</code>
等号右边的表达式是void *实现C语言泛型功能的典型方法。</p>
<blockquote>
<p>诚然，在语法上，二者并非等价的，但在逻辑上是可以理解的。仅仅是为了便于理解，简化叙述</p>
</blockquote>
<p>　　cmp前面我也提到了是一个回调函数，实现了自定义的比较操作。这里为了简化叙述，我们<strong>假定</strong>要完成的就是一个递增序列，而cmp完成的就是一般的大小比较操作。
　　同样为了便于表述，我们假定我们要完成的是数字的排序工作，而不是其他自定义类型的排序工作。</p>
<h2 id="局部变量">局部变量</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#00f">char</span> *pa, *pb, *pc, *pd, *pl, *pm, *pn;
</span></span><span style="display:flex;"><span>    size_t d, r;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> swaptype, cmp_result;123
</span></span></code></pre></div><h2 id="loop循环">loop循环</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>loop:   SWAPINIT(a, es);1
</span></span></code></pre></div><p>　　这一行使用SWAPINIT宏函数，求解出了swapcode的值。行首有一label（<em>标签</em>）——loop：说明接下来会有一个<strong>goto</strong>的循环语句。</p>
<blockquote>
<p>读者朋友请不要在这里跟我纠结方法论中的论调，我只想说： goto <strong>有时候</strong>确实是很方便的，可读性也不错。</p>
</blockquote>
<p>每循环一次完成的是快排的<strong>一趟排序工作</strong>。</p>
<h2 id="一段插入排序">一段插入排序</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n &lt; 7) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (pm = (<span style="color:#00f">char</span> *) a + es; pm &lt; (<span style="color:#00f">char</span> *) a + n * es; pm += es)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (pl = pm; pl &gt; (<span style="color:#00f">char</span> *) a &amp;&amp; cmp(pl - es, pl) &gt; 0;
</span></span><span style="display:flex;"><span>                 pl -= es)
</span></span><span style="display:flex;"><span>                swap(pl, pl - es);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }1234567
</span></span></code></pre></div><p>　　这段代码，如果你使用了我前面简化的数组表示法来代换的话，实际上不难理解。 在带排序元素个数小于7的时候，我们采用 <strong>插入排序</strong> 。</p>
<blockquote>
<p>　　在元素个数不多的时候，使用快排反而不能提高效率，倒不如传统的冒泡来的实在。</p>
<blockquote>
<p>　　然而到底这个数为什么是7，而不是6，8或其他数字，我也不得而知。我只能说这就是一个<code>Magic Number</code>（<em>中文译为魔数、幻数。指代码中出现的不明所以，意义不明的数字</em>）。</p>
</blockquote>
</blockquote>
<h2 id="选取模糊中位数">选取模糊中位数</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    pm = (<span style="color:#00f">char</span> *) a + (n / 2) * es;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n &gt; 7) {
</span></span><span style="display:flex;"><span>        pl = (<span style="color:#00f">char</span> *) a;
</span></span><span style="display:flex;"><span>        pn = (<span style="color:#00f">char</span> *) a + (n - 1) * es;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (n &gt; 40) {
</span></span><span style="display:flex;"><span>            d = (n / 8) * es;
</span></span><span style="display:flex;"><span>            pl = med3(pl, pl + d, pl + 2 * d, cmp);
</span></span><span style="display:flex;"><span>            pm = med3(pm - d, pm, pm + d, cmp);
</span></span><span style="display:flex;"><span>            pn = med3(pn - 2 * d, pn - d, pn, cmp);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pm = med3(pl, pm, pn, cmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    swap(a, pm);12345678910111213
</span></span></code></pre></div><p>　　首先是<code>pm = &amp;a[n/2]</code>，在n大于7的时候， <code>pl =&amp;a[0]; pn = &amp;a[n-1];</code> 然后在元素个数n大于40的时候：</p>
<blockquote>
<p>没错，为什么是40。这又是一个<code>Magic Number</code></p>
</blockquote>
<p>　　重新选择新的pl，pm，pr。<code>d = (n / 8) * es;</code>我们可以假想将n个数字分成8个子区间。</p>
<ul>
<li>
<p>pl是左边三个区间首部中的中位数索引（首部指的是子区间第0个元素）</p>
</li>
<li>
<p>pm是中间三个区间首部中的中位数索引</p>
</li>
<li>
<p>pr是右边三个区间首部中的中位数索引</p>
<p>　　接着一个<code>pm = med3(pl, pm, pn, cmp);</code>在这三个中位数中选取中位数。所以最后我们得到的pm实际上是<strong>比较接近于</strong>整个数字序列中位数的索引。当然并不是所有数字中的中位数。我们可称它为<strong>模糊中位数</strong>。</p>
<p>　　了解快排的过程，我们就会知道每趟排序之前选取一个元素作为基准，排序之后保证该基准左边都小于它，基准的右边都大于它。然后该基准的左右区间在重复这一排序过程。如果我们每趟选取的基准都接近中位数，保证左右区间的长度大致相同。那么接下来排序的效率就更高。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    swap(a, pm);
</span></span><span style="display:flex;"><span>    pa = pb = (<span style="color:#00f">char</span> *) a + es;
</span></span><span style="display:flex;"><span>    pc = pd = (<span style="color:#00f">char</span> *) a + (n - 1) * es;123
</span></span></code></pre></div><p>　　将pm的的值与a[0]的值交互。我们的<strong>模糊中位数</strong>此时保存在了第一个元素中，接下来我称它为<strong>基准</strong>。
　　然后：<code>pa = pb = a[1];</code> <code>pc = pd = a[n-1];</code></p>
<h2 id="一趟排序">一趟排序</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (pb &lt;= pc &amp;&amp; (cmp_result = cmp(pb, a)) &lt;= 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (cmp_result == 0) {
</span></span><span style="display:flex;"><span>                swap(pa, pb);
</span></span><span style="display:flex;"><span>                pa += es;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            pb += es;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (pb &lt;= pc &amp;&amp; (cmp_result = cmp(pc, a)) &gt;= 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (cmp_result == 0) {
</span></span><span style="display:flex;"><span>                swap(pc, pd);
</span></span><span style="display:flex;"><span>                pd -= es;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            pc -= es;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (pb &gt; pc)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        swap(pb, pc); <span style="color:#f00;font-style:italic">//能运行到这一步，说明*pb&gt;*a,*pc&lt;*a。交换一下。
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        pb += es;
</span></span><span style="display:flex;"><span>        pc -= es;
</span></span><span style="display:flex;"><span>    }123456789101112131415161718192021
</span></span></code></pre></div><p>　　一个两层循环。涉及代码量较多，这里我简单地介绍一下它的功能，大家努力去自行理解。~~好吧，其实是我说累了，懒得说了。~~它的功能是<strong>基本</strong>完成了快排中的一趟排序。唯一的不足之处就是我们的基准还不在中间位置。此外该操作还把序列中和基准a[0]相同的数都交换到了序列的左端和右端的连续区间。
　　
　　所以接下来我们要把基准区间都交换到中间位置才行。</p>
<h2 id="把基准交换到中间">把基准交换到中间</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    pn = (<span style="color:#00f">char</span> *) a + n * es; <span style="color:#f00;font-style:italic">//pn = a[n]...不要担心越界，下面并不会访问该内存
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    r = min(pa - (<span style="color:#00f">char</span> *) a, pb - pa);
</span></span><span style="display:flex;"><span>    vecswap(a, pb - r, r);
</span></span><span style="display:flex;"><span>    r = min((size_t)(pd - pc), pn - pd - es);
</span></span><span style="display:flex;"><span>    vecswap(pb, pn - r, r);12345
</span></span></code></pre></div><p>　　这部分代码就是把数字序列左右两端的连续区间（值等于基准）都交换到序列的中间。之所以调用min()来确定交换的个数r，是因为交换前后两个区间是可能有重合的，所以我们要保证交换的元素个数最少。以左端的交换为例*（黄颜色的部分表示值都等于基准a[0]）*：</p>
<ul>
<li>A图表示pa - (char *) a &lt; pb - pa</li>
<li>B图表示pa - (char *) a &gt; pb - pa
<img src="http://shanks.link/img/redis/4.png" alt="img">
　　到此为止，我们一趟排序工作完成了，接下来要做的就是用递归或循环来开始下一趟排序。</li>
</ul>
<h2 id="开始下一趟排序">开始下一趟排序</h2>
<blockquote>
<p>简单地描述一下快排过程，在一趟快排结束后。我们要用递归（或循环迭代）的方式在重复排序工作。此后就是在基准左边这一区间展开一趟排序，在基准右边区间也展开一趟排序。这就是<strong>分治思想</strong>。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#00f">if</span> ((r = pb - pa) &gt; es) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">void</span> *_l = a, *_r = ((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+r-1;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (!((lrange &lt; _l &amp;&amp; rrange &lt; _l) ||
</span></span><span style="display:flex;"><span>                    (lrange &gt; _r &amp;&amp; rrange &gt; _r)))
</span></span><span style="display:flex;"><span>            _pqsort(a, r / es, es, cmp, lrange, rrange);
</span></span><span style="display:flex;"><span>        }123456
</span></span></code></pre></div><p>　　这段代码是对基准左边的区间进行一趟递归的快排。注意，最外层的<code>if</code>条件中对<code>r</code>进行了重新赋值*(r = pb - pa)*。 判断<code>pb - pa</code>这一个区间元素个数是否大于1（只有一个元素显然不需要排序的）。为什么是判断<code>pb - pa</code>而不是判断<code>pa - a</code>呢？直接上图（与前文中的AB两种情况对应）：
<img src="//img/redis/5.png" alt="img">
<em>黄色左边的白色部分，是我们要排序的区间</em></p>
<p>　　接着看代码，内层也嵌套了一个<code>if</code>，他的条件很复杂。肢解一下，这个条件有一个<code>！</code>非操作。我设该条件为<code>!T</code>，用伪码表示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// T = ((lrange &lt; _l &amp;&amp; rrange &lt; _l)||(lrange &gt; _r &amp;&amp; rrange &gt; _r))
</span></span><span style="display:flex;"><span>if (!T)
</span></span><span style="display:flex;"><span>    _pqsort(...);123
</span></span></code></pre></div><p>　　去理解它的<strong>逆命题</strong>（else）: 如果满足条件<code>T</code>，则不会进行排序。其实很好理解，<code>lrange</code>，<code>rragne</code>是待排序的区间左右边界，而<code>_l</code>和<code>_r</code>是基准左侧区间的实际左右边界。如果待排序的边界比实际左边界还要小，或者比实际的右边界还要大，显然是不满足条件的。</p>
<blockquote>
<p>实际上在整个pqsort.c源码中，所做的操作几乎于普通的快排无异，唯一体现了<strong>部分快排算法</strong>的<strong>部分</strong>二字的地方就是这内层嵌套的循环而已。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#00f">if</span> ((r = pd - pc) &gt; es) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">void</span> *_l, *_r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">/* Iterate rather than recurse to save stack space */</span>
</span></span><span style="display:flex;"><span>        a = pn - r;
</span></span><span style="display:flex;"><span>        n = r / es;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                _l = a;
</span></span><span style="display:flex;"><span>                _r = ((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+r-1;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (!((lrange &lt; _l &amp;&amp; rrange &lt; _l) ||
</span></span><span style="display:flex;"><span>                    (lrange &gt; _r &amp;&amp; rrange &gt; _r)))
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> loop;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>　　这段代码是对基准右边的区间进行了一次快排。其过程和前面类似，就不赘述了。不同之处是关于首元素索引不再是原先的<code>a</code>，而是<code>pn - r</code>，这并不难理解。另外一个变化就是这一趟新排序的开始不是使用的递归，而是循环（<code>goto loop</code>）。作者在注释中也解释了，没有继续采用递归是为了节省<strong>栈空间</strong>。</p>
<hr>
<h1 id="pqsortc源码">pqsort.c源码</h1>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;sys/types.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;errno.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">char</span>  *<span style="color:#c34e00">med3</span> (<span style="color:#00f">char</span> *, <span style="color:#00f">char</span> *, <span style="color:#00f">char</span> *,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*)(<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *));
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">void</span>   <span style="color:#c34e00">swapfunc</span> (<span style="color:#00f">char</span> *, <span style="color:#00f">char</span> *, size_t, <span style="color:#00f">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define min(a, b)   (a) &lt; (b) ? a : b
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"> * Qsort routine from Bentley &amp; McIlroy&#39;s &#34;Engineering a Sort Function&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define swapcode(TYPE, parmi, parmj, n) {       \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    size_t i = (n) / sizeof (TYPE);         \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    TYPE *pi = (TYPE *)(void *)(parmi);         \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    TYPE *pj = (TYPE *)(void *)(parmj);         \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    do {                        \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        TYPE    t = *pi;            \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        *pi++ = *pj;                \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        *pj++ = t;              \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        } while (--i &gt; 0);              \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">}
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span><span style="color:#c34e00">swapfunc</span>(<span style="color:#00f">char</span> *a, <span style="color:#00f">char</span> *b, size_t n, <span style="color:#00f">int</span> swaptype)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (swaptype &lt;= 1)
</span></span><span style="display:flex;"><span>        swapcode(<span style="color:#00f">long</span>, a, b, n)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>        swapcode(<span style="color:#00f">char</span>, a, b, n)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define swap(a, b)                      \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    if (swaptype == 0) {                    \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        long t = *(long *)(void *)(a);          \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        *(long *)(void *)(a) = *(long *)(void *)(b);    \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        *(long *)(void *)(b) = t;           \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">    } else                          \
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">        swapfunc(a, b, es, swaptype)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define vecswap(a, b, n) if ((n) &gt; 0) swapfunc((a), (b), (size_t)(n), swaptype)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">inline</span> <span style="color:#00f">char</span> *
</span></span><span style="display:flex;"><span><span style="color:#c34e00">med3</span>(<span style="color:#00f">char</span> *a, <span style="color:#00f">char</span> *b, <span style="color:#00f">char</span> *c,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*cmp) (<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> cmp(a, b) &lt; 0 ?
</span></span><span style="display:flex;"><span>           (cmp(b, c) &lt; 0 ? b : (cmp(a, c) &lt; 0 ? c : a ))
</span></span><span style="display:flex;"><span>              :(cmp(b, c) &gt; 0 ? b : (cmp(a, c) &lt; 0 ? a : c ));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span><span style="color:#c34e00">_pqsort</span>(<span style="color:#00f">void</span> *a, size_t n, size_t es,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*cmp) (<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), <span style="color:#00f">void</span> *lrange, <span style="color:#00f">void</span> *rrange)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#00f">char</span> *pa, *pb, *pc, *pd, *pl, *pm, *pn;
</span></span><span style="display:flex;"><span>    size_t d, r;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> swaptype, cmp_result;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loop:   SWAPINIT(a, es);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n &lt; 7) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (pm = (<span style="color:#00f">char</span> *) a + es; pm &lt; (<span style="color:#00f">char</span> *) a + n * es; pm += es)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">for</span> (pl = pm; pl &gt; (<span style="color:#00f">char</span> *) a &amp;&amp; cmp(pl - es, pl) &gt; 0;
</span></span><span style="display:flex;"><span>                 pl -= es)
</span></span><span style="display:flex;"><span>                swap(pl, pl - es);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pm = (<span style="color:#00f">char</span> *) a + (n / 2) * es;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (n &gt; 7) {
</span></span><span style="display:flex;"><span>        pl = (<span style="color:#00f">char</span> *) a;
</span></span><span style="display:flex;"><span>        pn = (<span style="color:#00f">char</span> *) a + (n - 1) * es;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (n &gt; 40) {
</span></span><span style="display:flex;"><span>            d = (n / 8) * es;
</span></span><span style="display:flex;"><span>            pl = med3(pl, pl + d, pl + 2 * d, cmp);
</span></span><span style="display:flex;"><span>            pm = med3(pm - d, pm, pm + d, cmp);
</span></span><span style="display:flex;"><span>            pn = med3(pn - 2 * d, pn - d, pn, cmp);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pm = med3(pl, pm, pn, cmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    swap(a, pm);
</span></span><span style="display:flex;"><span>    pa = pb = (<span style="color:#00f">char</span> *) a + es;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pc = pd = (<span style="color:#00f">char</span> *) a + (n - 1) * es;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">for</span> (;;) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (pb &lt;= pc &amp;&amp; (cmp_result = cmp(pb, a)) &lt;= 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (cmp_result == 0) {
</span></span><span style="display:flex;"><span>                swap(pa, pb);
</span></span><span style="display:flex;"><span>                pa += es;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            pb += es;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">while</span> (pb &lt;= pc &amp;&amp; (cmp_result = cmp(pc, a)) &gt;= 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> (cmp_result == 0) {
</span></span><span style="display:flex;"><span>                swap(pc, pd);
</span></span><span style="display:flex;"><span>                pd -= es;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            pc -= es;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (pb &gt; pc)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>        swap(pb, pc);
</span></span><span style="display:flex;"><span>        pb += es;
</span></span><span style="display:flex;"><span>        pc -= es;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pn = (<span style="color:#00f">char</span> *) a + n * es;
</span></span><span style="display:flex;"><span>    r = min(pa - (<span style="color:#00f">char</span> *) a, pb - pa);
</span></span><span style="display:flex;"><span>    vecswap(a, pb - r, r);
</span></span><span style="display:flex;"><span>    r = min((size_t)(pd - pc), pn - pd - es);
</span></span><span style="display:flex;"><span>    vecswap(pb, pn - r, r);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> ((r = pb - pa) &gt; es) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">void</span> *_l = a, *_r = ((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+r-1;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (!((lrange &lt; _l &amp;&amp; rrange &lt; _l) ||
</span></span><span style="display:flex;"><span>                    (lrange &gt; _r &amp;&amp; rrange &gt; _r)))
</span></span><span style="display:flex;"><span>            _pqsort(a, r / es, es, cmp, lrange, rrange);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> ((r = pd - pc) &gt; es) {
</span></span><span style="display:flex;"><span>                <span style="color:#00f">void</span> *_l, *_r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">/* Iterate rather than recurse to save stack space */</span>
</span></span><span style="display:flex;"><span>        a = pn - r;
</span></span><span style="display:flex;"><span>        n = r / es;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                _l = a;
</span></span><span style="display:flex;"><span>                _r = ((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+r-1;
</span></span><span style="display:flex;"><span>                <span style="color:#00f">if</span> (!((lrange &lt; _l &amp;&amp; rrange &lt; _l) ||
</span></span><span style="display:flex;"><span>                    (lrange &gt; _r &amp;&amp; rrange &gt; _r)))
</span></span><span style="display:flex;"><span>            <span style="color:#00f">goto</span> loop;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*      qsort(pn - r, r / es, es, cmp);*/</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span>
</span></span><span style="display:flex;"><span><span style="color:#c34e00">pqsort</span>(<span style="color:#00f">void</span> *a, size_t n, size_t es,
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> (*cmp) (<span style="color:#00f">const</span> <span style="color:#00f">void</span> *, <span style="color:#00f">const</span> <span style="color:#00f">void</span> *), size_t lrange, size_t rrange)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _pqsort(a,n,es,cmp,((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+(lrange*es),
</span></span><span style="display:flex;"><span>                       ((<span style="color:#00f">unsigned</span> <span style="color:#00f">char</span>*)a)+((rrange+1)*es)-1);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/redis" rel="tag" title="redis">#redis#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/08/18/%E8%B7%8C%E5%AE%95%E8%B5%B7%E4%BC%8F%E6%98%AF%E5%B8%B8%E6%80%81/" rel="next" title="跌宕起伏是常态">
        <i class="fa fa-chevron-left"></i> 跌宕起伏是常态
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/08/13/%E4%B8%80%E9%94%AE%E6%90%9E%E5%AE%9A-vscode-%E4%B8%8B%E7%9A%84-c/c-%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="prev" title="一键搞定 VSCode 下的 C/C&#43;&#43;基本开发环境配置">
        一键搞定 VSCode 下的 C/C&#43;&#43;基本开发环境配置 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">500</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">32</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>