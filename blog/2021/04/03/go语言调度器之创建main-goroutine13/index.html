<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>go语言调度器之创建main goroutine(13) - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="go语言调度器之创建main goroutine(13)">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="go语言调度器之创建main goroutine(13) - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E5%88%9B%E5%BB%BAmain-goroutine13/" itemprop="url">
        go语言调度器之创建main goroutine(13)
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4816 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/FF8YU8nXP9TKt0qvSuzmtw">源码游记</a></p>
<p>本文是《Go语言调度器源代码情景分析》系列的第13篇，也是第二章的第3小节。</p>
<p>上一节我们分析了调度器的初始化，这一节我们来看程序中的第一个goroutine是如何创建的。</p>
<p>创建main goroutine
接上一节，schedinit完成调度系统初始化后，返回到rt0_go函数中开始调用newproc() 创建一个新的goroutine用于执行mainPC所对应的runtime·main函数，看下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">runtime/asm_amd64.s : 197

# create a new goroutine to start program
MOVQ  $runtime·<span style="color:#c34e00">mainPC</span>(SB), AX # entry，mainPC是runtime.main
# newproc的第二个参数入栈，也就是新的goroutine需要执行的函数
PUSHQ  AX          # AX = &amp;funcval{runtime·main},
 
# newproc的第一个参数入栈，该参数表示runtime.main函数需要的参数大小，因为runtime.main没有参数，所以这里是0
PUSHQ  $0
CALL  runtime·<span style="color:#c34e00">newproc</span>(SB) # 创建main goroutine
POPQ  AX
POPQ  AX
 
# start this M
CALL  runtime·<span style="color:#c34e00">mstart</span>(SB)  # 主线程进入调度循环，运行刚刚创建的goroutine
 
# 上面的mstart永远不应该返回的，如果返回了，一定是代码逻辑有问题，直接abort
CALL  runtime·<span style="color:#c34e00">abort</span>(SB)<span style="color:#f00;font-style:italic">// mstart should never return
</span><span style="color:#f00;font-style:italic"></span>RET
 
DATA  runtime·mainPC+0(SB)/8,$runtime·<span style="color:#c34e00">main</span>(SB)
GLOB  Lruntime·<span style="color:#c34e00">mainPC</span>(SB),RODATA,$8
</code></pre></div><p>在后面的分析过程中我们会看到这个runtime.main最终会调用我们写的main.main函数，在分析runtime·main之前我们先把重点放在newproc这个函数上。</p>
<p>newproc函数用于创建新的goroutine，它有两个参数，先说第二个参数fn，新创建出来的goroutine将从fn这个函数开始执行，而这个fn函数可能也会有参数，newproc的第一个参数正是fn函数的参数以字节为单位的大小。比如有如下go代码片段：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">start</span>(a, b, c <span style="color:#00f">int64</span>) {
    ......
}
 
<span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
    <span style="color:#00f">go</span> <span style="color:#c34e00">start</span>(1, 2, 3)
}
</code></pre></div><p>编译器在编译上面的go语句时，就会把其替换为对newproc函数的调用，编译后的代码逻辑上等同于下面的伪代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
    push 0x3
    push 0x2
    push 0x1
    runtime.<span style="color:#c34e00">newproc</span>(24, start)
}
</code></pre></div><p>编译器编译时首先会用几条指令把start函数需要用到的3个参数压栈，然后调用newproc函数。因为start函数的3个int64类型的参数共占24个字节，所以传递给newproc的第一个参数是24，表示start函数需要24字节大小的参数。</p>
<p>那为什么需要传递fn函数的参数大小给newproc函数呢？原因就在于newproc函数将创建一个新的goroutine来执行fn函数，而这个新创建的goroutine与当前这个goroutine会使用不同的栈，因此就需要在创建goroutine的时候把fn需要用到的参数先从当前goroutine的栈上拷贝到新的goroutine的栈上之后才能让其开始执行，而newproc函数本身并不知道需要拷贝多少数据到新创建的goroutine的栈上去，所以需要用参数的方式指定拷贝多少数据。</p>
<p>了解完这些背景知识之后，下面我们开始分析newproc的代码。newproc函数是对newproc1的一个包装，这里最重要的准备工作有两个，一个是获取fn函数第一个参数的地址（代码中的argp），另一个是使用systemstack函数切换到g0栈，当然，对于我们这个初始化场景来说现在本来就在g0栈，所以不需要切换，然而这个函数是通用的，在用户的goroutine中也会创建goroutine，这时就需要进行栈的切换。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">runtime/proc.<span style="color:#00f">go</span> : 3232

<span style="color:#f00;font-style:italic">// Create a new g running fn with siz bytes of arguments.
</span><span style="color:#f00;font-style:italic">// Put it on the queue of g&#39;s waiting to run.
</span><span style="color:#f00;font-style:italic">// The compiler turns a go statement into a call to this.
</span><span style="color:#f00;font-style:italic">// Cannot split the stack because it assumes that the arguments
</span><span style="color:#f00;font-style:italic">// are available sequentially after &amp;fn; they would not be
</span><span style="color:#f00;font-style:italic">// copied if a stack split occurred.
</span><span style="color:#f00;font-style:italic">//go:nosplit
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">newproc</span>(siz <span style="color:#00f">int32</span>, fn *funcval) {
    <span style="color:#f00;font-style:italic">//函数调用参数入栈顺序是从右向左，而且栈是从高地址向低地址增长的
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//注意：argp指向fn函数的第一个参数，而不是newproc函数的参数
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//参数fn在栈上的地址+8的位置存放的是fn函数的第一个参数
</span><span style="color:#f00;font-style:italic"></span>    argp := <span style="color:#c34e00">add</span>(unsafe.<span style="color:#c34e00">Pointer</span>(&amp;fn), sys.PtrSize)
    gp := <span style="color:#c34e00">getg</span>()  <span style="color:#f00;font-style:italic">//获取正在运行的g，初始化时是m0.g0
</span><span style="color:#f00;font-style:italic"></span>   
    <span style="color:#f00;font-style:italic">//getcallerpc()返回一个地址，也就是调用newproc时由call指令压栈的函数返回地址，
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//对于我们现在这个场景来说，pc就是CALLruntime·newproc(SB)指令后面的POPQ AX这条指令的地址
</span><span style="color:#f00;font-style:italic"></span>    pc := <span style="color:#c34e00">getcallerpc</span>()
   
    <span style="color:#f00;font-style:italic">//systemstack的作用是切换到g0栈执行作为参数的函数
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//我们这个场景现在本身就在g0栈，因此什么也不做，直接调用作为参数的函数
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">systemstack</span>(<span style="color:#00f">func</span>() {
        <span style="color:#c34e00">newproc1</span>(fn, (*<span style="color:#00f">uint8</span>)(argp), siz, gp, pc)
    })
}
newproc1函数的第一个参数fn是新创建的goroutine需要执行的函数，注意这个fn的类型是funcval结构体类型，其定义如下：

<span style="color:#00f">type</span> funcval <span style="color:#00f">struct</span> {
    fn <span style="color:#00f">uintptr</span>
    <span style="color:#f00;font-style:italic">// variable-size, fn-specific data here
</span><span style="color:#f00;font-style:italic"></span>}
</code></pre></div><p>newproc1的第二个参数argp是fn函数的第一个参数的地址，第三个参数是fn函数的参数以字节为单位的大小，后面两个参数我们不用关心。这里需要注意的是，newproc1是在g0的栈上执行的。该函数很长也很重要，所以我们分段来看。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">runtime/proc.<span style="color:#00f">go</span> : 3248

<span style="color:#f00;font-style:italic">// Create a new g running fn with narg bytes of arguments starting
</span><span style="color:#f00;font-style:italic">// at argp. callerpc is the address of the go statement that created
</span><span style="color:#f00;font-style:italic">// this. The new g is put on the queue of g&#39;s waiting to run.
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">newproc1</span>(fn *funcval, argp *<span style="color:#00f">uint8</span>, narg <span style="color:#00f">int32</span>, callergp *g, callerpc <span style="color:#00f">uintptr</span>) {
    <span style="color:#f00;font-style:italic">//因为已经切换到g0栈，所以无论什么场景都有 _g_ = g0，当然这个g0是指当前工作线程的g0
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//对于我们这个场景来说，当前工作线程是主线程，所以这里的g0 = m0.g0
</span><span style="color:#f00;font-style:italic"></span>    _g_ := <span style="color:#c34e00">getg</span>() 
 
    ......
 
    _p_ := _g_.m.p.<span style="color:#c34e00">ptr</span>() <span style="color:#f00;font-style:italic">//初始化时_p_ = g0.m.p，从前面的分析可以知道其实就是allp[0]
</span><span style="color:#f00;font-style:italic"></span>    newg := <span style="color:#c34e00">gfget</span>(_p_) <span style="color:#f00;font-style:italic">//从p的本地缓冲里获取一个没有使用的g，初始化时没有，返回nil
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> newg == <span style="color:#00f">nil</span> {
         <span style="color:#f00;font-style:italic">//new一个g结构体对象，然后从堆上为其分配栈，并设置g的stack成员和两个stackgard成员
</span><span style="color:#f00;font-style:italic"></span>        newg = <span style="color:#c34e00">malg</span>(_StackMin)
        <span style="color:#c34e00">casgstatus</span>(newg, _Gidle, _Gdead) <span style="color:#f00;font-style:italic">//初始化g的状态为_Gdead
</span><span style="color:#f00;font-style:italic"></span>         <span style="color:#f00;font-style:italic">//放入全局变量allgs切片中
</span><span style="color:#f00;font-style:italic"></span>        <span style="color:#c34e00">allgadd</span>(newg) <span style="color:#f00;font-style:italic">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span style="color:#f00;font-style:italic"></span>    }
   
    ......
   
    <span style="color:#f00;font-style:italic">//调整g的栈顶置针，无需关注
</span><span style="color:#f00;font-style:italic"></span>    totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize <span style="color:#f00;font-style:italic">// extra space in case of reads slightly beyond frame
</span><span style="color:#f00;font-style:italic"></span>    totalSize += -totalSize &amp; (sys.SpAlign - 1)                  <span style="color:#f00;font-style:italic">// align to spAlign
</span><span style="color:#f00;font-style:italic"></span>    sp := newg.stack.hi - totalSize
    spArg := sp
 
    <span style="color:#f00;font-style:italic">//......
</span><span style="color:#f00;font-style:italic"></span>   
    <span style="color:#00f">if</span> narg &gt; 0 {
         <span style="color:#f00;font-style:italic">//把参数从执行newproc函数的栈（初始化时是g0栈）拷贝到新g的栈
</span><span style="color:#f00;font-style:italic"></span>        <span style="color:#c34e00">memmove</span>(unsafe.<span style="color:#c34e00">Pointer</span>(spArg), unsafe.<span style="color:#c34e00">Pointer</span>(argp), uintptr(narg))
        <span style="color:#f00;font-style:italic">// ......
</span><span style="color:#f00;font-style:italic"></span>    }
</code></pre></div><p>这段代码主要从堆上分配一个g结构体对象并为这个newg分配一个大小为2048字节的栈，并设置好newg的stack成员，然后把newg需要执行的函数的参数从执行newproc函数的栈（初始化时是g0栈）拷贝到newg的栈，完成这些事情之后newg的状态如下图所示：</p>
<p>我们可以看到，经过前面的代码之后，程序中多了一个我们称之为newg的g结构体对象，该对象也已经获得了从堆上分配而来的2k大小的栈空间，newg的stack.hi和stack.lo分别指向了其栈空间的起止位置。</p>
<p>接下来我们继续分析newproc1函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">runtime/proc.<span style="color:#00f">go</span> : 3314

    <span style="color:#f00;font-style:italic">//把newg.sched结构体成员的所有成员设置为0
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">memclrNoHeapPointers</span>(unsafe.<span style="color:#c34e00">Pointer</span>(&amp;newg.sched), unsafe.<span style="color:#c34e00">Sizeof</span>(newg.sched))
   
    <span style="color:#f00;font-style:italic">//设置newg的sched成员，调度器需要依靠这些字段才能把goroutine调度到CPU上运行。
</span><span style="color:#f00;font-style:italic"></span>    newg.sched.sp = sp  <span style="color:#f00;font-style:italic">//newg的栈顶
</span><span style="color:#f00;font-style:italic"></span>    newg.stktopsp = sp
    <span style="color:#f00;font-style:italic">//newg.sched.pc表示当newg被调度起来运行时从这个地址开始执行指令
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//把pc设置成了goexit这个函数偏移1（sys.PCQuantum等于1）的位置，
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//至于为什么要这么做需要等到分析完gostartcallfn函数才知道
</span><span style="color:#f00;font-style:italic"></span>    newg.sched.pc = <span style="color:#c34e00">funcPC</span>(goexit) + sys.PCQuantum <span style="color:#f00;font-style:italic">// +PCQuantum so that previous instruction is in same function
</span><span style="color:#f00;font-style:italic"></span>    newg.sched.g = <span style="color:#c34e00">guintptr</span>(unsafe.<span style="color:#c34e00">Pointer</span>(newg))
 
    <span style="color:#c34e00">gostartcallfn</span>(&amp;newg.sched, fn) <span style="color:#f00;font-style:italic">//调整sched成员和newg的栈
</span><span style="color:#f00;font-style:italic"></span>这段代码首先对newg的sched成员进行了初始化，该成员包含了调度器代码在调度goroutine到CPU运行时所必须的一些信息，其中sched的sp成员表示newg被调度起来运行时应该使用的栈的栈顶，sched的pc成员表示当newg被调度起来运行时从这个地址开始执行指令，然而从上面的代码可以看到，new.sched.pc被设置成了goexit函数的第二条指令的地址而不是fn.fn，这是为什么呢？要回答这个问题，必须深入到gostartcallfn函数中做进一步分析。

<span style="color:#f00;font-style:italic">// adjust Gobuf as if it executed a call to fn
</span><span style="color:#f00;font-style:italic">// and then did an immediate gosave.
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">gostartcallfn</span>(gobuf *gobuf, fv *funcval) {
    <span style="color:#00f">var</span> fn unsafe.Pointer
    <span style="color:#00f">if</span> fv != <span style="color:#00f">nil</span> {
        fn = unsafe.<span style="color:#c34e00">Pointer</span>(fv.fn) <span style="color:#f00;font-style:italic">//fn: gorotine的入口地址，初始化时对应的是runtime.main
</span><span style="color:#f00;font-style:italic"></span>    } <span style="color:#00f">else</span> {
        fn = unsafe.<span style="color:#c34e00">Pointer</span>(<span style="color:#c34e00">funcPC</span>(nilfunc))
    }
    <span style="color:#c34e00">gostartcall</span>(gobuf, fn, unsafe.<span style="color:#c34e00">Pointer</span>(fv))
}
</code></pre></div><p>gostartcallfn首先从参数fv中提取出函数地址（初始化时是runtime.main），然后继续调用gostartcall函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f00;font-style:italic">// adjust Gobuf as if it executed a call to fn with context ctxt
</span><span style="color:#f00;font-style:italic">// and then did an immediate gosave.
</span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">gostartcall</span>(buf *gobuf, fn, ctxt unsafe.Pointer) {
    sp := buf.sp <span style="color:#f00;font-style:italic">//newg的栈顶，目前newg栈上只有fn函数的参数，sp指向的是fn的第一参数
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> sys.RegSize &gt; sys.PtrSize {
        sp -= sys.PtrSize
        *(*<span style="color:#00f">uintptr</span>)(unsafe.<span style="color:#c34e00">Pointer</span>(sp)) = 0
    }
    sp -= sys.PtrSize <span style="color:#f00;font-style:italic">//为返回地址预留空间，
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//这里在伪装fn是被goexit函数调用的，使得fn执行完后返回到goexit继续执行，从而完成清理工作
</span><span style="color:#f00;font-style:italic"></span>    *(*<span style="color:#00f">uintptr</span>)(unsafe.<span style="color:#c34e00">Pointer</span>(sp)) = buf.pc <span style="color:#f00;font-style:italic">//在栈上放入goexit+1的地址
</span><span style="color:#f00;font-style:italic"></span>    buf.sp = sp <span style="color:#f00;font-style:italic">//重新设置newg的栈顶寄存器
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//这里才真正让newg的ip寄存器指向fn函数，注意，这里只是在设置newg的一些信息，newg还未执行，
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//等到newg被调度起来运行时，调度器会把buf.pc放入cpu的IP寄存器，
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//从而使newg得以在cpu上真正的运行起来
</span><span style="color:#f00;font-style:italic"></span>    buf.pc = uintptr(fn) 
    buf.ctxt = ctxt
}
</code></pre></div><p>gostartcall函数的主要作用有两个：</p>
<p>调整newg的栈空间，把goexit函数的第二条指令的地址入栈，伪造成goexit函数调用了fn，从而使fn执行完成后执行ret指令时返回到goexit继续执行完成最后的清理工作；</p>
<p>重新设置newg.buf.pc 为需要执行的函数的地址，即fn，我们这个场景为runtime.main函数的地址。</p>
<p>调整完成newg的栈和sched成员之后，返回到newproc1函数，我们继续往下看，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    newg.gopc = callerpc  <span style="color:#f00;font-style:italic">//主要用于traceback
</span><span style="color:#f00;font-style:italic"></span>    newg.ancestors = <span style="color:#c34e00">saveAncestors</span>(callergp)
    <span style="color:#f00;font-style:italic">//设置newg的startpc为fn.fn，该成员主要用于函数调用栈的traceback和栈收缩
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">//newg真正从哪里开始执行并不依赖于这个成员，而是sched.pc
</span><span style="color:#f00;font-style:italic"></span>    newg.startpc = fn.fn  
 
    ......
   
    <span style="color:#f00;font-style:italic">//设置g的状态为_Grunnable，表示这个g代表的goroutine可以运行了
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">casgstatus</span>(newg, _Gdead, _Grunnable)
 
    ......
   
    <span style="color:#f00;font-style:italic">//把newg放入_p_的运行队列，初始化的时候一定是p的本地运行队列，其它时候可能因为本地队列满了而放入全局队列
</span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">runqput</span>(_p_, newg, <span style="color:#00f">true</span>)
 
    ......
}
</code></pre></div><p>newproc1函数最后这点代码比较直观，首先设置了几个与调度无关的成员变量，然后修改newg的状态为_Grunnable并把其放入了运行队列，到此程序中第一个真正意义上的goroutine已经创建完成。</p>
<p>这时newg也就是main goroutine的状态如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e56967d45a7cc5c2f6cd0d0d2338956e.png" alt=""></p>
<p>这个图看起来比较复杂，因为表示指针的箭头实在是太多了，这里对其稍作一下解释。</p>
<p>首先，main goroutine对应的newg结构体对象的sched成员已经完成了初始化，图中只显示了pc和sp成员，pc成员指向了runtime.main函数的第一条指令，sp成员指向了newg的栈顶内存单元，该内存单元保存了runtime.main函数执行完成之后的返回地址，也就是runtime.goexit函数的第二条指令，预期runtime.main函数执行完返回之后就会去执行runtime.exit函数的CALL runtime.goexit1(SB)这条指令；</p>
<p>其次，newg已经放入与当前主线程绑定的p结构体对象的本地运行队列，因为它是第一个真正意义上的goroutine，还没有其它goroutine，所以它被放在了本地运行队列的头部；</p>
<p>最后，newg的m成员为nil，因为它还没有被调度起来运行，也就没有跟任何m进行绑定。</p>
<p>这一节我们分析了程序中第一个goroutine也就是main goroutine的创建，下一节我们继续分析它是怎么被主工作线程调度到CPU上去执行的。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E8%B0%83%E5%BA%A6main-goroutine14/" rel="next" title="go语言调度器之调度main goroutine（14)">
        <i class="fa fa-chevron-left"></i> go语言调度器之调度main goroutine（14)
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%81%E4%BA%8C/" rel="prev" title="go语言goroutine调度器初始化 十二">
        go语言goroutine调度器初始化 十二 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">502</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">34</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">39</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>