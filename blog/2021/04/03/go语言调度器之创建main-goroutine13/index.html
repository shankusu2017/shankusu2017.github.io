<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>go语言调度器之创建main goroutine(13) - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="go语言调度器之创建main goroutine(13)">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="go语言调度器之创建main goroutine(13) - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E5%88%9B%E5%BB%BAmain-goroutine13/" itemprop="url">
        go语言调度器之创建main goroutine(13)
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4816 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/FF8YU8nXP9TKt0qvSuzmtw">源码游记</a></p>
<p>本文是《Go语言调度器源代码情景分析》系列的第13篇，也是第二章的第3小节。</p>
<p>上一节我们分析了调度器的初始化，这一节我们来看程序中的第一个goroutine是如何创建的。</p>
<p>创建main goroutine
接上一节，schedinit完成调度系统初始化后，返回到rt0_go函数中开始调用newproc() 创建一个新的goroutine用于执行mainPC所对应的runtime·main函数，看下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">197</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">create</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">new</span> <span style="color:#a6e22e">goroutine</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">start</span> <span style="color:#a6e22e">program</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MOVQ</span>  <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">mainPC</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span> <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">entry</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">mainPC是runtime</span>.<span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">newproc的第二个参数入栈</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">也就是新的goroutine需要执行的函数</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PUSHQ</span>  <span style="color:#a6e22e">AX</span>          <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">AX</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">funcval</span>{<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">main</span>},
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">newproc的第一个参数入栈</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">该参数表示runtime</span>.<span style="color:#a6e22e">main函数需要的参数大小</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">因为runtime</span>.<span style="color:#a6e22e">main没有参数</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">所以这里是0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PUSHQ</span>  <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">CALL</span>  <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">newproc</span>(<span style="color:#a6e22e">SB</span>) <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">创建main</span> <span style="color:#a6e22e">goroutine</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">POPQ</span>  <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">POPQ</span>  <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">start</span> <span style="color:#a6e22e">this</span> <span style="color:#a6e22e">M</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">CALL</span>  <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">mstart</span>(<span style="color:#a6e22e">SB</span>)  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">主线程进入调度循环</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">运行刚刚创建的goroutine</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">上面的mstart永远不应该返回的</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">如果返回了</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">一定是代码逻辑有问题</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">直接abort</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">CALL</span>  <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">abort</span>(<span style="color:#a6e22e">SB</span>)<span style="color:#75715e">// mstart should never return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">RET</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">DATA</span>  <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">mainPC</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span>(<span style="color:#a6e22e">SB</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">8</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">main</span>(<span style="color:#a6e22e">SB</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">GLOB</span>  <span style="color:#a6e22e">Lruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">mainPC</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">RODATA</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">8</span>
</span></span></code></pre></div><p>在后面的分析过程中我们会看到这个runtime.main最终会调用我们写的main.main函数，在分析runtime·main之前我们先把重点放在newproc这个函数上。</p>
<p>newproc函数用于创建新的goroutine，它有两个参数，先说第二个参数fn，新创建出来的goroutine将从fn这个函数开始执行，而这个fn函数可能也会有参数，newproc的第一个参数正是fn函数的参数以字节为单位的大小。比如有如下go代码片段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">start</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">start</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译器在编译上面的go语句时，就会把其替换为对newproc函数的调用，编译后的代码逻辑上等同于下面的伪代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">newproc</span>(<span style="color:#ae81ff">24</span>, <span style="color:#a6e22e">start</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译器编译时首先会用几条指令把start函数需要用到的3个参数压栈，然后调用newproc函数。因为start函数的3个int64类型的参数共占24个字节，所以传递给newproc的第一个参数是24，表示start函数需要24字节大小的参数。</p>
<p>那为什么需要传递fn函数的参数大小给newproc函数呢？原因就在于newproc函数将创建一个新的goroutine来执行fn函数，而这个新创建的goroutine与当前这个goroutine会使用不同的栈，因此就需要在创建goroutine的时候把fn需要用到的参数先从当前goroutine的栈上拷贝到新的goroutine的栈上之后才能让其开始执行，而newproc函数本身并不知道需要拷贝多少数据到新创建的goroutine的栈上去，所以需要用参数的方式指定拷贝多少数据。</p>
<p>了解完这些背景知识之后，下面我们开始分析newproc的代码。newproc函数是对newproc1的一个包装，这里最重要的准备工作有两个，一个是获取fn函数第一个参数的地址（代码中的argp），另一个是使用systemstack函数切换到g0栈，当然，对于我们这个初始化场景来说现在本来就在g0栈，所以不需要切换，然而这个函数是通用的，在用户的goroutine中也会创建goroutine，这时就需要进行栈的切换。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">proc</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">3232</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Create a new g running fn with siz bytes of arguments.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Put it on the queue of g&#39;s waiting to run.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The compiler turns a go statement into a call to this.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Cannot split the stack because it assumes that the arguments
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// are available sequentially after &amp;fn; they would not be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// copied if a stack split occurred.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//go:nosplit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc</span>(<span style="color:#a6e22e">siz</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//函数调用参数入栈顺序是从右向左，而且栈是从高地址向低地址增长的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//注意：argp指向fn函数的第一个参数，而不是newproc函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//参数fn在栈上的地址+8的位置存放的是fn函数的第一个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">argp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fn</span>), <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()  <span style="color:#75715e">//获取正在运行的g，初始化时是m0.g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//getcallerpc()返回一个地址，也就是调用newproc时由call指令压栈的函数返回地址，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//对于我们现在这个场景来说，pc就是CALLruntime·newproc(SB)指令后面的POPQ AX这条指令的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getcallerpc</span>()
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//systemstack的作用是切换到g0栈执行作为参数的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//我们这个场景现在本身就在g0栈，因此什么也不做，直接调用作为参数的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span>, (<span style="color:#f92672">*</span><span style="color:#66d9ef">uint8</span>)(<span style="color:#a6e22e">argp</span>), <span style="color:#a6e22e">siz</span>, <span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">pc</span>)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">newproc1函数的第一个参数fn是新创建的goroutine需要执行的函数</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">注意这个fn的类型是funcval结构体类型</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">其定义如下</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">funcval</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// variable-size, fn-specific data here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>newproc1的第二个参数argp是fn函数的第一个参数的地址，第三个参数是fn函数的参数以字节为单位的大小，后面两个参数我们不用关心。这里需要注意的是，newproc1是在g0的栈上执行的。该函数很长也很重要，所以我们分段来看。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">proc</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">3248</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Create a new g running fn with narg bytes of arguments starting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// at argp. callerpc is the address of the go statement that created
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// this. The new g is put on the queue of g&#39;s waiting to run.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>, <span style="color:#a6e22e">argp</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">narg</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">callergp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">callerpc</span> <span style="color:#66d9ef">uintptr</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//因为已经切换到g0栈，所以无论什么场景都有 _g_ = g0，当然这个g0是指当前工作线程的g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//对于我们这个场景来说，当前工作线程是主线程，所以这里的g0 = m0.g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>() 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#75715e">//初始化时_p_ = g0.m.p，从前面的分析可以知道其实就是allp[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gfget</span>(<span style="color:#a6e22e">_p_</span>) <span style="color:#75715e">//从p的本地缓冲里获取一个没有使用的g，初始化时没有，返回nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newg</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">//new一个g结构体对象，然后从堆上为其分配栈，并设置g的stack成员和两个stackgard成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">newg</span> = <span style="color:#a6e22e">malg</span>(<span style="color:#a6e22e">_StackMin</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gidle</span>, <span style="color:#a6e22e">_Gdead</span>) <span style="color:#75715e">//初始化g的状态为_Gdead
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>         <span style="color:#75715e">//放入全局变量allgs切片中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">allgadd</span>(<span style="color:#a6e22e">newg</span>) <span style="color:#75715e">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//调整g的栈顶置针，无需关注
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">siz</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">MinFrameSize</span> <span style="color:#75715e">// extra space in case of reads slightly beyond frame
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">+=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">&amp;</span> (<span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">SpAlign</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)                  <span style="color:#75715e">// align to spAlign
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">totalSize</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">spArg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sp</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//......
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">narg</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">//把参数从执行newproc函数的栈（初始化时是g0栈）拷贝到新g的栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">spArg</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">argp</span>), uintptr(<span style="color:#a6e22e">narg</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ......
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span></code></pre></div><p>这段代码主要从堆上分配一个g结构体对象并为这个newg分配一个大小为2048字节的栈，并设置好newg的stack成员，然后把newg需要执行的函数的参数从执行newproc函数的栈（初始化时是g0栈）拷贝到newg的栈，完成这些事情之后newg的状态如下图所示：</p>
<p>我们可以看到，经过前面的代码之后，程序中多了一个我们称之为newg的g结构体对象，该对象也已经获得了从堆上分配而来的2k大小的栈空间，newg的stack.hi和stack.lo分别指向了其栈空间的起止位置。</p>
<p>接下来我们继续分析newproc1函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">proc</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">3314</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//把newg.sched结构体成员的所有成员设置为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>))
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//设置newg的sched成员，调度器需要依靠这些字段才能把goroutine调度到CPU上运行。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>  <span style="color:#75715e">//newg的栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stktopsp</span> = <span style="color:#a6e22e">sp</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//newg.sched.pc表示当newg被调度起来运行时从这个地址开始执行指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//把pc设置成了goexit这个函数偏移1（sys.PCQuantum等于1）的位置，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//至于为什么要这么做需要等到分析完gostartcallfn函数才知道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">goexit</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PCQuantum</span> <span style="color:#75715e">// +PCQuantum so that previous instruction is in same function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">guintptr</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">newg</span>))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gostartcallfn</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>, <span style="color:#a6e22e">fn</span>) <span style="color:#75715e">//调整sched成员和newg的栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">这段代码首先对newg的sched成员进行了初始化</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">该成员包含了调度器代码在调度goroutine到CPU运行时所必须的一些信息</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">其中sched的sp成员表示newg被调度起来运行时应该使用的栈的栈顶</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">sched的pc成员表示当newg被调度起来运行时从这个地址开始执行指令</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">然而从上面的代码可以看到</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">new</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pc被设置成了goexit函数的第二条指令的地址而不是fn</span>.<span style="color:#a6e22e">fn</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">这是为什么呢</span><span style="color:#960050;background-color:#1e0010">？</span><span style="color:#a6e22e">要回答这个问题</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">必须深入到gostartcallfn函数中做进一步分析</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// adjust Gobuf as if it executed a call to fn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and then did an immediate gosave.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gostartcallfn</span>(<span style="color:#a6e22e">gobuf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fv</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fv</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">fv</span>.<span style="color:#a6e22e">fn</span>) <span style="color:#75715e">//fn: gorotine的入口地址，初始化时对应的是runtime.main
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">nilfunc</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gostartcall</span>(<span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">fv</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>gostartcallfn首先从参数fv中提取出函数地址（初始化时是runtime.main），然后继续调用gostartcall函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// adjust Gobuf as if it executed a call to fn with context ctxt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and then did an immediate gosave.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gostartcall</span>(<span style="color:#a6e22e">buf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">ctxt</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">sp</span> <span style="color:#75715e">//newg的栈顶，目前newg栈上只有fn函数的参数，sp指向的是fn的第一参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> &gt; <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span> <span style="color:#75715e">//为返回地址预留空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//这里在伪装fn是被goexit函数调用的，使得fn执行完后返回到goexit继续执行，从而完成清理工作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">pc</span> <span style="color:#75715e">//在栈上放入goexit+1的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span> <span style="color:#75715e">//重新设置newg的栈顶寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//这里才真正让newg的ip寄存器指向fn函数，注意，这里只是在设置newg的一些信息，newg还未执行，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//等到newg被调度起来运行时，调度器会把buf.pc放入cpu的IP寄存器，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//从而使newg得以在cpu上真正的运行起来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">pc</span> = uintptr(<span style="color:#a6e22e">fn</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">ctxt</span> = <span style="color:#a6e22e">ctxt</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>gostartcall函数的主要作用有两个：</p>
<p>调整newg的栈空间，把goexit函数的第二条指令的地址入栈，伪造成goexit函数调用了fn，从而使fn执行完成后执行ret指令时返回到goexit继续执行完成最后的清理工作；</p>
<p>重新设置newg.buf.pc 为需要执行的函数的地址，即fn，我们这个场景为runtime.main函数的地址。</p>
<p>调整完成newg的栈和sched成员之后，返回到newproc1函数，我们继续往下看，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">gopc</span> = <span style="color:#a6e22e">callerpc</span>  <span style="color:#75715e">//主要用于traceback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">ancestors</span> = <span style="color:#a6e22e">saveAncestors</span>(<span style="color:#a6e22e">callergp</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//设置newg的startpc为fn.fn，该成员主要用于函数调用栈的traceback和栈收缩
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//newg真正从哪里开始执行并不依赖于这个成员，而是sched.pc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">startpc</span> = <span style="color:#a6e22e">fn</span>.<span style="color:#a6e22e">fn</span>  
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//设置g的状态为_Grunnable，表示这个g代表的goroutine可以运行了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gdead</span>, <span style="color:#a6e22e">_Grunnable</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//把newg放入_p_的运行队列，初始化的时候一定是p的本地运行队列，其它时候可能因为本地队列满了而放入全局队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">runqput</span>(<span style="color:#a6e22e">_p_</span>, <span style="color:#a6e22e">newg</span>, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>newproc1函数最后这点代码比较直观，首先设置了几个与调度无关的成员变量，然后修改newg的状态为_Grunnable并把其放入了运行队列，到此程序中第一个真正意义上的goroutine已经创建完成。</p>
<p>这时newg也就是main goroutine的状态如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e56967d45a7cc5c2f6cd0d0d2338956e.png" alt=""></p>
<p>这个图看起来比较复杂，因为表示指针的箭头实在是太多了，这里对其稍作一下解释。</p>
<p>首先，main goroutine对应的newg结构体对象的sched成员已经完成了初始化，图中只显示了pc和sp成员，pc成员指向了runtime.main函数的第一条指令，sp成员指向了newg的栈顶内存单元，该内存单元保存了runtime.main函数执行完成之后的返回地址，也就是runtime.goexit函数的第二条指令，预期runtime.main函数执行完返回之后就会去执行runtime.exit函数的CALL runtime.goexit1(SB)这条指令；</p>
<p>其次，newg已经放入与当前主线程绑定的p结构体对象的本地运行队列，因为它是第一个真正意义上的goroutine，还没有其它goroutine，所以它被放在了本地运行队列的头部；</p>
<p>最后，newg的m成员为nil，因为它还没有被调度起来运行，也就没有跟任何m进行绑定。</p>
<p>这一节我们分析了程序中第一个goroutine也就是main goroutine的创建，下一节我们继续分析它是怎么被主工作线程调度到CPU上去执行的。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E8%B0%83%E5%BA%A6main-goroutine14/" rel="next" title="go语言调度器之调度main goroutine（14)">
        <i class="fa fa-chevron-left"></i> go语言调度器之调度main goroutine（14)
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%81%E4%BA%8C/" rel="prev" title="go语言goroutine调度器初始化 十二">
        go语言goroutine调度器初始化 十二 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">492</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">32</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>