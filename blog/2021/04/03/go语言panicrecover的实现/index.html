<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>go语言panic,recover的实现 - 愿星光伴你左右</title>
    <meta name="keywords" content="Lua,lua,Golang,go">
    
    <meta property="og:title" content="go语言panic,recover的实现">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="go语言panic,recover的实现 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80panicrecover%E7%9A%84%E5%AE%9E%E7%8E%B0/" itemprop="url">
        go语言panic,recover的实现
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6811 字 ~14分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/0JTBGHr-bV4ikLva-8ghEw">源码游记</a> 2019-07-02</p>
<p>本文主要分析Go语言的panic/recover在AMD64 Linux平台下的实现，包括：</p>
<p>主动调用 panic() 函数所引发的panic的处理流程，比如go代码中直接调用panic()函数或编译器插入的对panic()的调用；</p>
<p>非法操作所导致的panic的处理流程，这主要跟信号处理流程有关。</p>
<p>阅读本文所必需的预备知识：</p>
<p>defer/panic/recover 的基本用法；</p>
<p>defer 的实现机制；</p>
<p>mcall/gogo 函数的实现。</p>
<p>panic/recover例子</p>
<p>先来热一下身，大家可以先想想下面几个例子的输出会是什么，检测一下自己对panic/recover的理解。</p>
<p>例1:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;f&#34;</span>)
 
    <span style="color:#a6e22e">g</span>()
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>()
 
    panic(<span style="color:#e6db74">&#34;g panic&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">m</span>() {
    panic(<span style="color:#e6db74">&#34;m panic&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">catch</span>(<span style="color:#a6e22e">funcname</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">funcname</span>, <span style="color:#e6db74">&#34;recover:&#34;</span>, <span style="color:#a6e22e">r</span>)
    }
}
<span style="color:#a6e22e">例2</span>:

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;f&#34;</span>)
 
    <span style="color:#a6e22e">g</span>()
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>()
 
    panic(<span style="color:#e6db74">&#34;g panic&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">m</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;m&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">catch</span>(<span style="color:#a6e22e">funcname</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">funcname</span>, <span style="color:#e6db74">&#34;recover:&#34;</span>, <span style="color:#a6e22e">r</span>)
    }
}
<span style="color:#a6e22e">例3</span>:

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;f&#34;</span>)
 
    <span style="color:#a6e22e">g</span>()
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">catch</span>(<span style="color:#a6e22e">funcname</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">funcname</span>, <span style="color:#e6db74">&#34;recover:&#34;</span>, <span style="color:#a6e22e">r</span>)
    }
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>()
 
    panic(<span style="color:#e6db74">&#34;g panic&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">m</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;m&#34;</span>)
 
    panic(<span style="color:#e6db74">&#34;m panic&#34;</span>)
}
</code></pre></div><p>panic/recover要点简介</p>
<p>为了更好的理解panic/recover的实现代码，我们首先需要了解几个与之有关的要点：</p>
<p>当panic发生之后，程序从正常的执行流程跳转到执行panic发生之前通过defer语句注册的defered函数，直到某个defered函数通过recover函数捕获了panic后再恢复正常的执行流程，如果没有recover则当所有的defered函数被执行完成之后结束程序；</p>
<p>defer语句会被编译器翻译成对runtime包中deferproc()函数的调用，该函数会把defered函数打包成一个_defer结构体对象挂入goroutine对应的g结构体对象的_defer链表中，_defer对象除了保存有defered函数的地址以及该函数需要的参数外，还会分别把call deferproc指令的下一条指令的地址以及此时函数调用栈顶指针保存在_defer.pc和_defer.sp成员之中，用于recover时恢复程序的正常执行流程；</p>
<p>当某个defered函数通过recover()函数捕获到一个panic之后，程序将从该defered函数对应的_defer结构体对象的pc成员所保存的指令地址处开始执行；</p>
<p>panic可以嵌套，当发生panic之后在执行defer函数时又发生了panic即为嵌套。每个还未被recover的panic都会对应着一个_panic结构体对象，它们会被依次挂入g结构体的_panic链表之中，最近一次发生的panic位于_panic链表表头，最早发生的panic位于链表尾。</p>
<p>下面对第2点和第3点做个简单的说明。假设有如下程序片段：</p>
<p>例4</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
 
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">f</span>()
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;f&#34;</span>)      <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span> 
    panic(<span style="color:#e6db74">&#34;f panic&#34;</span>)
 
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;f continue&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">catch</span>(<span style="color:#a6e22e">funcname</span> <span style="color:#66d9ef">string</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">funcname</span>, <span style="color:#e6db74">&#34;recover:&#34;</span>, <span style="color:#a6e22e">r</span>)
    }
}
</code></pre></div><p>f()函数运行时会发生panic，但该panic会被它通过defer注册的catch函数所捕获从而恢复程序的正常执行流程，上一篇文章我们提到过deferproc函数有个隐含的返回值与panic/recover有关，下面我们通过f()函数再来看一下相关的汇编指令片段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">  <span style="color:#f92672">......</span>
  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">对应defer</span> <span style="color:#a6e22e">catch</span>(<span style="color:#e6db74">&#34;f&#34;</span>)
  <span style="color:#ae81ff">0x0000000000487245</span> &lt;<span style="color:#f92672">+</span><span style="color:#ae81ff">69</span>&gt;: <span style="color:#a6e22e">callq</span>   <span style="color:#ae81ff">0x426c00</span> &lt;<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">deferproc</span>&gt;
  <span style="color:#ae81ff">0x000000000048724a</span> &lt;<span style="color:#f92672">+</span><span style="color:#ae81ff">74</span>&gt;: <span style="color:#a6e22e">test</span>   <span style="color:#f92672">%</span><span style="color:#a6e22e">eax</span>,<span style="color:#f92672">%</span><span style="color:#a6e22e">eax</span>
  <span style="color:#ae81ff">0x000000000048724c</span> &lt;<span style="color:#f92672">+</span><span style="color:#ae81ff">76</span>&gt;: <span style="color:#a6e22e">jne</span>   <span style="color:#ae81ff">0x48726c</span> &lt;<span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">f</span><span style="color:#f92672">+</span><span style="color:#ae81ff">108</span>&gt;
  <span style="color:#f92672">......</span>
  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">对应panic</span>(<span style="color:#e6db74">&#34;f panic&#34;</span>)
  <span style="color:#ae81ff">0x0000000000487265</span> &lt;<span style="color:#f92672">+</span><span style="color:#ae81ff">101</span>&gt;: <span style="color:#a6e22e">callq</span>   <span style="color:#ae81ff">0x427880</span> &lt;<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">gopanic</span>&gt;
  <span style="color:#f92672">......</span>
  <span style="color:#ae81ff">0x000000000048726c</span> &lt;<span style="color:#f92672">+</span><span style="color:#ae81ff">108</span>&gt;: <span style="color:#a6e22e">nop</span>
  <span style="color:#ae81ff">0x000000000048726d</span> &lt;<span style="color:#f92672">+</span><span style="color:#ae81ff">109</span>&gt;: <span style="color:#a6e22e">callq</span>   <span style="color:#ae81ff">0x427490</span> &lt;<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">deferreturn</span>&gt;  
  <span style="color:#f92672">......</span>
</code></pre></div><p>该代码片段前3条指令对应着f()函数中注释1处的一行go代码，最后两条指令通过调用deferreturn函数去执行defered函数，如果f函数不发生panic，其执行流程我们在上一篇文章中已经详细介绍过，但此处的f函数会发生panic，其流程稍有不同：</p>
<p>当f函数执行到callq  0x426c00 &lt;runtime.deferproc&gt;指令时，deferproc函数将会把catch函数的地址及其参数&quot;f&quot;、下一条指令的地址0x000000000048724a以及当前的栈顶指针打包成一个_defer结构体对象挂入当前goroutine的_defer链表，然后通过eax寄存器隐形的返回一个0值；</p>
<p>因为从deferproc函数返回时，eax寄存器的值为0，所以0x000000000048724a &lt;+74&gt;: test   %eax,%eax这条指令不会导致下一条jne指令发生跳转，于是程序会继续执行到0x0000000000487265 &lt;+101&gt;处的callq   0x427880 &lt;runtime.gopanic&gt;指令；</p>
<p>gopanic函数内部会去调用defered函数即catch(&ldquo;f&rdquo;)，因为catch()函数调用了recover，这将导致CPU跳转到f()函数的0x000000000048724a &lt;+74&gt;: test   %eax,%eax指令处继续执行，这看起来就像deferproc函数再一次返回了，但这次eax寄存器的值却会被设置成1，所以执行这条test指令将导致下一条jne指令跳转到0x000000000048726c &lt;+108&gt;: nop处继续执行，此时已经恢复了程序的正常执行流程；</p>
<p>调用deferreturn函数，因为例4程序只有一个defered函数，而且已经被gopanic调用了，所以这里的deferreturn函数并不会调用任何defered函数就直接返回到了f()函数，然后从f函数返回到main函数继续执行main函数的fmt.Println(&ldquo;main&rdquo;)语句。</p>
<p>主动调用panic()函数</p>
<p>一般来说，Go程序在两种情况下会发生panic：</p>
<p>主动调用panic()函数，这包括go代码中直接调用以及由编译器插入的调用，比如编译器会插入代码检查访问数组/slice是否越界，同时还会插入调用panic()的代码，运行时如果越界就会去调用panic()函数；</p>
<p>非法操作，比如向只读内存写入数据，访问非法内存等也会发生panic。这种情况在Linux平台（其它平台不熟悉）下是通过信号(signal)机制来实现对panic()函数的调用。</p>
<p>我们先来看主动调用panic函数时panic/recover的流程。</p>
<p>通过反汇编可以得知go代码中对panic()/recover()函数的调用会被编译器翻译成对runtime包中的gopanic()以及gorecover()函数的调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">panic</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">453</span>

<span style="color:#75715e">// The implementation of the predeclared function panic.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gopanic</span>(<span style="color:#a6e22e">e</span> <span style="color:#66d9ef">interface</span>{}) {
    <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
    <span style="color:#f92672">......</span>
 
    <span style="color:#75715e">//panic可以嵌套，比如发生了panic之后运行defered函数又发生了panic，如上面的例3。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//最新的panic会被挂入goroutine对应的g结构体对象的_panic链表的表头
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#a6e22e">_panic</span>  <span style="color:#75715e">//创建_panic结构体对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">arg</span> = <span style="color:#a6e22e">e</span>  <span style="color:#75715e">//panic的参数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">link</span> = <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">_panic</span>)(<span style="color:#a6e22e">noescape</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>)))
 
    <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">runningPanicDefers</span>, <span style="color:#ae81ff">1</span>)
 
    <span style="color:#66d9ef">for</span> {
        <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span>  <span style="color:#75715e">//取出_defer链表头的defered函数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#66d9ef">break</span>  <span style="color:#75715e">//没有defer函数将会跳出循环，然后打印栈信息然后结束程序
</span><span style="color:#75715e"></span>        }
 
        <span style="color:#75715e">// If defer was started by earlier panic or Goexit (and, since we&#39;re back here, that triggered a new panic),
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// take defer off list. The earlier panic or Goexit will not continue running.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">started</span> {
            <span style="color:#75715e">//到这里一定发生了panic嵌套，即在defered函数中又发生了panic，请参考本文开头的例1
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//d.started = true是panic嵌套的充分条件，但并不是必要条件，也就是说
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//即使d.started为false也是可能发生嵌套的，请结合defer的处理流程并参考本文开头的例3
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//最近发生的一次panic并没有被recover所以取消上一次发生的panic
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
                <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span>.<span style="color:#a6e22e">aborted</span> = <span style="color:#66d9ef">true</span>
            }
            <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span> = <span style="color:#66d9ef">nil</span>
            <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span> = <span style="color:#66d9ef">nil</span>
            <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span>
            <span style="color:#a6e22e">freedefer</span>(<span style="color:#a6e22e">d</span>)
            <span style="color:#66d9ef">continue</span>
        }
 
        <span style="color:#75715e">// Mark defer as started, but keep on list, so that traceback
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// can find and update the defer&#39;s argument frame if stack growth
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// or a garbage collection happens before reflectcall starts executing d.fn.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">started</span> = <span style="color:#66d9ef">true</span>  <span style="color:#75715e">//用于判断是否发生了嵌套panic
</span><span style="color:#75715e"></span> 
        <span style="color:#75715e">// Record the panic that is running the defer.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// If there is a new panic during the deferred call, that panic
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// will find d in the list and will mark d._panic (this panic) aborted.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//把panic和defer函数关联起来
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">_panic</span>)(<span style="color:#a6e22e">noescape</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>)))
 
        <span style="color:#75715e">//在panic中记录当前panic的栈顶位置，用于recover判断
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">argp</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">getargp</span>(<span style="color:#ae81ff">0</span>))
        <span style="color:#75715e">//通过reflectcall函数调用defered函数
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//如果defered函数再次发生panic而且并未被该defered函数recover，则reflectcall永远不会返回，参考例2。
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//如果defered函数并没有发生过panic或者发生了panic但该defered函数成功recover了新发生的panic，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//则此函数会返回继续执行后面的代码。
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">reflectcall</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span>), <span style="color:#a6e22e">deferArgs</span>(<span style="color:#a6e22e">d</span>), uint32(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span>), uint32(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span>))
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">argp</span> = <span style="color:#66d9ef">nil</span>
 
        <span style="color:#75715e">// reflectcall did not panic. Remove d.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">d</span> {
            <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;bad defer entry in panic&#34;</span>)
        }
        <span style="color:#75715e">//defer函数已经被执行，脱链
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span> = <span style="color:#66d9ef">nil</span>
        <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span> = <span style="color:#66d9ef">nil</span>
        <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span>
 
        <span style="color:#75715e">// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//GC()
</span><span style="color:#75715e"></span> 
        <span style="color:#a6e22e">pc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">pc</span>  <span style="color:#75715e">//call deferproc的下一条指令的地址，下一条指令为 test rax, rax，在defer实现机制一文中有详细说明
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//call deferproc指令执行前的栈顶指针
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">sp</span>) <span style="color:#75715e">// must be pointer so it gets adjusted during stack copy
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">freedefer</span>(<span style="color:#a6e22e">d</span>)
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">recovered</span> {
            <span style="color:#75715e">//defered函数调用recover成功捕获了panic会设置p.recovered = true
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">runningPanicDefers</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
 
            <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">link</span>
            <span style="color:#75715e">// Aborted panics are marked but remain on the g.panic list.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// Remove them from the list.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span>.<span style="color:#a6e22e">aborted</span> {
                <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span> = <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span>.<span style="color:#a6e22e">link</span>
            }
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// must be done with signal
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sig</span> = <span style="color:#ae81ff">0</span>
            }
            <span style="color:#75715e">// Pass information about recovering frame to recovery.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sigcode0</span> = uintptr(<span style="color:#a6e22e">sp</span>)
            <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sigcode1</span> = <span style="color:#a6e22e">pc</span>
            <span style="color:#75715e">//mcall函数永远不会返回，mcall函数的实现可以参考公众号内的其它文章，有详细分析
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//调用recovery函数跳转到pc位置继续执行
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">mcall</span>(<span style="color:#a6e22e">recovery</span>)  
            <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;recovery failed&#34;</span>) <span style="color:#75715e">// mcall should not return
</span><span style="color:#75715e"></span>        }
    }
 
    <span style="color:#75715e">// ran out of deferred calls - old-school panic now
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Because it is unsafe to call arbitrary user code after freezing
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the world, we call preprintpanics to invoke all necessary Error
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// and String methods to prepare the panic strings before startpanic.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">preprintpanics</span>(<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span>)
 
    <span style="color:#75715e">//打印函数调用链，然后挂死程序
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fatalpanic</span>(<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span>) <span style="color:#75715e">// should not return
</span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">nil</span>) = <span style="color:#ae81ff">0</span>      <span style="color:#75715e">// not reached
</span><span style="color:#75715e"></span>}
 
<span style="color:#75715e">// runtime/panic.go : 578
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">// The implementation of the predeclared function recover.
</span><span style="color:#75715e">// Cannot split the stack because it needs to reliably
</span><span style="color:#75715e">// find the stack segment of its caller.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// TODO(rsc): Once we commit to CopyStackAlways,
</span><span style="color:#75715e">// this doesn&#39;t need to be nosplit.
</span><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gorecover</span>(<span style="color:#a6e22e">argp</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">interface</span>{} {
    <span style="color:#75715e">// Must be in a function running as part of a deferred call during the panic.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Must be called from the topmost function of the call
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// (the function used in the defer statement).
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// p.argp is the argument pointer of that topmost deferred function call.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Compare against argp reported by caller.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// If they match, the caller is the one who can recover.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span>
    <span style="color:#75715e">//条件argp == uintptr(p.argp)在判断panic和recover是否匹配，内层recover不能捕获外层的panic
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//比如本文开头的例2中m函数中的defer catch(&#34;m&#34;)不能捕获g函数中的panic
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">recovered</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">argp</span> <span style="color:#f92672">==</span> uintptr(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">argp</span>) {
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">recovered</span> = <span style="color:#66d9ef">true</span>  <span style="color:#75715e">//通过设置p.recovered = true告诉gopanic函数panic已经被recover了
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">arg</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
 
<span style="color:#75715e">// runtime/panic.go : 634
</span><span style="color:#75715e">// Unwind the stack after a deferred function calls recover
</span><span style="color:#75715e">// after a panic. Then arrange to continue running as though
</span><span style="color:#75715e">// the caller of the deferred function returned normally.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">recovery</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
    <span style="color:#75715e">// Info about defer passed in G struct.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sigcode0</span>   <span style="color:#75715e">//call deferproc时的栈顶指针
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sigcode1</span>   <span style="color:#75715e">//call deferproc下一条指令的地址
</span><span style="color:#75715e"></span> 
    <span style="color:#75715e">// d&#39;s arguments need to be in the stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sp</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">sp</span> &lt; <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> &lt; <span style="color:#a6e22e">sp</span>) {
        print(<span style="color:#e6db74">&#34;recover: &#34;</span>, <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">sp</span>), <span style="color:#e6db74">&#34; not in [&#34;</span>, <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span>), <span style="color:#e6db74">&#34;, &#34;</span>, <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span>), <span style="color:#e6db74">&#34;]\n&#34;</span>)
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;bad recovery&#34;</span>)
    }
 
    <span style="color:#75715e">// Make the deferproc for this d return again,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// this time returning 1. The calling function will
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// jump to the standard return epilogue.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#a6e22e">pc</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lr</span> = <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">ret</span> = <span style="color:#ae81ff">1</span>     <span style="color:#75715e">//该值（1）会被gogo函数放入eax寄存器
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gogo</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>)   <span style="color:#75715e">//跳转到pc所指的指令处继续执行，gogo函数的实现请参考公众号内的其它文章，有详细分析
</span><span style="color:#75715e"></span>}
</code></pre></div><p>从代码可以看出，如果不考虑嵌套，主动 panic/recover 的流程比较清晰：遍历当前 goroutine 所注册的 defered 函数并通过 reflectcall 调用遍历到的函数，如果某个 defered 函数调用了recover（对应到runtime的gorecover函数）则使用 mcall(recovery)  恢复程序的正常流程，否则执行完所有的 defered 函数之后打印出 panic 的栈信息然后退出程序。这里需要说明一下为什么需要通过 reflectcall 来调用 defered 函数而不是直接调用 defered 函数。原因在于直接调用 defered 函数就得在当前栈帧中为它准备参数，而不同的 defered 函数的参数大小可能会有很大差异，比如有的defered函数没有参数而有些defered函数可能又需要成千上万字节的参数，然而gopanic 函数的栈帧大小固定而且很小，所以很有可能没有足够的空间来存放 defered 函数的参数，而reflectcall函数可以处理这种情况，具体是怎么处理的这里就不介绍了，有兴趣的话大家可以去看一下reflectcall函数的代码。</p>
<p>对于panic的嵌套，也就是defered函数再次发生了panic，这会导致gopanic函数再次被调用，也就是说gopanic函数会存在递归调用，其调用链为 gopanic()-&gt;reflectcall()-&gt;defered函数-&gt;gopanic() ，这时有两种情况：</p>
<p>defered函数通过defer再次注册了defered函数而且recover了最新的panic，则上面的调用链将原路从reflect call()返回到gopanic函数继续执行；</p>
<p>defered函数没有recover它自己的panic，则reflectcall()不会返回。要么第二次gopanic执行完所有defered函数之后退出程序，要么新发生的panic代替了前一次panic然后由外层的defered函数recover。</p>
<p>对于上述两种情况，大家可以结合前面代码中的注释以及例2和例3加以理解。</p>
<p>非法操作引起的panic</p>
<p>最常见的非法操作主要是非法访问内存，我们来看一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
 
<span style="color:#f92672">import</span> (
   <span style="color:#e6db74">&#34;fmt&#34;</span>
)
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
 
    <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">100</span>  <span style="color:#75715e">// crash
</span><span style="color:#75715e"></span> 
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;not reached&#34;</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">f</span>()
}
</code></pre></div><p>这个程序运行时会发生panic，原因是f()函数企图向p所指的内存写入100，但指针变量p却是nil。来看看f函数的汇编代码片段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">  0x0000000000487200 &lt;+0&gt;: mov   %fs:0xfffffffffffffff8,%rcx
  0x0000000000487209 &lt;+9&gt;: cmp   0x10<span style="color:#f92672">(</span>%rcx<span style="color:#f92672">)</span>,%rsp
  0x000000000048720d &lt;+13&gt;: jbe   0x4872a1 &lt;main.f+161&gt;
  0x0000000000487213 &lt;+19&gt;: sub   $0x70,%rsp
  0x0000000000487217 &lt;+23&gt;: mov   %rbp,0x68<span style="color:#f92672">(</span>%rsp<span style="color:#f92672">)</span>
  0x000000000048721c &lt;+28&gt;: lea   0x68<span style="color:#f92672">(</span>%rsp<span style="color:#f92672">)</span>,%rbp
  0x0000000000487221 &lt;+33&gt;: movq   $0x0,0x30<span style="color:#f92672">(</span>%rsp<span style="color:#f92672">)</span>
  0x000000000048722a &lt;+42&gt;: xor   %eax,%eax
  0x000000000048722c &lt;+44&gt;: test   %al,<span style="color:#f92672">(</span>%rax<span style="color:#f92672">)</span>
  0x000000000048722e &lt;+46&gt;: movq   $0x64,<span style="color:#f92672">(</span>%rax<span style="color:#f92672">)</span>    <span style="color:#75715e"># *p = 100</span>
  0x0000000000487235 &lt;+53&gt;: xorps %xmm0,%xmm0
  0x0000000000487238 &lt;+56&gt;: movups %xmm0,0x40<span style="color:#f92672">(</span>%rsp<span style="color:#f92672">)</span>
  0x000000000048723d &lt;+61&gt;: lea   0x40<span style="color:#f92672">(</span>%rsp<span style="color:#f92672">)</span>,%rax
  ......
</code></pre></div><p>通过汇编代码我们可以确定编译器并未插入对gopanic函数的调用，但这个程序运行起来发生panic时与在go代码中直接调用gopanic函数时的表现是一样的，都会输出panic时栈的信息，所以这种非法操作最终应该也会调用到gopanic函数，但具体是怎么调用到它的呢？我们可以使用调试工具dlv给gopanic下一个断点，等断下来之后使用bt可以看到其函数调用链为：</p>
<p>f()-&gt;runtime.sigpanic()-&gt;runtime.panicmem()-&gt;runtime.gopanic()
可以看到f()调用了runtime.sigpanic()函数，但从上面的汇编代码可以得知f()其实并没有直接调用runtime.sigpanic()函数，是不是有些奇怪？</p>
<p>事实上，当CPU在执行</p>
<p>0x000000000048722e &lt;+46&gt;: movq   $0x64,(%rax)    # *p = 100
这一条指令时，CPU会发生异常，异常发生后将依次执行如下流程：</p>
<p>CPU在内存中保存发生异常的指令的地址（这里是0x000000000048722e）。为了方便描述，我们称这个地址为异常返回地址；</p>
<p>陷入内核执行由操作系统在系统启动时提供的异常处理程序，该异常处理程序会负责把CPU的所有相关寄存器的值保存在内存之中；</p>
<p>向引起异常的当前线程发送一个SIGSEGV信号；</p>
<p>从内核返回，在返回过程中发现有信号需要处理；</p>
<p>从内核返回到用户态执行信号处理程序（go程序启动时向内核注册的信号处理函数），该信号处理程序将会把第1步中由CPU保存的异常返回地址修改为runtime.sigpanic函数的地址；</p>
<p>信号处理程序执行完成后再次进入内核；</p>
<p>从内核返回开始执行runtime.sigpanic函数；</p>
<p>上述整个流程与Linux系统的信号处理有关，了解即可，如果有兴趣可以参考相关的内核资料，这里我们只需要关注第5步和第7步。从该流程可以看出，当go程序发生异常之后之所以能够最终执行到gopanic函数，关键在于上述流程的第5步修改了异常之后的执行流程，而第5步中的信号处理程序是由go语言的runtime提供的，所以下面我们直接从信号处理程序开始大致看一下其流程。</p>
<p>SIGSEGV信号处理流程</p>
<p>对于SIGSEGV信号，信号处理程序的函数调用链为</p>
<p>内核返回-&gt; runtime.sigtramp() -&gt;runtime.sigtrampgo()-&gt;runtime.sighandler()-&gt;sigctxt.preparePanic()修改异常返回地址
这个调用链中的函数由大家自己去挖掘细节，这里只说两点：</p>
<p>runtime.sigtramp是go程序启动时向内核注册的信号处理函数，所以当线程收到SIGSEGV信号后内核会负责让CPU进入这个函数运行；</p>
<p>内核在返回用户态执行信号处理程序runtime.sigtramp()函数之前，内核会把异常返回地址等数据保存在信号处理程序的函数调用栈之中，等信号处理程序执行完成之后再次进入内核时，内核会把它之前保存在信号处理程序函数栈上的异常返回地址等数据拷贝回内核，然后再返回到用户态继续执行异常返回地址处的指令。这个流程给信号处理程序提供了一个可以修改CPU执行流程的机会，我们来看看sigctxt.preparePanic()函数是怎么修改异常返回地址的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// preparePanic sets up the stack to look like a call to sigpanic.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sigctxt</span>) <span style="color:#a6e22e">preparePanic</span>(<span style="color:#a6e22e">sig</span> <span style="color:#66d9ef">uint32</span>, <span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;darwin&#34;</span> {
        <span style="color:#f92672">......</span>
    }
 
    <span style="color:#75715e">//指针c所指的内存即执行信号处理程序之前由内核保存在栈上的数据
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//c.rip即为异常返回地址，也就是异常发生时CPU正在执行的指令的地址
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pc</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">rip</span>())
    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">rsp</span>())
 
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">shouldPushSigpanic</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">pc</span>, <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>))) {
        <span style="color:#75715e">// Make it look the like faulting PC called sigpanic.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> &gt; <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span> {
            <span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>
            <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#ae81ff">0</span>
        }
        <span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>
        <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#a6e22e">pc</span>
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">set_rsp</span>(uint64(<span style="color:#a6e22e">sp</span>))
    }
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">set_rip</span>(uint64(<span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">sigpanic</span>)))  <span style="color:#75715e">//修改异常返回地址为sigpanic函数的地址
</span><span style="color:#75715e"></span>}
</code></pre></div><p>这个函数的最后一行把异常返回地址修改成了runtime.sigpanic函数的地址，等信号处理完成进入内核后再次返回用户态时CPU将会从runtime.sigpanic函数开始执行，最终执行到前面已经分析过的gopanic函数，这部分代码很清晰，大家有兴趣的话可以自己看看。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go-struct%E8%AF%A6%E8%A7%A3/" rel="next" title="go struct详解">
        <i class="fa fa-chevron-left"></i> go struct详解
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Bdefer%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" rel="prev" title="go深入理解defer（下）defer实现机制">
        go深入理解defer（下）defer实现机制 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">388</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">20</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">26</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.92.1</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>