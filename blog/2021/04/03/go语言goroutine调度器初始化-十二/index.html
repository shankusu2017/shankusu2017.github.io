<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>go语言goroutine调度器初始化 十二 - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="go语言goroutine调度器初始化 十二">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="go语言goroutine调度器初始化 十二 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E5%8D%81%E4%BA%8C/" itemprop="url">
        go语言goroutine调度器初始化 十二
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5811 字 ~12分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/W9D4Sl-6jYfcpczzdPfByQ">源码游记</a> 2019-05-05</p>
<h2 id="本文是go语言调度器源代码情景分析系列的第12篇也是第二章的第2小节">本文是《Go语言调度器源代码情景分析》系列的第12篇，也是第二章的第2小节。</h2>
<p>本章将以下面这个简单的Hello World程序为例，通过跟踪其从启动到退出这一完整的运行流程来分析Go语言调度器的初始化、goroutine的创建与退出、工作线程的调度循环以及goroutine的切换等重要内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello World!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先我们从程序启动开始分析调度器的初始化。</p>
<p>在分析程序的启动过程之前，我们首先来看看程序在执行第一条指令之前其栈的初始状态。</p>
<p>任何一个由编译型语言（不管是C，C++，go还是汇编语言）所编写的程序在被操作系统加载起来运行时都会顺序经过如下几个阶段：</p>
<p>从磁盘上把可执行程序读入内存；</p>
<p>创建进程和主线程；</p>
<p>为主线程分配栈空间；</p>
<p>把由用户在命令行输入的参数拷贝到主线程的栈；</p>
<p>把主线程放入操作系统的运行队列等待被调度执起来运行。</p>
<p>在主线程第一次被调度起来执行第一条指令之前，主线程的函数栈如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/01df3eb8b449a52a38f431f36c5fc530.png" alt=""></p>
<p>了解了程序的初始状态之后，下面我们正式开始。</p>
<p>程序入口</p>
<p>在Linux命令行用 go build 编译hello.go，得到可执行程序hello，然后使用gdb调试，在gdb中我们首先使用 info files 命令找到程序入口（Entry point）地址为0x452270，然后用 b *0x452270 在0x452270地址处下个断点，gdb告诉我们这个入口对应的源代码为 runtime/rt0_linux_amd64.s 文件的第8行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>bobo@ubuntu:~/study/go$ go build hello.go 
</span></span><span style="display:flex;"><span>bobo@ubuntu:~/study/go$ gdb hello
</span></span><span style="display:flex;"><span>GNU gdb <span style="color:#f92672">(</span>GDB<span style="color:#f92672">)</span> 8.0.1
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info files
</span></span><span style="display:flex;"><span>Symbols from <span style="color:#e6db74">&#34;/home/bobo/study/go/main&#34;</span>.
</span></span><span style="display:flex;"><span>Local exec file:
</span></span><span style="display:flex;"><span><span style="color:#e6db74">`</span>/home/bobo/study/go/main<span style="color:#960050;background-color:#1e0010">&#39;</span>, file type elf64-x86-64.
</span></span><span style="display:flex;"><span>Entry point: 0x452270
</span></span><span style="display:flex;"><span>0x0000000000401000 - 0x0000000000486aac is .text
</span></span><span style="display:flex;"><span>0x0000000000487000 - 0x00000000004d1a73 is .rodata
</span></span><span style="display:flex;"><span>0x00000000004d1c20 - 0x00000000004d27f0 is .typelink
</span></span><span style="display:flex;"><span>0x00000000004d27f0 - 0x00000000004d2838 is .itablink
</span></span><span style="display:flex;"><span>0x00000000004d2838 - 0x00000000004d2838 is .gosymtab
</span></span><span style="display:flex;"><span>0x00000000004d2840 - 0x00000000005426d9 is .gopclntab
</span></span><span style="display:flex;"><span>0x0000000000543000 - 0x000000000054fa9c is .noptrdata
</span></span><span style="display:flex;"><span>0x000000000054faa0 - 0x0000000000556790 is .data
</span></span><span style="display:flex;"><span>0x00000000005567a0 - 0x0000000000571ef0 is .bss
</span></span><span style="display:flex;"><span>0x0000000000571f00 - 0x0000000000574658 is .noptrbss
</span></span><span style="display:flex;"><span>0x0000000000400f9c - 0x0000000000401000 is .note.go.buildid
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b *0x452270
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#ae81ff">1</span> at 0x452270: file /usr/local/go/src/runtime/rt0_linux_amd64.s, line 8.
</span></span></code></pre></div><p>打开代码编辑器，找到 runtime/rt0_linx_amd64.s 文件，该文件是用go汇编语言编写而成的源代码文件，我们已经在本书的第一部分讨论过其格式。现在看看第8行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">rt0_linx_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">_rt0_amd64_linux</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">JMP_rt0_amd64</span>(<span style="color:#a6e22e">SB</span>)
</span></span></code></pre></div><p>上面第一行代码定义了_rt0_amd64_linux这个符号，并不是真正的CPU指令，第二行的JMP指令才是主线程的第一条指令，这条指令简单的跳转到（相当于go语言或c中的goto）_rt0_amd64 这个符号处继续执行，_rt0_amd64 这个符号的定义在runtime/asm_amd64.s 文件中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">_rt0_amd64</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">MOVQ0</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">DI</span><span style="color:#75715e">// argc 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">LEAQ8</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">SI</span> <span style="color:#75715e">// argv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">JMPruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">rt0_go</span>(<span style="color:#a6e22e">SB</span>)
</span></span></code></pre></div><p>前两行指令把操作系统内核传递过来的参数argc和argv数组的地址分别放在DI和SI寄存器中，第三行指令跳转到 rt0_go 去执行。</p>
<p>rt0_go函数完成了go程序启动时的所有初始化工作，因此这个函数比较长，也比较繁杂，但这里我们只关注与调度器相关的一些初始化，下面我们分段来看：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">87</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">rt0_go</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// copy arguments forward on an even stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MOVQDI</span>, <span style="color:#a6e22e">AX</span><span style="color:#75715e">// AX = argc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MOVQSI</span>, <span style="color:#a6e22e">BX</span><span style="color:#75715e">// BX = argv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">SUBQ</span><span style="color:#960050;background-color:#1e0010">$</span>(<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span><span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>), <span style="color:#a6e22e">SP</span><span style="color:#75715e">// 2args 2auto
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ANDQ</span><span style="color:#960050;background-color:#1e0010">$~</span><span style="color:#ae81ff">15</span>, <span style="color:#a6e22e">SP</span>     <span style="color:#75715e">//调整栈顶寄存器使其按16字节对齐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MOVQAX</span>, <span style="color:#ae81ff">16</span>(<span style="color:#a6e22e">SP</span>) <span style="color:#75715e">//argc放在SP + 16字节处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">MOVQBX</span>, <span style="color:#ae81ff">24</span>(<span style="color:#a6e22e">SP</span>) <span style="color:#75715e">//argv放在SP + 24字节处
</span></span></span></code></pre></div><p>上面的第4条指令用于调整栈顶寄存器的值使其按16字节对齐，也就是让栈顶寄存器SP指向的内存的地址为16的倍数，之所以要按16字节对齐，是因为CPU有一组SSE指令，这些指令中出现的内存地址必须是16的倍数，最后两条指令把argc和argv搬到新的位置。这段代码的其它部分已经做了比较详细的注释，所以这里就不做过多的解释了。</p>
<p>初始化g0</p>
<p>继续看后面的代码，下面开始初始化全局变量g0，前面我们说过，g0的主要作用是提供一个栈供runtime代码执行，因此这里主要对g0的几个与栈有关的成员进行了初始化，从这里可以看出g0的栈大约有64K，地址范围为 SP - 64*1024 + 104 ～ SP。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">96</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// create istack out of the given (operating system) stack.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// _cgo_init may update stackguard.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//下面这段代码从系统线程的栈空分出一部分当作g0的栈，然后初始化g0的栈信息和stackgard
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQ</span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">g0</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">DI</span>       <span style="color:#75715e">//g0的地址放入DI寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">LEAQ</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">64</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">+</span><span style="color:#ae81ff">104</span>)(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">BX</span> <span style="color:#75715e">//BX = SP - 64*1024 + 104
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQBX</span>, <span style="color:#a6e22e">g_stackguard0</span>(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">//g0.stackguard0 = SP - 64*1024 + 104
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQBX</span>, <span style="color:#a6e22e">g_stackguard1</span>(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">//g0.stackguard1 = SP - 64*1024 + 104
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQBX</span>, (<span style="color:#a6e22e">g_stack</span><span style="color:#f92672">+</span><span style="color:#a6e22e">stack_lo</span>)(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">//g0.stack.lo = SP - 64*1024 + 104
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQSP</span>, (<span style="color:#a6e22e">g_stack</span><span style="color:#f92672">+</span><span style="color:#a6e22e">stack_hi</span>)(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">//g0.stack.hi = SP
</span></span></span></code></pre></div><p>运行完上面这几行指令后g0与栈之间的关系如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/846b4e78af61697ea4ab003df5ed3a5d.png" alt=""></p>
<p>主线程与m0绑定</p>
<p>设置好g0栈之后，我们跳过CPU型号检查以及cgo初始化相关的代码，直接从164行继续分析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">164</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//下面开始初始化tls(thread local storage,线程本地存储)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">LEAQruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">m0</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m_tls</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">DI</span> <span style="color:#75715e">//DI = &amp;m0.tls，取m0的tls成员的地址到DI寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">CALLruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">settls</span>(<span style="color:#a6e22e">SB</span>) <span style="color:#75715e">//调用settls设置线程本地存储，settls函数的参数在DI寄存器中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// store through it, to make sure it works
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//验证settls是否可以正常工作，如果有问题则abort退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">get_tls</span>(<span style="color:#a6e22e">BX</span>) <span style="color:#75715e">//获取fs段基地址并放入BX寄存器，其实就是m0.tls[1]的地址，get_tls的代码由编译器生成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQ</span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0x123</span>, <span style="color:#a6e22e">g</span>(<span style="color:#a6e22e">BX</span>) <span style="color:#75715e">//把整型常量0x123拷贝到fs段基地址偏移-8的内存位置，也就是m0.tls[0]= 0x123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">m0</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m_tls</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span> <span style="color:#75715e">//AX = m0.tls[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">CMPQAX</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0x123</span> <span style="color:#75715e">//检查m0.tls[0]的值是否是通过线程本地存储存入的0x123来验证tls功能是否正常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">JEQ</span> <span style="color:#ae81ff">2</span>(<span style="color:#a6e22e">PC</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">CALLruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">abort</span>(<span style="color:#a6e22e">SB</span>) <span style="color:#75715e">//如果线程本地存储不能正常工作，退出程序
</span></span></span></code></pre></div><p>这段代码首先调用settls函数初始化主线程的线程本地存储(TLS)，目的是把m0与主线程关联在一起，至于为什么要把m和工作线程绑定在一起，我们已经在上一节介绍过了，这里就不再重复。设置了线程本地存储之后接下来的几条指令在于验证TLS功能是否正常，如果不正常则直接abort退出程序。</p>
<p>下面我们详细来详细看一下settls函数是如何实现线程私有全局变量的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">sys_linx_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">606</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// set tls base to DI
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">settls</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//......
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//DI寄存器中存放的是m.tls[0]的地址，m的tls成员是一个数组，读者如果忘记了可以回头看一下m结构体的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//下面这一句代码把DI寄存器中的地址加8，为什么要+8呢，主要跟ELF可执行文件格式中的TLS实现的机制有关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//执行下面这句指令之后DI寄存器中的存放的就是m.tls[1]的地址了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ADDQ</span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">8</span>, <span style="color:#a6e22e">DI</span><span style="color:#75715e">// ELF wants to use -8(FS)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//下面通过arch_prctl系统调用设置FS段基址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQDI</span>, <span style="color:#a6e22e">SI</span> <span style="color:#75715e">//SI存放arch_prctl系统调用的第二个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQ</span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0x1002</span>, <span style="color:#a6e22e">DI</span><span style="color:#75715e">// ARCH_SET_FS //arch_prctl的第一个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQ</span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">SYS_arch_prctl</span>, <span style="color:#a6e22e">AX</span> <span style="color:#75715e">//系统调用编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">SYSCALL</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">CMPQAX</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0xfffffffffffff001</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">JLS2</span>(<span style="color:#a6e22e">PC</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MOVL</span><span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0xf1</span>, <span style="color:#ae81ff">0xf1</span> <span style="color:#75715e">// crash //系统调用失败直接crash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">RET</span>
</span></span></code></pre></div><p>从代码可以看到，这里通过arch_prctl系统调用把m0.tls[1]的地址设置成了fs段的段基址。CPU中有个叫fs的段寄存器与之对应，而每个线程都有自己的一组CPU寄存器值，操作系统在把线程调离CPU运行时会帮我们把所有寄存器中的值保存在内存中，调度线程起来运行时又会从内存中把这些寄存器的值恢复到CPU，这样，在此之后，工作线程代码就可以通过fs寄存器来找到m.tls，读者可以参考上面初始化tls之后对tls功能验证的代码来理解这一过程。</p>
<p>下面继续分析rt0_go，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">174</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ok</span>:
</span></span><span style="display:flex;"><span><span style="color:#75715e">// set the per-goroutine and per-mach &#34;registers&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">get_tls</span>(<span style="color:#a6e22e">BX</span>) <span style="color:#75715e">//获取fs段基址到BX寄存器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">LEAQruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">g0</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">CX</span> <span style="color:#75715e">//CX = g0的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQCX</span>, <span style="color:#a6e22e">g</span>(<span style="color:#a6e22e">BX</span>) <span style="color:#75715e">//把g0的地址保存在线程本地存储里面，也就是m0.tls[0]=&amp;g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">LEAQruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">m0</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span> <span style="color:#75715e">//AX = m0的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//把m0和g0关联起来m0-&gt;g0 = g0，g0-&gt;m = m0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// save m-&gt;g0 = g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQCX</span>, <span style="color:#a6e22e">m_g0</span>(<span style="color:#a6e22e">AX</span>) <span style="color:#75715e">//m0.g0 = g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// save m0 to g0-&gt;m 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQAX</span>, <span style="color:#a6e22e">g_m</span>(<span style="color:#a6e22e">CX</span>) <span style="color:#75715e">//g0.m = m0
</span></span></span></code></pre></div><p>上面的代码首先把g0的地址放入主线程的线程本地存储中，然后通过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">m0</span>.<span style="color:#a6e22e">g0</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">g0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">g0</span>.<span style="color:#a6e22e">m</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m0</span>
</span></span></code></pre></div><p>把m0和g0绑定在一起，这样，之后在主线程中通过get_tls可以获取到g0，通过g0的m成员又可以找到m0，于是这里就实现了m0和g0与主线程之间的关联。从这里还可以看到，保存在主线程本地存储中的值是g0的地址，也就是说工作线程的私有全局变量其实是一个指向g的指针而不是指向m的指针，目前这个指针指向g0，表示代码正运行在g0栈。此时，主线程，m0，g0以及g0的栈之间的关系如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bd0bfab9f20d9fa2ac42c317f72315ee.png" alt=""></p>
<p>初始化m0</p>
<p>下面代码开始处理命令行参数，这部分我们不关心，所以跳过。命令行参数处理完成后调用osinit函数获取CPU核的数量并保存在全局变量ncpu之中，调度器初始化时需要知道当前系统有多少个CPU核。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">189</span>
</span></span></code></pre></div><p>//准备调用args函数，前面四条指令把参数放在栈上</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">MOVL16</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span><span style="color:#75715e">// AX = argc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVLAX</span>, <span style="color:#ae81ff">0</span>(<span style="color:#a6e22e">SP</span>)       <span style="color:#75715e">// argc放在栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQ24</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span><span style="color:#75715e">// AX = argv
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MOVQAX</span>, <span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>)       <span style="color:#75715e">// argv放在SP + 8的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">CALLruntime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">args</span>(<span style="color:#a6e22e">SB</span>)  <span style="color:#75715e">//处理操作系统传递过来的参数和env，不需要关心
</span></span></span></code></pre></div><p>//对于linx来说，osinit唯一功能就是获取CPU的核数并放在global变量ncpu中，
//调度器初始化时需要知道当前系统有多少CPU核
CALLruntime·osinit(SB)  //执行的结果是全局变量 ncpu = CPU核数
CALLruntime·schedinit(SB) //调度系统初始化
接下来继续看调度器是如何初始化的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>runtime/proc.go : 526
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func schedinit() {
</span></span><span style="display:flex;"><span>// raceinit must be the first call to race detector.
</span></span><span style="display:flex;"><span>// In particular, it must be done before mallocinit below calls racemapshadow.
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    //getg函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
</span></span><span style="display:flex;"><span>    //get_tls(CX) 
</span></span><span style="display:flex;"><span>    //MOVQ g(CX), BX; BX存器里面现在放的是当前g结构体对象的地址
</span></span><span style="display:flex;"><span>    _g_ := getg() // _g_ = &amp;g0
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    //设置最多启动10000个操作系统线程，也是最多10000个M
</span></span><span style="display:flex;"><span>    sched.maxmcount = 10000
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    mcommoninit(_g_.m) //初始化m0，因为从前面的代码我们知道g0-&gt;m = &amp;m0
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    sched.lastpoll = uint64(nanotime())
</span></span><span style="display:flex;"><span>    procs := ncpu  //系统中有多少核，就创建和初始化多少个p结构体对象
</span></span><span style="display:flex;"><span>    if n, ok := atoi32(gogetenv(&#34;GOMAXPROCS&#34;)); ok &amp;&amp; n &gt; 0 {
</span></span><span style="display:flex;"><span>        procs = n //如果环境变量指定了GOMAXPROCS，则创建指定数量的p
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    if procresize(procs) != nil {//创建和初始化全局变量allp
</span></span><span style="display:flex;"><span>        throw(&#34;unknown runnable goroutine during bootstrap&#34;)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>前面我们已经看到，g0的地址已经被设置到了线程本地存储之中，schedinit通过getg函数（getg函数是编译器实现的，我们在源代码中是找不到其定义的）从线程本地存储中获取当前正在运行的g，这里获取出来的是g0，然后调用mcommoninit函数对m0(g0.m)进行必要的初始化，对m0初始化完成之后调用procresize初始化系统需要用到的p结构体对象，按照go语言官方的说法，p就是processor的意思，它的数量决定了最多可以有都少个goroutine同时并行运行。schedinit函数除了初始化m0和p，还设置了全局变量sched的maxmcount成员为10000，限制最多可以创建10000个操作系统线程出来工作。</p>
<p>这里我们需要重点关注一下mcommoninit如何初始化m0以及procresize函数如何创建和初始化p结构体对象。首先我们深入到mcommoninit函数中一探究竟。这里需要注意的是不只是初始化的时候会执行该函数，在程序运行过程中如果创建了工作线程，也会执行它，所以我们会在函数中看到加锁和检查线程数量是否已经超过最大值等相关的代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>runtime/proc.go : 596
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>func mcommoninit(mp *m) {
</span></span><span style="display:flex;"><span>    _g_ := getg() //初始化过程中_g_ = g0
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    // g0 stack won&#39;t make sense for user (and is not necessary unwindable).
</span></span><span style="display:flex;"><span>    if _g_ != _g_.m.g0 {  //函数调用栈traceback，不需要关心
</span></span><span style="display:flex;"><span>        callers(1, mp.createstack[:])
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    lock(&amp;sched.lock)
</span></span><span style="display:flex;"><span>    if sched.mnext+1 &lt; sched.mnext {
</span></span><span style="display:flex;"><span>        throw(&#34;runtime: thread ID overflow&#34;)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mp.id = sched.mnext
</span></span><span style="display:flex;"><span>    sched.mnext++
</span></span><span style="display:flex;"><span>    checkmcount() //检查已创建系统线程是否超过了数量限制（10000）
</span></span><span style="display:flex;"><span>    //random初始化
</span></span><span style="display:flex;"><span>    mp.fastrand[0] = 1597334677 * uint32(mp.id)
</span></span><span style="display:flex;"><span>    mp.fastrand[1] = uint32(cputicks())
</span></span><span style="display:flex;"><span>    if mp.fastrand[0]|mp.fastrand[1] == 0 {
</span></span><span style="display:flex;"><span>        mp.fastrand[1] = 1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //创建用于信号处理的gsignal，只是简单的从堆上分配一个g结构体对象,然后把栈设置好就返回了
</span></span><span style="display:flex;"><span>    mpreinit(mp)
</span></span><span style="display:flex;"><span>    if mp.gsignal != nil {
</span></span><span style="display:flex;"><span>        mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    //把m挂入全局链表allm之中
</span></span><span style="display:flex;"><span>    // Add to allm so garbage collector doesn&#39;t free g-&gt;m
</span></span><span style="display:flex;"><span>    // when it is just in a register or thread-local storage.
</span></span><span style="display:flex;"><span>    mp.alllink = allm 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    // NumCgoCall() iterates over allm w/o schedlock,
</span></span><span style="display:flex;"><span>    // so we need to publish it safely.
</span></span><span style="display:flex;"><span>    atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))
</span></span><span style="display:flex;"><span>    unlock(&amp;sched.lock)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    // Allocate memory to hold a cgo traceback if the cgo call crashes.
</span></span><span style="display:flex;"><span>    if iscgo || GOOS == &#34;solaris&#34; || GOOS == &#34;windows&#34; {
</span></span><span style="display:flex;"><span>        mp.cgoCallers = new(cgoCallers)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从这个函数的源代码可以看出，这里并未对m0做什么关于调度相关的初始化，所以可以简单的认为这个函数只是把m0放入全局链表allm之中就返回了。</p>
<p>m0完成基本的初始化后，继续调用procresize创建和初始化p结构体对象，在这个函数里面会创建指定个数（根据cpu核数或环境变量确定）的p结构体对象放在全变量allp里, 并把m0和allp[0]绑定在一起，因此当这个函数执行完成之后就有</p>
<p>m0.p = allp[0]
allp[0].m = &amp;m0
到此m0, g0, 和m需要的p完全关联在一起了。</p>
<p>初始化allp</p>
<p>下面我们来看procresize函数，考虑到初始化完成之后用户代码还可以通过 GOMAXPROCS()函数调用它重新创建和初始化p结构体对象，而在运行过程中再动态的调整p牵涉到的问题比较多，所以这个函数的处理比较复杂，但如果只考虑初始化，相对来说要简单很多，所以这里只保留了初始化时会执行的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">proc</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">3902</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">procresize</span>(<span style="color:#a6e22e">nprocs</span> <span style="color:#66d9ef">int32</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">old</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gomaxprocs</span> <span style="color:#75715e">//系统初始化时 gomaxprocs = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Grow allp if necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nprocs</span> &gt; int32(len(<span style="color:#a6e22e">allp</span>)) { <span style="color:#75715e">//初始化时 len(allp) == 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Synchronize with retake, which could be running
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// concurrently since it doesn&#39;t run on a P.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">&lt;=</span> int32(cap(<span style="color:#a6e22e">allp</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">allp</span>[:<span style="color:#a6e22e">nprocs</span>]
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">//初始化时进入此分支，创建allp 切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">nallp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">nprocs</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Copy everything up to allp&#39;s cap so we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// never lose old allocated Ps.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            copy(<span style="color:#a6e22e">nallp</span>, <span style="color:#a6e22e">allp</span>[:cap(<span style="color:#a6e22e">allp</span>)])
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">nallp</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// initialize new P&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//循环创建nprocs个p并完成基本初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> int32(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">nprocs</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pp</span> = new(<span style="color:#a6e22e">p</span>)<span style="color:#75715e">//调用内存分配器从堆上分配一个struct p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">id</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pgcstop</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">atomicstorep</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">pp</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()  <span style="color:#75715e">// _g_ = g0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">id</span> &lt; <span style="color:#a6e22e">nprocs</span> {<span style="color:#75715e">//初始化时m0-&gt;p还未初始化，所以不会执行这个分支
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// continue to use the current P
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Prunning</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">mcache</span>.<span style="color:#a6e22e">prepareForSweep</span>()
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {<span style="color:#75715e">//初始化时执行这个分支
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// release the current P and acquire allp[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {<span style="color:#75715e">//初始化时这里不执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pidle</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">acquirep</span>(<span style="color:#a6e22e">p</span>) <span style="color:#75715e">//把p和m0关联起来，其实是这两个strct的成员相互赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">traceGoStart</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//下面这个for 循环把所有空闲的p放入空闲链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">runnablePs</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span> {<span style="color:#75715e">//allp[0]跟m0关联了，所以是不能放任
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pidle</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">runqempty</span>(<span style="color:#a6e22e">p</span>) {<span style="color:#75715e">//初始化时除了allp[0]其它p全部执行这个分支，放入空闲链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">pidleput</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">runnablePs</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数代码比较长，但并不复杂，这里总结一下这个函数的主要流程：</p>
<p>使用make([]*p, nprocs)初始化全局变量allp，即allp = make([]*p, nprocs)</p>
<p>循环创建并初始化nprocs个p结构体对象并依次保存在allp切片之中</p>
<p>把m0和allp[0]绑定在一起，即m0.p = allp[0], allp[0].m = m0</p>
<p>把除了allp[0]之外的所有p放入到全局变量sched的pidle空闲队列之中</p>
<p>procresize函数执行完后，调度器相关的初始化工作就基本结束了，这时整个调度器相关的各组成部分之间的联系如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e21c511e55325a7e1351a41993c270e.png" alt=""></p>
<p>分析完调度器的基本初始化后，下一节我们来看程序中的第一个goroutine是如何创建的。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E5%88%9B%E5%BB%BAmain-goroutine13/" rel="next" title="go语言调度器之创建main goroutine(13)">
        <i class="fa fa-chevron-left"></i> go语言调度器之创建main goroutine(13)
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8%E6%A6%82%E8%BF%B011/" rel="prev" title="goroutine调度器概述(11)">
        goroutine调度器概述(11) <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">476</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">30</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">35</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>