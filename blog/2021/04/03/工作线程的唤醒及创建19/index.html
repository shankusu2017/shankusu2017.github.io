<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>工作线程的唤醒及创建(19) - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="工作线程的唤醒及创建(19)">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="工作线程的唤醒及创建(19) - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92%E5%8F%8A%E5%88%9B%E5%BB%BA19/" itemprop="url">
        工作线程的唤醒及创建(19)
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5224 字 ~11分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/T9CDaNF5KUFjE_Z6YW7mRw">源码游记</a> 2019-05-23</p>
<p>本文是《Go语言调度器源代码情景分析》系列的第19篇，也是第四章《Goroutine被动调度》的第2小节。</p>
<p>本文需要重点关注：</p>
<p>如何唤醒睡眠中的工作线程</p>
<p>如何创建新的工作线程</p>
<p>上一篇文章我们分析到了ready函数通过把需要唤醒的goroutine放入运行队列来唤醒它，本文接着上文继续分析。</p>
<p>唤醒空闲的P</p>
<p>为了充分利用CPU，ready函数在唤醒goroutine之后会去判断是否需要启动新工作线程出来工作，判断规则是，如果当前有空闲的p而且没有工作线程正在尝试从各个工作线程的本地运行队列偷取goroutine的话（没有处于spinning状态的工作线程），那么就需要把空闲的p唤醒起来工作，详见下面的ready函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 639
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// Mark gp ready to run.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">ready</span>(gp *g, traceskip <span style="color:#00f">int</span>, next <span style="color:#00f">bool</span>) {
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// Mark runnable.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    _g_ := <span style="color:#c34e00">getg</span>()
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">casgstatus</span>(gp, _Gwaiting, _Grunnable)
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">runqput</span>(_g_.m.p.<span style="color:#c34e00">ptr</span>(), gp, next) <span style="color:#f00;font-style:italic">//放入运行队列
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> atomic.<span style="color:#c34e00">Load</span>(&amp;sched.npidle) != 0 &amp;&amp; atomic.<span style="color:#c34e00">Load</span>(&amp;sched.nmspinning) == 0 {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//有空闲的p而且没有正在偷取goroutine的工作线程，则需要唤醒p出来工作
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#c34e00">wakep</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而唤醒空闲的p是由wakep函数完成的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 2051
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// Tries to add one more P to execute G&#39;s.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// Called when a G is made runnable (newproc, ready).
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">wakep</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// be conservative about spinning threads
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> !atomic.<span style="color:#c34e00">Cas</span>(&amp;sched.nmspinning, 0, 1) {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">startm</span>(<span style="color:#00f">nil</span>, <span style="color:#00f">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>wakep首先通过cas操作再次确认是否有其它工作线程正处于spinning状态，这里之所以需要使用cas操作再次进行确认，原因在于，在当前工作线程通过如下条件</p>
<p>atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0
判断到需要启动工作线程之后到真正启动工作线程之前的这一段时间之内，如果已经有工作线程进入了spinning状态而在四处寻找需要运行的goroutine，这样的话我们就没有必要再启动一个多余的工作线程出来了。</p>
<p>如果cas操作成功，则继续调用startm创建一个新的或唤醒一个处于睡眠状态的工作线程出来工作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 1947
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// Schedules some M to run the p (creates an M if necessary).
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// If p==nil, tries to get an idle P, if no idle P&#39;s does nothing.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// May run with m.p==nil, so write barriers are not allowed.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// If spinning is set, the caller has incremented nmspinning and startm will
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// either decrement nmspinning or set m.spinning in the newly started M.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//go:nowritebarrierrec
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">startm</span>(_p_ *p, spinning <span style="color:#00f">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">lock</span>(&amp;sched.lock)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> _p_ == <span style="color:#00f">nil</span> { <span style="color:#f00;font-style:italic">//没有指定p的话需要从p的空闲队列中获取一个p
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        _p_ = <span style="color:#c34e00">pidleget</span>() <span style="color:#f00;font-style:italic">//从p的空闲队列中获取空闲p
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">if</span> _p_ == <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#c34e00">unlock</span>(&amp;sched.lock)
</span></span><span style="display:flex;"><span>            <span style="color:#00f">if</span> spinning {
</span></span><span style="display:flex;"><span>                <span style="color:#f00;font-style:italic">// The caller incremented nmspinning, but there are no idle Ps,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#f00;font-style:italic">// so it&#39;s okay to just undo the increment and give up.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#f00;font-style:italic">//spinning为true表示进入这个函数之前已经对sched.nmspinning加了1，需要还原
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>                <span style="color:#00f">if</span> int32(atomic.<span style="color:#c34e00">Xadd</span>(&amp;sched.nmspinning, -1)) &lt; 0 {
</span></span><span style="display:flex;"><span>                    <span style="color:#c34e00">throw</span>(<span style="color:#009c00">&#34;startm: negative nmspinning&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#00f">return</span> <span style="color:#f00;font-style:italic">//没有空闲的p，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mp := <span style="color:#c34e00">mget</span>() <span style="color:#f00;font-style:italic">//从m空闲队列中获取正处于睡眠之中的工作线程，所有处于睡眠状态的m都在此队列中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">unlock</span>(&amp;sched.lock)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> mp == <span style="color:#00f">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f00;font-style:italic">//没有处于睡眠状态的工作线程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">var</span> fn <span style="color:#00f">func</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> spinning {
</span></span><span style="display:flex;"><span>            <span style="color:#f00;font-style:italic">// The caller incremented nmspinning, so set m.spinning in the new M.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>            fn = mspinning
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">newm</span>(fn, _p_) <span style="color:#f00;font-style:italic">//创建新的工作线程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#00f">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> mp.spinning {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">throw</span>(<span style="color:#009c00">&#34;startm: m is spinning&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> mp.nextp != 0 {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">throw</span>(<span style="color:#009c00">&#34;startm: m has p&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> spinning &amp;&amp; !<span style="color:#c34e00">runqempty</span>(_p_) {
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">throw</span>(<span style="color:#009c00">&#34;startm: p has runnable gs&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// The caller incremented nmspinning, so set m.spinning in the new M.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    mp.spinning = spinning
</span></span><span style="display:flex;"><span>    mp.nextp.<span style="color:#c34e00">set</span>(_p_)
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">//唤醒处于休眠状态的工作线程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">notewakeup</span>(&amp;mp.park)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>startm函数首先判断是否有空闲的p结构体对象，如果没有则直接返回，如果有则需要创建或唤醒一个工作线程出来与之绑定，从这里可以看出所谓的唤醒p，其实就是把空闲的p利用起来。</p>
<p>在确保有可以绑定的p对象之后，startm函数首先尝试从m的空闲队列中查找正处于休眠状态的工作线程，如果找到则通过notewakeup函数唤醒它，否则调用newm函数创建一个新的工作线程出来。</p>
<p>下面我们首先分析notewakeup函数是如何唤醒工作线程的，然后再讨论newm函数创建工作线程的流程。</p>
<p>唤醒睡眠中的工作线程</p>
<p>在第三章我们讨论过，当找不到需要运行的goroutine时，工作线程会通过notesleep函数睡眠在m.park成员上，所以这里使用m.park成员作为参数调用notewakeup把睡眠在该成员之上的工作线程唤醒。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/lock_futex.<span style="color:#00f">go</span> : 130
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> <span style="color:#c34e00">notewakeup</span>(n *note) {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">//设置n.key = 1, 被唤醒的线程通过查看该值是否等于1来确定是被其它线程唤醒还是意外从睡眠中苏醒
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    old := atomic.<span style="color:#c34e00">Xchg</span>(<span style="color:#c34e00">key32</span>(&amp;n.key), 1)  
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> old != 0 {
</span></span><span style="display:flex;"><span>        print(<span style="color:#009c00">&#34;notewakeup - double wakeup (&#34;</span>, old, <span style="color:#009c00">&#34;)\n&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#c34e00">throw</span>(<span style="color:#009c00">&#34;notewakeup - double wakeup&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">//调用futexwakeup唤醒
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">futexwakeup</span>(<span style="color:#c34e00">key32</span>(&amp;n.key), 1)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>notewakeup函数首先使用atomic.Xchg设置note.key值为1，这是为了使被唤醒的线程可以通过查看该值是否等于1来确定是被其它线程唤醒还是意外从睡眠中苏醒了过来，如果该值为1则表示是被唤醒的，可以继续工作了，但如果该值为0则表示是意外苏醒，需要再次进入睡眠，工作线程苏醒之后的处理逻辑我们已经在notesleep函数中见过，所以这里略过。</p>
<p>把note.key的值设置为1后，notewakeup函数继续调用futexwakeup函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/os_linux.<span style="color:#00f">go</span> : 66
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// If any procs are sleeping on addr, wake up at most cnt.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//go:nosplit
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">futexwakeup</span>(addr *<span style="color:#00f">uint32</span>, cnt <span style="color:#00f">uint32</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">//调用futex函数唤醒工作线程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    ret := <span style="color:#c34e00">futex</span>(unsafe.<span style="color:#c34e00">Pointer</span>(addr), _FUTEX_WAKE_PRIVATE, cnt, <span style="color:#00f">nil</span>, <span style="color:#00f">nil</span>, 0)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> ret &gt;= 0 {
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// I don&#39;t know that futex wakeup can return
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">// EAGAIN or EINTR, but if it does, it would be
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">// safe to loop and call futex again.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">systemstack</span>(<span style="color:#00f">func</span>() {
</span></span><span style="display:flex;"><span>        print(<span style="color:#009c00">&#34;futexwakeup addr=&#34;</span>, addr, <span style="color:#009c00">&#34; returned &#34;</span>, ret, <span style="color:#009c00">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    *(*<span style="color:#00f">int32</span>)(unsafe.<span style="color:#c34e00">Pointer</span>(uintptr(0x1006))) = 0x1006
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于Linux平台来说，工作线程通过note睡眠其实是通过futex系统调用睡眠在内核之中，所以唤醒处于睡眠状态的线程也需要通过futex系统调用进入内核来唤醒，所以这里的futexwakeup又继续调用包装了futex系统调用的futex函数来实现唤醒睡眠在内核中的工作线程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/sys_linux_amd64.s : 525
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// int64 futex(int32 *uaddr, int32 op, int32 val,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//struct timespec *timeout, int32 *uaddr2, int32 val2);
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>TEXT runtime·<span style="color:#c34e00">futex</span>(SB),NOSPLIT,$0
</span></span><span style="display:flex;"><span>    MOVQ  addr+0(FP), DI  #这6条指令在为futex系统调用准备参数
</span></span><span style="display:flex;"><span>    MOVL  op+8(FP), SI
</span></span><span style="display:flex;"><span>    MOVL  val+12(FP), DX
</span></span><span style="display:flex;"><span>    MOVQ  ts+16(FP), R10
</span></span><span style="display:flex;"><span>    MOVQ  addr2+24(FP), R8
</span></span><span style="display:flex;"><span>    MOVL  val3+32(FP), R9
</span></span><span style="display:flex;"><span>    MOVL  $SYS_futex, AX   #futex系统调用编号放入AX寄存器
</span></span><span style="display:flex;"><span>    SYSCALL   #系统调用，进入内核
</span></span><span style="display:flex;"><span>    MOVL  AX, ret+40(FP) #系统调用通过AX寄存器返回返回值，这里把返回值保存到内存之中
</span></span><span style="display:flex;"><span>    RET
</span></span></code></pre></div><p>futex函数由汇编代码写成，前面的几条指令都在为futex系统调用准备参数，参数准备完成之后则通过SYSCALL指令进入操作系统内核完成线程的唤醒功能，内核在完成唤醒工作之后当前工作线程则从内核返回到futex函数继续执行SYSCALL指令之后的代码并按函数调用链原路返回，继续执行其它代码，而被唤醒的工作线程则由内核负责在适当的时候调度到CPU上运行。</p>
<p>看完唤醒流程，下面我们来分析工作线程的创建。</p>
<p>创建工作线程</p>
<p>回到startm函数，如果没有正处于休眠状态的工作线程，则需要调用newm函数新建一个工作线程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 1807
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// Create a new m. It will start off with a call to fn, or else the scheduler.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// fn needs to be static and not a heap allocated closure.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// May run with m.p==nil, so write barriers are not allowed.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//go:nowritebarrierrec
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">newm</span>(fn <span style="color:#00f">func</span>(), _p_ *p) {
</span></span><span style="display:flex;"><span>    mp := <span style="color:#c34e00">allocm</span>(_p_, fn)
</span></span><span style="display:flex;"><span>    mp.nextp.<span style="color:#c34e00">set</span>(_p_)
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">newm1</span>(mp)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>newm首先调用allocm函数从堆上分配一个m结构体对象，然后调用newm1函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 1843
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> <span style="color:#c34e00">newm1</span>(mp *m) {
</span></span><span style="display:flex;"><span>      <span style="color:#f00;font-style:italic">//省略cgo相关代码.......
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>      execLock.<span style="color:#c34e00">rlock</span>() <span style="color:#f00;font-style:italic">// Prevent process clone.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>      <span style="color:#c34e00">newosproc</span>(mp)
</span></span><span style="display:flex;"><span>      execLock.<span style="color:#c34e00">runlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>newm1继续调用newosproc函数，newosproc的主要任务是调用clone函数创建一个系统线程，而新建的这个系统线程将从mstart函数开始运行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/os_linux.<span style="color:#00f">go</span> : 143
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// May run with m.p==nil, so write barriers are not allowed.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//go:nowritebarrier
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">newosproc</span>(mp *m) {
</span></span><span style="display:flex;"><span>    stk := unsafe.<span style="color:#c34e00">Pointer</span>(mp.g0.stack.hi)                     
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>    ret := <span style="color:#c34e00">clone</span>(cloneFlags, stk, unsafe.<span style="color:#c34e00">Pointer</span>(mp), unsafe.<span style="color:#c34e00">Pointer</span>(mp.g0),        unsafe.<span style="color:#c34e00">Pointer</span>(<span style="color:#c34e00">funcPC</span>(mstart)))
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">//clone系统调用的Flags选项
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>cloneFlags = _CLONE_VM | <span style="color:#f00;font-style:italic">/* share memory */</span> <span style="color:#f00;font-style:italic">//指定父子线程共享进程地址空间
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>  _CLONE_FS | <span style="color:#f00;font-style:italic">/* share cwd, etc */</span>
</span></span><span style="display:flex;"><span>  _CLONE_FILES | <span style="color:#f00;font-style:italic">/* share fd table */</span>
</span></span><span style="display:flex;"><span>  _CLONE_SIGHAND | <span style="color:#f00;font-style:italic">/* share sig handler table */</span>
</span></span><span style="display:flex;"><span>  _CLONE_SYSVSEM | <span style="color:#f00;font-style:italic">/* share SysV semaphore undo lists (see issue #20763) */</span>
</span></span><span style="display:flex;"><span>  _CLONE_THREAD <span style="color:#f00;font-style:italic">/* revisit - okay for now */</span>  <span style="color:#f00;font-style:italic">//创建子线程而不是子进程
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>clone函数是由汇编语言实现的，该函数使用clone系统调用完成创建系统线程的核心功能。我们分段来看
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>runtime/sys_linux_amd64.s : 539
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>TEXT runtime·<span style="color:#c34e00">clone</span>(SB),NOSPLIT,$0
</span></span><span style="display:flex;"><span>    MOVL  flags+0(FP), DI <span style="color:#f00;font-style:italic">//系统调用的第一个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    MOVQ  stk+8(FP), SI   <span style="color:#f00;font-style:italic">//系统调用的第二个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    MOVQ  $0, DX         <span style="color:#f00;font-style:italic">//第三个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    MOVQ  $0, R10         <span style="color:#f00;font-style:italic">//第四个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// Copy mp, gp, fn off parent stack for use by child.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">// Careful: Linux system call clobbers CX and R11.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    MOVQ  mp+16(FP), R8
</span></span><span style="display:flex;"><span>    MOVQ  gp+24(FP), R9
</span></span><span style="display:flex;"><span>    MOVQ  fn+32(FP), R12
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    MOVL  $SYS_clone, AX
</span></span><span style="display:flex;"><span>    SYSCALL
</span></span></code></pre></div><p>clone函数首先用了4条指令为clone系统调用准备参数，该系统调用一共需要四个参数，根据Linux系统调用约定，这四个参数需要分别放入rdi， rsi，rdx和r10寄存器中，这里最重要的是第一个参数和第二个参数，分别用来指定内核创建线程时需要的选项和新线程应该使用的栈。因为即将被创建的线程与当前线程共享同一个进程地址空间，所以这里必须为子线程指定其使用的栈，否则父子线程会共享同一个栈从而造成混乱，从上面的newosproc函数可以看出，新线程使用的栈为m.g0.stack.lo～m.g0.stack.hi这段内存，而这段内存是newm函数在创建m结构体对象时从进程的堆上分配而来的。</p>
<p>准备好系统调用的参数之后，还有另外一件很重的事情需要做，那就是把clone函数的其它几个参数（mp, gp和线程入口函数）保存到寄存器中，之所以需要在系统调用之前保存这几个参数，原因在于这几个参数目前还位于父线程的栈之中，而一旦通过系统调用把子线程创建出来之后，子线程将会使用我们在clone系统调用时给它指定的栈，所以这里需要把这几个参数先保存到寄存器，等子线程从系统调用返回后直接在寄存器中获取这几个参数。这里要注意的是虽然这个几个参数值保存在了父线程的寄存器之中，但创建子线程时，操作系统内核会把父线程的所有寄存器帮我们复制一份给子线程，所以当子线程开始运行时就能拿到父线程保存在寄存器中的值，从而拿到这几个参数。这些准备工作完成之后代码调用syscall指令进入内核，由内核帮助我们创建系统线程。</p>
<p>clone系统调用完成后实际上就多了一个操作系统线程，新创建的子线程和当前线程都得从系统调用返回然后继续执行后面的代码，那么从系统调用返回之后我们怎么知道哪个是父线程哪个是子线程，从而来决定它们的执行流程？使用过fork系统调用的读者应该知道，我们需要通过返回值来判断父子线程，系统调用的返回值如果是0则表示这是子线程，不为0则表示这个是父线程。用c代码来描述大概就是这个样子：</p>
<p>if (clone(&hellip;) == 0) { //子线程
子线程代码
} else { //父线程
父线程代码
}
虽然这里只有一次clone调用，但它却返回了2次，一次返回到父线程，一次返回到子线程，然后2个线程各自执行自己的代码流程。</p>
<p>回到clone函数，下面代码的第一条指令就在判断系统调用的返回值，如果是子线程则跳转到后面的代码继续执行，如果是父线程，它创建子线程的任务已经完成，所以这里把返回值保存在栈上之后就直接执行ret指令返回到newosproc函数了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/sys_linux_amd64.s : 555
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// In parent, return.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    CMPQ  AX, $0  #判断clone系统调用的返回值
</span></span><span style="display:flex;"><span>    JEQ  3(PC) / #跳转到子线程部分
</span></span><span style="display:flex;"><span>    MOVL  AX, ret+40(FP) #父线程需要执行的指令
</span></span><span style="display:flex;"><span>    RET  #父线程需要执行的指令
</span></span></code></pre></div><p>而对于子线程来说，还有很多初始化工作要做，下面是子线程需要继续执行的指令。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/sys_linux_amd64.s : 561
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    # In child, on new stack.
</span></span><span style="display:flex;"><span>    #子线程需要继续执行的指令
</span></span><span style="display:flex;"><span>    MOVQ  SI, SP  #设置CPU栈顶寄存器指向子线程的栈顶，这条指令看起来是多余的？内核应该已经把SP设置好了
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    # If g or m are <span style="color:#00f">nil</span>, skip Go-related setup.
</span></span><span style="display:flex;"><span>    CMPQ  R8, $0    # m，新创建的m结构体对象的地址，由父线程保存在R8寄存器中的值被复制到了子线程
</span></span><span style="display:flex;"><span>    JEQ  nog
</span></span><span style="display:flex;"><span>    CMPQ  R9, $0    # g，m.g0的地址，由父线程保存在R9寄存器中的值被复制到了子线程
</span></span><span style="display:flex;"><span>    JEQ  nog
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    # Initialize m-&gt;procid to Linux tid
</span></span><span style="display:flex;"><span>    MOVL  $SYS_gettid, AX  #通过gettid系统调用获取线程ID（tid）
</span></span><span style="display:flex;"><span>    SYSCALL
</span></span><span style="display:flex;"><span>    MOVQ  AX, <span style="color:#c34e00">m_procid</span>(R8)  #m.procid = tid
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #Set FS to point at m-&gt;tls.
</span></span><span style="display:flex;"><span>    #新线程刚刚创建出来，还未设置线程本地存储，即m结构体对象还未与工作线程关联起来，
</span></span><span style="display:flex;"><span>    #下面的指令负责设置新线程的TLS，把m对象和工作线程关联起来
</span></span><span style="display:flex;"><span>    LEAQ  <span style="color:#c34e00">m_tls</span>(R8), DI  #取m.tls字段的地址
</span></span><span style="display:flex;"><span>    CALL  runtime·<span style="color:#c34e00">settls</span>(SB)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #In child, set up new stack
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">get_tls</span>(CX)
</span></span><span style="display:flex;"><span>    MOVQ  R8, <span style="color:#c34e00">g_m</span>(R9)  # g.m = m 
</span></span><span style="display:flex;"><span>    MOVQ  R9, <span style="color:#c34e00">g</span>(CX)      # tls.g = &amp;m.g0
</span></span><span style="display:flex;"><span>    CALL  runtime·<span style="color:#c34e00">stackcheck</span>(SB)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>nog:
</span></span><span style="display:flex;"><span>    # Call fn
</span></span><span style="display:flex;"><span>    CALL  R12  #这里调用mstart函数
</span></span><span style="display:flex;"><span>    ......
</span></span></code></pre></div><p>这段代码的第一条指令把CPU寄存器的栈顶指针设置为新线程的的栈顶，这条指令看起来是多余的，因为我们在clone系统调用时已经把栈信息告诉操作系统了，操作系统在把新线程调度起来运行时已经帮我们把CPU的rsp寄存器设置好了，这里应该没必要自己去设置。接下来的4条指令判断m和g是否为nil，如果是则直接去执行fn函数，对于我们这个流程来说，因为现在正在创建工作线程，所以m和g（其实是m.g0）都不为空，因而需要继续对m进行初始化。</p>
<p>对新创建出来的工作线程的初始化过程从上面代码片段的第6条指令开始，它首先通过系统调用获取到子线程的线程id，并赋值给m.procid，然后调用settls设置线程本地存储并通过把m.g0的地址放入线程本地存储之中，从而实现了m结构体对象与工作线程之间的关联，settls函数我们已经在第二章详细分析过，所以这里直接跳过。</p>
<p>新工作线程的初始化完成之后，便开始执行mstart函数，我们在第二章也见过该函数，主线程初始化完成之后也是调用的它。回忆一下，mstart函数首先会去设置m.g0的stackguard成员，然后调用mstart1()函数把当前工作线程的g0的调度信息保存在m.g0.sched成员之中，最后通过调用schedule函数进入调度循环。</p>
<p>总结</p>
<p>本章仅以读写channel为例分析了goroutine因操作被阻塞而发生的被动调度，其实发生被动调度的情况还比较多，比如因读写网络连接而阻塞、加锁被阻塞或select操作阻塞等等都会发生被动调度，读者可以自行阅读相关源代码。</p>
<p>本章还分析了睡眠中的工作线程是如何被唤起起来工作的以及新工作线程的创建和初始化流程。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A620/" rel="next" title="go语言调度器之主动调度(20)">
        <i class="fa fa-chevron-left"></i> go语言调度器之主动调度(20)
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/goroutine%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%8018/" rel="prev" title="goroutine被动调度之一（18）">
        goroutine被动调度之一（18） <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">514</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">32</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>