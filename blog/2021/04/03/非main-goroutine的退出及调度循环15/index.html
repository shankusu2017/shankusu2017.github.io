<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>非main goroutine的退出及调度循环（15） - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="非main goroutine的退出及调度循环（15）">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="非main goroutine的退出及调度循环（15） - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/%E9%9D%9Emain-goroutine%E7%9A%84%E9%80%80%E5%87%BA%E5%8F%8A%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF15/" itemprop="url">
        非main goroutine的退出及调度循环（15）
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4744 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/XttP9q7-PO7VXhskaBzGqA">源码游记</a> 2019-05-12</p>
<p>本文是《Go语言调度器源代码情景分析》系列的第15篇，也是第二章的第5小节。</p>
<p>上一节我们说过main goroutine退出时会直接执行exit系统调用退出整个进程，而非main goroutine退出时则会进入goexit函数完成最后的清理工作，本小节我们首先就来验证一下非main goroutine执行完成后是否真的会去执行goexit，然后再对非main goroutine的退出流程做个梳理。这一节我们需要重点理解以下内容：</p>
<p>非main goroutine是如何返回到goexit函数的；</p>
<p>mcall函数如何从用户goroutine切换到g0继续执行；</p>
<p>调度循环。</p>
<p>非main goroutine会返回到goexit吗</p>
<p>首先来看一段代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#00f">package</span> main
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00f">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#009c00">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> <span style="color:#c34e00">g2</span>(n <span style="color:#00f">int</span>, ch <span style="color:#00f">chan</span> <span style="color:#00f">int</span>) {
</span></span><span style="display:flex;"><span>    ch &lt;- n * n
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
</span></span><span style="display:flex;"><span>    ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">go</span> <span style="color:#c34e00">g2</span>(100, ch)
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#c34e00">Println</span>(&lt;-ch)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个程序比较简单，main goroutine启动后在main函数中创建了一个goroutine执行g2函数，我们称它为g2 goroutine，下面我们就用这个g2的退出来验证一下非main goroutine退出时是否真的会返回到goexit继续执行。</p>
<p>怎么验证呢？比较简单的办法就是用gdb来调试，在gdb中首先使用backtrace命令查看g2函数是被谁调用的，然后单步执行看它能否返回到goexit继续执行。下面是gdb调试过程：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>(gdb) b main.g2       // 在main.g2函数入口处下断点
</span></span><span style="display:flex;"><span>Breakpoint 1 at 0x4869c0: file /home/bobo/study/go/goexit.go, line 7.
</span></span><span style="display:flex;"><span>(gdb) r
</span></span><span style="display:flex;"><span>Starting program: /home/bobo/study/go/goexit 
</span></span><span style="display:flex;"><span>Thread 1 <span style="color:#009c00">&#34;goexit&#34;</span> hit Breakpoint 1 at /home/bobo/study/go/goexit.go:7
</span></span><span style="display:flex;"><span>(gdb) bt       //查看函数调用链，看起来g2真的是被runtime.goexit调用的
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#0 main.g2 (n=100, ch=0xc000052060) at /home/bobo/study/go/goexit.go:7</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#1 0x0000000000450ad1 in runtime.goexit () at /usr/local/go/src/runtime/asm_amd64.s:1337</span>
</span></span><span style="display:flex;"><span>(gdb) disass     //反汇编找ret的地址，这是为了在ret处下断点
</span></span><span style="display:flex;"><span>Dump of assembler code <span style="color:#00f">for</span> <span style="color:#00f">function</span> main.g2:
</span></span><span style="display:flex;"><span>=&gt; 0x00000000004869c0 &lt;+0&gt;:mov   %fs:0xfffffffffffffff8,%rcx
</span></span><span style="display:flex;"><span>  0x00000000004869c9 &lt;+9&gt;:cmp   0x10(%rcx),%rsp
</span></span><span style="display:flex;"><span>  0x00000000004869cd &lt;+13&gt;:jbe   0x486a0d &lt;main.g2+77&gt;
</span></span><span style="display:flex;"><span>  0x00000000004869cf &lt;+15&gt;:sub   $0x20,%rsp
</span></span><span style="display:flex;"><span>  0x00000000004869d3 &lt;+19&gt;:mov   %rbp,0x18(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869d8 &lt;+24&gt;:lea   0x18(%rsp),%rbp
</span></span><span style="display:flex;"><span>  0x00000000004869dd &lt;+29&gt;:mov   0x28(%rsp),%rax
</span></span><span style="display:flex;"><span>  0x00000000004869e2 &lt;+34&gt;:imul   %rax,%rax
</span></span><span style="display:flex;"><span>  0x00000000004869e6 &lt;+38&gt;:mov   %rax,0x10(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869eb &lt;+43&gt;:mov   0x30(%rsp),%rax
</span></span><span style="display:flex;"><span>  0x00000000004869f0 &lt;+48&gt;:mov   %rax,(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869f4 &lt;+52&gt;:lea   0x10(%rsp),%rax
</span></span><span style="display:flex;"><span>  0x00000000004869f9 &lt;+57&gt;:mov   %rax,0x8(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869fe &lt;+62&gt;:callq 0x4046a0 &lt;runtime.chansend1&gt;
</span></span><span style="display:flex;"><span>  0x0000000000486a03 &lt;+67&gt;:mov   0x18(%rsp),%rbp
</span></span><span style="display:flex;"><span>  0x0000000000486a08 &lt;+72&gt;:add   $0x20,%rsp
</span></span><span style="display:flex;"><span>  0x0000000000486a0c &lt;+76&gt;:retq   
</span></span><span style="display:flex;"><span>  0x0000000000486a0d &lt;+77&gt;:callq 0x44ece0 &lt;runtime.morestack_noctxt&gt;
</span></span><span style="display:flex;"><span>  0x0000000000486a12 &lt;+82&gt;:jmp   0x4869c0 &lt;main.g2&gt;
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span><span style="display:flex;"><span>(gdb) b *0x0000000000486a0c             //在retq指令位置下断点
</span></span><span style="display:flex;"><span>Breakpoint 2 at 0x486a0c: file /home/bobo/study/go/goexit.go, line 9.
</span></span><span style="display:flex;"><span>(gdb) c
</span></span><span style="display:flex;"><span>Continuing.
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>Thread 1 <span style="color:#009c00">&#34;goexit&#34;</span> hit Breakpoint 2 at /home/bobo/study/go/goexit.go:9
</span></span><span style="display:flex;"><span>(gdb) disass             //程序停在了ret指令处
</span></span><span style="display:flex;"><span>Dump of assembler code <span style="color:#00f">for</span> <span style="color:#00f">function</span> main.g2:
</span></span><span style="display:flex;"><span>  0x00000000004869c0 &lt;+0&gt;:mov   %fs:0xfffffffffffffff8,%rcx
</span></span><span style="display:flex;"><span>  0x00000000004869c9 &lt;+9&gt;:cmp   0x10(%rcx),%rsp
</span></span><span style="display:flex;"><span>  0x00000000004869cd &lt;+13&gt;:jbe   0x486a0d &lt;main.g2+77&gt;
</span></span><span style="display:flex;"><span>  0x00000000004869cf &lt;+15&gt;:sub   $0x20,%rsp
</span></span><span style="display:flex;"><span>  0x00000000004869d3 &lt;+19&gt;:mov   %rbp,0x18(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869d8 &lt;+24&gt;:lea   0x18(%rsp),%rbp
</span></span><span style="display:flex;"><span>  0x00000000004869dd &lt;+29&gt;:mov   0x28(%rsp),%rax
</span></span><span style="display:flex;"><span>  0x00000000004869e2 &lt;+34&gt;:imul   %rax,%rax
</span></span><span style="display:flex;"><span>  0x00000000004869e6 &lt;+38&gt;:mov   %rax,0x10(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869eb &lt;+43&gt;:mov   0x30(%rsp),%rax
</span></span><span style="display:flex;"><span>  0x00000000004869f0 &lt;+48&gt;:mov   %rax,(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869f4 &lt;+52&gt;:lea   0x10(%rsp),%rax
</span></span><span style="display:flex;"><span>  0x00000000004869f9 &lt;+57&gt;:mov   %rax,0x8(%rsp)
</span></span><span style="display:flex;"><span>  0x00000000004869fe &lt;+62&gt;:callq 0x4046a0 &lt;runtime.chansend1&gt;
</span></span><span style="display:flex;"><span>  0x0000000000486a03 &lt;+67&gt;:mov   0x18(%rsp),%rbp
</span></span><span style="display:flex;"><span>  0x0000000000486a08 &lt;+72&gt;:add   $0x20,%rsp
</span></span><span style="display:flex;"><span>=&gt; 0x0000000000486a0c &lt;+76&gt;:retq   
</span></span><span style="display:flex;"><span>  0x0000000000486a0d &lt;+77&gt;:callq 0x44ece0 &lt;runtime.morestack_noctxt&gt;
</span></span><span style="display:flex;"><span>  0x0000000000486a12 &lt;+82&gt;:jmp   0x4869c0 &lt;main.g2&gt;
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span><span style="display:flex;"><span>(gdb) si         //单步执行一条指令
</span></span><span style="display:flex;"><span>runtime.goexit () at /usr/local/go/src/runtime/asm_amd64.s:1338
</span></span><span style="display:flex;"><span>1338CALLruntime·goexit1(SB)// does not <span style="color:#00f">return</span>
</span></span><span style="display:flex;"><span>(gdb) disass           //可以看出来g2已经返回到了goexit函数中
</span></span><span style="display:flex;"><span>Dump of assembler code <span style="color:#00f">for</span> <span style="color:#00f">function</span> runtime.goexit:
</span></span><span style="display:flex;"><span>  0x0000000000450ad0 &lt;+0&gt;:nop
</span></span><span style="display:flex;"><span>=&gt; 0x0000000000450ad1 &lt;+1&gt;:callq 0x42faf0 &lt;runtime.goexit1&gt;
</span></span><span style="display:flex;"><span>  0x0000000000450ad6 &lt;+6&gt;:nop
</span></span></code></pre></div><p>使用gdb调试时，首先我们在g2函数入口处下了一个断点，程序暂停后通过查看函数调用栈发现g2函数确实是被goexit调用的，然后再一次使用断点让程序暂停在g2返回之前的最后一条指令retq处，最后单步执行这条指令，可以看到程序从g2函数返回到了goexit函数的第二条指令的位置，这个位置正是当初在创建goroutine时设置好的返回地址。可以看到，虽然g2函数并不是被goexit函数直接调用的，但它执行完成之后却返回到了goexit函数中！</p>
<p>至此，我们已经证实非main goroutine退出时确实会返回到goexit函数继续执行，下面我们就沿着这条线继续分析非main goroutine的退出流程。</p>
<p>非main goroutine的退出流程</p>
<p>首先来看goexit函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/asm_amd64.s : 1334
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// The top-most function running on a goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// returns to goexit+PCQuantum.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>TEXT runtime·<span style="color:#c34e00">goexit</span>(SB),NOSPLIT,$0-0
</span></span><span style="display:flex;"><span>    BYTE  $0x90  <span style="color:#f00;font-style:italic">// NOP
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    CALL  runtime·<span style="color:#c34e00">goexit1</span>(SB)  <span style="color:#f00;font-style:italic">// does not return
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">// traceback from goexit1 must hit code range of goexit
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    BYTE  $0x90  <span style="color:#f00;font-style:italic">// NOP
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>从前面的分析我们已经看到，非main goroutine返回时直接返回到了goexit的第二条指令：CALL runtime·<span style="color:#c34e00">goexit1</span>(SB)，该指令继续调用goexit1函数。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 2652
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// Finishes execution of the current goroutine.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">goexit1</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> raceenabled {  <span style="color:#f00;font-style:italic">//与竞态检查有关，不关注
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#c34e00">racegoend</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> trace.enabled { <span style="color:#f00;font-style:italic">//与backtrace有关，不关注
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>        <span style="color:#c34e00">traceGoEnd</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">mcall</span>(goexit0)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>goexit1函数通过调用mcall从当前运行的g2 goroutine切换到g0，然后在g0栈上调用和执行goexit0这个函数。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>runtime/asm_amd64.s : 270
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># <span style="color:#00f">func</span> <span style="color:#c34e00">mcall</span>(fn <span style="color:#00f">func</span>(*g))
</span></span><span style="display:flex;"><span># Switch to m-&gt;g0&#39;s stack, call <span style="color:#c34e00">fn</span>(g).
</span></span><span style="display:flex;"><span># Fn must never <span style="color:#00f">return</span>. It should <span style="color:#c34e00">gogo</span>(&amp;g-&gt;sched)
</span></span><span style="display:flex;"><span># to keep running g.
</span></span><span style="display:flex;"><span># mcall的参数是一个指向funcval对象的指针
</span></span><span style="display:flex;"><span>TEXT runtime·<span style="color:#c34e00">mcall</span>(SB), NOSPLIT, $0-8
</span></span><span style="display:flex;"><span>    #取出参数的值放入DI寄存器，它是funcval对象的指针，此场景中fn.fn是goexit0的地址
</span></span><span style="display:flex;"><span>    MOVQ  fn+0(FP), DI
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">get_tls</span>(CX)
</span></span><span style="display:flex;"><span>    MOVQ  <span style="color:#c34e00">g</span>(CX), AX # AX = g，本场景g 是 g2
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #mcall返回地址放入BX
</span></span><span style="display:flex;"><span>    MOVQ  0(SP), BX# caller&#39;s PC
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #保存g2的调度信息，因为我们要从当前正在运行的g2切换到g0
</span></span><span style="display:flex;"><span>    MOVQ  BX, (g_sched+gobuf_pc)(AX)   #g.sched.pc = BX，保存g2的rip
</span></span><span style="display:flex;"><span>    LEAQ  fn+0(FP), BX # caller&#39;s SP  
</span></span><span style="display:flex;"><span>    MOVQ  BX, (g_sched+gobuf_sp)(AX)  #g.sched.sp = BX，保存g2的rsp
</span></span><span style="display:flex;"><span>    MOVQ  AX, (g_sched+gobuf_g)(AX)   #g.sched.g = g
</span></span><span style="display:flex;"><span>    MOVQ  BP, (g_sched+gobuf_bp)(AX)  #g.sched.bp = BP，保存g2的rbp
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    # <span style="color:#00f">switch</span> to m-&gt;g0 &amp; its stack, call fn
</span></span><span style="display:flex;"><span>    #下面三条指令主要目的是找到g0的指针
</span></span><span style="display:flex;"><span>    MOVQ  <span style="color:#c34e00">g</span>(CX), BX         #BX = g
</span></span><span style="display:flex;"><span>    MOVQ  <span style="color:#c34e00">g_m</span>(BX), BX    #BX = g.m
</span></span><span style="display:flex;"><span>    MOVQ  <span style="color:#c34e00">m_g0</span>(BX), SI   #SI = g.m.g0
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #此刻，SI = g0， AX = g，所以这里在判断g 是否是 g0，如果g == g0则一定是哪里代码写错了
</span></span><span style="display:flex;"><span>    CMPQ  SI, AX# <span style="color:#00f">if</span> g == m-&gt;g0 call badmcall
</span></span><span style="display:flex;"><span>    JNE  3(PC)
</span></span><span style="display:flex;"><span>    MOVQ  $runtime·<span style="color:#c34e00">badmcall</span>(SB), AX
</span></span><span style="display:flex;"><span>    JMP  AX
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #把g0的地址设置到线程本地存储之中
</span></span><span style="display:flex;"><span>    MOVQ  SI, <span style="color:#c34e00">g</span>(CX)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #恢复g0的栈顶指针到CPU的rsp积存，这一条指令完成了栈的切换，从g的栈切换到了g0的栈
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">MOVQ</span>  (g_sched+gobuf_sp)(SI), SP# rsp = g0-&gt;sched.sp
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    #AX = g
</span></span><span style="display:flex;"><span>    PUSHQ  AX   #fn的参数g入栈 
</span></span><span style="display:flex;"><span>    MOVQ  DI, DX   #DI是结构体funcval实例对象的指针，它的第一个成员才是goexit0的地址
</span></span><span style="display:flex;"><span>    MOVQ  0(DI), DI   #读取第一个成员到DI寄存器
</span></span><span style="display:flex;"><span>    CALL  DI   #调用goexit0(g)
</span></span><span style="display:flex;"><span>    POPQ  AX
</span></span><span style="display:flex;"><span>    MOVQ  $runtime·<span style="color:#c34e00">badmcall2</span>(SB), AX
</span></span><span style="display:flex;"><span>    JMP  AX
</span></span><span style="display:flex;"><span>    RET
</span></span><span style="display:flex;"><span>mcall的参数是一个函数，在Go语言的实现中，函数变量并不是一个直接指向函数代码的指针，而是一个指向funcval结构体对象的指针，funcval结构体对象的第一个成员fn才是真正指向函数代码的指针。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">type</span> funcval <span style="color:#00f">struct</span> {
</span></span><span style="display:flex;"><span>    fn <span style="color:#00f">uintptr</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// variable-size, fn-specific data here
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>}
</span></span></code></pre></div><p>也就是说，在我们这个场景中mcall函数的fn参数的fn成员中存放的才是goexit0函数的第一条指令的地址。</p>
<p>mcall函数主要有两个功能：</p>
<p>首先从当前运行的g(我们这个场景是g2)切换到g0，这一步包括保存当前g的调度信息，把g0设置到tls中，修改CPU的rsp寄存器使其指向g0的栈；</p>
<p>以当前运行的g(我们这个场景是g2)为参数调用fn函数(此处为goexit0)。</p>
<p>从mcall的功能我们可以看出，mcall做的事情跟gogo函数完全相反，gogo函数实现了从g0切换到某个goroutine去运行，而mcall实现了从某个goroutine切换到g0来运行，因此，mcall和gogo的代码非常相似，然而mcall和gogo在做切换时有个重要的区别：gogo函数在从g0切换到其它goroutine时首先切换了栈，然后通过跳转指令从runtime代码切换到了用户goroutine的代码，而mcall函数在从其它goroutine切换回g0时只切换了栈，并未使用跳转指令跳转到runtime代码去执行。为什么会有这个差别呢？原因在于在从g0切换到其它goroutine之前执行的是runtime的代码而且使用的是g0栈，所以切换时需要首先切换栈然后再从runtime代码跳转某个goroutine的代码去执行（切换栈和跳转指令不能颠倒，因为跳转之后执行的就是用户的goroutine代码了，没有机会切换栈了），然而从某个goroutine切换回g0时，goroutine使用的是call指令来调用mcall函数，mcall函数本身就是runtime的代码，所以call指令其实已经完成了从goroutine代码到runtime代码的跳转，因此mcall函数自身的代码就不需要再跳转了，只需要把栈切换到g0栈即可。</p>
<p>因为mcall跟gogo非常相似，前面我们对gogo的每一条指令已经做过详细的分析，所以这里就不再详细解释mcall的每一条指令了，但笔者在上面所展示的mcall代码中做了一些注释（注释中的g表示当前正在运行的goroutine，我们这个场景g就是g2），这里大家可以结合gogo的代码以及mcall的代码和注释来加深对g0与其它goroutine之间的切换的理解。</p>
<p>从g2栈切换到g0栈之后，下面开始在g0栈执行goexit0函数，该函数完成最后的清理工作：</p>
<p>把g的状态从_Grunning变更为_Gdead；</p>
<p>然后把g的一些字段清空成0值；</p>
<p>调用dropg函数解除g和m之间的关系，其实就是设置g-&gt;m = nil, m-&gt;currg = nil；</p>
<p>把g放入p的freeg队列缓存起来供下次创建g时快速获取而不用从内存分配。freeg就是g的一个对象池；</p>
<p>调用schedule函数再次进行调度；</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>runtime/proc.<span style="color:#00f">go</span> : 2662
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">// goexit continuation on g0.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span><span style="color:#00f">func</span> <span style="color:#c34e00">goexit0</span>(gp *g) {
</span></span><span style="display:flex;"><span>    _g_ := <span style="color:#c34e00">getg</span>()  <span style="color:#f00;font-style:italic">//g0
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">casgstatus</span>(gp, _Grunning, _Gdead) <span style="color:#f00;font-style:italic">//g马上退出，所以设置其状态为_Gdead
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#00f">if</span> <span style="color:#c34e00">isSystemGoroutine</span>(gp, <span style="color:#00f">false</span>) {
</span></span><span style="display:flex;"><span>        atomic.<span style="color:#c34e00">Xadd</span>(&amp;sched.ngsys, -1)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>   <span style="color:#f00;font-style:italic">//清空g保存的一些信息
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    gp.m = <span style="color:#00f">nil</span>
</span></span><span style="display:flex;"><span>    locked := gp.lockedm != 0
</span></span><span style="display:flex;"><span>    gp.lockedm = 0
</span></span><span style="display:flex;"><span>    _g_.m.lockedg = 0
</span></span><span style="display:flex;"><span>    gp.paniconfault = <span style="color:#00f">false</span>
</span></span><span style="display:flex;"><span>    gp._defer = <span style="color:#00f">nil</span> <span style="color:#f00;font-style:italic">// should be true already but just in case.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    gp._panic = <span style="color:#00f">nil</span> <span style="color:#f00;font-style:italic">// non-nil for Goexit during panic. points at stack-allocated data.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    gp.writebuf = <span style="color:#00f">nil</span>
</span></span><span style="display:flex;"><span>    gp.waitreason = 0
</span></span><span style="display:flex;"><span>    gp.param = <span style="color:#00f">nil</span>
</span></span><span style="display:flex;"><span>    gp.labels = <span style="color:#00f">nil</span>
</span></span><span style="display:flex;"><span>    gp.timer = <span style="color:#00f">nil</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">// Note that gp&#39;s stack scan is now &#34;valid&#34; because it has no
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#f00;font-style:italic">// stack.
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    gp.gcscanvalid = <span style="color:#00f">true</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">//g-&gt;m = nil, m-&gt;currg = nil 解绑g和m之关系
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">dropg</span>()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#c34e00">gfput</span>(_g_.m.p.<span style="color:#c34e00">ptr</span>(), gp) <span style="color:#f00;font-style:italic">//g放入p的freeg队列，方便下次重用，免得再去申请内存，提高效率
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span> 
</span></span><span style="display:flex;"><span>    ......
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">//下面再次调用schedule
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>    <span style="color:#c34e00">schedule</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>到此为止g2的生命周期就结束了，工作线程再次调用了schedule函数进入新一轮的调度循环。</p>
<p>调度循环</p>
<p>我们说过，任何goroutine被调度起来运行都是通过schedule()-&gt;execute()-&gt;gogo()这个函数调用链完成的，而且这个调用链中的函数一直没有返回。以我们刚刚讨论过的g2 goroutine为例，从g2开始被调度起来运行到退出是沿着下面这条路径进行的</p>
<p>schedule()-&gt;execute()-&gt;gogo()-&gt;g2()-&gt;goexit()-&gt;goexit1()-&gt;mcall()-&gt;goexit0()-&gt;schedule()
可以看出，一轮调度是从调用schedule函数开始的，然后经过一系列代码的执行到最后又再次通过调用schedule函数来进行新一轮的调度，从一轮调度到新一轮调度的这一过程我们称之为一个调度循环，这里说的调度循环是指某一个工作线程的调度循环，而同一个Go程序中可能存在多个工作线程，每个工作线程都有自己的调度循环，也就是说每个工作线程都在进行着自己的调度循环。</p>
<p>从前面的代码分析可以得知，上面调度循环中的每一个函数调用都没有返回，虽然g2()-&gt;goexit()-&gt;goexit1()-&gt;mcall()这几个函数是在g2的栈空间执行的，但剩下的函数都是在g0的栈空间执行的，那么问题就来了，在一个复杂的程序中，调度可能会进行无数次循环，也就是说会进行无数次没有返回的函数调用，大家都知道，每调用一次函数都会消耗一定的栈空间，而如果一直这样无返回的调用下去无论g0有多少栈空间终究是会耗尽的，那么这里是不是有问题？其实没有问题，关键点就在于，每次执行mcall切换到g0栈时都是切换到g0.sched.sp所指的固定位置，这之所以行得通，正是因为从schedule函数开始之后的一系列函数永远都不会返回，所以重用这些函数上一轮调度时所使用过的栈内存是没有问题的。</p>
<p>每个工作线程的执行流程和调度循环都一样，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/61038477913f3d941762171b0ff1b92a.png" alt=""></p>
<p>总结</p>
<p>我们用上图来总结一下工作线程的执行流程：</p>
<p>初始化，调用mstart函数；</p>
<p>调用mstart1函数，在该函数中调用save函数设置g0.sched.sp和g0.sched.pc等调度信息，其中g0.sched.sp指向mstart函数栈帧的栈顶；</p>
<p>依次调用schedule-&gt;execute-&gt;gogo函数执行调度；</p>
<p>运行用户的goroutine代码；</p>
<p>用户goroutine代码执行过程中调用runtime中的某些函数，然后这些函数调用mcall切换到g0.sched.sp所指的栈并最终再次调用schedule函数进入新一轮调度，之后工作线程一直循环执行着3～5这一调度循环直到进程退出为止。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/%E7%AC%AC%E4%B8%89%E7%AB%A0-goroutine%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A516/" rel="next" title="第三章 goroutine调度策略（16）">
        <i class="fa fa-chevron-left"></i> 第三章 goroutine调度策略（16）
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80%E8%B0%83%E5%BA%A6%E5%99%A8%E4%B9%8B%E8%B0%83%E5%BA%A6main-goroutine14/" rel="prev" title="go语言调度器之调度main goroutine（14)">
        go语言调度器之调度main goroutine（14) <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">512</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">32</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>