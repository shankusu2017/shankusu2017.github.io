<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>go深入理解defer（下）defer实现机制 - 愿星光伴你左右</title>
    <meta name="keywords" content="愿星光伴你左右,openresty,nginx,Lua,lua,Golang,go">
    
    <meta property="og:title" content="go深入理解defer（下）defer实现机制">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="go深入理解defer（下）defer实现机制 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />thinking
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />links
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />about
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Bdefer%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" itemprop="url">
        go深入理解defer（下）defer实现机制
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-03">
    2021-04-03
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/" itemprop="url" rel="index">
        <span itemprop="name">[go]</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6131 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>原创 爱写程序的阿波张 <a href="https://mp.weixin.qq.com/s/iEtMbRXW4yYyCG0TTW5y9g">源码游记</a> 2019-06-17</p>
<p>上一篇文章我们主要从使用的角度介绍了 defer 的基础知识，本文我们来分析一下 defer 的实现机制。</p>
<p>还是从一个例子程序开始。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
 
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;sum:&#34;</span> , <span style="color:#a6e22e">c</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">sum</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
 
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a: %d, b: %d\n&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
}
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>
    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>从前一篇文章我们得知，编译器会把 defer 语句翻译成对 deferproc 函数的调用，同时，编译器也会在使用了 defer 语句的 go 函数的末尾插入对 deferreturn 函数的调用，下面我们来看一下这两个函数的实现代码。</p>
<p>deferproc 函数</p>
<p>先来看看 deferproc 的函数原型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">panic</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">89</span>

<span style="color:#75715e">// Create a new deferred function fn with siz bytes of arguments.
</span><span style="color:#75715e">// The compiler turns a defer statement into a call to this.
</span><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">deferproc</span>(<span style="color:#a6e22e">siz</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>)
<span style="color:#a6e22e">deferproc</span> <span style="color:#a6e22e">函数的第一个参数</span> <span style="color:#a6e22e">siz</span> <span style="color:#a6e22e">是</span> <span style="color:#a6e22e">defered</span> <span style="color:#a6e22e">函数</span><span style="color:#960050;background-color:#1e0010">（</span><span style="color:#a6e22e">比如本例中的</span> <span style="color:#a6e22e">sum</span> <span style="color:#a6e22e">函数</span><span style="color:#960050;background-color:#1e0010">）</span><span style="color:#a6e22e">的参数以字节为单位的大小</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">第二个参数</span> <span style="color:#a6e22e">funcval</span> <span style="color:#a6e22e">是一个变长结构体</span><span style="color:#960050;background-color:#1e0010">：</span>

<span style="color:#a6e22e">proc</span><span style="color:#f92672">/</span><span style="color:#a6e22e">runtime2</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">139</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">funcval</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">uintptr</span>
    <span style="color:#75715e">// variable-size, fn-specific data here
</span><span style="color:#75715e"></span>}
</code></pre></div><p>于是，在64位系统中本文例子中的 defer sum(a, b) 大致等价于</p>
<p>deferproc(16, &amp;funcval{sum})
因为 sum 函数有 2 个 int 型的参数共 16 字节，所以在调用 deferproc 函数时第一个参数为16，第二个参数 funcval 结构体对象的 fn 成员为 sum 函数的地址。我们可以先想一下为什么需要把 sum 函数的参数大小传递给 deferproc() 函数？另外为什么没看到 sum 函数需要的两个参数呢？</p>
<p>为了搞清楚编译器到底会怎么翻译 defer 关键字，我们需要看一下 f() 函数的汇编代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488de0</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   %fs:<span style="color:#ae81ff">0xfffffffffffffff8</span>,%rcx
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488de9</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">9</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">cmp</span>   <span style="color:#ae81ff">0x10</span>(%rcx),%rsp
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488ded</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">13</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">jbe</span>   <span style="color:#ae81ff">0x488f10</span> &lt;<span style="color:#66d9ef">main.f</span>+<span style="color:#ae81ff">304</span>&gt;
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488df3</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">19</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">sub</span>   <span style="color:#66d9ef">$0x80</span>,%rsp
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488dfa</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">26</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   %rbp,<span style="color:#ae81ff">0x78</span>(%rsp)
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488dff</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">31</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">lea</span>   <span style="color:#ae81ff">0x78</span>(%rsp),%rbp   <span style="color:#75715e"># 这一条指令以及前面几条指令是函数序言，跟defer无关
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e04</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">36</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">movl</span>   <span style="color:#66d9ef">$0x10</span>,(%rsp)     <span style="color:#75715e"># deferproc的第一个参数siz
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e0b</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">43</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">lea</span>   <span style="color:#ae81ff">0x39076</span>(%rip),%rax      
<span style="color:#ae81ff">0x0000000000488e12</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">50</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   %rax,<span style="color:#ae81ff">0x8</span>(%rsp)  <span style="color:#75715e"># 第二个参数funcval结构体对象的地址
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e17</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">55</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   <span style="color:#ae81ff">0x88</span>(%rsp),%rax
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488e1f</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">63</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   %rax,<span style="color:#ae81ff">0x10</span>(%rsp)  <span style="color:#75715e"># f()函数的第一个参数a，a = 1
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e24</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">68</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   <span style="color:#ae81ff">0x90</span>(%rsp),%rcx
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488e2c</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">76</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   %rcx,<span style="color:#ae81ff">0x18</span>(%rsp)  <span style="color:#75715e"># f()函数的第二个参数b, b = 2
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e31</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">81</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">callq</span>   <span style="color:#ae81ff">0x426c00</span> &lt;<span style="color:#66d9ef">runtime.deferproc</span>&gt;  <span style="color:#75715e"># 调用deferproc函数
</span><span style="color:#75715e"># 注意deferproc函数本来是没有返回值的，下面的test指令在检查deferproc的隐性返回值
</span><span style="color:#75715e"># 这条指令是编译器专门针对deferproc函数而插入的，对其它go函数调用时编译器不会插入该指令
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e36</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">86</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">test</span>   %eax,%eax  
<span style="color:#75715e"># 如果deferproc返回不为0则直接跳转到函数结尾去执行deferreturn函数
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488e38</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">88</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">jne</span>   <span style="color:#ae81ff">0x488efd</span> &lt;<span style="color:#66d9ef">main.f</span>+<span style="color:#ae81ff">285</span>&gt; 
<span style="color:#ae81ff">0x0000000000488e3e</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">94</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   <span style="color:#ae81ff">0x88</span>(%rsp),%rax
<span style="color:#a6e22e">......</span>
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488ee5</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">261</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">callq</span>  <span style="color:#ae81ff">0x480b20</span> &lt;<span style="color:#66d9ef">fmt.Fprintf</span>&gt;  <span style="color:#75715e">#输出a b的值
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488eea</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">266</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">nop</span>
<span style="color:#75715e">#调用deferreturn函数完成对sum函数的延迟调用
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488eeb</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">267</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">callq</span>   <span style="color:#ae81ff">0x427490</span> &lt;<span style="color:#66d9ef">runtime.deferreturn</span>&gt;  
<span style="color:#ae81ff">0x0000000000488ef0</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">272</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   <span style="color:#ae81ff">0x78</span>(%rsp),%rbp
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488ef5</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">277</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">add</span>   <span style="color:#66d9ef">$0x80</span>,%rsp
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488efc</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">284</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">retq</span> 
<span style="color:#ae81ff">0x0000000000488efd</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">285</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">nop</span>
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488efe</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">286</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">callq</span>   <span style="color:#ae81ff">0x427490</span> &lt;<span style="color:#66d9ef">runtime.deferreturn</span>&gt;
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488f03</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">291</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">mov</span>   <span style="color:#ae81ff">0x78</span>(%rsp),%rbp
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488f08</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">296</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">add</span>   <span style="color:#66d9ef">$0x80</span>,%rsp
<span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000000000488f0f</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">303</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">retq</span>   
<span style="color:#ae81ff">0x0000000000488f10</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">304</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">callq</span>  <span style="color:#ae81ff">0x44f300</span> &lt;<span style="color:#66d9ef">runtime.morestack_noctxt</span>&gt; <span style="color:#75715e">#扩栈处理
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0x0000000000488f15</span> <span style="color:#960050;background-color:#1e0010">&lt;+</span><span style="color:#ae81ff">309</span><span style="color:#960050;background-color:#1e0010">&gt;</span>: <span style="color:#66d9ef">jmpq</span>   <span style="color:#ae81ff">0x488de0</span> &lt;<span style="color:#66d9ef">main.f</span>&gt;
</code></pre></div><p>从 f() 函数的汇编代码可以看出，在调用 runtime.deferproc 时，栈上除了保存了 deferproc 函数需要的两个参数之外，还保存了 defered 函数所需要的参数（我们这个例子中 defered 函数是 sum 函数，它的2个参数 a 和 b 也都保存在了栈上，它们紧邻 deferproc 函数的第二个参数），也就是说，在执行 defer 语句时，defer 后面的函数的参数已经确定了。</p>
<p>另外需要注意的是，从 deferproc 函数的原型可以知道它并没有返回值，但上面的汇编代码在调用了 deferproc 函数之后却检查了 rax 寄存器的值是否为0(0x0000000000488e36 &lt;+86&gt;: test   %eax,%eax)，也就是说 deferproc 函数实际上会通过 rax 寄存器返回一个隐性的返回值！</p>
<p>接着我们继续看 deferproc 函数的实现:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">proc</span><span style="color:#f92672">/</span><span style="color:#a6e22e">panic</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">89</span>

<span style="color:#75715e">// Create a new deferred function fn with siz bytes of arguments.
</span><span style="color:#75715e">// The compiler turns a defer statement into a call to this.
</span><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">deferproc</span>(<span style="color:#a6e22e">siz</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>) { <span style="color:#75715e">// arguments of fn follow fn
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">curg</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">getg</span>() {  <span style="color:#75715e">//用户goroutine才能使用defer
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// go code on the system stack can&#39;t defer
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;defer on system stack&#34;</span>)
    }
 
    <span style="color:#75715e">// the arguments of fn are in a perilous state. The stack map
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// for deferproc does not describe them. So we can&#39;t let garbage
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// collection or stack copying trigger until we&#39;ve copied them out
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// to somewhere safe. The memmove below does that.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Until the copy completes, we can only call nosplit routines.
</span><span style="color:#75715e"></span> 
    <span style="color:#75715e">// 对getcallersp()和getcallerpc() 函数的分析可以参考本公众号的其它文章
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getcallersp</span>() <span style="color:#75715e">//sp = 调用deferproc之前的rsp寄存器的值
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// argp指向defer函数的第一个参数，本例为sum函数的参数a
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">argp</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fn</span>)) <span style="color:#f92672">+</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">fn</span>)
    <span style="color:#a6e22e">callerpc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getcallerpc</span>() <span style="color:#75715e">// deferproc函数的返回地址
</span><span style="color:#75715e"></span> 
    <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newdefer</span>(<span style="color:#a6e22e">siz</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;deferproc: d.panic != nil after newdefer&#34;</span>)
    }
    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">fn</span> <span style="color:#75715e">//需要延迟执行的函数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#a6e22e">callerpc</span>  <span style="color:#75715e">//记录deferproc函数的返回地址，主要用于panic/recover
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span> <span style="color:#75715e">//调用deferproc之前rsp寄存器的值
</span><span style="color:#75715e"></span> 
    <span style="color:#75715e">//把defer函数需要用到的参数拷贝到d结构体后面，下面的deferrArgs返回的是一个地址
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//deferArgs(d) = d + sizeof(d) ，newdefer返回的内存空间 &gt;= deferArgs(d)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">siz</span> {
    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#75715e">// Do nothing.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>: <span style="color:#75715e">//如果defered函数的参数只有指针大小则直接通过赋值来拷贝参数
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">deferArgs</span>(<span style="color:#a6e22e">d</span>)) = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">argp</span>))
    <span style="color:#66d9ef">default</span>: <span style="color:#75715e">//通过memmove拷贝defered函数的参数
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">deferArgs</span>(<span style="color:#a6e22e">d</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">argp</span>), uintptr(<span style="color:#a6e22e">siz</span>))
  }
 
    <span style="color:#75715e">// deferproc returns 0 normally.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// a deferred func that stops a panic
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// makes the deferproc return 1.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// the code the compiler generates always
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// checks the return value and jumps to the
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// end of the function if deferproc returns != 0.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">return0</span>()  <span style="color:#75715e">//通过汇编指令设置rax = 0
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// No code can go here - the C return register has
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// been set and must not be clobbered.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>deferproc 函数流程很清晰，它首先通过 newdefer 函数分配一个 _defer 结构体对象，然后把需要延迟执行的函数以及该函数需要用到的参数、调用 deferproc 函数时的 rsp 寄存器的值以及 deferproc 函数的返回地址保存在  _defer 结构体对象之中，最后通过 return0() 设置 rax 寄存器的值为 0 隐性的给调用者返回一个 0 值。</p>
<p>不知道大家是否会觉得很奇怪，deferproc 明明只会隐性的返回 0 值，但为什么上面的 f() 函数在调用了 deferproc 之后还用了一条指令来判断返回值是否是 0 呢，这不多此一举吗？事实上这里主要与 panic 和 recover 的实现机制有关，当程序发生 panic 之后，程序会“再次从 deferproc 函数返回”，这种情况下返回值就不是 0 了，因为 panic/recover 机制这一块比较复杂，所以我们以后会专门写一篇文章来分析，现在略过。</p>
<p>回到主题，_defer 结构体的定义为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">runtime2</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">727</span>

<span style="color:#75715e">// A _defer holds an entry on the list of deferred calls.
</span><span style="color:#75715e">// If you add a field here, add code to clear it in freedefer.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_defer</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">siz</span>           <span style="color:#66d9ef">int32</span>  <span style="color:#75715e">//defer函数的参数大小
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">started</span>    <span style="color:#66d9ef">bool</span>
    <span style="color:#a6e22e">sp</span>           <span style="color:#66d9ef">uintptr</span>  <span style="color:#75715e">// sp at time of defer
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pc</span>           <span style="color:#66d9ef">uintptr</span>  <span style="color:#75715e">// defer语句下一条语句的地址
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fn</span>           <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>  <span style="color:#75715e">//需要被延迟执行的函数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_panic</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">_panic</span>  <span style="color:#75715e">// panic that is running defer
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">link</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span>  <span style="color:#75715e">//同一个goroutine所有被延迟执行的函数通过该成员链在一起形成一个链表
</span><span style="color:#75715e"></span>}
</code></pre></div><p>该结构中的 sp、pc以及 _panic 成员主要与 panic/recover 有关，这里我们无需过多关注（ sp 成员还会被用来判断 _defer 结构体对象中保存的延迟执行函数是否应该在当前函数结束时执行，后面我们会分析到）。</p>
<p>对于本文的例子，初始化完成后的 _defer 结构体对象各成员的值大致如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span> = <span style="color:#ae81ff">16</span>
<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">started</span> = <span style="color:#66d9ef">false</span>
<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">调用deferproc函数之前的rsp寄存器的值</span>
<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#ae81ff">0x0000000000488e36</span>
<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">funcval</span>{<span style="color:#a6e22e">sum</span>}
<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_panic</span> = <span style="color:#66d9ef">nil</span>
<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#66d9ef">nil</span>
</code></pre></div><p>sum函数的参数a
sum函数的参数b
注意，defered 函数的参数并未在 _defer 结构体中定义，它所需要的参数在内存中紧跟在 _defer 结构体对象的后面。</p>
<p>我们接着看 newdefer 是如何分配 _defer 结构体对象的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">proc</span><span style="color:#f92672">/</span><span style="color:#a6e22e">panic</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">205</span>

<span style="color:#75715e">// Allocate a Defer, usually using per-P pool.
</span><span style="color:#75715e">// Each defer must be released with freedefer.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// This must not grow the stack because there may be a frame without
</span><span style="color:#75715e">// stack map information when this is called.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newdefer</span>(<span style="color:#a6e22e">siz</span> <span style="color:#66d9ef">int32</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span> {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span>
    <span style="color:#a6e22e">sc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">deferclass</span>(uintptr(<span style="color:#a6e22e">siz</span>))
    <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()  <span style="color:#75715e">//获取当前goroutine的g结构体对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sc</span> &lt; uintptr(len(<span style="color:#a6e22e">p</span>{}.<span style="color:#a6e22e">deferpool</span>)) {
        <span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()  <span style="color:#75715e">//与当前工作线程绑定的p
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#75715e">// Take the slow path on the system stack so
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// we don&#39;t grow newdefer&#39;s stack.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() { <span style="color:#75715e">//切换到系统栈
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">deferlock</span>)
                <span style="color:#75715e">//从全局_defer对象池拿一些到p的本地_defer对象池
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>]) &lt; cap(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
                    <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>]
                    <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>] = <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span>
                    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span> = <span style="color:#66d9ef">nil</span>
                    <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>] = append(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>], <span style="color:#a6e22e">d</span>)
                }
                <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">deferlock</span>)
            })
        }
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>]); <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
            <span style="color:#a6e22e">d</span> = <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>][<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>][<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">nil</span>
            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>] = <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">sc</span>][:<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        }
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">//如果p的缓存中没有可用的_defer结构体对象则从堆上分配
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Allocate new defer+args.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//因为roundupsize以及mallocgc函数都不会处理扩栈，所以需要切换到系统栈执行
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() { 
            <span style="color:#a6e22e">total</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">roundupsize</span>(<span style="color:#a6e22e">totaldefersize</span>(uintptr(<span style="color:#a6e22e">siz</span>)))
            <span style="color:#a6e22e">d</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span>)(<span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">total</span>, <span style="color:#a6e22e">deferType</span>, <span style="color:#66d9ef">true</span>))
        })
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">debugCachedWork</span> {
            <span style="color:#75715e">// Duplicate the tail below so if there&#39;s a
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// crash in checkPut we can tell if d was just
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// allocated or came from the pool.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span> = <span style="color:#a6e22e">siz</span>
            <span style="color:#75715e">//把新分配出来的d放入当前goroutine的_defer链表头
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span> = <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span>
            <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#a6e22e">d</span>
            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">d</span>
        }
    }
    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span> = <span style="color:#a6e22e">siz</span>
    <span style="color:#75715e">//把新分配出来的d放入当前goroutine的_defer链表头
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span> = <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#a6e22e">d</span>  <span style="color:#75715e">//把新分配出来的d放入当前goroutine的_defer链表头
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">d</span>
}
</code></pre></div><p>newdefer 函数比较长，大家可以参考上面的代码和注释加以理解。newdefer 函数首先会尝试从与当前工作线程绑定的 p 的 _defer 对象池和全局对象池中获取一个满足大小要求(sizeof(_defer) + siz向上取整至16的倍数)的 _defer 结构体对象，如果没有能够满足要求的空闲 _defer 对象则从堆上分一个，最后把分配到的对象链入当前 goroutine 的 _defer 链表的表头。</p>
<p>到此 defer 语句中被延迟执行的函数已经挂入当前 goroutine 的 _defer 链表，我们来简单的总结一下这个过程：</p>
<p>编译器会把 go 代码中 defer 语句翻译成对 deferproc 函数的调用；</p>
<p>deferproc 函数通过 newdefer 函数分配一个 _defer 结构体对象并放入当前 goroutine 的 _defer 链表的表头；</p>
<p>在 _defer 结构体对象中保存被延迟执行的函数 fn 的地址以及 fn 所需的参数；</p>
<p>返回到调用 deferproc 的函数继续执行后面的代码。</p>
<p>deferreturn 函数</p>
<p>分析完 deferproc，我们接着分析 deferreturn：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">panic</span>.<span style="color:#66d9ef">go</span> : <span style="color:#ae81ff">331</span>

<span style="color:#75715e">// Run a deferred function if there is one.
</span><span style="color:#75715e">// The compiler inserts a call to this at the end of any
</span><span style="color:#75715e">// function which calls defer.
</span><span style="color:#75715e">// If there is a deferred function, this will call runtime·jmpdefer,
</span><span style="color:#75715e">// which will jump to the deferred function such that it appears
</span><span style="color:#75715e">// to have been called by the caller of deferreturn at the point
</span><span style="color:#75715e">// just before deferreturn was called. The effect is that deferreturn
</span><span style="color:#75715e">// is called again and again until there are no more deferred functions.
</span><span style="color:#75715e">// Cannot split the stack because we reuse the caller&#39;s frame to
</span><span style="color:#75715e">// call the deferred function.
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">// The single argument isn&#39;t actually used - it just has its address
</span><span style="color:#75715e">// taken so it can be matched against pending defers.
</span><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">deferreturn</span>(<span style="color:#a6e22e">arg0</span> <span style="color:#66d9ef">uintptr</span>) {
    <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()  <span style="color:#75715e">//获取当前goroutine对应的g结构体对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> <span style="color:#75715e">//defer函数链表
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { 
        <span style="color:#75715e">//没有需要执行的函数直接返回，deferreturn和deferproc是配对使用的
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//为什么这里d可能为nil？因为deferreturn其实是一个递归调用，这个是递归结束条件之一
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getcallersp</span>()  <span style="color:#75715e">//获取调用deferreturn时的栈顶位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">sp</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">sp</span> {  <span style="color:#75715e">//递归结束条件之二
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//如果保存在_defer对象中的sp值与调用deferretuen时的栈顶位置不一样，直接返回
</span><span style="color:#75715e"></span>       <span style="color:#75715e">//因为sp不一样表示d代表的是在其他函数中通过defer注册的延迟调用函数，比如:
</span><span style="color:#75715e"></span>       <span style="color:#75715e">//a()-&gt;b()-&gt;c()它们都通过defer注册了延迟函数，那么当c()执行完时只能执行在c中注册的函数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>
    }
 
    <span style="color:#75715e">// Moving arguments around.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Everything called after this point must be recursively
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// nosplit because the garbage collector won&#39;t know the form
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// of the arguments until the jmpdefer can flip the PC over to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fn.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//把保存在_defer对象中的fn函数需要用到的参数拷贝到栈上，准备调用fn
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//注意fn的参数放在了调用调用者的栈帧中，而不是此函数的栈帧中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#75715e">// Do nothing.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>:
            <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arg0</span>)) = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">deferArgs</span>(<span style="color:#a6e22e">d</span>))
        <span style="color:#66d9ef">default</span>:
            <span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arg0</span>), <span style="color:#a6e22e">deferArgs</span>(<span style="color:#a6e22e">d</span>), uintptr(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">siz</span>))
    }
    <span style="color:#a6e22e">fn</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span>
    <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">fn</span> = <span style="color:#66d9ef">nil</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">link</span> <span style="color:#75715e">//使gp._defer指向下一个_defer结构体对象
</span><span style="color:#75715e"></span>   <span style="color:#75715e">//因为需要调用的函数d.fn已经保存在了fn变量中，它的参数也已经拷贝到了栈上，所以释放_defer结构体对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">freedefer</span>(<span style="color:#a6e22e">d</span>) 
    <span style="color:#a6e22e">jmpdefer</span>(<span style="color:#a6e22e">fn</span>, uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">arg0</span>)))  <span style="color:#75715e">//调用fn
</span><span style="color:#75715e"></span>}
</code></pre></div><p>deferreturn 函数主要流程为：</p>
<p>通过当前 goroutine 对应的 g 结构体对象的 _defer 链表判断是否有需要执行的 defered 函数，如果没有（g._defer == nil 或则 defered 函数不是在 deferreturn 的 caller 函数中注册的函数）则直接返回；</p>
<p>从 _defer 对象中把 defered 函数需要的参数拷贝到栈上；</p>
<p>释放 _defer 结构体对象；</p>
<p>通过 jmpdefer 函数调用 defered 函数（比如本文的sum函数）。</p>
<p>deferreturn 函数虽然比较简单，但有2点需要注意：</p>
<p>代码中的两个提前return的条件：d == nil 和 d.sp != sp。其中 d == nil 在判断是否有 defered 函数需要执行，可能有些读者会有疑问，deferreturn 明明是与 deferproc 配套使用的，这里怎么会是nil呢？这个是因为deferreturn 函数其实是被递归调用的，每次调用它只会执行一个 defered 函数，比如本文使用的例子在 f() 函数中注册了一个 defered 函数(sum函数)，所以 deferreturn 函数会被调用两次，第一次进入时会去执行 sum 函数，第二次进入时 d 为 nil 就直接返回了；另外一个条件 d.sp != sp 在判断 d 对象所包装的 defered 函数现在是否应该被执行，比如有函数调用链a()-&gt;b()-&gt;c()，即 a 函数调用了 b 函数，b 函数又调用了 c 函数，它们都通过 defer 注册了延迟函数，那么当 c() 执行完时只能执行在 c 中注册的函数，而不能执行 a 函数和 b 函数注册的 defered 函数；</p>
<p>defered 函数的参数并不是放在 deferreturn 函数的栈帧中的，比如前面的例子，f() 调用 deferreturn 函数，所以 deferreturn 函数通过 memmove 把 sum 函数的两个参数 copy 到了 f() 函数的栈中，结合前面 f() 函数的汇编代码，可知在调用 jmpdefer 函数之前，f() 以及 deferreturn() 函数的栈帧大致如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3820c64f460811abdab0e3a135deda76.png" alt=""></p>
<p>jmpdefer 函数</p>
<p>下面我们来看 jmpdefer 函数，该函数使用了些技巧实现了一个对 deferreturn 函数的递归调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">runtime</span><span style="color:#f92672">/</span><span style="color:#a6e22e">asm_amd64</span>.<span style="color:#a6e22e">s</span> : <span style="color:#ae81ff">560</span>

<span style="color:#75715e">// func jmpdefer(fv *funcval, argp uintptr)
</span><span style="color:#75715e">// argp is a caller SP.
</span><span style="color:#75715e">// called from deferreturn.
</span><span style="color:#75715e">// 1. pop the caller
</span><span style="color:#75715e">// 2. sub 5 bytes from the callers return
</span><span style="color:#75715e">// 3. jmp to the argument
</span><span style="color:#75715e"></span><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">jmpdefer</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">NOSPLIT</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span><span style="color:#f92672">-</span><span style="color:#ae81ff">16</span>
    <span style="color:#a6e22e">MOVQ</span>  <span style="color:#a6e22e">fv</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span>(<span style="color:#a6e22e">FP</span>), <span style="color:#a6e22e">DX</span>  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">fn</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">fn</span>.<span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">sum函数的地址</span>
    <span style="color:#a6e22e">MOVQ</span>  <span style="color:#a6e22e">argp</span><span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">FP</span>), <span style="color:#a6e22e">BX</span>  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">caller</span> <span style="color:#a6e22e">sp</span>
    <span style="color:#a6e22e">LEAQ</span>  <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">BX</span>), <span style="color:#a6e22e">SP</span>  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">caller</span> <span style="color:#a6e22e">sp</span> <span style="color:#a6e22e">after</span> <span style="color:#a6e22e">CALL</span>
    <span style="color:#a6e22e">MOVQ</span>  <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">BP</span>  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">restore</span> <span style="color:#a6e22e">BP</span> <span style="color:#a6e22e">as</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">deferreturn</span> <span style="color:#a6e22e">returned</span> (<span style="color:#a6e22e">harmless</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">framepointers</span> <span style="color:#a6e22e">not</span> <span style="color:#a6e22e">in</span> <span style="color:#a6e22e">use</span>)
    <span style="color:#a6e22e">SUBQ</span>  <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">5</span>, (<span style="color:#a6e22e">SP</span>)  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">to</span> <span style="color:#a6e22e">CALL</span> <span style="color:#a6e22e">again</span>
    <span style="color:#a6e22e">MOVQ</span>  <span style="color:#ae81ff">0</span>(<span style="color:#a6e22e">DX</span>), <span style="color:#a6e22e">BX</span>  
    <span style="color:#a6e22e">JMP</span>  <span style="color:#a6e22e">BX</span>  <span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#a6e22e">but</span> <span style="color:#a6e22e">first</span> <span style="color:#a6e22e">run</span> <span style="color:#a6e22e">the</span> <span style="color:#a6e22e">deferred</span> <span style="color:#a6e22e">function</span>
</code></pre></div><p>要理解这个函数的功能，需要对函数调用栈及函数调用过程有比较清晰的认识，如果对这部分不熟悉，可以先去看一下网上的资料或本公众号之前写的文章。</p>
<p>下面我们结合本文前面的例子程序来逐条分析 jmpdefer 函数的 7 条汇编指令。</p>
<p>第1条指令：</p>
<p>MOVQ  fv+0(FP), DX  # fn，fn.fn = sum函数的地址
把jmpdefer的第一个参数也就是结构体对象fn的地址放入DX寄存器，之后的代码就可以通过DX寄存器访问到fn.fn从而拿到 sum 函数的地址。</p>
<p>第2条指令：</p>
<p>MOVQ  argp+8(FP), BX  # caller sp
把jmpdefer的第二个参数放入 BX 寄存器，该参数是一个指针，它指向 sum 函数的第一个参数，见上图的箭头。</p>
<p>第3条指令：</p>
<p>LEAQ  -8(BX), SP  # caller sp after CALL
从第二条指令得知 BX 存放的是一个指针，BX - 8所指的位置是 deferreturn 函数执行完后的返回地址 0x488ef0，所以这条指令的作用是让 SP 寄存器指向 deferreturn 函数的返回地址所在的栈内存单元，执行完这条指令后 SP 寄存器与栈之间的关系如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/234c6e28bd0882798042ea05c15a04d3.png" alt=""></p>
<p>第4条指令：</p>
<p>MOVQ  -8(SP), BP  # restore BP as if deferreturn returned (harmless if framepointers not in use)
调整 BP 寄存器的值，因为此时 SP - 8 的位置存放的是 f() 函数的 rbp 寄存器的值，所以这条指令在调整 rbp 寄存器的值使其指向 f() 函数的栈帧的适当位置，执行完这条指令后 rbp 寄存器与栈之间的关系如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5359c3a66d5cd2adb43c9366323568e7.png" alt=""></p>
<p>经过第3条和第4条指令之后，deferreturn 函数的栈帧被抛弃了，因为 jmpdefer 函数并不会直接返回到 deferreturn 之中，所以这里抛弃 deferreturn 函数的栈帧没有问题。</p>
<p>第5条指令：</p>
<p>SUBQ  $5, (SP)  # return to CALL again
CPU 在执行这条指令是，rsp 寄存器指向的是 deferreturn 函数的返回地址，也就是 f() 函数中的 0x0000000000488ef0 &lt;+272&gt;: mov    0x78(%rsp),%rbp 这一条指令的地址，即0x488ef0，所以这条指令把 rsp 寄存器所指的内存中的值 0x488ef0 减了 5 得到 0x488eeb，对照前面f函数的汇编代码可知，这个地址指向的是 0x0000000000488eeb &lt;+267&gt;: callq  0x427490 &lt;runtime.deferreturn&gt; 这条指令。注意看下图中rsp寄存器所指的内存单元中的值的变化：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2ae661c7dbf52ff6ebd5e59e4446721f.png" alt=""></p>
<p>到此，sum 函数的参数以及 sum 函数执行完的返回地址在栈上已经构造完成，下面开始调用 sum 函数。</p>
<p>第6～7条指令</p>
<p>MOVQ  0(DX), BX       # BX = fn.fn
JMP  BX  # but first run the deferred function
会跳转到 sum 函数去执行，完成对 sum 函数的调用，在 sum 函数的执行过程中，栈如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fe24f63524c7b5426bc5aadd759e2f82.png" alt=""></p>
<p>因为 sum 函数的返回地址被上面的第5条指令设置成了 0x488eeb，所以等 sum 函数执行完成之后它会直接返回到 f() 函数的</p>
<p>0x0000000000488eeb &lt;+267&gt;: callq 0x427490 &lt;runtime.deferreturn&gt;
指令处继续执行，而这条指令又调用了 deferreturn 函数。回忆一下sum函数的调用路径 f()-&gt;deferreturn()-&gt;jmpdefer()-&gt;sum()，sum函数返回到 f() 时又再一次调用了 deferreturn ，这个过程从形式上看起来就是一个递归，只不过每次“递归”时并没有增加栈空间！</p>
<p>因为 f 函数只使用了一次 defer 语句，所以这里的第二次进入 deferreturn 函数会因为 d == nil 这个条件结束递归，然后返回到 f() 函数中继续执行后面的指令。</p>
<p>总结</p>
<p>最后我们来总结一下 defer 的实现机制。</p>
<p>对于如下所示的 defer 语句</p>
<p>func x() {
&hellip;&hellip;.
defer y(&hellip;&hellip;)
&hellip;&hellip;.
}
首先，编译器会把 defer 语句翻译成对 deferproc 函数的调用，deferproc 负责构造一个用来保存 y 函数的地址以及 y 函数需要用到的参数的 _defer 结构体对象，并把该对象加入当前 goroutine 对应的 g 结构体对象的 _defer 链表表头；</p>
<p>然后，编译器会在 x 函数的结尾处插入对 deferreturn 的调用，deferreturn 负责递归的调用 x 函数通过 defer 语句注册的函数。</p>
<p>总体说来，在不考虑 panic/recover 的情况下，go语言对 defer 的实现机制还是比较简单，但其具体实现细节还是有很多地方值得我们仔细思考和学习的。</p>
<p>最后，如果你觉得本文对你有帮助的话，麻烦帮忙点一下文末右下角的 在看 或转发到朋友圈，非常感谢！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb1306280e12ad8be259c63547ad1b1f.png" alt=""></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E8%AF%AD%E8%A8%80panicrecover%E7%9A%84%E5%AE%9E%E7%8E%B0/" rel="next" title="go语言panic,recover的实现">
        <i class="fa fa-chevron-left"></i> go语言panic,recover的实现
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/03/go%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3defer%E4%B8%8Adefer%E5%9F%BA%E7%A1%80/" rel="prev" title="go深入理解defer（上）defer基础">
        go深入理解defer（上）defer基础 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">383</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">20</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">27</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.92.1</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>