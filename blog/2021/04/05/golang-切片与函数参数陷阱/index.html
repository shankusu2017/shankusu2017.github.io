<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Golang 切片与函数参数陷阱 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="Golang 切片与函数参数陷阱">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="Golang 切片与函数参数陷阱 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/05/golang-%E5%88%87%E7%89%87%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%99%B7%E9%98%B1/" itemprop="url">
        Golang 切片与函数参数陷阱
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-05">
    2021-04-05
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5382 字 ~11分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://studygolang.com/articles/9876">原文链接</a></p>
<p>线性结构是计算机最常用的数据结构之一。无论是数组（arrary）还是链表（list），在编程中不可或缺。golang也有数组，不同于别的语言，golang还提供了切片（slice）。切片比数组有更好的灵活性，具有某些动态特性。然而切片又不像动态语言的列表（Python list）。不明白切片的基本实现，写程序的时候容易掉“坑”里。
<strong>slice参数</strong>
本来写一个堆排序，使用了golang的slice来做堆，可是发现在pop数据的时候，切片不改变。进而引发了golang函数切片的参数，是传值还是传引用呢？我们知道slice相比array是引用类型。那么直觉上告诉我们如果函数修改了参数的切片，那么外层的切片变量也会变啦。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    slice := []<span style="color:#00f">int</span>{0, 1, 2, 3}
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice: %v slice addr %p \n&#34;</span>, slice, &amp;slice)
 
    ret := <span style="color:#c34e00">changeSlice</span>(slice)
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice: %v ret: %v slice addr %p \n&#34;</span>, slice, &amp;slice, ret)
}
 
<span style="color:#00f">func</span> <span style="color:#c34e00">changeSlice</span>(s []<span style="color:#00f">int</span>) []<span style="color:#00f">int</span> {
    s[1] = 111
    <span style="color:#00f">return</span> s
}
</code></pre></div><p>结果和假设的一样：</p>
<ol>
<li>slice: [0 1 2 3], slice addr: 0xc4200660c0</li>
<li>slice: [0 111 2 3], ret: [0 111 2 3], slice addr: 0xc4200660c0
changeSlice函数修改了切片，变量 slice也跟着修改了。可是如果轻易就下结论，切片参数是按照引用传递，那么下面的现象就需要一种说法了：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">changeSlice</span>(s []<span style="color:#00f">int</span>) []<span style="color:#00f">int</span> {
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;func: %p \n&#34;</span>, &amp;s)
    s[1] = 111
    <span style="color:#00f">return</span> s
}
</code></pre></div><p>我们在函数中打出参数 s 的地址，可以看见这个地址和main函数中的slice竟然不是同一个。为了了解这个，我们需要了解golang中的slice基本实现。</p>
<p><strong>slice基本实现</strong>
Golang中的slice，是一个看似array却不是array的复合结构。切片顾名思义，就是数组切下来的一个片段。slice结构大致存储了三个部分，第一部分为指向底层数组的指针ptr，其次是切片的大小len和切片的容量cap：</p>
<pre><code>  +--------+
  |        |
  |  ptr   |+------------+-------+-----------+
  |        |                     |           |
  +--------+                     |           |
  |        |                     |           |
  |        |                     |           |
  |  len 5 |                     |           |
  |        |                     |           |
  +--------+                     v           v
  |        |             +-----+-----+-----+-----+----+
  |        |             |     |     |     |     |    |
  |  cap 5 |     [5]int  |  0  |  1  |  2  |  3  | 4  |
  |        |             +-----+-----+-----+-----+----+
  +--------+



   slice := arr[1:4]             arr := [5]int{0,1,2,3,4}
</code></pre>
<p>有一个数组arr是一个包含五个int类型的结构，它的切片slice只是从其取了 1到3这几个数字。我们同样可以再生成一个切片 slice2 := arr[2:5], 所取的就是数组后面的连续块。他们共同使用arr作为底层的结构，可以看见共用了数字的第3，4个元素。修改其中任何一个，都能改变两个切片的值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    arr := [5]<span style="color:#00f">int</span>{0, 1, 2, 3, 4}
    fmt.<span style="color:#c34e00">Println</span>(arr)
 
    slice := arr[1:4]
    slice2 := arr[2:5]
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v, slice1 %v, slice2 %v, %p %p %p\n&#34;</span>, arr, slice, slice2, &amp;arr, &amp;slice, &amp;slice2)
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr[2]%p slice[1] %p slice2[0]%p\n&#34;</span>, &amp;arr[2], &amp;slice[1], &amp;slice2[0])
 
    arr[2] = 2222
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v, slice1 %v, slice2 %v\n&#34;</span>, arr, slice, slice2)
 
 
    slice[1] = 1111
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v, slice1 %v, slice2 %v\n&#34;</span>, arr, slice, slice2)
 
}
</code></pre></div><p>输出的值为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">[0 1 2 3 4]
arr [0 1 2 3 4], slice1 [1 2 3], slice2 [2 3 4], 0xc42006e0c0 0xc4200660c0 0xc4200660e0
arr[2]0xc42006e0d0 slice[1] 0xc42006e0d0 slice2[0]0xc42006e0d0
arr [0 1 2222 3 4], slice1 [1 2222 3], slice2 [2222 3 4]
arr [0 1 1111 3 4], slice1 [1 1111 3], slice2 [1111 3 4]
</code></pre></div><p>由此可见，数组的切片，只是从数组上切一段数据下来，不同的切片，其实是共享这些底层的数据数据。不过这些切片本身是不一样的对象，其内存地址都不一样。</p>
<p>从数组中切一块下来形成切片很好理解，有时候我们用make函数创建切片，实际上golang会在底层创建一个匿名的数组。如果从新的slice再切，那么新创建的两个切片都共享这个底层的匿名数组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    slice := make([]<span style="color:#00f">int</span>, 5)
    <span style="color:#00f">for</span> i:=0; i&lt;len(slice);i++{
        slice[i] = i
    }
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v \n&#34;</span>, slice)
 
    slice2 := slice[1:4]
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice2 %v \n&#34;</span>, slice, slice2)
 
    slice[1] = 1111
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice2 %v \n&#34;</span>, slice, slice2)
}
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">slice [0 1 2 3 4] 
slice [0 1 2 3 4], slice2 [1 2 3] 
slice [0 1111 2 3 4], slice2 [1111 2 3]
</code></pre></div><p><strong>slice的复制</strong>
既然slice的创建依赖于数组，有时候新生成的slice会修改，但是又不想修改原来的切片或者数组。此时就需要针对原来的切片进行复制了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    slice := []<span style="color:#00f">int</span>{0, 1, 2, 3, 4}
 
    slice2 := slice[1:4]
 
    slice3 := make([]<span style="color:#00f">int</span>, len(slice2))
 
    <span style="color:#00f">for</span> i, e := <span style="color:#00f">range</span> slice2 {
        slice3[i] = e
    }
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice3 %v \n&#34;</span>, slice, slice3)
 
    slice[1] = 1111
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice3 %v \n&#34;</span>, slice, slice3)
}
</code></pre></div><p>输出：</p>
<p>slice [0 1 2 3 4], slice3 [1 2 3]
slice [0 1111 2 3 4], slice3 [1 2 3]
由此可见，新创建的slice3，不会因为slice和slice2的修改而改变slice3。复制很有用，因此golang实现了一个内建的函数copy， copy有两个参数，第一个参数是复制后的对象，第二个是复制前的数组切片对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    slice := []<span style="color:#00f">int</span>{0, 1, 2, 3, 4}
    slice2 := slice[1:4]
 
    slice4 := make([]<span style="color:#00f">int</span>, len(slice2))
 
    copy(slice4, slice2)
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice4 %v \n&#34;</span>, slice, slice4)
    slice[1] = 1111
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice4 %v \n&#34;</span>, slice, slice4)
}
</code></pre></div><p>slice4是从slice2中copy生成，slice和slice4底层的匿名数组是不一样的。因此修改他们不会影响彼此。</p>
<p><strong>slice 追加</strong>
append 简介</p>
<p>创建复制切片都是常用的操作，还有一个追加元素或者追加数组也是很常用的功能。golang提供了append函数用于给切片追加元素。append第一个参数为原切片，随后是一些可变参数，用于将要追加的元素或多个元素。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    slice := make([]<span style="color:#00f">int</span>, 1, 2)
    slice[0] = 111
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice addr %p, len %d, cap %d \n&#34;</span>, slice, &amp;slice, len(slice), cap(slice))
 
    slice = append(slice, 222)
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice addr %p, len %d, cap %d \n&#34;</span>, slice, &amp;slice, len(slice), cap(slice))
 
    slice = append(slice, 333)
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v, slice addr %p, len %d, cap %d \n&#34;</span>, slice, &amp;slice, len(slice), cap(slice))
 
}
</code></pre></div><p>输出结果为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">slice [111], slice addr 0xc4200660c0, len 1, cap 2 
slice [111 222], slice addr 0xc4200660c0, len 2, cap 2 
slice [111 222 333], slice addr 0xc4200660c0, len 3, cap 4
</code></pre></div><p>切片容量</p>
<p>无论数组还是切片，都有长度限制。也就是追加切片的时候，如果元素正好在切片的容量范围内，直接在尾部追加一个元素即可。如果超出了最大容量，再追加元素就需要针对底层的数组进行复制和扩容操作了。</p>
<p>这里有一个切片容量的概念，从数组中切数据，切片的容量应该是切片的最后一个数据，和数组剩下元素的大小，再加上现有切片的大小。</p>
<p>数组 [0, 1, 2, 3, 4] 中，数组有5个元素。如果切片 s = [1, 2, 3]，那么3在数组的索引为3，也就是数组还剩最后一个元素的大小，加上s已经有3个元素，因此最后s的容量为 1 + 3 = 4。如果切片是
s1 = [4]，4的索引再数组中是最大的了，数组空余的元素为0，那么s1的容量为 0 + 1 = 1。具体如下表：</p>
<p>切片	切片字面量	数组剩下空间	长度	容量
s[1:3]	[1 2]	2	2	4
s[1:1]	[]	4	0	4
s[4:4]	[]	1	0	1
s[4:5]	[4]	0	1	1
尽管上面的第二个和第三个切片的长度一样，但是他们的容量不一样。容量与最终append的策略有关系。</p>
<p>append简单实现</p>
<p>我们已经知道，切片都依赖底层的数组结构，即使是直接创建的切片，也会生成一个匿名的数组。使用append时候，本质上是针对底层依赖的数组进行操作。如果切片的容量大于长度，给切片追加元素其实是修改底层数中，切片元素后面的元素。如果容量满了，就不能在原来的数组上修改，而是要创建一个新的数组，当然golang是通过创建一个新的切片实现的，因为新切片必然也有一个新的数组，并且这个数组的长度是原来的2倍，使用动态规划算法的简单实现。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
 
    arr := [3]<span style="color:#00f">int</span>{0, 1, 2}
 
    slice := arr[1:2]
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v len %d, slice %v  len %d, cap %d, \n&#34;</span>, arr, len(arr), slice, len(slice), cap(slice))
 
    slice[0] = 333
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v len %d, slice %v  len %d, cap %d, \n&#34;</span>, arr, len(arr), slice, len(slice), cap(slice))
 
    slice = append(slice, 4444)
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v len %d, slice %v  len %d, cap %d, \n&#34;</span>, arr, len(arr), slice, len(slice), cap(slice))
 
    slice = append(slice, 5555)
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v len %d, slice %v  len %d, cap %d, \n&#34;</span>, arr, len(arr), slice, len(slice), cap(slice))
 
    slice[0] = 333
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;arr %v len %d, slice %v  len %d, cap %d, \n&#34;</span>, arr, len(arr), slice, len(slice), cap(slice))
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">arr [0 1 2] len 3, slice [1]  len 1, cap 2, 
arr [0 333 2] len 3, slice [333]  len 1, cap 2, 
arr [0 333 444] len 3, slice [333 444]  len 2, cap 2, 
arr [0 333 444] len 3, slice [333 444 555]  len 3, cap 4, 
arr [0 333 444] len 3, slice [333 444 555]  len 3, cap 4,
</code></pre></div><p>小于容量的append</p>
<p>重输出，我们来画一下这个动态过程的图示：</p>
<pre><code>   +----+----+----+                           +----+----+----+                             +----+----+----+
   |    |    |    |                           |    |    |    |                             |    |    |    |
</code></pre>
<p>arr   | 0  |  1 |  2 |                     arr   | 0  |333 | 2  |                       arr   | 0  |333 |444 |
+&mdash;-+&mdash;-+&mdash;-+                           +&mdash;-+&mdash;-+&mdash;-+                             +&mdash;-+&mdash;-+&mdash;-+
^                                          ^                                            ^    ^
|                                          |                                            |    |
|                                          |                                            |    |
|                 slic0] = 333             |              slice = append(slice, 444)    +&mdash;-+
|               +&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&gt;        |                +&mdash;&mdash;&mdash;&mdash;&mdash;-&gt;          |
|                                          |                                            |
+&ndash;+&ndash;+&mdash;-+&mdash;-+                          +&ndash;+&ndash;+&mdash;-+&mdash;-+                            +&ndash;+&ndash;+&mdash;-+&mdash;-+
|     |    |    |                          |     |    |    |                            |     |    |    |
| p   | 1  | 2  |                          | p   | 1  | 2  |                            | p   | 2  | 2  |
+&mdash;&ndash;+&mdash;-+&mdash;-+                          +&mdash;&ndash;+&mdash;-+&mdash;-+                            +&mdash;&ndash;+&mdash;-+&mdash;-+</p>
<pre><code>        slice :=arr[1:2]                           slice :=arr[1:2]                             slice :=arr[1:2]
</code></pre>
<p>arr 是一个含有三个元素的数组，slice从arr中切了一个元素，由于切片的最后一个元素1是数组的索引是1，距离数组的最大长度还是1，因此slice的容量为2。当修改slice的第一个元素，由于slice底层是arr数组，因此arr的第二个元素也相应被修改。使用append方法给slice追加元素的时候，由于slice的容量还未满，因此等同于扩展了slice指向数组的内容，可以理解为重新切了一个数组内容附给slice，同时修改了数组的内容。</p>
<p>超出容量的append</p>
<p>如果接着append一个元素，那么数组肯定越界。此时append的原理大致如下：</p>
<ol>
<li>
<p>创建一个新的临时切片t，t的长度和slice切片的长度一样，但是t的容量是slice切片的2倍，一个动态规划的方式。新建切片的时候，底层也创建了一个匿名的数组，数组的长度和切片容量一样。</p>
</li>
<li>
<p>复制s里面的元素到t里，即填入匿名数组中。然后把t赋值给slice，现在slice的指向了底层的匿名数组。</p>
</li>
<li>
<p>转变成小于容量的append方法。
+&mdash;-+&mdash;-+&mdash;-+                                +&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
|    |    |    |                                |    |    |    |    |    |    |
arr   | 0  |333 |444 |                                | 333| 444|    |    |    |    |
+&mdash;-+&mdash;-+&mdash;-+                                +&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
^    ^                                    ^     ^
|    |                                    |     |
|    |                                    +&mdash;&ndash;+
+&mdash;-+           +&mdash;&mdash;&mdash;&mdash;&mdash;&gt;        |
|                                         |
|                                         +
+&ndash;+&ndash;+&mdash;-+&mdash;-+                          +&mdash;&ndash;+&mdash;&ndash;+&mdash;&ndash;+
|     |    |    |                          |     |     |     |
| p   | 2  | 2  |                          | p   |  2  |  6  |
+&mdash;&ndash;+&mdash;-+&mdash;-+                          +&mdash;&ndash;+&mdash;&ndash;+&mdash;&ndash;+</p>
<pre><code>     slice :=arr[1:2]                          t := make([]int, len=2, cap=6)

                                                           +
                                                           |
                                                           |
                                                           |
                                                           |
                                                           v


                                                +----+----+----+----+----+----+
                                                |    |    |    |    |    |    |
                                                | 333| 444|555 |    |    |    |
                                                +----+----+----+----+----+----+
                                                  ^         ^
                                                  |         |
                                                  +----+----+
                                                  |
                                                  |
                                                  +
                                                +-----+-----+-----+
                                                |     |     |     |
                                                | p   |  3  |  6  |
                                                +-----+-----+-----+

                                                 slice = t
</code></pre>
</li>
</ol>
<p>上面的图示描述了大于容量的时候append的操作原理。新生成的切片其依赖的数组和原来的数组就没有关系了，因此在修改新的切片元素，旧的数组也不会有关系。至于临时的切片t，将会被golang的gc回收。当然arr或它衍生的切片都没有应用的时候，也会被gc所回收。</p>
<p>slice和array的关系十分密切，通过两者的合理构建，既能实现动态灵活的线性结构，也能提供访问元素的高效性能。当然，这种结构也不是完美无暇，共用底层数组，在部分修改操作的时候，可能带来副作用，同时如果一个很大的数组，那怕只有一个元素被切片应用，那么剩下的数组都不会被垃圾回收，这往往也会带来额外的问题。</p>
<p><strong>作为函数参数的切片</strong>
直接改变切片</p>
<p>回到最开始的问题，当函数的参数是切片的时候，到底是传值还是传引用？从changeSlice函数中打出的参数s的地址，可以看出肯定不是传引用，毕竟引用都是一个地址才对。然而changeSlice函数内改变了s的值，也改变了原始变量slice的值，这个看起来像引用的现象，实际上正是我们前面讨论的切片共享底层数组的实现。</p>
<p>即切片传递的时候，传的是数组的值，等效于从原始切片中再切了一次。原始切片slice和参数s切片的底层数组是一样的。因此修改函数内的切片，也就修改了数组。</p>
<pre><code>                                            +-----+----+-----+
                                            |     |    |     |
             +-----------------------------+| p   |  3 |  3  |
             |          +                   +-----+----+-----+
             |          |
             |          |                     s
             |          |
             |          |
             v          v
           +----+----+-----+
           |    |    |     |
   arr     | 0  |  1 |  2  |
           +----+----+-----+
             ^           ^
             |           |
             |           |
             +-----------+
             |
             |
           +-+--+----+-----+
           |    |    |     |
           |  p |  3 |  3  |
           +----+----+-----+
              slice
</code></pre>
<p>例如下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    slice := make([]<span style="color:#00f">int</span>, 2, 3)
    <span style="color:#00f">for</span> i := 0; i &lt; len(slice); i++ {
        slice[i] = i
    }
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p \n&#34;</span>, slice, &amp;slice)
 
    ret := <span style="color:#c34e00">changeSlice</span>(slice)
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p, ret %v \n&#34;</span>, slice, &amp;slice, ret)
 
    ret[1] = 1111
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p, ret %v \n&#34;</span>, slice, &amp;slice, ret)
}
 
<span style="color:#00f">func</span> <span style="color:#c34e00">changeSlice</span>(s []<span style="color:#00f">int</span>) []<span style="color:#00f">int</span> {
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;func s %v %p \n&#34;</span>, s, &amp;s)
    s = append(s, 3)
    <span style="color:#00f">return</span> s
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">slice [0 1] 0xc42000a1e0 
func s [0 1] 0xc42000a260 
slice [0 1] 0xc42000a1e0, ret [0 1 3] 
slice [0 1111] 0xc42000a1e0, ret [0 1111 3]
</code></pre></div><p>从输出可以看出，当slice传递给函数的时候，新建了切片s。在函数中给s进行了append一个元素，由于此时s的容量足够到，并没有生成新的底层数组。当修改返回的ret的时候，ret也共用了底层的数组，因此修改ret的原始，相应的也看到了slice的改变。</p>
<p>append 操作</p>
<p>如果在函数内，append操作超过了原始切片的容量，将会有一个新建底层数组的过程，那么此时再修改函数返回切片，应该不会再影响原始切片。例如下面代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"> <span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
    slice := make([]<span style="color:#00f">int</span>, 2, 2)
    <span style="color:#00f">for</span> i := 0; i &lt; len(slice); i++ {
        slice[i] = i
    }
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p \n&#34;</span>, slice, &amp;slice)
 
    ret := <span style="color:#c34e00">changeSlice</span>(slice)
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p, ret %v \n&#34;</span>, slice, &amp;slice, ret)
 
    ret[1] = -1111
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p, ret %v \n&#34;</span>, slice, &amp;slice, ret)
}
 
<span style="color:#00f">func</span> <span style="color:#c34e00">changeSlice</span>(s []<span style="color:#00f">int</span>) []<span style="color:#00f">int</span> {
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;func s %v %p \n&#34;</span>, s, &amp;s)
    s[0] = -1
    s = append(s, 3)
    s[1] =  1111
    <span style="color:#00f">return</span> s
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">slice [0 1] 0xc42000a1a0 
<span style="color:#00f">func</span> s [0 1] 0xc42000a200 
slice [-1 1] 0xc42000a1a0, ret [-1 1111 3] 
slice [-1 1] 0xc42000a1a0, ret [-1 -1111 3]
</code></pre></div><p>从输出可以很清楚的看到了我们的猜想。 即函数中先改变s第一个元素的值，由于slice和s都共用了底层数组，因此无论原始切片slice还是ret，第一个元素都是-1.然后append操作之后，因为超出了s的容量，因此会新建底层数组，虽然s变量没变，但是他的底层数组变了，此时修改s第一个元素，并不会影响原始的slice切片。也就是slice[1]还是1，而ret[1]则是-1。最后在外面修改ret[1]为 -1111，也不会影响原始的切片slice。</p>
<p>通过上面的分析，我们大致可以下结论，slice或者array作为函数参数传递的时候，本质是传值而不是传引用。传值的过程复制一个新的切片，这个切片也指向原始变量的底层数组。（个人感觉称之为传切片可能比传值的表述更准确）。函数中无论是直接修改切片，还是append创建新的切片，都是基于共享切片底层数组的情况作为基础。也就是最外面的原始切片是否改变，取决于函数内的操作和切片本身容量。</p>
<p>传引用方式</p>
<p>array和slice作为参数传递的过程基本上是一样的，即传递他们切片。有时候我们需要处理传递引用的形式。golang提供了指针很方便实现类似的功能。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
    slice := []<span style="color:#00f">int</span>{0, 1}
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p \n&#34;</span>, slice, &amp;slice)
 
    <span style="color:#c34e00">changeSlice</span>(&amp;slice)
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p \n&#34;</span>, slice, &amp;slice)
 
    slice[1] = -1111
 
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;slice %v %p \n&#34;</span>, slice, &amp;slice)
}
 
<span style="color:#00f">func</span> <span style="color:#c34e00">changeSlice</span>(s *[]<span style="color:#00f">int</span>) {
    fmt.<span style="color:#c34e00">Printf</span>(<span style="color:#009c00">&#34;func s %v %p \n&#34;</span>, *s, s)
    (*s)[0] = -1
    *s = append(*s, 3)
    (*s)[1] =  1111
}
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">slice [0 1] 0xc42000a1e0 
func s [0 1] 0xc42000a1e0 
slice [-1 1111 3] 0xc42000a1e0 
slice [-1 -1111 3] 0xc42000a1e0
</code></pre></div><p>从输出可以看到，传递给函数的是slice的指针，函数内对对s的操作本质上都是对slice的操作。并且也可以从函数内打出的s地址看到，至始至终就只有一个切片。虽然在append过程中会出现临时的切片或数组。</p>
<p><strong>总结</strong>
golang提供了array和slice两种序列结构。其中array是值类型。slice则是复合类型。slice是基于array实现的。slice的第一个内容为指向数组的指针，然后是其长度和容量。通过array的切片可以切出slice，也可以使用make创建slice，此时golang会生成一个匿名的数组。</p>
<p>因为slice依赖其底层的array，修改slice本质是修改array，而array又是有大小限制，当超过slice的容量，即数组越界的时候，需要通过动态规划的方式创建一个新的数组块。把原有的数据复制到新数组，这个新的array则为slice新的底层依赖。</p>
<p>数组还是切片，在函数中传递的不是引用，是另外一种值类型，即通过原始变量进行切片传入。函数内的操作即对切片的修改操作了。当然，如果为了修改原始变量，可以指定参数的类型为指针类型。传递的就是slice的内存地址。函数内的操作都是根据内存地址找到变量本身。</p>
<p>参考资料：Go 切片：用法和本质</p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/05/go%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="next" title="go单例模式">
        <i class="fa fa-chevron-left"></i> go单例模式
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/04/go-%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0golang%E4%B8%87%E5%AD%97%E8%AF%A6%E6%96%87%E6%95%99%E4%BD%A0go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" rel="prev" title="go 汇编入门 如何学习Golang？万字详文教你Go语言入门">
        go 汇编入门 如何学习Golang？万字详文教你Go语言入门 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">523</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">40</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">45</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>