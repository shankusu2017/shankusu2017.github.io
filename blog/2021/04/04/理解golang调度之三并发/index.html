<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>理解golang调度之三：并发 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="理解golang调度之三：并发">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="理解golang调度之三：并发 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%B8%89%E5%B9%B6%E5%8F%91/" itemprop="url">
        理解golang调度之三：并发
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-04">
    2021-04-04
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6190 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="简介"><strong>简介</strong></h2>
<p>当我在解决一个问题尤其是新问题的时候，我开始不会去考虑并发(concurrency)是否合适。我首先会去找一系列的解决方式然后确保它有效。然后在可读性和技术方案评估之后，我会开始去考虑并发是否实际合理。有些时候并发的好处是显而易见的，但是有时候并不是很明显。
第一篇文章，我解释了OS调度器的相关内容，我觉得这部分对于你写多线程代码很重要。第二篇里，我讲解了一些Go调度器的一些内容，这部分对于你理解和写go的并发代码很有帮助。在这篇文章里，我会在OS和Go调度器层面让你去深层次的理解并发到底是什么。
这部分内容的目标是：</p>
<p>你的工作负载(workloads)使用并发是否合适，为此提供一些指导建议
不同工作负载的含义，并针对其作出相应的工程方面的决策。</p>
<h2 id="什么是并发"><strong>什么是并发</strong></h2>
<h2 id="工作负载workloads">并发的含义就是无序的执行。给你一系列的指令，去找到一个方式可以无序执行而且和有序执行产生同样的结果。这个问题在你面前，显而易见的是无序执行会增加一些足够的性能增益在计算了复杂性成本之后，但是你可能会觉得无序执行是不可能的甚至是没有意义的。
你也要清楚一点，并发和并行是不一样的。并行是在相同时间内同时执行两个或两个以上的指令，这和并发的概念不一样。
图3.1
<img src="https://user-gold-cdn.xitu.io/2019/5/20/16ad5476fb5b267c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">
图3.1里，你看到主机上有两个逻辑处理器。每个都有他们单独的OS线程(M)依附于一个独立的硬件线程(Core)。你可以看到2个Goroutine(G1和G2) 正在并行在各自的OS/硬件线程上面同时执行它们的指令。在每个逻辑处理器里，有3个Goroutines以轮转的方式共享OS线程。这些Goroutines正在以无序的方式并发地执行它们的指令，并且在OS线程上共享时间片。
这里有一个问题。有些时候利用并发而不采用并行实际上会降低你的吞吐量，有趣的是，有时候利用并发同时加上并行处理也不会为你带来你理想中的性能增益。
<strong>工作负载(workloads)</strong></h2>
<p>你是如何知道无序执行(并发)是可行的呢？了解你所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。</p>
<ul>
<li><strong>CPU密集(CPU-Bound)</strong>：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。</li>
<li><strong>IO密集(IO-Bound)</strong>：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。</li>
</ul>
<h2 id="整数累加">cpu-bound的工作负载，你需要并行去使用并发。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。
在IO-Bound的workloads里，你不需要并行去使用并发。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。
你如何知道每个硬件线程设置多少个Goroutines会有最好的吞吐量呢？太少的Goroutines你会有更多空闲时间。太多Goroutines你会有更多上下文切换延迟。这件事情你需要考虑，但是这超出了
本篇文章讲述的范围。
现在，我们需要看一些代码来巩固你去判断什么时候workload可以利用并发，以及什么时候需要利用并行什么时候不需要并行。
<strong>整数累加</strong></h2>
<p>不需要太复杂的代码，就看一下下面的add函数。它计算了一堆整数的和。
<strong>L1</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">36 <span style="color:#00f">func</span> <span style="color:#c34e00">add</span>(numbers []<span style="color:#00f">int</span>) <span style="color:#00f">int</span> {
37     <span style="color:#00f">var</span> v <span style="color:#00f">int</span>
38     <span style="color:#00f">for</span> _, n := <span style="color:#00f">range</span> numbers {
39         v += n
40     }
41     <span style="color:#00f">return</span> v
42 }
</code></pre></div><p>在L1的36行，声明了add方法，他接受一个int型的slice，然后返回它们的和。37定义了一个变量v去做数字累加。38行函数遍历这些整数，39行把当前数加上去。最后41行返回它们的和。
Question: add是否适合无序执行？我相信答案肯定是yes。整数集可以被分解成更小的lists，并且这些lists可以并行去处理。一旦所有lists都各自加完，这一系列lists的和可以加到一起，得到上面代码里一样的结果。
但是，另一个问题来了。我们应该分多少个lists去分别单独处理才能得到最好的吞吐量呢？为了回答这个问题，你需要知道add方法运行到底是哪种workload。add方法处理的是CPU-Bound类型的workload因为这是一个纯数学计算的方法，它不会导致goroutines进入自动等待状态。这意味着每个OS/硬件线程一个Goroutine即可获得理想的吞吐量。
下面的L2是add方法的并发版本。
<strong>注意：你有多种方式去写add的并发版本，不必去纠结代码本身。</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">44 <span style="color:#00f">func</span> <span style="color:#c34e00">addConcurrent</span>(goroutines <span style="color:#00f">int</span>, numbers []<span style="color:#00f">int</span>) <span style="color:#00f">int</span> {
45     <span style="color:#00f">var</span> v <span style="color:#00f">int64</span>
46     totalNumbers := len(numbers)
47     lastGoroutine := goroutines - 1
48     stride := totalNumbers / goroutines
49
50     <span style="color:#00f">var</span> wg sync.WaitGroup
51     wg.<span style="color:#c34e00">Add</span>(goroutines)
52
53     <span style="color:#00f">for</span> g := 0; g &lt; goroutines; g++ {
54         <span style="color:#00f">go</span> <span style="color:#00f">func</span>(g <span style="color:#00f">int</span>) {
55             start := g * stride
56             end := start + stride
57             <span style="color:#00f">if</span> g == lastGoroutine {
58                 end = totalNumbers
59             }
60
61             <span style="color:#00f">var</span> lv <span style="color:#00f">int</span>
62             <span style="color:#00f">for</span> _, n := <span style="color:#00f">range</span> numbers[start:end] {
63                 lv += n
64             }
65
66             atomic.<span style="color:#c34e00">AddInt64</span>(&amp;v, int64(lv))
67             wg.<span style="color:#c34e00">Done</span>()
68         }(g)
69     }
70
71     wg.<span style="color:#c34e00">Wait</span>()
72
73     <span style="color:#00f">return</span> int(v)
74 }
</code></pre></div><p>在L2里面，addConcurrent方法是add方法的并发版本。这里有很多代码因此我只讲解重要的代码行
<strong>Line 48：每个Goroutine会有它单独的一个小的list去处理。list的size由整数集的size去除以Goroutines的数量得到。
Line 53：创建goroutines线程池去处理加数操作。
Line 57-59：最后一个goroutines会处理剩下的最后一个list，它可能比其他list的size要大。
Line 66：所有lists算出来的sum，加到一起得到最后的一个sum。</strong>
并发版本比有序版本更复杂，这种复杂度是否值得呢？回答这个问题最好的方式就是写一个benchmark。这里我用了一个一千万个数大小整数集，并且关掉了垃圾回收。这里对add和addConcurrent进行了对比。
<strong>L3</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">BenchmarkSequential</span>(b *testing.B) {
    <span style="color:#00f">for</span> i := 0; i &lt; b.N; i++ {
        <span style="color:#c34e00">add</span>(numbers)
    }
}

<span style="color:#00f">func</span> <span style="color:#c34e00">BenchmarkConcurrent</span>(b *testing.B) {
    <span style="color:#00f">for</span> i := 0; i &lt; b.N; i++ {
        <span style="color:#c34e00">addConcurrent</span>(runtime.<span style="color:#c34e00">NumCPU</span>(), numbers)
    }
}
</code></pre></div><p>L3展示了benchmark函数。下面是当Goroutines只有一个单独的OS/硬件线程能用的情况。有序版本使用1个Goroutine然后并发版本使用runtime.NumCPU数，我的机器上是8。这个例子下面，并发版本没有使用并行去做并发。
L4</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">10 Million Numbers using 8 goroutines with 1 core
2.9 GHz Intel 4 Core i7
Concurrency WITHOUT Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -cpu 1 -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/cpu-bound
BenchmarkSequential      	    1000	   5720764 ns/op : ~10% Faster
BenchmarkConcurrent      	    1000	   6387344 ns/op
BenchmarkSequentialAgain 	    1000	   5614666 ns/op : ~13% Faster
BenchmarkConcurrentAgain 	    1000	   6482612 ns/op
</code></pre></div><p><strong>注意：在你的本机上跑BenchMark很复杂。有很多因素会导致你的benchmarks不够精确。你的机器尽可能的处于空闲状态这样可以去跑一段时间benchmark，以确保自己看到的结果和上面的大体一致。使用测试工具跑两遍benchmark能够得到更一致的结果。</strong>
L4给出的benchmark表明，在仅有一个单独OS/硬件线程时候有序版本比并发版本大约要快%10&ndash;%13。这在我们的意料之中，因为并发版本需要在一个单独的OS线程上频繁进行上下文切换(context switches)以及处理Goroutines。
下面是每个Goroutines有一个单独的OS/硬件线程的情况下的结果。有序版本用一个Goroutine然后并发版本使用runtime.NumCPU，在我本机上是8个。这种情况下利用了并行去处理并发。
<strong>L5</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">10 Million Numbers using 8 goroutines with 8 cores
2.9 GHz Intel 4 Core i7
Concurrency WITH Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -cpu 8 -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/cpu-bound
BenchmarkSequential-8        	    1000	   5910799 ns/op
BenchmarkConcurrent-8        	    2000	   3362643 ns/op : ~43% Faster
BenchmarkSequentialAgain-8   	    1000	   5933444 ns/op
BenchmarkConcurrentAgain-8   	    2000	   3477253 ns/op : ~41% Faster
</code></pre></div><h2 id="排序">L5中的benchmark表明了,每个Goroutines使用一个OS/硬件线程的时候并发版本比有序版本要快大约41%&ndash;43%。这是我们期望中的事情，因为所有的Goroutines现在都在并行执行，8个Goroutines现在都在同一时间并发执行。
<strong>排序</strong></h2>
<p>需要明白，不是所有的CPU-bound的workloads都适合并发处理。当把工作拆解或者是把结果合并需要花费很大代价的时候这种说法是正确的。这种情况我们可以看一个算法的例子：冒泡排序。看一下下Go实现的冒泡排序。
L6</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">package</span> main
02
03 <span style="color:#00f">import</span> <span style="color:#009c00">&#34;fmt&#34;</span>
04
05 <span style="color:#00f">func</span> <span style="color:#c34e00">bubbleSort</span>(numbers []<span style="color:#00f">int</span>) {
06     n := len(numbers)
07     <span style="color:#00f">for</span> i := 0; i &lt; n; i++ {
08         <span style="color:#00f">if</span> !<span style="color:#c34e00">sweep</span>(numbers, i) {
09             <span style="color:#00f">return</span>
10         }
11     }
12 }
13
14 <span style="color:#00f">func</span> <span style="color:#c34e00">sweep</span>(numbers []<span style="color:#00f">int</span>, currentPass <span style="color:#00f">int</span>) <span style="color:#00f">bool</span> {
15     <span style="color:#00f">var</span> idx <span style="color:#00f">int</span>
16     idxNext := idx + 1
17     n := len(numbers)
18     <span style="color:#00f">var</span> swap <span style="color:#00f">bool</span>
19
20     <span style="color:#00f">for</span> idxNext &lt; (n - currentPass) {
21         a := numbers[idx]
22         b := numbers[idxNext]
23         <span style="color:#00f">if</span> a &gt; b {
24             numbers[idx] = b
25             numbers[idxNext] = a
26             swap = <span style="color:#00f">true</span>
27         }
28         idx++
29         idxNext = idx + 1
30     }
31     <span style="color:#00f">return</span> swap
32 }
33
34 <span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
35     org := []<span style="color:#00f">int</span>{1, 3, 2, 4, 8, 6, 7, 2, 3, 0}
36     fmt.<span style="color:#c34e00">Println</span>(org)
37
38     <span style="color:#c34e00">bubbleSort</span>(org)
39     fmt.<span style="color:#c34e00">Println</span>(org)
40 }
</code></pre></div><p>在L6里，给出了Go版本的冒泡排序。排序算法遍历每个值并在整数集上进行数据交替。根据初始顺序不同，排序可能需要多次的遍历。
Question: bubbleSort的workload适合无序执行吗？答案肯定是no。整数集可以分解成更小的lists并且这些lists可以并发地排序。但是所有并发工作完成之后，并没有一个有效的方式再去把这些小的lists排序到一起。这里是一个并发版本的冒泡排序。
<strong>L8</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">01 <span style="color:#00f">func</span> <span style="color:#c34e00">bubbleSortConcurrent</span>(goroutines <span style="color:#00f">int</span>, numbers []<span style="color:#00f">int</span>) {
02     totalNumbers := len(numbers)
03     lastGoroutine := goroutines - 1
04     stride := totalNumbers / goroutines
05
06     <span style="color:#00f">var</span> wg sync.WaitGroup
07     wg.<span style="color:#c34e00">Add</span>(goroutines)
08
09     <span style="color:#00f">for</span> g := 0; g &lt; goroutines; g++ {
10         <span style="color:#00f">go</span> <span style="color:#00f">func</span>(g <span style="color:#00f">int</span>) {
11             start := g * stride
12             end := start + stride
13             <span style="color:#00f">if</span> g == lastGoroutine {
14                 end = totalNumbers
15             }
16
17             <span style="color:#c34e00">bubbleSort</span>(numbers[start:end])
18             wg.<span style="color:#c34e00">Done</span>()
19         }(g)
20     }
21
22     wg.<span style="color:#c34e00">Wait</span>()
23
24     <span style="color:#f00;font-style:italic">// Ugh, we have to sort the entire list again.
</span><span style="color:#f00;font-style:italic"></span>25     <span style="color:#c34e00">bubbleSort</span>(numbers)
26 }
</code></pre></div><h2 id="读取文件">L8中，bubbleSortConcurrent方法是bubbleSort的并发版本。它使用多个Goroutines去并发地排序整个整数集的一部分。结果你得到的是各自的排序的list。结果你最终在25行还是要整个list做一次排序。
因为冒泡排序的本质就是遍历整个list。25行调用bubbleSort直接否定了任何并发的潜在收益。冒泡排序里，使用并发并没有性能上的增益。
<strong>读取文件</strong></h2>
<p>我们给出了2个CPU-Bound类型的workloads，那么IO-Bound类型的workload情况是什么样的？当Goroutines自动进入或者是离开waiting状态，情况会有什么不同么？看一个IO-bound类型的workload，它的工作内容是读取文件并查找文本。
第一个版本是一个有序版本的find方法
<strong>L10</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">42 <span style="color:#00f">func</span> <span style="color:#c34e00">find</span>(topic <span style="color:#00f">string</span>, docs []<span style="color:#00f">string</span>) <span style="color:#00f">int</span> {
43     <span style="color:#00f">var</span> found <span style="color:#00f">int</span>
44     <span style="color:#00f">for</span> _, doc := <span style="color:#00f">range</span> docs {
45         items, err := <span style="color:#c34e00">read</span>(doc)
46         <span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
47             <span style="color:#00f">continue</span>
48         }
49         <span style="color:#00f">for</span> _, item := <span style="color:#00f">range</span> items {
50             <span style="color:#00f">if</span> strings.<span style="color:#c34e00">Contains</span>(item.Description, topic) {
51                 found++
52             }
53         }
54     }
55     <span style="color:#00f">return</span> found
56 }
</code></pre></div><p>在L10里面，你看到一个有序版本的find函数。line 43定义了一个found变量去存topic在文档里的出现次数。line 44，对所有文档进行遍历，并且在45行上使用read方法对每个doc进行读取。最后从49&ndash;53行，使用strings包的Contains方法去检查topic是否在读取到的items里面。如果发现，found变量就对应加一。
这里是find调用的read方法的实现。
<strong>L11</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">33 <span style="color:#00f">func</span> <span style="color:#c34e00">read</span>(doc <span style="color:#00f">string</span>) ([]item, <span style="color:#00f">error</span>) {
34     time.<span style="color:#c34e00">Sleep</span>(time.Millisecond) <span style="color:#f00;font-style:italic">// Simulate blocking disk read.
</span><span style="color:#f00;font-style:italic"></span>35     <span style="color:#00f">var</span> d document
36     <span style="color:#00f">if</span> err := xml.<span style="color:#c34e00">Unmarshal</span>([]byte(file), &amp;d); err != <span style="color:#00f">nil</span> {
37         <span style="color:#00f">return</span> <span style="color:#00f">nil</span>, err
38     }
39     <span style="color:#00f">return</span> d.Channel.Items, <span style="color:#00f">nil</span>
40 }
</code></pre></div><p>read方法以一个time.Sleep方法开始。这个里模拟了真实从硬盘读取文档的系统调用所产生的延迟。设置这个延迟对我们精确地测试有序版本和并发版本find方法的性能差异十分重要。然后在35&ndash;39行，测试的xml文档存储在fine的全局变量里，它被反序列化成一个要去处理的struct。最后返回了一个items的集合。
下面是一个并发版本代码。
注意：有多种方式去写并发版本代码，不要纠结于这个代码本身实现。
<strong>L12</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">58 <span style="color:#00f">func</span> <span style="color:#c34e00">findConcurrent</span>(goroutines <span style="color:#00f">int</span>, topic <span style="color:#00f">string</span>, docs []<span style="color:#00f">string</span>) <span style="color:#00f">int</span> {
59     <span style="color:#00f">var</span> found <span style="color:#00f">int64</span>
60
61     ch := make(<span style="color:#00f">chan</span> <span style="color:#00f">string</span>, len(docs))
62     <span style="color:#00f">for</span> _, doc := <span style="color:#00f">range</span> docs {
63         ch &lt;- doc
64     }
65     close(ch)
66
67     <span style="color:#00f">var</span> wg sync.WaitGroup
68     wg.<span style="color:#c34e00">Add</span>(goroutines)
69
70     <span style="color:#00f">for</span> g := 0; g &lt; goroutines; g++ {
71         <span style="color:#00f">go</span> <span style="color:#00f">func</span>() {
72             <span style="color:#00f">var</span> lFound <span style="color:#00f">int64</span>
73             <span style="color:#00f">for</span> doc := <span style="color:#00f">range</span> ch {
74                 items, err := <span style="color:#c34e00">read</span>(doc)
75                 <span style="color:#00f">if</span> err != <span style="color:#00f">nil</span> {
76                     <span style="color:#00f">continue</span>
77                 }
78                 <span style="color:#00f">for</span> _, item := <span style="color:#00f">range</span> items {
79                     <span style="color:#00f">if</span> strings.<span style="color:#c34e00">Contains</span>(item.Description, topic) {
80                         lFound++
81                     }
82                 }
83             }
84             atomic.<span style="color:#c34e00">AddInt64</span>(&amp;found, lFound)
85             wg.<span style="color:#c34e00">Done</span>()
86         }()
87     }
88
89     wg.<span style="color:#c34e00">Wait</span>()
90
91     <span style="color:#00f">return</span> int(found)
92 }
</code></pre></div><p>L12是find方法的并发版本。并发版本有30行代码，而非并发版本代码只有13行。我的目标是处理未知数量的documents时候控制Goroutines的数量。这里我选择在池化模式里使用一个channel去给池子里的goroutines喂数据。
这部分代码比较多，我只讲解重要部分
Line 61-64: 创建一个channel去处理所有的documents。
Line 65 关闭这个channel，来让池子里的goroutines在所有documents处理完成后能自动停止。
Line 70:创建一个goroutines线程池
Line 73&ndash;83:每一个池子里的goroutine从channel接受一个document，读取到内存然后检查内容是否有topic。匹配的话,lfound就加一个。
Line 84:把每个单独goroutines跑出来的数加到一起。
并发版本确实比有序版本代码更加复杂，这个复杂性是否值得？验证的最好方式就是再次写一个benchmark。我用了1000个documents的集合，并且关闭了垃圾回收。一个是顺序版本find，一个是并发版本findConcurrent
<strong>L13</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00f">func</span> <span style="color:#c34e00">BenchmarkSequential</span>(b *testing.B) {
    <span style="color:#00f">for</span> i := 0; i &lt; b.N; i++ {
        <span style="color:#c34e00">find</span>(<span style="color:#009c00">&#34;test&#34;</span>, docs)
    }
}

<span style="color:#00f">func</span> <span style="color:#c34e00">BenchmarkConcurrent</span>(b *testing.B) {
    <span style="color:#00f">for</span> i := 0; i &lt; b.N; i++ {
        <span style="color:#c34e00">findConcurrent</span>(runtime.<span style="color:#c34e00">NumCPU</span>(), <span style="color:#009c00">&#34;test&#34;</span>, docs)
    }
}
</code></pre></div><p>L13给出了benchmark。下面是当所有goroutines只有一个OS/硬件线程的时候。顺序代码使用1个goroutines，而并发版本是runtime.NumCPU的数，在我本机上是8。这种情况下，我们没用并行去做并发。
<strong>L14</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">10 Thousand Documents using 8 goroutines with 1 core
2.9 GHz Intel 4 Core i7
Concurrency WITHOUT Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -cpu 1 -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/io-bound
BenchmarkSequential      	       3	1483458120 ns/op
BenchmarkConcurrent      	      20	 188941855 ns/op : ~87% Faster
BenchmarkSequentialAgain 	       2	1502682536 ns/op
BenchmarkConcurrentAgain 	      20	 184037843 ns/op : ~88% Faster
</code></pre></div><p>L14里面表明了，在只有一个单独OS/硬件线程的时候，并发版本大概要比顺序版本代码快87%&ndash;%88。这是我们预料到的因为每个Goroutines都能有效的共享这一个OS/硬件线程。在read调用的时候每个goroutines能够自动进行上下文切换，这样OS/硬件线程会一直有事情做。
下面是使用并行去做并发处理。
L15</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">10 Thousand Documents using 8 goroutines with 1 core
2.9 GHz Intel 4 Core i7
Concurrency WITH Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/io-bound
BenchmarkSequential-8        	       3	1490947198 ns/op
BenchmarkConcurrent-8        	      20	 187382200 ns/op : ~88% Faster
BenchmarkSequentialAgain-8   	       3	1416126029 ns/op
BenchmarkConcurrentAgain-8   	      20	 185965460 ns/op : ~87% Faster
</code></pre></div><h2 id="结论">L15的benchmark结果说明，额外的OS/硬件线程并没有提供更好的性能。
<strong>结论</strong></h2>
<p>这篇文章的目的就是让你知道什么时候你的workload适合使用并发。考虑到不同的场景，我给出了不同的例子。
你可以清楚的看到IO-Bound类型的workload并不需要使用并行处理去获得性能的大幅增加，这正好跟CPU-Bound类型的工作截然相反。像类似冒泡算法这种，使用并发其实会增加代码复杂度，而且不会有任何性能增益。所以，一定要确定你的workload是否适合使用并发场景，这是很重要的事情。</p>
<p>原文链接：<a href="https://juejin.cn/post/6844903847568080904">www.ardanlabs.com/blog/2018/1…</a></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/04/%E8%AF%A6%E8%A7%A3go%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" rel="next" title="详解Go逃逸分析">
        <i class="fa fa-chevron-left"></i> 详解Go逃逸分析
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/04/%E7%90%86%E8%A7%A3golang%E8%B0%83%E5%BA%A6%E4%B9%8B%E4%BA%8C-go%E8%B0%83%E5%BA%A6%E5%99%A8/" rel="prev" title="理解golang调度之二 ：Go调度器">
        理解golang调度之二 ：Go调度器 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">563</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">45</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">50</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>