<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>一文吃透 Go 语言解密之接口 interface - 愿星光伴你左右</title>
    <meta name="keywords" content="愿星光伴你左右,openresty,nginx,Lua,lua,Golang,go">
    
    <meta property="og:title" content="一文吃透 Go 语言解密之接口 interface">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="一文吃透 Go 语言解密之接口 interface - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />about me
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-go-%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%AF%86%E4%B9%8B%E6%8E%A5%E5%8F%A3-interface/" itemprop="url">
        一文吃透 Go 语言解密之接口 interface
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-15">
    2021-04-15
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">4862 字 ~10分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="一文吃透-go-语言解密之接口-interface">一文吃透 Go 语言解密之接口 interface</h2>
<p><a href="https://mp.weixin.qq.com/s/vSgV_9bfoifnh2LEX0Y7cQ">转载自煎鱼的blog</a></p>
<p>自古流传着一个传言&hellip;在 Go 语言面试的时候必有人会问接口（interface）的实现原理。这又是为什么？为何对接口如此执着？</p>
<p>实际上，Go 语言的接口设计在整体扮演着非常重要的角色，没有他，很多程序估计都跑的不愉快了。</p>
<p>在 Go 语言的语义上，只要某个类型实现了所定义的一组方法集，则就认为其就是同一种类型，是一个东西。大家常常称其为鸭子类型（Duck typing），因为其与鸭子类型类型的定义相对吻合。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8Binterface2/1.jpg" alt="img"></p>
<p>在维基百科中，鸭子类型的谚语定义为 ”If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.“，翻译过来就是 ”如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那他就可以认为是鸭子“。</p>
<p>回归到 Go 语言，在接口之下，接口又蕴含了怎么样的底层结构，其设计原理和思考又是什么呢？我们不能只看表面，接下来在这一章节中都会进行一一分析和道来。看看其深层到底是何 “物”。</p>
<p>本文目录：</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8Binterface2/2.jpg" alt="img"></p>
<h2 id="什么是-interface">什么是 interface</h2>
<p>Go 语言中的接口声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type Human interface {
 Say(s string) error
}
</code></pre></div><p>关键字主体为 <code>type xxx interface</code>，紧接着可以在方括号中编写方法集，用于声明和定义该接口所包含的方法集。</p>
<p>更进一步的代码演示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type Human interface {
 Say(s string) error
}

type TestA string

func (t TestA) Say(s string) error {
 fmt.Printf(&#34;煎鱼：%s\n&#34;, s)
 return nil
}

func main() {
 var h Human
 var t TestA
 _ = t.Say(&#34;炸鸡翅&#34;)
 h = t
 _ = h.Say(&#34;烤羊排&#34;)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">煎鱼：炸鸡翅
煎鱼：烤羊排
</code></pre></div><p>我们在上述代码中，声明了一个名为 <code>Human</code> 的 <code>interface</code>，其包含一个 <code>Say</code> 方法。同时我们声明了一个 <code>TestA</code> 类型，也有自己的一个 <code>Say</code> 方法。他们两者的方法入参和出参类型均为一样。</p>
<p>而与此同时，我们在主函数 <code>main</code> 中通过声明和赋值，成功将类型为 <code>TestA</code> 的变量 <code>t</code> 赋给了类型为 <code>Human</code> 的变量 <code>h</code>，也就是说两者只因有了个 <code>Say</code> 方法，在 Go 语言的编译器中就认为他们是 “一样” 的了，这也就是业界中常说的鸭子类型。</p>
<h2 id="数据结构">数据结构</h2>
<p>通过上面的功能代码一看，似乎 Go 语言非常优秀。一个接口，不同的类型，2 个包含相同的方法，也能够对标到一起。</p>
<p>接口到底是怎么实现的呢？底层数据结构又是什么？带着问题，我们开始深挖细节之路。</p>
<p>在 Go 语言中，接口的底层数据结构在运行时一共分为两类结构<img src="3.jpg" alt="3">体（struct），分别是：</p>
<ul>
<li><code>runtime.eface</code> 结构体：表示不包含任何方法的空接口，也称为 empty interface。</li>
<li><code>runtime.iface</code> 结构体：表示包含方法的接口。</li>
</ul>
<h4 id="runtimeeface">runtime.eface</h4>
<p>首先我们来介绍 <code>eface</code>，看看 “他” 到底是何许人也。源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type eface struct {
 _type *_type
 data  unsafe.Pointer
}
</code></pre></div><p>其表示不包含任何方法的空接口。在结构上来讲 <code>eface</code> 非常简单，就两个属性，分别是 <code>_type</code> 和 <code>data</code> 属性，分别代表底层的指向的类型信息和指向的值信息指针。</p>
<p>再进一步到 <code>type</code> 属性里看看，其包含的类型信息更多：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type _type struct {
 size       uintptr
 ptrdata    uintptr 
 hash       uint32
 tflag      tflag
 align      uint8
 fieldAlign uint8
 kind       uint8
 equal func(unsafe.Pointer, unsafe.Pointer) bool
 gcdata    *byte
 str       nameOff
 ptrToThis typeOff
}
</code></pre></div><ul>
<li>size：类型的大小。</li>
<li>ptrdata：包含所有指针的内存前缀的大小。</li>
<li>hash：类型的 hash 值。此处提前计算好，可以避免在哈希表中计算。</li>
<li>tflag：额外的类型信息标志。此处为类型的 flag 标志，主要用于反射。</li>
<li>align：对应变量与该类型的内存对齐大小。</li>
<li>fieldAlign：对应类型的结构体的内存对齐大小。</li>
<li>kind：类型的枚举值。包含 Go 语言中的所有类型，例如：<code>kindBool</code>、<code>kindInt</code>、<code>kindInt8</code>、<code>kindInt16</code> 等。</li>
<li>equal：用于比较此对象的回调函数。</li>
<li>gcdata：存储垃圾收集器的 GC 类型数据。</li>
</ul>
<p>总结一句，就是类型信息所需的信息都会存储在这里面，其中包含字节大小、类型标志、内存对齐、GC 等相关属性。而在 <code>eface</code> 来讲，其由于没有方法集的包袱，因此只需要存储类型和值信息的指针即可，非常简单。</p>
<h4 id="runtimeiface">runtime.iface</h4>
<p>其次就是我们日常在应用程序中应用的较多的 <code>iface</code>，源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type iface struct {
 tab  *itab
 data unsafe.Pointer
}
</code></pre></div><p>与 <code>eface</code> 结构体类型一样，主要也是分为类型和值信息，分别对应 <code>tab</code> 和 <code>data</code> 属性。但是我们再加思考一下，为什么 <code>iface</code> 能藏住那么多的方法集呢，难道施了黑魔法？</p>
<p>为了解密，我们进一步深入看看 <code>itab</code> 结构体。源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type itab struct {
 inter *interfacetype
 _type *_type
 hash  uint32 
 _     [4]byte
 fun   [1]uintptr 
}
</code></pre></div><ul>
<li><code>inter</code>：接口的类型信息。</li>
<li><code>_type</code>：具体类型信息</li>
<li><code>hash</code>：<code>_type.hash</code> 的副本，用于目标类型和接口变量的类型对比判断。</li>
<li><code>fun</code>：底层数组，存储接口的方法集的具体实现的地址，其包含一组函数指针，实现了接口方法的动态分派，且每次在接口发生变更时都会更新。</li>
</ul>
<p>对应 <code>func</code> 属性会在后面的章节进一步展开讲解，便于大家对于接口中的函数指针管理的使用和理解，在此可以先行思考长度为 1 的 uintptr 数组是如何做到存储多方法的？</p>
<p>接下来我们进一步展开 <code>interfacetype</code> 结构体。源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type nameOff int32
type typeOff int32

type imethod struct {
 name nameOff
 ityp typeOff
}

type interfacetype struct {
 typ     _type
 pkgpath name
 mhdr    []imethod
}
</code></pre></div><ul>
<li><code>_type</code>：接口的具体类型信息。</li>
<li><code>pkgpath</code>：接口的包（package）名信息。</li>
<li><code>mhdr</code>：接口所定义的函数列表。</li>
</ul>
<p>而相对应 <code>interfacetype</code>，还有各种类型的 <code>type</code>。例如：<code>maptype</code>、<code>arraytype</code>、<code>chantype</code>、<code>slicetype</code> 等，都是针对具体的类型做的具体类型定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type arraytype struct {
 typ   _type
 elem  *_type
 slice *_type
 len   uintptr
}

type chantype struct {
 typ  _type
 elem *_type
 dir  uintptr
}
...
</code></pre></div><p>若有兴趣自行翻看 <code>runtime</code> 里相应源码即可，都是一些基本数据结构信息的存储和配套方法，就不在此一一展开讲解了。</p>
<h4 id="小结">小结</h4>
<p><img src="http://shanks.link/img/Go%E4%B9%8Binterface2/4.jpg" alt="img"></p>
<p>总结来讲，接口的数据结构基本表示形式比较简单，就是类型和值描述。再根据其具体的区别，例如是否包含方法集，具体的接口类型等进行组合使用。</p>
<h2 id="值接收者和指针接收者">值接收者和指针接收者</h2>
<p>在接口的具体应用使用场景中，有一个是大家常常会碰到，甚至会对其产生较大纠结心里的东西。那就是到底用值接收者，又或是用指针接收者来声明。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8Binterface2/5.jpg" alt="img"></p>
<h3 id="演示说明">演示说明</h3>
<p>演示代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type Human interface {
 Say(s string) error
 Eat(s string) error
}

type TestA struct{}

func (t TestA) Say(s string) error {
 fmt.Printf(&#34;说煎鱼：%s\n&#34;, s)
 return nil
}

func (t *TestA) Eat(s string) error {
 fmt.Printf(&#34;吃煎鱼：%s\n&#34;, s)
 return nil
}

func main() {
 var h Human = &amp;TestA{}
 _ = h.Say(&#34;催更&#34;)
 _ = h.Eat(&#34;真香&#34;)
}
</code></pre></div><p>在 <code>Human</code> 接口中，其包含 <code>Say</code> 和 <code>Eat</code> 方法，并且在 <code>TestA</code> 结构体中我们进行了针对性的实现。</p>
<p>具体的区别就是：</p>
<ul>
<li>在 <code>Say</code> 方法中是值接收对象，如：<code>(t TestA)</code>。</li>
<li>在 <code>Eat</code> 方法中是指针接收对象，如：<code>(t *TestA)</code>。</li>
</ul>
<p>最终的输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">说煎鱼：催更
吃煎鱼：真香
</code></pre></div><h3 id="值和指针">值和指针</h3>
<p>如果我们将演示代码的主函数 main 改成下述这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">func main() {
 var h Human = TestA{}
 _ = h.Say(&#34;催更&#34;)
 _ = h.Eat(&#34;真香&#34;)
}
</code></pre></div><p>你觉得这段代码还能正常运行吗？在编译时会出现如下报错信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"># command-line-arguments
./main.go:23:6: cannot use TestA literal (type TestA) as type Human in assignment:
 TestA does not implement Human (Eat method has pointer receiver)
</code></pre></div><p>显然是不能的。因为接口校验不对，编译器过不了。其根本原因在于 <code>Eat</code> 是指针接收者。而当声明改为 <code>TestA{}</code> 后，其就会变成值对象，所以不匹配。</p>
<p>这时候又会出现新的问题，为什么在上面代码声明为 <code>&amp;TestA{}</code> 时，那肯定是指针引用了，那为什么 <code>Say</code> 方法又能正常运行，不会报错呢？</p>
<p>其实 <code>TestA{}</code> 实现了 <code>Say</code> 方法，那么 <code>&amp;TestA{}</code> 也能自动拥有该方法。显然，这是 Go 语言自身在背后做了一些事情。</p>
<p>因此如果我们实现了一个值对象的接收者时，也会相应拥有了一个指针接收者。两者并不会互相影响，因为值对象会产生值拷贝，对象会独立开来。</p>
<p>而指针对象的接收者不行，因为指针引用的对象，在应用上是期望能够直接对源接收者的值进行修改，若又支持值接收者，显然是不符合其语义的。</p>
<h3 id="两者怎么用">两者怎么用</h3>
<p>既然支持值接收，又支持指针接收。那平时在工程应用开发中，到底用谁？还是说随便用？</p>
<p>其实问题的答案，在前面就有提到。本质上还是要看你业务逻辑所期望修改的是什么？还是说程序很严谨，每次都重新 <code>new</code> 一个，是值又或是指针引用对于程序逻辑的结果都没有任何的影响。</p>
<p>总结一下，如果你想使用指针接收者，可以想想是否有以下诉求：</p>
<ul>
<li>期望接收者直接修改能够直接修改源值。</li>
<li>期望在大结构体的情况下，性能更好，可以在理论上避免每次值拷贝，但也会有增加别的开销，需要具体情况具体权衡。</li>
</ul>
<p>但若应用场景没什么区别，只是个人习惯问题就不用过于纠结了，适度统一也是很重要的一环。</p>
<h2 id="类型断言">类型断言</h2>
<p>在 Go 语言中使用接口，必搭配一个 “技能”。那就是进行类型断言（type assertion）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">var i interface{} = &#34;吃煎鱼&#34;

// 进行变量断言，若不判断容易出现 panic
s := i.(string)

// 进行安全断言
s, ok := i.(string)
</code></pre></div><p>在 <code>switch case</code> 中，还有另外一种写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">var i interface{} = &#34;炸煎鱼&#34;

// 进行 switch 断言
switch i.(type) {
case string:
    // do something...
case int:
    // do something...
case float64:
    // do something...
}
</code></pre></div><p>采取的是 <code>(变量).(type)</code> 的调用方式，再给予 <code>case</code> 不同的类型进行判断识别。在 Go 语言的背后，类型断言其实是在编译器翻译后，根据 <code>iface</code> 和 <code>eface</code> 分别对应了下述方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) {
 tab := i.tab
 if tab == nil {
  return
 }
 if tab.inter != inter {
  tab = getitab(inter, tab._type, true)
  if tab == nil {
   return
  }
 }
 r.tab = tab
 r.data = i.data
 b = true
 return
}
func assertI2I(inter *interfacetype, i iface) (r iface)

func assertE2I2(inter *interfacetype, e eface) (r iface, b bool)
func assertE2I(inter *interfacetype, e eface) (r iface)
</code></pre></div><p>主要是根据接口的类型信息进行一轮判断和识别，基本就完成了。主要核心在于 <code>getitab</code> 方法，会在后面进行统一介绍和说明。</p>
<h2 id="类型转换">类型转换</h2>
<p>演示代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">func main() {
 x := &#34;煎鱼&#34;
 var v interface{} = x
 fmt.Println(v)
}
</code></pre></div><p>查看汇编代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"> 0x0021 00033 (main.go:9) LEAQ go.string.&#34;煎鱼&#34;(SB), AX
 0x0028 00040 (main.go:9) MOVQ AX, (SP)
 0x002c 00044 (main.go:9) MOVQ $6, 8(SP)
 0x0035 00053 (main.go:9) PCDATA $1, $0
 0x0035 00053 (main.go:9) CALL runtime.convTstring(SB)
 0x003a 00058 (main.go:9) MOVQ 16(SP), AX
 0x003f 00063 (main.go:10) XORPS X0, X0
</code></pre></div><p>主要对应了 <code>runtime.convTstring</code> 方法。同时很显然其是根据类型来区分来方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">func convTstring(val string) (x unsafe.Pointer) {
 if val == &#34;&#34; {
  x = unsafe.Pointer(&amp;zeroVal[0])
 } else {
  x = mallocgc(unsafe.Sizeof(val), stringType, true)
  *(*string)(x) = val
 }
 return
}

func convT16(val uint16) (x unsafe.Pointer)
func convT32(val uint32) (x unsafe.Pointer)
func convT64(val uint64) (x unsafe.Pointer)
func convTstring(val string) (x unsafe.Pointer) 
func convTslice(val []byte) (x unsafe.Pointer)
func convT2Enoptr(t *_type, elem unsafe.Pointer) (e eface)
func convT2I(tab *itab, elem unsafe.Pointer) (i iface)
...
</code></pre></div><h2 id="动态分派">动态分派</h2>
<p>前面有提到接口中的 <code>fun [1]uintptr</code> 属性会可以存储接口的方法集，但不知道为什么。</p>
<p>接下来我们将进行具体的分析，演示代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">type Human interface {
 Say(s string) error
 Eat(s string) error
 Walk(s string) error
}

type TestA string

func (t TestA) Say(s string) error {
 fmt.Printf(&#34;煎鱼：%s\n&#34;, s)
 return nil
}
func (t TestA) Eat(s string) error {
 fmt.Printf(&#34;煎鱼：%s\n&#34;, s)
 return nil
}

func (t TestA) Walk(s string) error {
 fmt.Printf(&#34;煎鱼：%s\n&#34;, s)
 return nil
}

func main() {
 var h Human
 var t TestA
 h = t
 _ = h.Eat(&#34;烤羊排&#34;)
 _ = h.Say(&#34;炸鸡翅&#34;)
 _ = h.Walk(&#34;去炸鸡翅&#34;)
}
</code></pre></div><h3 id="存储方式">存储方式</h3>
<p>执行 <code>go build -gcflags '-l' -o awesomeProject .</code> 编译后，再次执行 <code>go tool objdump -s &quot;main&quot; awesomeProject</code>。</p>
<p>查看具体的汇编代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">  LEAQ go.itab.main.TestA,main.Human(SB), AX 
  TESTB AL, 0(AX)     
  MOVQ 0x10(SP), AX    
  MOVQ AX, 0x28(SP)    
  MOVQ go.itab.main.TestA,main.Human+32(SB), CX 
  MOVQ AX, 0(SP)     
  LEAQ go.string.*+3048(SB), DX   
  MOVQ DX, 0x8(SP)    
  MOVQ $0x9, 0x10(SP)    
  CALL CX      
  MOVQ go.itab.main.TestA,main.Human+24(SB), AX 
  MOVQ 0x28(SP), CX    
  MOVQ CX, 0(SP)     
  LEAQ go.string.*+3057(SB), DX   
  MOVQ DX, 0x8(SP)    
  MOVQ $0x9, 0x10(SP)    
  CALL AX      
  MOVQ go.itab.main.TestA,main.Human+40(SB), AX 
  MOVQ 0x28(SP), CX    
  MOVQ CX, 0(SP)     
  LEAQ go.string.*+4973(SB), CX   
  MOVQ CX, 0x8(SP)    
  MOVQ $0xc, 0x10(SP)    
  CALL AX   
</code></pre></div><p>结合来看，虽然 <code>fun</code> 属性的类型是 <code>[1]uintptr</code>，只有一个元素，但其实就是存放了接口方法集的首个方法的地址信息,接着根据顺序往后计算并获取就好了。也就是说其是存在一定规律的。在存入方法时就决定了，所以获取也能明确。</p>
<p>我们进一步展开，看看 itab hash table 是如何获取和新增的。</p>
<h3 id="获取-itab-元素">获取 itab 元素</h3>
<p><code>getitab</code> 方法的主要作用是获取 <code>itab</code> 元素，若不存在则新增。源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
 // 省略一些边界、异常处理
 var m *itab

 t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&amp;itabTable)))
 if m = t.find(inter, typ); m != nil {
  goto finish
 }

 lock(&amp;itabLock)
 if m = itabTable.find(inter, typ); m != nil {
  unlock(&amp;itabLock)
  goto finish
 }

 m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))
 m.inter = inter
 m._type = typ
 m.hash = 0
 m.init()
 itabAdd(m)
 unlock(&amp;itabLock)
finish:
 if m.fun[0] != 0 {
  return m
 }

 panic(&amp;TypeAssertionError{concrete: typ, asserted: &amp;inter.typ, missingMethod: m.init()})
}
</code></pre></div><ul>
<li>
<p>调用 <code>atomic.Loadp</code> 方法加载并查找现有的 itab hash table，看看是否是否可以找到所需的 itab 元素。</p>
</li>
<li>
<p>若没有找到，则调用 <code>lock</code> 方法对 <code>itabLock</code> 上锁，并进行重试（再一次查找）。</p>
</li>
<li>
<ul>
<li>若找到，则跳到 <code>finish</code> 标识的收尾步骤。</li>
<li>若没有找到，则新生成一个 itab 元素，并调用 <code>itabAdd</code> 方法新增到全局的 hash table 中。</li>
</ul>
</li>
<li>
<p>返回 <code>fun</code> 属性的首位地址，继续后续业务逻辑。</p>
</li>
</ul>
<h3 id="新增-itab-元素">新增 itab 元素</h3>
<p><code>itabAdd</code> 方法的主要作用是将所生成好的 <code>itab</code> 元素新增到 itab hash table 中。源码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">func itabAdd(m *itab) {
 // 省略一些边界、异常处理
 t := itabTable
 if t.count &gt;= 3*(t.size/4) { // 75% load factor
  t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true))
  t2.size = t.size * 2
  iterate_itabs(t2.add)
  if t2.count != t.count {
   throw(&#34;mismatched count during itab table copy&#34;)
  }

  atomicstorep(unsafe.Pointer(&amp;itabTable), unsafe.Pointer(t2))
  t = itabTable
 }
 t.add(m)
}
</code></pre></div><ul>
<li>检查 itab hash table 的容量情况，查看容量情况是否已经满足大于或等于 75%。</li>
<li>若满足扩容策略，则调用 <code>mallocgc</code> 方法申请内存，按既有 <code>size</code> 大小扩容双倍容量。</li>
<li>若不满足扩容策略，则直接新增 <code>itab</code> 元素到 hash table 中。</li>
</ul>
<h2 id="总结">总结</h2>
<p>在本文中，我们先介绍了 Go 语言接口的 <code>runtime.eface</code> 和 <code>runtime.iface</code> 两个基本数据结构，其代表了一切的开端。</p>
<p>随后针对值接受者和指针接收者进行了详细的说明，同时日常用的较多的类型断言和转换也一一进行了描述。</p>
<p>最后对接口的多方法这个神秘的地方进行了基本分析和了解，相信这一番轮流吸收下来，能够打开大家对接口的一个新的理解。</p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%90%83%E9%80%8F-go-%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%AF%86%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87-context/" rel="next" title="一文吃透 Go 语言解密之上下文 context">
        <i class="fa fa-chevron-left"></i> 一文吃透 Go 语言解密之上下文 context
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/15/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E8%A7%A3%E5%AF%86-go-%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%80%9A%E9%81%93-channel/" rel="prev" title="一文带你解密 Go 语言之通道 channel">
        一文带你解密 Go 语言之通道 channel <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">387</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">19</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">26</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.92.1</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>