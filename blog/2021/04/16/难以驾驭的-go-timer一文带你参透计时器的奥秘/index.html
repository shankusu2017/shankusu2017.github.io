<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>难以驾驭的 Go timer，一文带你参透计时器的奥秘 - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="难以驾驭的 Go timer，一文带你参透计时器的奥秘">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="难以驾驭的 Go timer，一文带你参透计时器的奥秘 - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/04/16/%E9%9A%BE%E4%BB%A5%E9%A9%BE%E9%A9%AD%E7%9A%84-go-timer%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%8F%82%E9%80%8F%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E5%A5%A5%E7%A7%98/" itemprop="url">
        难以驾驭的 Go timer，一文带你参透计时器的奥秘
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-04-16">
    2021-04-16
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">5033 字 ~11分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://mp.weixin.qq.com/s/gxX-q2EvgWZEWe-deRITSw">转载自煎鱼的blog</a></p>
<p>#Go进阶之旅1</p>
<p>大家好，我是煎鱼。久违的源码剖析系列，让我们一起努力，看看谁能坚持到最后，因为学习一定是给能够坚持重复啃和热衷于<strong>三连</strong>的人。</p>
<p>接下来正式开始今天的内容讲解，今天的男主角是计时器 timer。</p>
<p>在实际的应用工程中，我们常常会需要多久后，或定时去做某个事情。甚至在分析标准库 context 的父子级传播时，都能见到等待多久后自动触发取消事件的踪影。</p>
<p>而在 Go 语言中，能够完成这类运行的功能诉求就是标准库 time，在具体的功能范畴上我们称其为 “计时器“，是一个非常具有价值的一个模块。在这篇文章中我们将对其做进一步的分析和研讨。</p>
<h2 id="什么是-timer">什么是 timer</h2>
<p>可以控制时间，确保应用程序中的某段代码在某个时刻运行。在 Go 语言中可以单次执行，也可以循环执行。</p>
<p>最常见的方式就是引用标准库 <code>time</code> 去做一些事情，普通开发者经常使用到的标准库代码是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>time.Now().Unix()
</span></span></code></pre></div><p>上述代码可用于获取当前时间的 <code>Unix</code> 时间戳，而在内部的具体实现上提供了<code>Time</code>、<code>Timer</code> 以及 <code>Ticker</code> 的各类配套方法。</p>
<h2 id="timer-基本特性">timer 基本特性</h2>
<h3 id="timer">Timer</h3>
<p>演示代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func main() {
</span></span><span style="display:flex;"><span> timer := time.NewTimer(2 * time.Second)
</span></span><span style="display:flex;"><span> &lt;-timer.C
</span></span><span style="display:flex;"><span> fmt.Println(&#34;我的脑子真的进煎鱼了！&#34;)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 等待两秒...
</span></span><span style="display:flex;"><span>我的脑子真的进煎鱼了！
</span></span></code></pre></div><p>我们可以通过 <code>time.NewTimer</code> 方法定时在 2 秒进行程序的执行。而其还有个变种的用法，在做 channel 的源码剖析时有发现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func main() {
</span></span><span style="display:flex;"><span> v := make(chan struct{})
</span></span><span style="display:flex;"><span> timer := time.AfterFunc(2*time.Second, func() {
</span></span><span style="display:flex;"><span>  fmt.Println(&#34;我想在这个点吃煎鱼！&#34;)
</span></span><span style="display:flex;"><span>  v &lt;- struct{}{}
</span></span><span style="display:flex;"><span> })
</span></span><span style="display:flex;"><span> defer timer.Stop()
</span></span><span style="display:flex;"><span> &lt;-v
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在等待 2 秒后，会立即调用 <code>time.AfterFunc</code> 所对应的匿名方法。在时间上我们也可以指定对应的具体时间，达到异步的定时执行等诉求。</p>
<h3 id="ticker">Ticker</h3>
<p>演示代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func main() {
</span></span><span style="display:flex;"><span> ticker := time.NewTicker(time.Second)
</span></span><span style="display:flex;"><span> defer ticker.Stop()
</span></span><span style="display:flex;"><span> done := make(chan bool)
</span></span><span style="display:flex;"><span> go func() {
</span></span><span style="display:flex;"><span>  time.Sleep(10 * time.Second)
</span></span><span style="display:flex;"><span>  done &lt;- true
</span></span><span style="display:flex;"><span> }()
</span></span><span style="display:flex;"><span> for {
</span></span><span style="display:flex;"><span>  select {
</span></span><span style="display:flex;"><span>  case &lt;-done:
</span></span><span style="display:flex;"><span>   fmt.Println(&#34;Done!&#34;)
</span></span><span style="display:flex;"><span>   return
</span></span><span style="display:flex;"><span>  case t := &lt;-ticker.C:
</span></span><span style="display:flex;"><span>   fmt.Println(&#34;炸煎鱼: &#34;, t.Unix())
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 每隔一秒输出一次
</span></span><span style="display:flex;"><span>炸煎鱼:  1611666168
</span></span><span style="display:flex;"><span>炸煎鱼:  1611666169
</span></span><span style="display:flex;"><span>炸煎鱼:  1611666170
</span></span><span style="display:flex;"><span>炸煎鱼:  1611666171
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>我们通过 <code>time.NewTicker</code> 方法设定每 1 秒执行一次方法，因此在 <code>for-select</code> 中，我们会每 1 秒就可以自动 “炸一条煎鱼”，真是快乐极了。</p>
<p>而由于我们在 goroutine 中通过 <code>sleep</code> 方法的设定了 <code>done</code> 变量的输入，因此在 10 秒后就会结束炸煎鱼的循环输出，最终退出。</p>
<h2 id="最小堆四叉堆">最小堆：四叉堆</h2>
<p>在 Go 语言中，内置计时器的数据结构都会涉及到最小四叉堆，如下图所示：</p>
<p><img src="http://shanks.link/img/GoTimer/1.jpg" alt="img"></p>
<p>整体来讲就是父节点一定比其子节点小，子节点之间没有任何关系和大小的要求。</p>
<h2 id="数据结构">数据结构</h2>
<p>在 Go 语言中每个计时器运行时的基本单元是 <code>runtime.timer</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>type timer struct {
</span></span><span style="display:flex;"><span> pp puintptr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> when   int64
</span></span><span style="display:flex;"><span> period int64
</span></span><span style="display:flex;"><span> f      func(interface{}, uintptr)
</span></span><span style="display:flex;"><span> arg    interface{}
</span></span><span style="display:flex;"><span> seq    uintptr
</span></span><span style="display:flex;"><span> nextwhen int64
</span></span><span style="display:flex;"><span> status uint32
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>pp：计时器所在的处理器 P 的指针地址。</li>
<li>when：计时器被唤醒的时间。</li>
<li>period：计时器再次被唤醒的时间（when+period）。</li>
<li>f：回调函数，每次在计时器被唤醒时都会调用。</li>
<li>arg：回调函数的参数，每次在计时器被唤醒时会将该参数项传入回调函数 <code>f</code> 中。</li>
<li>seq：回调函数的参数，该参数仅在 <code>netpoll</code> 的应用场景下使用。</li>
<li>nextwhen：当计时器状态为 timerModifiedXX 时，将会使用 <code>nextwhen</code> 的值设置到 <code>where</code>字段上。</li>
<li>status：计时器的当前状态值，计时器本身包含大量的枚举标识，这块会在后面介绍。</li>
</ul>
<p>但这类基本单元都不会是对用户端暴露的结构体，在对外上我们直观见的最多的是 <code>time.NewTimer</code> 所创建的 <code>Timer</code> 结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>type Timer struct {
</span></span><span style="display:flex;"><span> C &lt;-chan Time
</span></span><span style="display:flex;"><span> r runtimeTimer
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>C：用于接收 <code>Timer</code> 所触发的事件，当计时器的消息事件（例如：到期）发生时，该 channel 会接收到通知。</li>
<li>r：与 <code>runtime.timer</code> 作用类似，内在属性保持一致。</li>
</ul>
<p>同时在计时器运行模式上自 Go1.14 起发生了变更，<code>runtime.timer</code> 改为将每个 <code>timer</code> 均存储在对应的处理器 P 中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>type p struct {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> timersLock mutex
</span></span><span style="display:flex;"><span> timers []*timer
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在处理器 P 上，<code>timers</code> 字段就是一个以最小四叉堆形式存储的媒介。在时序上，需要立刻执行，或说需要越早执行的，就越排在堆的越上面：</p>
<p><img src="http://shanks.link/img/GoTimer/2.jpg" alt="img"></p>
<h2 id="实现原理">实现原理</h2>
<p>在了解了计时器的基本特性和数据结构后，我们进一步展开，一层层剖析其原理，看看其是何物。在 Go 语言中，计时器在运行时涉及十种状态处理，分别涉及增、删、改以及重置等操作。</p>
<p>计时器所包含的状态如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">timerNoStatus</td>
<td style="text-align:left">计时器尚未设置状态</td>
</tr>
<tr>
<td style="text-align:left">timerWaiting</td>
<td style="text-align:left">等待计时器启动</td>
</tr>
<tr>
<td style="text-align:left">timerRunning</td>
<td style="text-align:left">运行计时器的回调方法</td>
</tr>
<tr>
<td style="text-align:left">timerDeleted</td>
<td style="text-align:left">计时器已经被删除，但仍然在某些 P 的堆中</td>
</tr>
<tr>
<td style="text-align:left">timerRemoving</td>
<td style="text-align:left">计时器即将被删除</td>
</tr>
<tr>
<td style="text-align:left">timerRemoved</td>
<td style="text-align:left">计时器已经停止，且不在任何 P 的堆中</td>
</tr>
<tr>
<td style="text-align:left">timerModifying</td>
<td style="text-align:left">计时器正在被修改</td>
</tr>
<tr>
<td style="text-align:left">timerModifiedEarlier</td>
<td style="text-align:left">计时器已被修改为更早的时间</td>
</tr>
<tr>
<td style="text-align:left">timerModifiedLater</td>
<td style="text-align:left">计时器已被修改为更晚的时间</td>
</tr>
<tr>
<td style="text-align:left">timerMoving</td>
<td style="text-align:left">计时器已经被修改，正在被移动</td>
</tr>
</tbody>
</table>
<p>这时候可能就会有小伙伴疑惑，各种启动、删除、停止、启动是指代的是什么意思？为什么会涉及到 P 的管理？</p>
<h3 id="创建计时器">创建计时器</h3>
<p>接下来我们依然是从 <code>NewTimer</code> 和 <code>NewTicker</code> 方法开始入手：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func NewTimer(d Duration) *Timer {
</span></span><span style="display:flex;"><span> c := make(chan Time, 1)
</span></span><span style="display:flex;"><span> t := &amp;Timer{
</span></span><span style="display:flex;"><span>  C: c,
</span></span><span style="display:flex;"><span>  r: runtimeTimer{
</span></span><span style="display:flex;"><span>   when: when(d),
</span></span><span style="display:flex;"><span>   f:    sendTime,
</span></span><span style="display:flex;"><span>   arg:  c,
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> startTimer(&amp;t.r)
</span></span><span style="display:flex;"><span> return t
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在该方法中，其主要包含如下动作：</p>
<ul>
<li>创建 <code>Timer</code> 对象，主要是 <code>C</code> 和 <code>r</code> 属性，含义与前面所表述的一致。</li>
<li>调用 <code>startTimer</code> 方法，启动计时器。</li>
</ul>
<p><code>NewTicker</code> 方法与 <code>NewTimer</code> 类似，主要是增加了 <code>period</code> 字段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func NewTicker(d Duration) *Ticker {
</span></span><span style="display:flex;"><span> c := make(chan Time, 1)
</span></span><span style="display:flex;"><span> t := &amp;Ticker{
</span></span><span style="display:flex;"><span>  C: c,
</span></span><span style="display:flex;"><span>  r: runtimeTimer{
</span></span><span style="display:flex;"><span>   when:   when(d),
</span></span><span style="display:flex;"><span>   period: int64(d),
</span></span><span style="display:flex;"><span>   f:      sendTime,
</span></span><span style="display:flex;"><span>   arg:    c,
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> startTimer(&amp;t.r)
</span></span><span style="display:flex;"><span> return t
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在 <code>Ticker</code> 结构体中，<code>period</code> 字段用于表示计时器再次被唤醒的时间，可以便于做轮询触发。</p>
<h3 id="启动计时器">启动计时器</h3>
<p>在前面调用 <code>NewTimer</code>、<code>NewTicker</code> 方法时，会将新创建的新计时器 <code>timer</code> 加入到创建 timer 的 P 的最小堆中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func addtimer(t *timer) {
</span></span><span style="display:flex;"><span> if t.when &lt; 0 {
</span></span><span style="display:flex;"><span>  t.when = maxWhen
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> if t.status != timerNoStatus {
</span></span><span style="display:flex;"><span>  throw(&#34;addtimer called with initialized timer&#34;)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> t.status = timerWaiting
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> when := t.when
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> pp := getg().m.p.ptr()
</span></span><span style="display:flex;"><span> lock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span> cleantimers(pp)
</span></span><span style="display:flex;"><span> doaddtimer(pp, t)
</span></span><span style="display:flex;"><span> unlock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> wakeNetPoller(when)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>检查是否满足基本条件：新增计时器的边界处理，<code>timerNoStatus</code> 状态判断排除。</li>
<li>调用 <code>cleantimers</code> 方法：清理处理器 P 中的计时器队列，可以加快创建和删除计时器的程序的速度。</li>
<li>调用 <code>doaddtimer</code> 方法：将当前所新创建的 <code>timer</code> 新增到当前处理器 P 的堆中。</li>
<li>调用 <code>wakeNetPoller</code> 方法：唤醒网络轮询器中休眠的线程，检查计时器被唤醒的时间（when）是否在当前轮询预期运行的时间（pollerPollUntil）内，若是唤醒。</li>
</ul>
<h3 id="停止计时器">停止计时器</h3>
<p>在计时器的运转中，一般会调用 <code>timer.Stop()</code> 方法来停止/终止/删除计时器。虽然说法多样。但大家的真实目的是一样的，就是让这个 <code>timer</code> 从轮询器中消失，也就是从处理器 P 的堆中移除 <code>timer</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func deltimer(t *timer) bool {
</span></span><span style="display:flex;"><span> for {
</span></span><span style="display:flex;"><span>  switch s := atomic.Load(&amp;t.status); s {
</span></span><span style="display:flex;"><span>  case timerWaiting, timerModifiedLater:
</span></span><span style="display:flex;"><span>   // timerWaiting/timerModifiedLater -&gt; timerDeleted
</span></span><span style="display:flex;"><span>   ...
</span></span><span style="display:flex;"><span>  case timerModifiedEarlier:
</span></span><span style="display:flex;"><span>      // timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted
</span></span><span style="display:flex;"><span>   ...
</span></span><span style="display:flex;"><span>  case timerDeleted, timerRemoving, timerRemoved:
</span></span><span style="display:flex;"><span>      // timerDeleted/timerRemoving/timerRemoved 
</span></span><span style="display:flex;"><span>   return false
</span></span><span style="display:flex;"><span>  case timerRunning, timerMoving:
</span></span><span style="display:flex;"><span>      // timerRunning/timerMoving
</span></span><span style="display:flex;"><span>   osyield()
</span></span><span style="display:flex;"><span>  case timerNoStatus:
</span></span><span style="display:flex;"><span>   return false
</span></span><span style="display:flex;"><span>  case timerModifying:
</span></span><span style="display:flex;"><span>   osyield()
</span></span><span style="display:flex;"><span>  default:
</span></span><span style="display:flex;"><span>   badTimer()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但移除也不是直接一个 <code>delete</code> 就完事的，其在真正的删除方法 <code>deltimer</code> 中遵循了基本的规则处理：</p>
<ol>
<li>timerWaiting/timerModifiedLater -&gt; timerDeleted。</li>
<li>timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted。</li>
<li>timerDeleted/timerRemoving/timerRemoved -&gt; 无需变更，已经满足条件。</li>
<li>timerRunning/timerMoving/timerModifying -&gt; 正在执行、移动中，无法停止，等待下一次状态检查再处理。</li>
<li>timerNoStatus -&gt; 无法停止，不满足条件。</li>
</ol>
<p>上述五个基本流转逻辑就覆盖了 runtimer.deltimer 方法了，若有进一步需求的可通过传送门详细阅读。</p>
<h3 id="修改重置计时器">修改/重置计时器</h3>
<p>在应用程序的调度中，有时候因为逻辑产生了变更，我们需要重置计时器。这时候一般会调用<code>timer.Reset()</code> 方法来重新设置 <code>Duration</code> 值。</p>
<p>其表面对应的是 <code>resetTimer</code> 方法，但实际与修改计时器的 <code>modtimer</code> 方法是共用的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func resettimer(t *timer, when int64) bool {
</span></span><span style="display:flex;"><span> return modtimer(t, when, t.period, t.f, t.arg, t.seq)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因此在这节中我们可以将重置和修改计时器放在一起分析。修改计时器，本质上是需要变更现有计时器，而在 Go 语言的计时器中是需要遵循基本规则，因此 <code>modtimer</code> 遵循下述规则处理：</p>
<ol>
<li>timerWaiting   -&gt; timerModifying -&gt; timerModifiedXX</li>
<li>timerModifiedXX -&gt; timerModifying -&gt; timerModifiedYY</li>
<li>timerNoStatus  -&gt; timerModifying -&gt; timerWaiting</li>
<li>timerRemoved   -&gt; timerModifying -&gt; timerWaiting</li>
<li>timerDeleted   -&gt; timerModifying -&gt; timerModifiedXX</li>
<li>timerRunning   -&gt; 等待状态改变，才可以进行下一步</li>
<li>timerMoving   -&gt; 等待状态改变，才可以进行下一步</li>
<li>timerRemoving  -&gt; 等待状态改变，才可以进行下一步</li>
<li>timerModifying  -&gt; 等待状态改变，才可以进行下一步</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) bool {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> if wasRemoved {
</span></span><span style="display:flex;"><span>  t.when = when
</span></span><span style="display:flex;"><span>  pp := getg().m.p.ptr()
</span></span><span style="display:flex;"><span>  lock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span>  doaddtimer(pp, t)
</span></span><span style="display:flex;"><span>  unlock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  releasem(mp)
</span></span><span style="display:flex;"><span>  wakeNetPoller(when)
</span></span><span style="display:flex;"><span> } else {
</span></span><span style="display:flex;"><span>  t.nextwhen = when
</span></span><span style="display:flex;"><span>  newStatus := uint32(timerModifiedLater)
</span></span><span style="display:flex;"><span>  if when &lt; t.when {
</span></span><span style="display:flex;"><span>   newStatus = timerModifiedEarlier
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  releasem(mp)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  if newStatus == timerModifiedEarlier {
</span></span><span style="display:flex;"><span>   wakeNetPoller(when)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> return pending
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在完成了计时器的状态处理后，会分为两种情况处理：</p>
<ul>
<li>待修改的计时器已经被删除：由于既有的计时器已经没有了，因此会调用 <code>doaddtimer</code> 方法创建一个新的计时器，并将原本的 <code>timer</code> 属性赋值过去，再调用 <code>wakeNetPoller</code> 方法在预定时间唤醒网络轮询。</li>
<li>正常逻辑处理：如果修改后的计时器的触发时间小于原本的触发时间，则修改该计时器的状态为 <code>timerModifiedEarlier</code>，并且调用 <code>wakeNetPoller</code> 方法在预定时间唤醒网络轮询。</li>
</ul>
<h3 id="触发计时器">触发计时器</h3>
<p>在前面有提到 Go1.14 后，Go Timer 都已经归属到各个处理器 P 中去了，因此计时器的触发分为了两个部分：</p>
<ul>
<li>通过调度器在调度时进行计时器的触发。</li>
<li>通过系统监控检查并触发计时器（到期未执行）。</li>
</ul>
<h4 id="调度器触发">调度器触发</h4>
<p>调度器的触发一共分两种情况，一种是在调度循环的时候调用 <code>checkTimers</code> 方法进行计时器的触发：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func schedule() {
</span></span><span style="display:flex;"><span> _g_ := getg()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>top:
</span></span><span style="display:flex;"><span> pp := _g_.m.p.ptr()
</span></span><span style="display:flex;"><span> pp.preempt = false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> // 处理调度时的计时器触发
</span></span><span style="display:flex;"><span> checkTimers(pp, 0)
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> execute(gp, inheritTime)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外一种是当前处理器 P 没有可执行的 Timer，且没有可执行的 G。那么按照调度模型，就会去窃取其他计时器和 G：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func findrunnable() (gp *g, inheritTime bool) {
</span></span><span style="display:flex;"><span> _g_ := getg()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>top:
</span></span><span style="display:flex;"><span> _p_ := _g_.m.p.ptr()
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> now, pollUntil, _ := checkTimers(_p_, 0)
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调度系统在计时器处不深究，我们进一步剖析具体触发计时器的 <code>checkTimers</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {
</span></span><span style="display:flex;"><span> if atomic.Load(&amp;pp.adjustTimers) == 0 {
</span></span><span style="display:flex;"><span>  next := int64(atomic.Load64(&amp;pp.timer0When))
</span></span><span style="display:flex;"><span>  if next == 0 {
</span></span><span style="display:flex;"><span>   return now, 0, false
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  if now == 0 {
</span></span><span style="display:flex;"><span>   now = nanotime()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  if now &lt; next {
</span></span><span style="display:flex;"><span>   if pp != getg().m.p.ptr() || int(atomic.Load(&amp;pp.deletedTimers)) &lt;= int(atomic.Load(&amp;pp.numTimers)/4) {
</span></span><span style="display:flex;"><span>    return now, next, false
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> lock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> adjusttimers(pp)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>起始先通过 <code>pp.adjustTimers</code> 检查当前处理器 P 中是否有需要处理的计时器。</p>
</li>
<li>
<ul>
<li>若无需执行的计时器，则直接返回。</li>
<li>若有，则判断下一个计时器待删除的计时器和处理器 P 上的计时器数量，若前者小于后者 1/4 则直接返回。</li>
</ul>
</li>
<li>
<p>确定需要处理计时器后，通过调用 <code>adjusttimers</code> 方法重新根据时间将 <code>timers</code> 切片中 <code>timer</code> 的先后顺序重新排列（相当于 resort）。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> rnow = now
</span></span><span style="display:flex;"><span> if len(pp.timers) &gt; 0 {
</span></span><span style="display:flex;"><span>  if rnow == 0 {
</span></span><span style="display:flex;"><span>   rnow = nanotime()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  for len(pp.timers) &gt; 0 {
</span></span><span style="display:flex;"><span>   if tw := runtimer(pp, rnow); tw != 0 {
</span></span><span style="display:flex;"><span>    if tw &gt; 0 {
</span></span><span style="display:flex;"><span>     pollUntil = tw
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    break
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   ran = true
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在前面调整了 <code>timers</code> 切片中的最小堆的排序后，将会调用 <code>runtimer</code> 方法去真正运行所需要执行的 <code>timer</code>，完成触计时器的发。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> if pp == getg().m.p.ptr() &amp;&amp; int(atomic.Load(&amp;pp.deletedTimers)) &gt; len(pp.timers)/4 {
</span></span><span style="display:flex;"><span>  clearDeletedTimers(pp)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> unlock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> return rnow, pollUntil, ran
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在最后扫尾阶段，如果当前 G 的处理器与调用 <code>checkTimers</code> 方法所传入的处理器一致，并且处理器中 <code>timerDeleted</code> 状态的计时器数量是处理器 P 堆中的计时器的 1/4 以上，则调用 <code>clearDeletedTimers</code> 方法对已为删除状态的的计时器进行清理。</p>
<h4 id="系统监控触发">系统监控触发</h4>
<p>即使是通过每次调度器调度和窃取的时候触发，但毕竟是具有一定的随机和不确定性。</p>
<p>因此系统监控触发依然是一个兜底保障，在 Go 语言中 <code>runtime.sysmon</code> 方法承担了这一个责任，存在触发计时器的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func sysmon() {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> for {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  next, _ := timeSleepUntil()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  if debug.schedtrace &lt;= 0 &amp;&amp; (sched.gcwaiting != 0 || atomic.Load(&amp;sched.npidle) == uint32(gomaxprocs)) {
</span></span><span style="display:flex;"><span>   lock(&amp;sched.lock)
</span></span><span style="display:flex;"><span>   if atomic.Load(&amp;sched.gcwaiting) != 0 || atomic.Load(&amp;sched.npidle) == uint32(gomaxprocs) {
</span></span><span style="display:flex;"><span>    if next &gt; now {
</span></span><span style="display:flex;"><span>     ...
</span></span><span style="display:flex;"><span>     next, _ = timeSleepUntil()
</span></span><span style="display:flex;"><span>     lock(&amp;sched.lock)
</span></span><span style="display:flex;"><span>     atomic.Store(&amp;sched.sysmonwait, 0)
</span></span><span style="display:flex;"><span>     noteclear(&amp;sched.sysmonnote)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    idle = 0
</span></span><span style="display:flex;"><span>    delay = 20
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   unlock(&amp;sched.lock)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在每次进行系统监控时，都会在流程上调用 <code>timeSleepUntil</code> 方法去获取下一个计时器应触发的时间，以及保存该计时器已打开的计时器堆的 P。</p>
<p>在获取完毕后会马上检查当前是否存在 GC，若是正在 STW 则获取调度互斥锁。若发现下一个计时器的触发时间已经过去，则重新调用 <code>timeSleepUntil</code> 获取下一个计时器的时间和相应 P 的地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func sysmon() {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> for {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  lock(&amp;sched.sysmonlock)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>   now1 := nanotime()
</span></span><span style="display:flex;"><span>   if now1-now &gt; 50*1000 /* 50µs */ {
</span></span><span style="display:flex;"><span>    next, _ = timeSleepUntil()
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   now = now1
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>检查 <code>sched.sysmonlock</code> 所花费的时间是否超过 50µs。若是，则有可能前面所获取的下一个计时器触发时间已过期，因此重新调用 <code>timeSleepUntil</code> 方法再次获取。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func sysmon() {
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> for {
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>  lastpoll := int64(atomic.Load64(&amp;sched.lastpoll))
</span></span><span style="display:flex;"><span>  if netpollinited() &amp;&amp; lastpoll != 0 &amp;&amp; lastpoll+10*1000*1000 &lt; now {
</span></span><span style="display:flex;"><span>   atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))
</span></span><span style="display:flex;"><span>   list := netpoll(0) // non-blocking - returns list of goroutines
</span></span><span style="display:flex;"><span>   if !list.empty() {
</span></span><span style="display:flex;"><span>    incidlelocked(-1)
</span></span><span style="display:flex;"><span>    injectglist(&amp;list)
</span></span><span style="display:flex;"><span>    incidlelocked(1)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  if next &lt; now {
</span></span><span style="display:flex;"><span>   startm(nil, false)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果发现超过 10ms 的时间没有进行 <code>netpoll</code> 网络轮询，则主动调用 <code>netpoll</code> 方法触发轮询。</p>
<p>同时如果存在不可抢占的处理器 P，则调用 <code>startm</code> 方法来运行那些应该运行，但没有在运行的计时器。</p>
<h3 id="运行计时器">运行计时器</h3>
<p><code>runtimer</code> 方法主要承担计时器的具体运行，同时也会针对计时器的不同状态（含删除、修改、等待等）都进行了对应的处理，也相当于是个大的集中处理中枢了。例如在<code>timerDeleted</code> 状态下的计时器将会进行删除。</p>
<p>其遵循下述规则处理</p>
<ol>
<li>timerNoStatus   -&gt; 恐慌：计时器未初始化</li>
<li>timerWaiting   -&gt; timerWaiting</li>
<li>timerWaiting   -&gt; timerRunning -&gt; timerNoStatus</li>
<li>timerWaiting   -&gt; timerRunning -&gt; timerWaiting</li>
<li>timerModifying  -&gt; 等待状态改变，才可以进行下一步</li>
<li>timerModifiedXX  -&gt; timerMoving -&gt; timerWaiting</li>
<li>timerDeleted   -&gt; timerRemoving -&gt; timerRemoved</li>
<li>timerRunning   -&gt; 恐慌：并发调用</li>
<li>timerRemoved   -&gt; 恐慌：计时器堆不一致</li>
<li>timerRemoving  -&gt; 恐慌：计时器堆不一致</li>
<li>timerMoving   -&gt; 恐慌：计时器堆不一致</li>
</ol>
<p>我们再根据时间状态机，去针对性的看看源码是如何实现的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func runtimer(pp *p, now int64) int64 {
</span></span><span style="display:flex;"><span> for {
</span></span><span style="display:flex;"><span>  t := pp.timers[0]
</span></span><span style="display:flex;"><span>  switch s := atomic.Load(&amp;t.status); s {
</span></span><span style="display:flex;"><span>  case timerWaiting:
</span></span><span style="display:flex;"><span>   if t.when &gt; now {
</span></span><span style="display:flex;"><span>    return t.when
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   runOneTimer(pp, t, now)
</span></span><span style="display:flex;"><span>   return 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  case timerDeleted:
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>  case timerModifiedEarlier, timerModifiedLater:
</span></span><span style="display:flex;"><span>      ...
</span></span><span style="display:flex;"><span>  case timerModifying:
</span></span><span style="display:flex;"><span>   osyield()
</span></span><span style="display:flex;"><span>  case timerNoStatus, timerRemoved:
</span></span><span style="display:flex;"><span>   badTimer()
</span></span><span style="display:flex;"><span>  case timerRunning, timerRemoving, timerMoving:
</span></span><span style="display:flex;"><span>   badTimer()
</span></span><span style="display:flex;"><span>  default:
</span></span><span style="display:flex;"><span>   badTimer()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们主要关注运行计时器，也就是 <code>timerWaiting</code> 状态下的处理，其首先会对触发时间（when）进行判定，若大于当前时间则直接返回（因为所需触发的时间未到）。否则将会调用 <code>runOneTimer</code> 方法去执行本次触发：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func runOneTimer(pp *p, t *timer, now int64) {
</span></span><span style="display:flex;"><span> f := t.f
</span></span><span style="display:flex;"><span> arg := t.arg
</span></span><span style="display:flex;"><span> seq := t.seq
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> if t.period &gt; 0 {
</span></span><span style="display:flex;"><span>  delta := t.when - now
</span></span><span style="display:flex;"><span>  t.when += t.period * (1 + -delta/t.period)
</span></span><span style="display:flex;"><span>  siftdownTimer(pp.timers, 0)
</span></span><span style="display:flex;"><span>  if !atomic.Cas(&amp;t.status, timerRunning, timerWaiting) {
</span></span><span style="display:flex;"><span>   badTimer()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  updateTimer0When(pp)
</span></span><span style="display:flex;"><span> } else {
</span></span><span style="display:flex;"><span>  dodeltimer0(pp)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> unlock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span> f(arg, seq)
</span></span><span style="display:flex;"><span> lock(&amp;pp.timersLock)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>如果 <code>period</code> 大于 0，说明当前是 ticker，需要再次触发，因此还需要调整计时器的状态。</p>
</li>
<li>
<ul>
<li>重新计算下一次的触发时间，并且更新其在最小堆的位置。</li>
<li>调用 <code>atomic.Cas</code> 方法该计时器的状态从 <code>timerRunning</code> 原子修改为 <code>timerWaiting</code> 状态。</li>
<li>调用 <code>updateTimer0When</code> 方法设置处理器 P 的 <code>timer0When</code> 字段。</li>
</ul>
</li>
<li>
<p>如果 <code>period</code> 等于 0，说明当前是 timer，只需要单次触发就可以了。</p>
</li>
</ul>
<p>在完成计时器的运行属性更新后，上互斥锁，调用计时器的回调方法 <code>f</code>，完成本次完整的触发流程。</p>
<h2 id="总结">总结</h2>
<p>Go 语言的 Timer 其实已经改过了好几版，在 Go1.14 的正式大改版后。目前来看已经初步的到了一个新的阶段。其设计的模式主要围绕三块：</p>
<ul>
<li>在各个处理器 P 中，Timer 以最小四叉堆的存储方式在 timers 中。</li>
<li>在调度器的每轮调度中都会对计时器进行触发和检查。</li>
<li>在系统监听上 <code>netpoll</code> 会定时进行计时器的触发和检查。</li>
<li>在计时器的处理中，十个状态的流转和对应处理非常重要。</li>
</ul>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/16/%E6%89%8B%E6%92%95-go-%E9%9D%A2%E8%AF%95%E5%AE%98go-%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%AF%94%E8%BE%83%E4%B8%BA%E4%BB%80%E4%B9%88/" rel="next" title="手撕 Go 面试官：Go 结构体是否可以比较，为什么？">
        <i class="fa fa-chevron-left"></i> 手撕 Go 面试官：Go 结构体是否可以比较，为什么？
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/16/%E5%86%8D%E8%A7%81-go-%E9%9D%A2%E8%AF%95%E5%AE%98gmp-%E6%A8%A1%E5%9E%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-p/" rel="prev" title="再见 Go 面试官：GMP 模型，为什么要有 P？">
        再见 Go 面试官：GMP 模型，为什么要有 P？ <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">475</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">30</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">35</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>