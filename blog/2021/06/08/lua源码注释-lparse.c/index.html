<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>lua源码注释 lparse.c - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="lua源码注释 lparse.c">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="lua源码注释 lparse.c - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lparse.c/" itemprop="url">
        lua源码注释 lparse.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-08">
    2021-06-08
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">9719 字 ~20分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/* 参考的BNF地址 shankusu.me/lua/TheCompleteSyntaxOfLua51/ */</span>
<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** $Id: lparser.c,v 2.42.1.4 2011/10/21 19:31:42 roberto Exp $
</span><span style="color:#f00;font-style:italic">** Lua Parser
</span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span><span style="color:#f00;font-style:italic">*/</span>


<span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#define lparser_c
</span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lcode.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lfunc.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;llex.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lmem.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lparser.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstring.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>

<span style="color:#f00;font-style:italic">/* 也只有函数调用或变参操作符这两种TOKEN能返回 ... */</span>
<span style="color:#f00;font-style:italic">#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* i:当前活跃的locvar的索引 */</span>
<span style="color:#f00;font-style:italic">#define getlocvar(fs, i)	((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* 检查value是否超过了limit限制,超过则报错msg */</span>
<span style="color:#f00;font-style:italic">#define luaY_checklimit(fs,v,l,m)	if ((v)&gt;(l)) errorlimit(fs,l,m)
</span><span style="color:#f00;font-style:italic"></span>

<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** nodes for block list (list of active blocks)
</span><span style="color:#f00;font-style:italic">** previous:往前跳(eg:查找变量时从now-block往前一级一级的block找)
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">typedef</span> <span style="color:#00f">struct</span> BlockCnt {
  <span style="color:#00f">struct</span> BlockCnt *previous;  <span style="color:#f00;font-style:italic">/* chain */</span>
  <span style="color:#00f">int</span> breaklist;  <span style="color:#f00;font-style:italic">/* list of jumps out of this loop */</span>

  <span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">  ** ！！！！在进入本block的瞬间，外面已经激活的var的数量， ！！！！
</span><span style="color:#f00;font-style:italic">  ** 意味着本块内激活的locvar的reg.idx不会低于整个值，
</span><span style="color:#f00;font-style:italic">  ** 用于按照便变量的生存期检索变量 
</span><span style="color:#f00;font-style:italic">  ** 退出本block后，将fs-&gt;reg重置到本次即可清掉本block内激活的actvar
</span><span style="color:#f00;font-style:italic">  */</span>
  lu_byte nactvar;  <span style="color:#f00;font-style:italic">/* # active locals outside the breakable structure */</span>
  
  lu_byte upval;  <span style="color:#f00;font-style:italic">/* true if some variable in the block is an upvalue(本块中存在某些变量是其它块的upvalues：本块关闭时要做善后处理？) */</span>
  lu_byte isbreakable;  <span style="color:#f00;font-style:italic">/* true if `block&#39; is a loop, 语法规则：break仅能用于loop的block中 */</span>
} BlockCnt;



<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** prototypes for recursive non-terminal functions
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">chunk</span> (LexState *ls);
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">expr</span> (LexState *ls, expdesc *v);

<span style="color:#f00;font-style:italic">/* anchor:锚 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">anchor_token</span> (LexState *ls) {
  <span style="color:#00f">if</span> (ls-&gt;t.token == TK_NAME || ls-&gt;t.token == TK_STRING) {
    TString *ts = ls-&gt;t.seminfo.ts;
    luaX_newstring(ls, getstr(ts), ts-&gt;tsv.len);
  }
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">error_expected</span> (LexState *ls, <span style="color:#00f">int</span> token) {
  luaX_syntaxerror(ls,
      luaO_pushfstring(ls-&gt;L, LUA_QS <span style="color:#009c00">&#34; expected&#34;</span>, luaX_token2str(ls, token)));
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">errorlimit</span> (FuncState *fs, <span style="color:#00f">int</span> limit, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *what) {
  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *msg = (fs-&gt;f-&gt;linedefined == 0) ?
    luaO_pushfstring(fs-&gt;L, <span style="color:#009c00">&#34;main function has more than %d %s&#34;</span>, limit, what) :
    luaO_pushfstring(fs-&gt;L, <span style="color:#009c00">&#34;function at line %d has more than %d %s&#34;</span>,
                            fs-&gt;f-&gt;linedefined, limit, what);
  luaX_lexerror(fs-&gt;ls, msg, 0);
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">testnext</span> (LexState *ls, <span style="color:#00f">int</span> c) {
  <span style="color:#00f">if</span> (ls-&gt;t.token == c) {
    luaX_next(ls);
    <span style="color:#00f">return</span> 1;
  }
  <span style="color:#00f">else</span> <span style="color:#00f">return</span> 0;
}

<span style="color:#f00;font-style:italic">/* 检查当前c是否为特定的token&#39;Type */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">check</span> (LexState *ls, <span style="color:#00f">int</span> c) {
  <span style="color:#00f">if</span> (ls-&gt;t.token != c)
    error_expected(ls, c);
}

<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">checknext</span> (LexState *ls, <span style="color:#00f">int</span> c) {
  check(ls, c);
  luaX_next(ls);
}


<span style="color:#f00;font-style:italic">#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
</span><span style="color:#f00;font-style:italic"></span>

<span style="color:#f00;font-style:italic">/* 在where(line)这里，who(TK.1)需要一个what(TK.2)匹配
</span><span style="color:#f00;font-style:italic">** eg: function 需要一个end来结束函数定义
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">check_match</span> (LexState *ls, <span style="color:#00f">int</span> what, <span style="color:#00f">int</span> who, <span style="color:#00f">int</span> where) {
  <span style="color:#00f">if</span> (!testnext(ls, what)) {
    <span style="color:#00f">if</span> (where == ls-&gt;linenumber)	<span style="color:#f00;font-style:italic">/* 当前行，那就不需要打印line信息了？ */</span>
      error_expected(ls, what);
    <span style="color:#00f">else</span> {
		<span style="color:#f00;font-style:italic">/* 输出连带line信息的错误信息 */</span>
      luaX_syntaxerror(ls, luaO_pushfstring(ls-&gt;L,
             LUA_QS <span style="color:#009c00">&#34; expected (to close &#34;</span> LUA_QS <span style="color:#009c00">&#34; at line %d)&#34;</span>,
              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
    }
  }
}

<span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">** 强制检查并当前token的type为TK_NAME，返回当前token，
</span><span style="color:#f00;font-style:italic">** 读取下一个token 
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> TString *<span style="color:#c34e00">str_checkname</span> (LexState *ls) {
  TString *ts;
  check(ls, TK_NAME);		<span style="color:#f00;font-style:italic">/* 当前token&#39;type必须是TK_NAME的类型 */</span>
  ts = ls-&gt;t.seminfo.ts;	<span style="color:#f00;font-style:italic">/* 提取token的值 */</span>
  luaX_next(ls);			<span style="color:#f00;font-style:italic">/* 继续读下一个token */</span>
  <span style="color:#00f">return</span> ts;
}

<span style="color:#f00;font-style:italic">/*  KEYCODE: 关键函数 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">init_exp</span> (expdesc *e, expkind k, <span style="color:#00f">int</span> i) {
  e-&gt;f = e-&gt;t = NO_JUMP;
  
  <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">  ************************************exp对应的reg已定或是一个参数无需reg*********************************
</span><span style="color:#f00;font-style:italic">  ** VVOID, VKNUM, VNIL, VTRUE, VFALSE,   	i:0 值直接被包含在表达式expdesc中，无需寄存器
</span><span style="color:#f00;font-style:italic">  ** VK   								    i:常量表中的索引
</span><span style="color:#f00;font-style:italic">  ** VLOCAL									i:locvar占用的reg索引
</span><span style="color:#f00;font-style:italic">  ** VGLOBAL							    i:NO_REG-&gt;全局变量名的NAME在常量表中的索引
</span><span style="color:#f00;font-style:italic">  **
</span><span style="color:#f00;font-style:italic">  **
</span><span style="color:#f00;font-style:italic">  ***********************************需回填指令的RA?**********************************
</span><span style="color:#f00;font-style:italic">  ** VRELOCABLE								i:？对应指令OP在指令数组中的下标（方便回填指令中的RA？)？
</span><span style="color:#f00;font-style:italic">  ** VCALL, VVARARG							i:对应指令OP在指令数组中的下标（方便回填指令中的RA？)
</span><span style="color:#f00;font-style:italic">  **
</span><span style="color:#f00;font-style:italic">  ** VNONRELOC								i:对应指令OP在指令数组的下标(方便回填指令中的RA?)
</span><span style="color:#f00;font-style:italic">  */</span>
  e-&gt;k = k;
  e-&gt;u.s.info = i;
}

<span style="color:#f00;font-style:italic">/* 用字符串(TK_NAME)s初始化expdesc的e表达式 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codestring</span> (LexState *ls, expdesc *e, TString *s) {
  init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));
}

<span style="color:#f00;font-style:italic">/* 先检查当前t的类型为NAME，后将其携带的string赋值给expdesc, 内部读取一次luaX_next() */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">checkname</span>(LexState *ls, expdesc *e) {
  codestring(ls, e, str_checkname(ls));
}

<span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">** 填充一个全新的 Locvar信息到 Proto.locvars (供调试用)
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">registerlocalvar</span> (LexState *ls, TString *varname) {
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  <span style="color:#00f">int</span> oldsize = f-&gt;sizelocvars;

  <span style="color:#f00;font-style:italic">/* 原来的总数组f-&gt;sizelocvars空间不足则扩大 */</span>
  luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
                  LocVar, SHRT_MAX, <span style="color:#009c00">&#34;too many local variables&#34;</span>);
  
  <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizelocvars)	<span style="color:#f00;font-style:italic">/* locvars数组扩大则将新增的slot填NULL */</span>
  	f-&gt;locvars[oldsize++].varname = NULL;
  
  <span style="color:#f00;font-style:italic">/* 更新locvar信息, startPC,endPC暂时还不确定 */</span>
  f-&gt;locvars[fs-&gt;nlocvars].varname = varname; 
  <span style="color:#f00;font-style:italic">/* printf(&#34;registerlocalvar: idx(%d), name(%p)\n&#34;, fs-&gt;nlocvars, varname); */</span>
  luaC_objbarrier(ls-&gt;L, f, varname);
  <span style="color:#00f">return</span> fs-&gt;nlocvars++;
}

<span style="color:#f00;font-style:italic">/* 如果v是不变的string则此宏定义可以利用宏处理阶段提高程序速度 */</span>
<span style="color:#f00;font-style:italic">#define new_localvarliteral(ls,v,n) \
</span><span style="color:#f00;font-style:italic">  new_localvar(ls, luaX_newstring(ls, &#34;&#34; v, (sizeof(v)/sizeof(char))-1), n)
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* KEYCODE
</span><span style="color:#f00;font-style:italic">** 注册一个本地变量信息到 Proto.locvars ,
</span><span style="color:#f00;font-style:italic">** 填充变量名, startpc,endpc稍后再处理
</span><span style="color:#f00;font-style:italic">**
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">new_localvar</span> (LexState *ls, TString *name, <span style="color:#00f">int</span> n) {
  FuncState *fs = ls-&gt;fs;
  luaY_checklimit(fs, fs-&gt;nactvar+n+1, LUAI_MAXVARS, <span style="color:#009c00">&#34;local variables&#34;</span>);
  <span style="color:#f00;font-style:italic">/* 设置actvar 到 Proto.nlocvars 的映射 */</span>
  <span style="color:#f00;font-style:italic">/* 这里仅设置了变量的name, 尚未设置startpc,endpc */</span>
  fs-&gt;actvar[fs-&gt;nactvar+n] = cast(<span style="color:#00f">unsigned</span> <span style="color:#00f">short</span>, registerlocalvar(ls, name));
  <span style="color:#f00;font-style:italic">//printf(&#34;......... %d-&gt;%d&#34;, fs-&gt;nactvar+n, fs-&gt;actvar[fs-&gt;nactvar+n]);
</span><span style="color:#f00;font-style:italic"></span>}

<span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">** 更新!!! FunState.nactvar 数量，更新 Proto.locvars.startpc 
</span><span style="color:#f00;font-style:italic">** 一次性生成多个locvar时，nvars可以告诉本函数方便一次性调整到位
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">adjustlocalvars</span> (LexState *ls, <span style="color:#00f">int</span> nvars) {
  FuncState *fs = ls-&gt;fs;
  
  <span style="color:#f00;font-style:italic">/* 更新fs中当前激活的locvar数量 */</span>
  <span style="color:#f00;font-style:italic">/* 更新fs中当前激活的locvar数量 */</span>
  <span style="color:#f00;font-style:italic">/* 更新fs中当前激活的locvar数量 */</span>
  fs-&gt;nactvar = cast_byte(fs-&gt;nactvar + nvars);	

  <span style="color:#f00;font-style:italic">/* 更新localvar的startpc */</span>
  <span style="color:#00f">for</span> (; nvars; nvars--) {
    getlocvar(fs, fs-&gt;nactvar - nvars).startpc = fs-&gt;pc;
	<span style="color:#f00;font-style:italic">/* 对应的chunk结束时，再更新endpc信息，也只有那个时候才能确切的知道endpc */</span>
  }
}

<span style="color:#f00;font-style:italic">/* 确定一批actvar的endpc 
</span><span style="color:#f00;font-style:italic">** 仔细看这个函数，很有意思哈（结合 new_localvar adjustlocalvars 一起看 ）
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">removevars</span> (LexState *ls, <span style="color:#00f">int</span> tolevel) {
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">while</span> (fs-&gt;nactvar &gt; tolevel)	<span style="color:#f00;font-style:italic">/* 这里tolevel是指block结束时对应的pc.idx */</span>
    getlocvar(fs, --fs-&gt;nactvar).endpc = fs-&gt;pc;	<span style="color:#f00;font-style:italic">/* 离开block时,关闭block内actvar */</span>
}

<span style="color:#f00;font-style:italic">/* 查找一个upvalue,返回其在upval数组中的索引，没有则构建 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">indexupvalue</span> (FuncState *fs, TString *name, expdesc *v) {
  <span style="color:#00f">int</span> i;
  Proto *f = fs-&gt;f;
  <span style="color:#00f">int</span> oldsize = f-&gt;sizeupvalues;
  <span style="color:#f00;font-style:italic">/* 当前存在的upvalue中已存在吗? */</span>
  <span style="color:#00f">for</span> (i=0; i&lt;f-&gt;nups; i++) {
    <span style="color:#00f">if</span> (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp;			<span style="color:#f00;font-style:italic">/* 类型为VUPVAL */</span>
		fs-&gt;upvalues[i].info == v-&gt;u.s.info) {	<span style="color:#f00;font-style:italic">/* 在proto中的索引一致 */</span>
      lua_assert(f-&gt;upvalues[i] == name);		<span style="color:#f00;font-style:italic">/* 名字就必须一致了 */</span>
      <span style="color:#00f">return</span> i;
    }
  }

  <span style="color:#f00;font-style:italic">/* new one */</span>
  
  <span style="color:#f00;font-style:italic">/* 数组容量不够则扩大 */</span>
  luaY_checklimit(fs, f-&gt;nups + 1, LUAI_MAXUPVALUES, <span style="color:#009c00">&#34;upvalues&#34;</span>);
  luaM_growvector(fs-&gt;L, f-&gt;upvalues, f-&gt;nups, f-&gt;sizeupvalues,
                  TString *, MAX_INT, <span style="color:#009c00">&#34;&#34;</span>);
  <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizeupvalues)
  	f-&gt;upvalues[oldsize++] = NULL;
  
  f-&gt;upvalues[f-&gt;nups] = name;
  luaC_objbarrier(fs-&gt;L, f, name);
  lua_assert(v-&gt;k == VLOCAL || v-&gt;k == VUPVAL);	<span style="color:#f00;font-style:italic">/* 这里的v-&gt;k==VLOCAL ? */</span>
  <span style="color:#f00;font-style:italic">/* 更新到fs */</span>
  fs-&gt;upvalues[f-&gt;nups].k = cast_byte(v-&gt;k);
  fs-&gt;upvalues[f-&gt;nups].info = cast_byte(v-&gt;u.s.info);
  <span style="color:#00f">return</span> f-&gt;nups++;
}

<span style="color:#f00;font-style:italic">/* 尝试在当前fs中匹配激活状态的locvar */</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">searchvar</span> (FuncState *fs, TString *n) {
  <span style="color:#00f">int</span> i;
  <span style="color:#00f">for</span> (i=fs-&gt;nactvar-1; i &gt;= 0; i--) {
    <span style="color:#00f">if</span> (n == getlocvar(fs, i).varname)
      <span style="color:#00f">return</span> i;
  }
  <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* not found */</span>
}

<span style="color:#f00;font-style:italic">/* fs中的locvar在其它函数中被当作upval引用
</span><span style="color:#f00;font-style:italic">** 标记fs中对应的block，你有变量是其它fs的upval
</span><span style="color:#f00;font-style:italic">** level:actvar在reg数组中的索引
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">markupval</span> (FuncState *fs, <span style="color:#00f">int</span> level) {
  BlockCnt *bl = fs-&gt;bl;
  <span style="color:#f00;font-style:italic">/* 这个标记过程的逻辑蛮有意思的 */</span>
  <span style="color:#00f">while</span> (bl &amp;&amp; bl-&gt;nactvar &gt; level)
  	bl = bl-&gt;previous;
  <span style="color:#00f">if</span> (bl)
  	bl-&gt;upval = 1;
}

<span style="color:#f00;font-style:italic">/* 查找变量名对应的表达式类型的值类型(VLOCAL还是?)
</span><span style="color:#f00;font-style:italic">**
</span><span style="color:#f00;font-style:italic">** 仔细看这个函数的逻辑，搞明白关于变量的查找过程
</span><span style="color:#f00;font-style:italic">** step1:先在本地fs6激活中的locvar查找，找到则返回VLOCAL
</span><span style="color:#f00;font-style:italic">** step2:往前一个fs5中的激活中的locvar查找，找不到，继续下一步step3
</span><span style="color:#f00;font-style:italic">** step3:继续往前一个fs1中的激活的locvar查找，一直到fs1-&gt;pre为空，则
</span><span style="color:#f00;font-style:italic">**     可以确定var是一个VGLOBAL
</span><span style="color:#f00;font-style:italic">** step4:在某一个fs3中的激活中的locvar被找到，则标记此fs3中的bl表示你的某个var被其它fsX当作upval了
</span><span style="color:#f00;font-style:italic">**        往前退，在fs4中的upval中新增一条信息(此upval在父fs3中是VLOCAL,且在fs3的actvar中的索引是多少)
</span><span style="color:#f00;font-style:italic">**        再往前退，在fs5中的upval中新增一条信息(此upval在父fs4中是UPVAL，且在fs4的upvalues的索引是多少)
</span><span style="color:#f00;font-style:italic">**        再往前退，直到初始的fs6，在fs6中的upval中新增一条信息（此upval在父fs5中是UPVAL,且在fs5的upvalues的索引是多少)
</span><span style="color:#f00;font-style:italic">**
</span><span style="color:#f00;font-style:italic">** 理论上可以优化下：在本地locvar找不到时，先不要在父fs中找，而是在本fs的upvales中找下
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">singlevaraux</span> (FuncState *fs, TString *n, expdesc *var, <span style="color:#00f">int</span> base) {
  <span style="color:#00f">if</span> (fs == NULL) {  <span style="color:#f00;font-style:italic">/* no more levels? */</span>
  	<span style="color:#f00;font-style:italic">/* default is global variable, NO_REG:表示此全局变量尚未决定其寄存器的位置
</span><span style="color:#f00;font-style:italic">	** 全局变量对应的NAME在p中常量表的索引由singlevar()函数来处理
</span><span style="color:#f00;font-style:italic">  	*/</span>
    init_exp(var, VGLOBAL, NO_REG);  
    <span style="color:#00f">return</span> VGLOBAL;	<span style="color:#f00;font-style:italic">/* 往外一层一层都找不到时，则认为它是全局变量 */</span>
  }
  <span style="color:#00f">else</span> {
  	<span style="color:#f00;font-style:italic">/* 在激活的locvar中找到了，则是本地变量 */</span>
    <span style="color:#00f">int</span> v = searchvar(fs, n);  <span style="color:#f00;font-style:italic">/* look up at current level */</span>
    <span style="color:#00f">if</span> (v &gt;= 0) {
      init_exp(var, VLOCAL, v);
      <span style="color:#00f">if</span> (!base)
        markupval(fs, v);  <span style="color:#f00;font-style:italic">/* local will be used as an upval */</span>
      <span style="color:#00f">return</span> VLOCAL;
    }
    <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* not found at current level; try upper one */</span>
      <span style="color:#00f">if</span> (singlevaraux(fs-&gt;prev, n, var, 0) == VGLOBAL)	<span style="color:#f00;font-style:italic">/* 都没找到，则是全局变量 */</span>
        <span style="color:#00f">return</span> VGLOBAL;
	  <span style="color:#f00;font-style:italic">/* 父func中找到，在自己的fun中算upval */</span>
      var-&gt;u.s.info = indexupvalue(fs, n, var);  <span style="color:#f00;font-style:italic">/* else was LOCAL or UPVAL */</span>
      var-&gt;k = VUPVAL;  <span style="color:#f00;font-style:italic">/* upvalue in this level */</span>
      <span style="color:#00f">return</span> VUPVAL;
    }
  }
}

<span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">** step1: 检查ls-&gt;t.token的类型为TK_NAME，读取下一个TOKEN
</span><span style="color:#f00;font-style:italic">** step2: 根据上一个token的NAME，确定其变量(VLOCAL,VGLOBAL还是VUPVAL？)类型，
</span><span style="color:#f00;font-style:italic">**            后填充expdesc.u.s.info信息
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">singlevar</span> (LexState *ls, expdesc *var) {
  TString *varname = str_checkname(ls);
  FuncState *fs = ls-&gt;fs;

  <span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">  ** OP_GETGLOBAL A Bx R(A) := Gbl[Kst(Bx)]
</span><span style="color:#f00;font-style:italic">  ** OP_SETGLOBAL A Bx Gbl[Kst(Bx)] := R(A)
</span><span style="color:#f00;font-style:italic">  ** 全局变量的指令需要知道表示全局变量的NAME在常量表中的idx，
</span><span style="color:#f00;font-style:italic">  **     理解这一点就明白了下面var-&gt;u.s.info的赋值的意义
</span><span style="color:#f00;font-style:italic">  */</span>
  <span style="color:#00f">if</span> (singlevaraux(fs, varname, var, 1) == VGLOBAL) {	<span style="color:#f00;font-style:italic">/* VLOCVAR,VUPVAL在singlevaraux中已被init_exp初始化 */</span>
    var-&gt;u.s.info = luaK_stringK(fs, varname);  <span style="color:#f00;font-style:italic">/* info points to global name */</span>
  }
}

<span style="color:#f00;font-style:italic">/* 针对 nvars = nexps 赋值进行调整
</span><span style="color:#f00;font-style:italic">** 如果右边少了则给左边赋NIL
</span><span style="color:#f00;font-style:italic">** 如果右边有call,...则确定期待的返回值个数
</span><span style="color:#f00;font-style:italic">**
</span><span style="color:#f00;font-style:italic">** ！！！ 如果右边多了，本函数未处理！！！
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">adjust_assign</span> (LexState *ls, <span style="color:#00f">int</span> nvars, <span style="color:#00f">int</span> nexps, expdesc *e) {
  FuncState *fs = ls-&gt;fs;
  <span style="color:#f00;font-style:italic">/* extra: 右边除掉fun和...外，表达式的数量少于左边的val的数量的情况下，缺失的数量? */</span>
  <span style="color:#00f">int</span> extra = nvars - nexps;	
  <span style="color:#00f">if</span> (hasmultret(e-&gt;k)) {	<span style="color:#f00;font-style:italic">/* exp的类型为VARARG或CALL */</span>
    extra++;  <span style="color:#f00;font-style:italic">/* includes call itself：除开VARARG和CALL本身 */</span>
	<span style="color:#f00;font-style:italic">/* 如果右边exp多了，那就不用补偿左边了
</span><span style="color:#f00;font-style:italic">	** OP_VARARG A B R(A), R(A+1), ..., R(A+B-1) = vararg
</span><span style="color:#f00;font-style:italic">	** 看上面的指令的含义，猜测这里是在确定B的值
</span><span style="color:#f00;font-style:italic">	*/</span>
    <span style="color:#00f">if</span> (extra &lt; 0) extra = 0;
	
    luaK_setreturns(fs, e, extra);  <span style="color:#f00;font-style:italic">/* last exp. provides the difference */</span>
    <span style="color:#00f">if</span> (extra &gt; 1) luaK_reserveregs(fs, extra-1);
  }
  <span style="color:#00f">else</span> {
    <span style="color:#00f">if</span> (e-&gt;k != VVOID) luaK_exp2nextreg(fs, e);  <span style="color:#f00;font-style:italic">/* close last expression */</span>
    <span style="color:#00f">if</span> (extra &gt; 0) {	<span style="color:#f00;font-style:italic">/* nexps：包含右边最后一个exp */</span>
      <span style="color:#00f">int</span> reg = fs-&gt;freereg;
	  <span style="color:#f00;font-style:italic">/* 为左边多出来的var申请reg,然后填NIL */</span>
      luaK_reserveregs(fs, extra);
      luaK_nil(fs, reg, extra);
    }
  }
}

<span style="color:#f00;font-style:italic">/* 进入一个新的block */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">enterlevel</span> (LexState *ls) {
  <span style="color:#00f">if</span> (++ls-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS)
	luaX_lexerror(ls, <span style="color:#009c00">&#34;chunk has too many syntax levels&#34;</span>, 0);
}


<span style="color:#f00;font-style:italic">#define leavelevel(ls)	((ls)-&gt;L-&gt;nCcalls--)
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* 进入块时，初始化block信息 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">enterblock</span> (FuncState *fs, BlockCnt *bl, lu_byte isbreakable) {
  bl-&gt;breaklist = NO_JUMP;
  bl-&gt;isbreakable = isbreakable;
  bl-&gt;nactvar = fs-&gt;nactvar;
  bl-&gt;upval = 0;
  
  <span style="color:#f00;font-style:italic">/* 这里有个印象 */</span>
  bl-&gt;previous = fs-&gt;bl;
  fs-&gt;bl = bl;
  
  lua_assert(fs-&gt;freereg == fs-&gt;nactvar);
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">leaveblock</span> (FuncState *fs) {
  BlockCnt *bl = fs-&gt;bl;
  fs-&gt;bl = bl-&gt;previous;
  
  <span style="color:#f00;font-style:italic">/* 确定本block内激活的var的生存周期的endpc */</span>
  removevars(fs-&gt;ls, bl-&gt;nactvar);

  <span style="color:#f00;font-style:italic">/* OP_CLOSE A close all variables in the stack up to (&gt;=) R(A) */</span>
  <span style="color:#00f">if</span> (bl-&gt;upval) {
    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
  }
  
  <span style="color:#f00;font-style:italic">/* a block either controls scope or breaks (never both) */</span>
  lua_assert(!bl-&gt;isbreakable || !bl-&gt;upval);	<span style="color:#f00;font-style:italic">/* TODOLOOK 还不是太理解 */</span>
  
  lua_assert(bl-&gt;nactvar == fs-&gt;nactvar);	<span style="color:#f00;font-style:italic">/* 这个必须保证 */</span>
  fs-&gt;freereg = fs-&gt;nactvar;  <span style="color:#f00;font-style:italic">/* free registers */</span>
  
  luaK_patchtohere(fs, bl-&gt;breaklist);
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">pushclosure</span> (LexState *ls, FuncState *func, expdesc *v) {
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  <span style="color:#00f">int</span> oldsize = f-&gt;sizep;
  <span style="color:#00f">int</span> i;
  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,
                  MAXARG_Bx, <span style="color:#009c00">&#34;constant table overflow&#34;</span>);
  <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;
  f-&gt;p[fs-&gt;np++] = func-&gt;f;
  luaC_objbarrier(ls-&gt;L, f, func-&gt;f);
  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));
  <span style="color:#00f">for</span> (i=0; i&lt;func-&gt;f-&gt;nups; i++) {
    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;	<span style="color:#f00;font-style:italic">/* TODOLOOK 这里不是明白 */</span>
    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);
  }
}

<span style="color:#f00;font-style:italic">/* 开始编译函数 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">open_func</span> (LexState *ls, FuncState *fs) {
  lua_State *L = ls-&gt;L;
  
  fs-&gt;L = L;	
  Proto *f = luaF_newproto(L);
  fs-&gt;ls = ls;
  fs-&gt;f = f;	<span style="color:#f00;font-style:italic">/* funState 在编译哪个Proto */</span>
  
  <span style="color:#f00;font-style:italic">/* ls指向最新的一个FuncState,这里可以猜测，只有先编译完了子函数才有可能编译父函数 */</span>
  fs-&gt;prev = ls-&gt;fs;  <span style="color:#f00;font-style:italic">/* linked list of funcstates */</span>
  ls-&gt;fs = fs;
  
  fs-&gt;pc = 0;
  fs-&gt;lasttarget = -1;
  fs-&gt;jpc = NO_JUMP;
  fs-&gt;freereg = 0;
  fs-&gt;nk = 0;
  fs-&gt;np = 0;
  fs-&gt;nlocvars = 0;
  fs-&gt;nactvar = 0;
  fs-&gt;bl = NULL;	<span style="color:#f00;font-style:italic">/* 这里是NULL */</span>
  f-&gt;source = ls-&gt;source;
  f-&gt;maxstacksize = 2;  <span style="color:#f00;font-style:italic">/* registers 0/1 are always valid */</span>
  fs-&gt;h = luaH_new(L, 0, 0);
  
  <span style="color:#f00;font-style:italic">/* anchor table of constants and prototype (to avoid being collected)
</span><span style="color:#f00;font-style:italic">  ** 常量和原型的锚表（避免被收集）
</span><span style="color:#f00;font-style:italic">  */</span>
  sethvalue2s(L, L-&gt;top, fs-&gt;h);
  incr_top(L);	<span style="color:#f00;font-style:italic">/* 放到堆栈上可避免被gc,如果编译失败stack回缩，则可自动被gc（没有被其它obj引用的话 ） */</span>
  setptvalue2s(L, L-&gt;top, f);
  incr_top(L);
  
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">close_func</span> (LexState *ls) {
  lua_State *L = ls-&gt;L;
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;

  <span style="color:#f00;font-style:italic">/* 关闭还处于激活状态的actvar(设置endpc) */</span>
  removevars(ls, 0);

  <span style="color:#f00;font-style:italic">/* 自动补一个 OP_RETURN 指令 */</span>
  luaK_ret(fs, 0, 0);  <span style="color:#f00;font-style:italic">/* final return */</span>

  <span style="color:#f00;font-style:italic">/* 释放多余的mem */</span>
  luaM_reallocvector(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
  f-&gt;sizecode = fs-&gt;pc;
  
  luaM_reallocvector(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, <span style="color:#00f">int</span>);
  f-&gt;sizelineinfo = fs-&gt;pc;
  
  luaM_reallocvector(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TValue);
  f-&gt;sizek = fs-&gt;nk;
  
  luaM_reallocvector(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, Proto *);
  f-&gt;sizep = fs-&gt;np;
  
  luaM_reallocvector(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
  f-&gt;sizelocvars = fs-&gt;nlocvars;
  
  luaM_reallocvector(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, TString *);
  f-&gt;sizeupvalues = f-&gt;nups;
  
  lua_assert(luaG_checkcode(f));	<span style="color:#f00;font-style:italic">/* 检查生成的字节码是否有明显的问题 */</span>
  lua_assert(fs-&gt;bl == NULL);
  
  <span style="color:#f00;font-style:italic">/* 本子函数编译完毕，切换到母函数中去 */</span>
  ls-&gt;fs = fs-&gt;prev;
  
  <span style="color:#f00;font-style:italic">/* last token read was anchored(锚定) in defunct function; must reanchor(锚) it */</span>
  <span style="color:#00f">if</span> (fs) anchor_token(ls);
  L-&gt;top -= 2;  <span style="color:#f00;font-style:italic">/* remove table and prototype from the stack */</span>
}


Proto *<span style="color:#c34e00">luaY_parser</span> (lua_State *L, ZIO *z, Mbuffer *buff, <span style="color:#00f">const</span> <span style="color:#00f">char</span> *name) {
  <span style="color:#00f">struct</span> LexState lexstate;
  <span style="color:#00f">struct</span> FuncState funcstate;	<span style="color:#f00;font-style:italic">/* mainFunc */</span>
  
  lexstate.buff = buff;
  <span style="color:#f00;font-style:italic">/* 设置input信息，但，buff在上面就设置了，有点意思吧，z和buff对于lexState是有点不同的 */</span>
  luaX_setinput(L, &amp;lexstate, z, luaS_new(L, name));

  <span style="color:#f00;font-style:italic">/* 一个lua文件，编译模块将其当做一个函数来看待
</span><span style="color:#f00;font-style:italic">  ** 函数原型 function (...)
</span><span style="color:#f00;font-style:italic">  **          end
</span><span style="color:#f00;font-style:italic">  **
</span><span style="color:#f00;font-style:italic">  ** BNF funcbody ::= `(´ [parlist] `)´ block end
</span><span style="color:#f00;font-style:italic">  */</span>
  open_func(&amp;lexstate, &amp;funcstate);
  funcstate.f-&gt;is_vararg = VARARG_ISVARARG;  <span style="color:#f00;font-style:italic">/* main func. is always vararg，哈哈知道lua文件一般开头的local modName=...的语法支撑了吧 */</span>
  luaX_next(&amp;lexstate);  <span style="color:#f00;font-style:italic">/* read first token */</span>
  chunk(&amp;lexstate);
  check(&amp;lexstate, TK_EOS);	<span style="color:#f00;font-style:italic">/* 直到编译到文件EOF才结束编译流程 */</span>
  close_func(&amp;lexstate);
  
  lua_assert(lexstate.fs == NULL);		<span style="color:#f00;font-style:italic">/* lexstate下不应该还有未编译完的funState了 */</span>
  lua_assert(funcstate.prev == NULL);	<span style="color:#f00;font-style:italic">/* 已编译完的主函数上面还有其它函数，不可能的嘛 */</span>
  lua_assert(funcstate.f-&gt;nups == 0);	<span style="color:#f00;font-style:italic">/* 编译结束，主函数不应该有nups了 */</span>
  <span style="color:#00f">return</span> funcstate.f;
}



<span style="color:#f00;font-style:italic">/*============================================================*/</span>
<span style="color:#f00;font-style:italic">/* GRAMMAR RULES */</span>
<span style="color:#f00;font-style:italic">/*============================================================*/</span>

<span style="color:#f00;font-style:italic">/* A.B, A:B 
</span><span style="color:#f00;font-style:italic">** 对前缀生成必要的估值指令，放入free&#39;reg(若有必要)
</span><span style="color:#f00;font-style:italic">** 用上述值作为A,再和B一起生成新的VINDEXED表达式
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">field</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* field -&gt; [&#39;.&#39; | &#39;:&#39;] NAME */</span>
  FuncState *fs = ls-&gt;fs;
  expdesc key;
  
  <span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">  **将前缀(a.b.c中的a.b)加载到reg中
</span><span style="color:#f00;font-style:italic">  **若前缀已在寄存器中则无需处理(A=VLOCAL(a))
</span><span style="color:#f00;font-style:italic">  */</span>
  luaK_exp2anyreg(fs, v);	
  
  luaX_next(ls); 		<span style="color:#f00;font-style:italic">/* skip the dot or colon */</span>
  
  checkname(ls, &amp;key);	<span style="color:#f00;font-style:italic">/* 读取NAME这个域的常量exp并返回给key */</span>		

  <span style="color:#f00;font-style:italic">/* 生成新的VINDEXED表达式（求值指令，指令的目标寄存器尚未处理） */</span>
  luaK_indexed(fs, v, &amp;key);	
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">yindex</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* index -&gt; &#39;[&#39; expr &#39;]&#39; */</span>
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip the &#39;[&#39; */</span>
  expr(ls, v);
  luaK_exp2val(ls-&gt;fs, v);
  checknext(ls, <span style="color:#009c00">&#39;]&#39;</span>);
}


<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** {======================================================================
</span><span style="color:#f00;font-style:italic">** Rules for Constructors
</span><span style="color:#f00;font-style:italic">** =======================================================================
</span><span style="color:#f00;font-style:italic">*/</span>

<span style="color:#f00;font-style:italic">/* 构造表   tbl {a, b, c=val, d.e} */</span>
<span style="color:#00f">struct</span> ConsControl {
  expdesc *t;  <span style="color:#f00;font-style:italic">/* table descriptor 指代本表的expdesc */</span>
  expdesc v;  <span style="color:#f00;font-style:italic">/* last list item read: 指代正在分析到的哪一个元素eg(b),对于c=val用不上v */</span>
  <span style="color:#00f">int</span> nh;  <span style="color:#f00;font-style:italic">/* total number of `record&#39; elements */</span>
  <span style="color:#00f">int</span> na;  <span style="color:#f00;font-style:italic">/* total number of array elements */</span>
  <span style="color:#00f">int</span> tostore;  <span style="color:#f00;font-style:italic">/* number of array elements pending to be stored */</span>
};

<span style="color:#f00;font-style:italic">/* 形如 local tbl = { x = y, [a] = b,}
</span><span style="color:#f00;font-style:italic">** 中的x=1,这种指定tbl[k]=v的表达式
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">recfield</span> (LexState *ls, <span style="color:#00f">struct</span> ConsControl *cc) {
  <span style="color:#f00;font-style:italic">/* recfield -&gt; (NAME | `[&#39;exp1`]&#39;) = exp1 */</span>
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> reg = ls-&gt;fs-&gt;freereg;
  expdesc key, val;
  <span style="color:#00f">int</span> rkkey;

  <span style="color:#f00;font-style:italic">/* 对key生成加载指令 */</span>
  <span style="color:#00f">if</span> (ls-&gt;t.token == TK_NAME) {
    luaY_checklimit(fs, cc-&gt;nh, MAX_INT, <span style="color:#009c00">&#34;items in a constructor&#34;</span>);
    checkname(ls, &amp;key);
  }
  <span style="color:#00f">else</span>  <span style="color:#f00;font-style:italic">/* ls-&gt;t.token == &#39;[&#39; */</span>
    yindex(ls, &amp;key);
  
  cc-&gt;nh++;
  checknext(ls, <span style="color:#009c00">&#39;=&#39;</span>);
  <span style="color:#f00;font-style:italic">/* 回填上述k的加载指令,将表达式的值SET到next&#39;free&#39;reg上 */</span>
  rkkey = luaK_exp2RK(fs, &amp;key);

  <span style="color:#f00;font-style:italic">/* 初始化表达式val */</span>
  expr(ls, &amp;val);
  <span style="color:#f00;font-style:italic">/* 先生成对val的LOAD_XXX加载指令，后生成OP_SETTABLE */</span>
  luaK_codeABC(fs, OP_SETTABLE, cc-&gt;t-&gt;u.s.info, rkkey, luaK_exp2RK(fs, &amp;val));
  
  fs-&gt;freereg = reg;  <span style="color:#f00;font-style:italic">/* free registers 释放表达式占用的临时寄存器 */</span>
}

<span style="color:#f00;font-style:italic">/* local tbl = {a,b,c,d}
</span><span style="color:#f00;font-style:italic">** 解析完毕b,关闭对b的解析
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">closelistfield</span> (FuncState *fs, <span style="color:#00f">struct</span> ConsControl *cc) {
  <span style="color:#00f">if</span> (cc-&gt;v.k == VVOID) <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* there is no list item */</span>
  luaK_exp2nextreg(fs, &amp;cc-&gt;v);
  cc-&gt;v.k = VVOID;	<span style="color:#f00;font-style:italic">/* 释放表达式 */</span>
  <span style="color:#00f">if</span> (cc-&gt;tostore == LFIELDS_PER_FLUSH) {
    luaK_setlist(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);  <span style="color:#f00;font-style:italic">/* flush */</span>
    cc-&gt;tostore = 0;  <span style="color:#f00;font-style:italic">/* no more items pending */</span>
  }
}

<span style="color:#f00;font-style:italic">/* local tbl = {a, b, c, d}
</span><span style="color:#f00;font-style:italic">** 结束d的解析后，调到这里 
</span><span style="color:#f00;font-style:italic">** 逻辑独立出来是因为函数调用作为表的最后一个元素和非最后一个元素，其期望对其返回值的个数是不一样的
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">lastlistfield</span> (FuncState *fs, <span style="color:#00f">struct</span> ConsControl *cc) {
  <span style="color:#00f">if</span> (cc-&gt;tostore == 0) <span style="color:#00f">return</span>;
  <span style="color:#00f">if</span> (hasmultret(cc-&gt;v.k)) {
    luaK_setmultret(fs, &amp;cc-&gt;v);
    luaK_setlist(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, LUA_MULTRET);
    cc-&gt;na--;  <span style="color:#f00;font-style:italic">/* do not count last expression (unknown number of elements) */</span>
  }
  <span style="color:#00f">else</span> {
    <span style="color:#00f">if</span> (cc-&gt;v.k != VVOID)
      luaK_exp2nextreg(fs, &amp;cc-&gt;v);
    luaK_setlist(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);
  }
}

<span style="color:#f00;font-style:italic">/* tbl = {a,b, c = 100} 数组中单个field eg:a
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">listfield</span> (LexState *ls, <span style="color:#00f">struct</span> ConsControl *cc) {
  expr(ls, &amp;cc-&gt;v);
  luaY_checklimit(ls-&gt;fs, cc-&gt;na, MAX_INT, <span style="color:#009c00">&#34;items in a constructor&#34;</span>);
  cc-&gt;na++;
  cc-&gt;tostore++;
}

<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">constructor</span> (LexState *ls, expdesc *t) {
  <span style="color:#f00;font-style:italic">/* constructor -&gt; ?? */</span>
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> line = ls-&gt;linenumber;
  
  <span style="color:#00f">int</span> pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
  <span style="color:#00f">struct</span> ConsControl cc;
  cc.na = cc.nh = cc.tostore = 0;
  cc.t = t;
  
  <span style="color:#f00;font-style:italic">/* 初始化table的exp */</span>
  init_exp(t, VRELOCABLE, pc);
  
  init_exp(&amp;cc.v, VVOID, 0);  <span style="color:#f00;font-style:italic">/* no value (yet) */</span>
  
  luaK_exp2nextreg(ls-&gt;fs, t);  <span style="color:#f00;font-style:italic">/* fix it at stack top (for gc) */</span>
  checknext(ls, <span style="color:#009c00">&#39;{&#39;</span>);
  <span style="color:#00f">do</span> {
    lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);
    <span style="color:#00f">if</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;}&#39;</span>) <span style="color:#00f">break</span>;	<span style="color:#f00;font-style:italic">/* 表被遍历完毕 */</span>
    closelistfield(fs, &amp;cc);
    <span style="color:#00f">switch</span>(ls-&gt;t.token) {
      <span style="color:#00f">case</span> TK_NAME: {  <span style="color:#f00;font-style:italic">/* may be listfields or recfields */</span>
        luaX_lookahead(ls);
        <span style="color:#00f">if</span> (ls-&gt;lookahead.token != <span style="color:#009c00">&#39;=&#39;</span>)  <span style="color:#f00;font-style:italic">/* expression? */</span>
          listfield(ls, &amp;cc);
        <span style="color:#00f">else</span>
          recfield(ls, &amp;cc);
        <span style="color:#00f">break</span>;
      }
      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;[&#39;</span>: {  <span style="color:#f00;font-style:italic">/* constructor_item -&gt; recfield */</span>
        recfield(ls, &amp;cc);
        <span style="color:#00f">break</span>;
      }
      <span style="color:#00f">default</span>: {  <span style="color:#f00;font-style:italic">/* constructor_part -&gt; listfield */</span>
        listfield(ls, &amp;cc);
        <span style="color:#00f">break</span>;
      }
    }
  } <span style="color:#00f">while</span> (testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>) || testnext(ls, <span style="color:#009c00">&#39;;&#39;</span>));
  check_match(ls, <span style="color:#009c00">&#39;}&#39;</span>, <span style="color:#009c00">&#39;{&#39;</span>, line);
  lastlistfield(fs, &amp;cc);
  SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); <span style="color:#f00;font-style:italic">/* set initial array size */</span>
  SETARG_C(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.nh));  <span style="color:#f00;font-style:italic">/* set initial table size */</span>
}

<span style="color:#f00;font-style:italic">/* }====================================================================== */</span>


<span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">** 解析函数的显式形参列表（对于modName:sub(x,y) 这种隐含的第一个self参数，在外面已被解析完毕
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">parlist</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* parlist -&gt; [ param { `,&#39; param } ] */</span>
  FuncState *fs = ls-&gt;fs;
  Proto *f = fs-&gt;f;
  <span style="color:#00f">int</span> nparams = 0;
  f-&gt;is_vararg = 0;
  <span style="color:#00f">if</span> (ls-&gt;t.token != <span style="color:#009c00">&#39;)&#39;</span>) {  <span style="color:#f00;font-style:italic">/* is `parlist&#39; not empty? */</span>
    <span style="color:#00f">do</span> {
      <span style="color:#00f">switch</span> (ls-&gt;t.token) {
        <span style="color:#00f">case</span> TK_NAME: {  <span style="color:#f00;font-style:italic">/* param -&gt; NAME */</span>
          new_localvar(ls, str_checkname(ls), nparams++);
		  <span style="color:#f00;font-style:italic">/* adjustlocalvars 在下面调用：一次性调整到位 */</span>
          <span style="color:#00f">break</span>;
        }
        <span style="color:#00f">case</span> TK_DOTS: {  <span style="color:#f00;font-style:italic">/* param -&gt; `...&#39; */</span>
          luaX_next(ls);
<span style="color:#f00;font-style:italic">#if defined(LUA_COMPAT_VARARG)
</span><span style="color:#f00;font-style:italic"></span>          <span style="color:#f00;font-style:italic">/* use `arg&#39; as default name */</span>
          new_localvarliteral(ls, <span style="color:#009c00">&#34;arg&#34;</span>, nparams++);
          f-&gt;is_vararg = VARARG_HASARG | VARARG_NEEDSARG;
<span style="color:#f00;font-style:italic">#endif
</span><span style="color:#f00;font-style:italic"></span>          f-&gt;is_vararg |= VARARG_ISVARARG;
          <span style="color:#00f">break</span>;
        }
        <span style="color:#00f">default</span>: luaX_syntaxerror(ls, <span style="color:#009c00">&#34;&lt;name&gt; or &#34;</span> LUA_QL(<span style="color:#009c00">&#34;...&#34;</span>) <span style="color:#009c00">&#34; expected&#34;</span>);
      }
    } <span style="color:#00f">while</span> (!f-&gt;is_vararg &amp;&amp; testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>));	<span style="color:#f00;font-style:italic">/* 这里看得出来 ... 只能是最后一个形参 */</span>
  }<span style="color:#00f">else</span> {
  	<span style="color:#f00;font-style:italic">// function name() body end 显式形参为空
</span><span style="color:#f00;font-style:italic"></span>  }
  
  adjustlocalvars(ls, nparams);
  f-&gt;numparams = cast_byte(fs-&gt;nactvar - (f-&gt;is_vararg &amp; VARARG_HASARG));
  luaK_reserveregs(fs, fs-&gt;nactvar);  <span style="color:#f00;font-style:italic">/* reserve register for parameters */</span>
}

<span style="color:#f00;font-style:italic">/* 解析函数形参和函数体 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">body</span> (LexState *ls, expdesc *e, <span style="color:#00f">int</span> needself, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* body -&gt;  `(&#39; parlist `)&#39; chunk END */</span>
  FuncState new_fs;
  
  <span style="color:#f00;font-style:italic">/* 更新ls中的fs变量，完成编译对象的切换 */</span>
  open_func(ls, &amp;new_fs);
  
  <span style="color:#f00;font-style:italic">/* 新函数从哪一方开始定义 */</span>
  new_fs.f-&gt;linedefined = line;
  
  <span style="color:#f00;font-style:italic">/* local name = function () 或者 local function name() 这两种函数定义格式对应的函数都是从‘(’开始，*/</span>
  checknext(ls, <span style="color:#009c00">&#39;(&#39;</span>);

  <span style="color:#f00;font-style:italic">/* 这里看得出来self将是本fs的第一个locvar，占用一个正常的locvar
</span><span style="color:#f00;font-style:italic">  ** Proto.numparams 中也包含self
</span><span style="color:#f00;font-style:italic">  */</span>
  <span style="color:#00f">if</span> (needself) {	<span style="color:#f00;font-style:italic">/* 处理 function modName:sub() body end 这种情况，参考funcname()代码可知 */</span>
    new_localvarliteral(ls, <span style="color:#009c00">&#34;self&#34;</span>, 0);
    adjustlocalvars(ls, 1);
  }
  <span style="color:#f00;font-style:italic">/* 解析显式形参 */</span>
  parlist(ls);
  
  checknext(ls, <span style="color:#009c00">&#39;)&#39;</span>);
  
  chunk(ls);
  
  <span style="color:#f00;font-style:italic">/* 函数定义结束于哪一行 */</span>
  new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;
  
  check_match(ls, TK_END, TK_FUNCTION, line);
  
  close_func(ls);
  
  pushclosure(ls, &amp;new_fs, e);
}

<span style="color:#f00;font-style:italic">/* 解析表达式，返回表达式中的项的数量 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">explist1</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* explist1 -&gt; expr { `,&#39; expr } */</span>
  <span style="color:#00f">int</span> n = 1;  <span style="color:#f00;font-style:italic">/* at least one expression */</span>
  expr(ls, v);
  <span style="color:#00f">while</span> (testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>)) {
    luaK_exp2nextreg(ls-&gt;fs, v);
    expr(ls, v);
    n++;
  }
  <span style="color:#00f">return</span> n;
}

<span style="color:#f00;font-style:italic">/* funcargs -&gt; `(&#39; [ explist1 ] `)&#39; | constructor | STRING */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">funcargs</span> (LexState *ls, expdesc *f) {
  FuncState *fs = ls-&gt;fs;
  expdesc args;
  <span style="color:#00f">int</span> base, nparams;
  <span style="color:#00f">int</span> line = ls-&gt;linenumber;
  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;(&#39;</span>: {  <span style="color:#f00;font-style:italic">/* funcargs -&gt; `(&#39; [ explist1 ] `)&#39; */</span>
      <span style="color:#00f">if</span> (line != ls-&gt;lastline)
        luaX_syntaxerror(ls,<span style="color:#009c00">&#34;ambiguous syntax (function call x new statement)&#34;</span>);
      luaX_next(ls);
      <span style="color:#00f">if</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;)&#39;</span>)  <span style="color:#f00;font-style:italic">/* arg list is empty? */</span>
        args.k = VVOID;
      <span style="color:#00f">else</span> {
        explist1(ls, &amp;args);
        luaK_setmultret(fs, &amp;args);
      }
      check_match(ls, <span style="color:#009c00">&#39;)&#39;</span>, <span style="color:#009c00">&#39;(&#39;</span>, line);
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;{&#39;</span>: {  <span style="color:#f00;font-style:italic">/* funcargs -&gt; constructor */</span>
      constructor(ls, &amp;args);
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> TK_STRING: {  <span style="color:#f00;font-style:italic">/* funcargs -&gt; STRING */</span>
      codestring(ls, &amp;args, ls-&gt;t.seminfo.ts);
      luaX_next(ls);  <span style="color:#f00;font-style:italic">/* must use `seminfo&#39; before `next&#39; */</span>
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">default</span>: {
      luaX_syntaxerror(ls, <span style="color:#009c00">&#34;function arguments expected&#34;</span>);
      <span style="color:#00f">return</span>;
    }
  }
  lua_assert(f-&gt;k == VNONRELOC);
  base = f-&gt;u.s.info;  <span style="color:#f00;font-style:italic">/* base register for call */</span>
  <span style="color:#00f">if</span> (hasmultret(args.k))
    nparams = LUA_MULTRET;  <span style="color:#f00;font-style:italic">/* open call */</span>
  <span style="color:#00f">else</span> {
    <span style="color:#00f">if</span> (args.k != VVOID)
      luaK_exp2nextreg(fs, &amp;args);  <span style="color:#f00;font-style:italic">/* close last argument */</span>
    nparams = fs-&gt;freereg - (base+1);
  }
  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
  luaK_fixline(fs, line);
  fs-&gt;freereg = base+1;  <span style="color:#f00;font-style:italic">/* call remove function and arguments and leaves
</span><span style="color:#f00;font-style:italic">                            (unless changed) one result */</span>
}




<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** {======================================================================
</span><span style="color:#f00;font-style:italic">** Expression parsing
</span><span style="color:#f00;font-style:italic">** =======================================================================
</span><span style="color:#f00;font-style:italic">*/</span>


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">prefixexp</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* prefixexp -&gt; NAME | &#39;(&#39; expr &#39;)&#39; */</span>
  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;(&#39;</span>: {
      <span style="color:#00f">int</span> line = ls-&gt;linenumber;
      luaX_next(ls);
      expr(ls, v);
      check_match(ls, <span style="color:#009c00">&#39;)&#39;</span>, <span style="color:#009c00">&#39;(&#39;</span>, line);
      luaK_dischargevars(ls-&gt;fs, v);
      <span style="color:#00f">return</span>;
    }
    <span style="color:#00f">case</span> TK_NAME: {
      <span style="color:#f00;font-style:italic">/* 确定当前ls-&gt;t.token的变量类型(VLOCAL,VGLOBAL还是VUPVAL？)
</span><span style="color:#f00;font-style:italic">      **     填充expdesc.u.s.info信息
</span><span style="color:#f00;font-style:italic">      ** 读取下一个Token
</span><span style="color:#f00;font-style:italic">      */</span>
      singlevar(ls, v); 
      <span style="color:#00f">return</span>;
    }
    <span style="color:#00f">default</span>: {
      luaX_syntaxerror(ls, <span style="color:#009c00">&#34;unexpected symbol&#34;</span>);
      <span style="color:#00f">return</span>;
    }
  }
}

<span style="color:#f00;font-style:italic">/* primary：基本的 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">primaryexp</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* primaryexp -&gt; prefixexp { `.&#39; NAME | `[&#39; exp `]&#39; | `:&#39; NAME funcargs | funcargs } */</span>
  FuncState *fs = ls-&gt;fs;
  
  prefixexp(ls, v);
  
  <span style="color:#00f">for</span> (;;) {
    <span style="color:#00f">switch</span> (ls-&gt;t.token) {
      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;.&#39;</span>: {  <span style="color:#f00;font-style:italic">/* field */</span>
        field(ls, v);
        <span style="color:#00f">break</span>;
      }
      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;[&#39;</span>: {  <span style="color:#f00;font-style:italic">/* `[&#39; exp1 `]&#39; */</span>
        expdesc key;
        luaK_exp2anyreg(fs, v);
        yindex(ls, &amp;key);
        luaK_indexed(fs, v, &amp;key);
        <span style="color:#00f">break</span>;
      }
      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;:&#39;</span>: {  <span style="color:#f00;font-style:italic">/* `:&#39; NAME funcargs */</span>
        expdesc key;
        luaX_next(ls);
        checkname(ls, &amp;key);
        luaK_self(fs, v, &amp;key);
        funcargs(ls, v);
        <span style="color:#00f">break</span>;
      }
      <span style="color:#00f">case</span> <span style="color:#009c00">&#39;(&#39;</span>: <span style="color:#00f">case</span> TK_STRING: <span style="color:#00f">case</span> <span style="color:#009c00">&#39;{&#39;</span>: {  <span style="color:#f00;font-style:italic">/* funcargs 函数调用 */</span>
        luaK_exp2nextreg(fs, v);
        funcargs(ls, v);
        <span style="color:#00f">break</span>;
      }
      <span style="color:#00f">default</span>: <span style="color:#00f">return</span>;
    }
  }
}

<span style="color:#f00;font-style:italic">/* 对表达式进行初始化，间接表达式则生成求src.val的指令, 等待回填dst.reg */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">simpleexp</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* simpleexp -&gt; NUMBER | STRING | NIL | true | false | ... |
</span><span style="color:#f00;font-style:italic">                  constructor | FUNCTION body | primaryexp */</span>
  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
    <span style="color:#00f">case</span> TK_NUMBER: {
      init_exp(v, VKNUM, 0);
      v-&gt;u.nval = ls-&gt;t.seminfo.r;	<span style="color:#f00;font-style:italic">/* 直接赋值NUMBER */</span>
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> TK_STRING: {
      codestring(ls, v, ls-&gt;t.seminfo.ts);
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> TK_NIL: {
      init_exp(v, VNIL, 0);
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> TK_TRUE: {
      init_exp(v, VTRUE, 0);
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> TK_FALSE: {
      init_exp(v, VFALSE, 0);
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> TK_DOTS: {  <span style="color:#f00;font-style:italic">/* vararg */</span>
      FuncState *fs = ls-&gt;fs;
      check_condition(ls, fs-&gt;f-&gt;is_vararg,
                      <span style="color:#009c00">&#34;cannot use &#34;</span> LUA_QL(<span style="color:#009c00">&#34;...&#34;</span>) <span style="color:#009c00">&#34; outside a vararg function&#34;</span>);
      fs-&gt;f-&gt;is_vararg &amp;= ~VARARG_NEEDSARG;  <span style="color:#f00;font-style:italic">/* don&#39;t need &#39;arg&#39; */</span>
      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
      <span style="color:#00f">break</span>;
    }
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;{&#39;</span>: {  <span style="color:#f00;font-style:italic">/* constructor */</span>
      constructor(ls, v);
      <span style="color:#00f">return</span>;
    }
    <span style="color:#00f">case</span> TK_FUNCTION: {
      luaX_next(ls);
      body(ls, v, 0, ls-&gt;linenumber);
      <span style="color:#00f">return</span>;
    }
    <span style="color:#00f">default</span>: {
      primaryexp(ls, v);
      <span style="color:#00f">return</span>;
    }
  }
  luaX_next(ls);
}

<span style="color:#f00;font-style:italic">/* 返回TK可能的一元操作符TK */</span>
<span style="color:#00f">static</span> UnOpr <span style="color:#c34e00">getunopr</span> (<span style="color:#00f">int</span> op) {
  <span style="color:#00f">switch</span> (op) {
    <span style="color:#00f">case</span> TK_NOT: <span style="color:#00f">return</span> OPR_NOT;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;-&#39;</span>: <span style="color:#00f">return</span> OPR_MINUS;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;#&#39;</span>: <span style="color:#00f">return</span> OPR_LEN;
    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> OPR_NOUNOPR;
  }
}


<span style="color:#00f">static</span> BinOpr <span style="color:#c34e00">getbinopr</span> (<span style="color:#00f">int</span> op) {
  <span style="color:#00f">switch</span> (op) {
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;+&#39;</span>: <span style="color:#00f">return</span> OPR_ADD;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;-&#39;</span>: <span style="color:#00f">return</span> OPR_SUB;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;*&#39;</span>: <span style="color:#00f">return</span> OPR_MUL;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;/&#39;</span>: <span style="color:#00f">return</span> OPR_DIV;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;%&#39;</span>: <span style="color:#00f">return</span> OPR_MOD;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;^&#39;</span>: <span style="color:#00f">return</span> OPR_POW;
    <span style="color:#00f">case</span> TK_CONCAT: <span style="color:#00f">return</span> OPR_CONCAT;
    <span style="color:#00f">case</span> TK_NE: <span style="color:#00f">return</span> OPR_NE;
    <span style="color:#00f">case</span> TK_EQ: <span style="color:#00f">return</span> OPR_EQ;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&lt;&#39;</span>: <span style="color:#00f">return</span> OPR_LT;
    <span style="color:#00f">case</span> TK_LE: <span style="color:#00f">return</span> OPR_LE;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;&gt;&#39;</span>: <span style="color:#00f">return</span> OPR_GT;
    <span style="color:#00f">case</span> TK_GE: <span style="color:#00f">return</span> OPR_GE;
    <span style="color:#00f">case</span> TK_AND: <span style="color:#00f">return</span> OPR_AND;
    <span style="color:#00f">case</span> TK_OR: <span style="color:#00f">return</span> OPR_OR;
    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> OPR_NOBINOPR;
  }
}

<span style="color:#f00;font-style:italic">/* 操作符的优先级分左右：用于处理结合性？ */</span>
<span style="color:#00f">static</span> <span style="color:#00f">const</span> <span style="color:#00f">struct</span> {
  lu_byte left;  <span style="color:#f00;font-style:italic">/* left priority for each binary operator */</span>
  lu_byte right; <span style="color:#f00;font-style:italic">/* right priority */</span>
} priority[] = {  <span style="color:#f00;font-style:italic">/* ORDER OPR */</span>
   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  <span style="color:#f00;font-style:italic">/* `+&#39; `-&#39; `/&#39; `%&#39; */</span>
   {10, 9}, {5, 4},                 <span style="color:#f00;font-style:italic">/* power and concat (right associative) */</span>
   {3, 3}, {3, 3},                  <span style="color:#f00;font-style:italic">/* equality and inequality */</span>
   {3, 3}, {3, 3}, {3, 3}, {3, 3},  <span style="color:#f00;font-style:italic">/* order */</span>
   {2, 2}, {1, 1}                   <span style="color:#f00;font-style:italic">/* logical (and/or) */</span>
};

<span style="color:#f00;font-style:italic">#define UNARY_PRIORITY	8  </span><span style="color:#f00;font-style:italic">/* priority for unary operators,一元操作符的优先级？ */</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>

<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** subexpr -&gt; (simpleexp | unop subexpr) { binop subexpr }
</span><span style="color:#f00;font-style:italic">** where `binop&#39; is any binary operator with a priority higher than `limit&#39;
</span><span style="color:#f00;font-style:italic">** 操作符表达式
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> BinOpr <span style="color:#c34e00">subexpr</span> (LexState *ls, expdesc *v, <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> limit) {
  BinOpr op;
  UnOpr uop;
  enterlevel(ls);
  uop = getunopr(ls-&gt;t.token);
  <span style="color:#00f">if</span> (uop != OPR_NOUNOPR) {
    luaX_next(ls);
    subexpr(ls, v, UNARY_PRIORITY);
    luaK_prefix(ls-&gt;fs, uop, v);
  }
  <span style="color:#00f">else</span> simpleexp(ls, v);
  
  <span style="color:#f00;font-style:italic">/* expand while operators have priorities higher than `limit&#39; */</span>
  op = getbinopr(ls-&gt;t.token);
  <span style="color:#00f">while</span> (op != OPR_NOBINOPR &amp;&amp; priority[op].left &gt; limit) {
    expdesc v2;
    BinOpr nextop;
    luaX_next(ls);
    luaK_infix(ls-&gt;fs, op, v);
    <span style="color:#f00;font-style:italic">/* read sub-expression with higher priority */</span>
    nextop = subexpr(ls, &amp;v2, priority[op].right);
    luaK_posfix(ls-&gt;fs, op, v, &amp;v2);
    op = nextop;
  }
  leavelevel(ls);
  <span style="color:#00f">return</span> op;  <span style="color:#f00;font-style:italic">/* return first untreated operator */</span>
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">expr</span> (LexState *ls, expdesc *v) {
  subexpr(ls, v, 0);
}

<span style="color:#f00;font-style:italic">/* }==================================================================== */</span>



<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** {======================================================================
</span><span style="color:#f00;font-style:italic">** Rules for Statements
</span><span style="color:#f00;font-style:italic">** =======================================================================
</span><span style="color:#f00;font-style:italic">*/</span>

<span style="color:#f00;font-style:italic">/* repeat
</span><span style="color:#f00;font-style:italic">**   statements
</span><span style="color:#f00;font-style:italic">** until( condition )
</span><span style="color:#f00;font-style:italic">*/</span>

<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">block_follow</span> (<span style="color:#00f">int</span> token) {
  <span style="color:#00f">switch</span> (token) {	<span style="color:#f00;font-style:italic">/* END和EOS还没理解 */</span>
    <span style="color:#00f">case</span> TK_ELSE: <span style="color:#00f">case</span> TK_ELSEIF: <span style="color:#00f">case</span> TK_END:
    <span style="color:#00f">case</span> TK_UNTIL: <span style="color:#00f">case</span> TK_EOS:
      <span style="color:#00f">return</span> 1;
    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> 0;
  }
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">block</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* block -&gt; chunk */</span>
  FuncState *fs = ls-&gt;fs;
  BlockCnt bl;
  enterblock(fs, &amp;bl, 0);
  chunk(ls);
  lua_assert(bl.breaklist == NO_JUMP);
  leaveblock(fs);
}


<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** structure to chain all variables in the left-hand side of an
</span><span style="color:#f00;font-style:italic">** assignment
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">struct</span> LHS_assign {
  <span style="color:#00f">struct</span> LHS_assign *prev;
  expdesc v;  <span style="color:#f00;font-style:italic">/* variable (global, local, upvalue, or indexed) */</span>
};


<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** check whether, in an assignment to a local variable, the local variable
</span><span style="color:#f00;font-style:italic">** is needed in a previous assignment (to a table). If so, save original
</span><span style="color:#f00;font-style:italic">** local value in a safe place and use this safe copy in the previous
</span><span style="color:#f00;font-style:italic">** assignment.
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">check_conflict</span> (LexState *ls, <span style="color:#00f">struct</span> LHS_assign *lh, expdesc *v) {
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> extra = fs-&gt;freereg;  <span style="color:#f00;font-style:italic">/* eventual position to save local variable */</span>
  <span style="color:#00f">int</span> conflict = 0;
  <span style="color:#00f">for</span> (; lh; lh = lh-&gt;prev) {
    <span style="color:#00f">if</span> (lh-&gt;v.k == VINDEXED) {
      <span style="color:#00f">if</span> (lh-&gt;v.u.s.info == v-&gt;u.s.info) {  <span style="color:#f00;font-style:italic">/* conflict? */</span>
        conflict = 1;
        lh-&gt;v.u.s.info = extra;  <span style="color:#f00;font-style:italic">/* previous assignment will use safe copy */</span>
      }
      <span style="color:#00f">if</span> (lh-&gt;v.u.s.aux == v-&gt;u.s.info) {  <span style="color:#f00;font-style:italic">/* conflict? */</span>
        conflict = 1;
        lh-&gt;v.u.s.aux = extra;  <span style="color:#f00;font-style:italic">/* previous assignment will use safe copy */</span>
      }
    }
  }
  <span style="color:#00f">if</span> (conflict) {
    luaK_codeABC(fs, OP_MOVE, fs-&gt;freereg, v-&gt;u.s.info, 0);  <span style="color:#f00;font-style:italic">/* make copy */</span>
    luaK_reserveregs(fs, 1);
  }
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">assignment</span> (LexState *ls, <span style="color:#00f">struct</span> LHS_assign *lh, <span style="color:#00f">int</span> nvars) {
  expdesc e;
  check_condition(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
                      <span style="color:#009c00">&#34;syntax error&#34;</span>);
  <span style="color:#00f">if</span> (testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>)) {  <span style="color:#f00;font-style:italic">/* assignment -&gt; `,&#39; primaryexp assignment */</span>
    <span style="color:#00f">struct</span> LHS_assign nv;
    nv.prev = lh;
    primaryexp(ls, &amp;nv.v);
    <span style="color:#00f">if</span> (nv.v.k == VLOCAL)
      check_conflict(ls, lh, &amp;nv.v);
    luaY_checklimit(ls-&gt;fs, nvars, LUAI_MAXCCALLS - ls-&gt;L-&gt;nCcalls,
                    <span style="color:#009c00">&#34;variables in assignment&#34;</span>);
    assignment(ls, &amp;nv, nvars+1);
  }
  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* assignment -&gt; `=&#39; explist1 */</span>
    <span style="color:#00f">int</span> nexps;
    checknext(ls, <span style="color:#009c00">&#39;=&#39;</span>);
    nexps = explist1(ls, &amp;e);
    <span style="color:#00f">if</span> (nexps != nvars) {
      adjust_assign(ls, nvars, nexps, &amp;e);
      <span style="color:#00f">if</span> (nexps &gt; nvars)
        ls-&gt;fs-&gt;freereg -= nexps - nvars;  <span style="color:#f00;font-style:italic">/* remove extra values */</span>
    }
    <span style="color:#00f">else</span> {
      luaK_setoneret(ls-&gt;fs, &amp;e);  <span style="color:#f00;font-style:italic">/* close last expression */</span>
      luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
      <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* avoid default */</span>
    }
  }
  init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  <span style="color:#f00;font-style:italic">/* default assignment */</span>
  luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">cond</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* cond -&gt; exp */</span>
  expdesc v;
  expr(ls, &amp;v);  <span style="color:#f00;font-style:italic">/* read condition */</span>
  <span style="color:#00f">if</span> (v.k == VNIL) v.k = VFALSE;  <span style="color:#f00;font-style:italic">/* `falses&#39; are all equal here */</span>
  luaK_goiftrue(ls-&gt;fs, &amp;v);
  <span style="color:#00f">return</span> v.f;
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">breakstat</span> (LexState *ls) {
  FuncState *fs = ls-&gt;fs;
  BlockCnt *bl = fs-&gt;bl;
  <span style="color:#00f">int</span> upval = 0;
  <span style="color:#00f">while</span> (bl &amp;&amp; !bl-&gt;isbreakable) {
    upval |= bl-&gt;upval;
    bl = bl-&gt;previous;
  }
  <span style="color:#00f">if</span> (!bl)
    luaX_syntaxerror(ls, <span style="color:#009c00">&#34;no loop to break&#34;</span>);
  <span style="color:#00f">if</span> (upval)
    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
  luaK_concat(fs, &amp;bl-&gt;breaklist, luaK_jump(fs));
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">whilestat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* whilestat -&gt; WHILE cond DO block END */</span>
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> whileinit;
  <span style="color:#00f">int</span> condexit;
  BlockCnt bl;
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip WHILE */</span>
  whileinit = luaK_getlabel(fs);
  condexit = cond(ls);
  enterblock(fs, &amp;bl, 1);
  checknext(ls, TK_DO);
  block(ls);
  luaK_patchlist(fs, luaK_jump(fs), whileinit);
  check_match(ls, TK_END, TK_WHILE, line);
  leaveblock(fs);
  luaK_patchtohere(fs, condexit);  <span style="color:#f00;font-style:italic">/* false conditions finish the loop */</span>
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">repeatstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* repeatstat -&gt; REPEAT block UNTIL cond */</span>
  <span style="color:#00f">int</span> condexit;
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> repeat_init = luaK_getlabel(fs);
  BlockCnt bl1, bl2;
  enterblock(fs, &amp;bl1, 1);  <span style="color:#f00;font-style:italic">/* loop block */</span>
  enterblock(fs, &amp;bl2, 0);  <span style="color:#f00;font-style:italic">/* scope block */</span>
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip REPEAT */</span>
  chunk(ls);
  check_match(ls, TK_UNTIL, TK_REPEAT, line);
  condexit = cond(ls);  <span style="color:#f00;font-style:italic">/* read condition (inside scope block) */</span>
  <span style="color:#00f">if</span> (!bl2.upval) {  <span style="color:#f00;font-style:italic">/* no upvalues? */</span>
    leaveblock(fs);  <span style="color:#f00;font-style:italic">/* finish scope */</span>
    luaK_patchlist(ls-&gt;fs, condexit, repeat_init);  <span style="color:#f00;font-style:italic">/* close the loop */</span>
  }
  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* complete semantics when there are upvalues */</span>
    breakstat(ls);  <span style="color:#f00;font-style:italic">/* if condition then break */</span>
    luaK_patchtohere(ls-&gt;fs, condexit);  <span style="color:#f00;font-style:italic">/* else... */</span>
    leaveblock(fs);  <span style="color:#f00;font-style:italic">/* finish scope... */</span>
    luaK_patchlist(ls-&gt;fs, luaK_jump(fs), repeat_init);  <span style="color:#f00;font-style:italic">/* and repeat */</span>
  }
  leaveblock(fs);  <span style="color:#f00;font-style:italic">/* finish loop */</span>
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">exp1</span> (LexState *ls) {
  expdesc e;
  <span style="color:#00f">int</span> k;
  expr(ls, &amp;e);
  k = e.k;
  luaK_exp2nextreg(ls-&gt;fs, &amp;e);
  <span style="color:#00f">return</span> k;
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">forbody</span> (LexState *ls, <span style="color:#00f">int</span> base, <span style="color:#00f">int</span> line, <span style="color:#00f">int</span> nvars, <span style="color:#00f">int</span> isnum) {
  <span style="color:#f00;font-style:italic">/* forbody -&gt; DO block */</span>
  BlockCnt bl;
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> prep, endfor;
  adjustlocalvars(ls, 3);  <span style="color:#f00;font-style:italic">/* control variables */</span>
  checknext(ls, TK_DO);
  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
  enterblock(fs, &amp;bl, 0);  <span style="color:#f00;font-style:italic">/* scope for declared variables */</span>
  adjustlocalvars(ls, nvars);
  luaK_reserveregs(fs, nvars);
  block(ls);
  leaveblock(fs);  <span style="color:#f00;font-style:italic">/* end of scope for declared variables */</span>
  luaK_patchtohere(fs, prep);
  endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
                     luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars);
  luaK_fixline(fs, line);  <span style="color:#f00;font-style:italic">/* pretend that `OP_FOR&#39; starts the loop */</span>
  luaK_patchlist(fs, (isnum ? endfor : luaK_jump(fs)), prep + 1);
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">fornum</span> (LexState *ls, TString *varname, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* fornum -&gt; NAME = exp1,exp1[,exp1] forbody */</span>
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> base = fs-&gt;freereg;
  new_localvarliteral(ls, <span style="color:#009c00">&#34;(for index)&#34;</span>, 0);
  new_localvarliteral(ls, <span style="color:#009c00">&#34;(for limit)&#34;</span>, 1);
  new_localvarliteral(ls, <span style="color:#009c00">&#34;(for step)&#34;</span>, 2);
  new_localvar(ls, varname, 3);
  checknext(ls, <span style="color:#009c00">&#39;=&#39;</span>);
  exp1(ls);  <span style="color:#f00;font-style:italic">/* initial value */</span>
  checknext(ls, <span style="color:#009c00">&#39;,&#39;</span>);
  exp1(ls);  <span style="color:#f00;font-style:italic">/* limit */</span>
  <span style="color:#00f">if</span> (testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>))
    exp1(ls);  <span style="color:#f00;font-style:italic">/* optional step */</span>
  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* default step = 1 */</span>
    luaK_codeABx(fs, OP_LOADK, fs-&gt;freereg, luaK_numberK(fs, 1));
    luaK_reserveregs(fs, 1);
  }
  forbody(ls, base, line, 1, 1);
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">forlist</span> (LexState *ls, TString *indexname) {
  <span style="color:#f00;font-style:italic">/* forlist -&gt; NAME {,NAME} IN explist1 forbody */</span>
  FuncState *fs = ls-&gt;fs;
  expdesc e;
  <span style="color:#00f">int</span> nvars = 0;
  <span style="color:#00f">int</span> line;
  <span style="color:#00f">int</span> base = fs-&gt;freereg;
  <span style="color:#f00;font-style:italic">/* create control variables */</span>
  new_localvarliteral(ls, <span style="color:#009c00">&#34;(for generator)&#34;</span>, nvars++);
  new_localvarliteral(ls, <span style="color:#009c00">&#34;(for state)&#34;</span>, nvars++);
  new_localvarliteral(ls, <span style="color:#009c00">&#34;(for control)&#34;</span>, nvars++);
  <span style="color:#f00;font-style:italic">/* create declared variables */</span>
  new_localvar(ls, indexname, nvars++);
  <span style="color:#00f">while</span> (testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>))
    new_localvar(ls, str_checkname(ls), nvars++);
  checknext(ls, TK_IN);
  line = ls-&gt;linenumber;
  adjust_assign(ls, 3, explist1(ls, &amp;e), &amp;e);
  luaK_checkstack(fs, 3);  <span style="color:#f00;font-style:italic">/* extra space to call generator */</span>
  forbody(ls, base, line, nvars - 3, 0);
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">forstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* forstat -&gt; FOR (fornum | forlist) END */</span>
  FuncState *fs = ls-&gt;fs;
  TString *varname;
  BlockCnt bl;
  enterblock(fs, &amp;bl, 1);  <span style="color:#f00;font-style:italic">/* scope for loop and control variables */</span>
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip `for&#39; */</span>
  varname = str_checkname(ls);  <span style="color:#f00;font-style:italic">/* first variable name */</span>
  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;=&#39;</span>: fornum(ls, varname, line); <span style="color:#00f">break</span>;
    <span style="color:#00f">case</span> <span style="color:#009c00">&#39;,&#39;</span>: <span style="color:#00f">case</span> TK_IN: forlist(ls, varname); <span style="color:#00f">break</span>;
    <span style="color:#00f">default</span>: luaX_syntaxerror(ls, LUA_QL(<span style="color:#009c00">&#34;=&#34;</span>) <span style="color:#009c00">&#34; or &#34;</span> LUA_QL(<span style="color:#009c00">&#34;in&#34;</span>) <span style="color:#009c00">&#34; expected&#34;</span>);
  }
  check_match(ls, TK_END, TK_FOR, line);
  leaveblock(fs);  <span style="color:#f00;font-style:italic">/* loop scope (`break&#39; jumps to this point) */</span>
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">test_then_block</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* test_then_block -&gt; [IF | ELSEIF] cond THEN block */</span>
  <span style="color:#00f">int</span> condexit;
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip IF or ELSEIF */</span>
  condexit = cond(ls);
  checknext(ls, TK_THEN);
  block(ls);  <span style="color:#f00;font-style:italic">/* `then&#39; part */</span>
  <span style="color:#00f">return</span> condexit;
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">ifstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</span>
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">int</span> flist;	<span style="color:#f00;font-style:italic">/* false&#39;list */</span>
  <span style="color:#00f">int</span> escapelist = NO_JUMP;	<span style="color:#f00;font-style:italic">/* 块结束的addr */</span>
  flist = test_then_block(ls);  <span style="color:#f00;font-style:italic">/* IF cond THEN block */</span>
  <span style="color:#00f">while</span> (ls-&gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    flist = test_then_block(ls);  <span style="color:#f00;font-style:italic">/* ELSEIF cond THEN block */</span>
  }
  <span style="color:#00f">if</span> (ls-&gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip ELSE (after patch, for correct line info) */</span>
    block(ls);  <span style="color:#f00;font-style:italic">/* `else&#39; part */</span>
  }
  <span style="color:#00f">else</span>
    luaK_concat(fs, &amp;escapelist, flist);
  luaK_patchtohere(fs, escapelist);
  check_match(ls, TK_END, TK_IF, line);
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">localfunc</span> (LexState *ls) {
  expdesc v, b;
  FuncState *fs = ls-&gt;fs;
  
  <span style="color:#f00;font-style:italic">/* local function funA(...) end 
</span><span style="color:#f00;font-style:italic">  ** 注册locvar(函数名)到Proto.nlocvars,填充name信息，建立fs-&gt;actvar[fs-&gt;nactvars]到p.nlocvars的映射
</span><span style="color:#f00;font-style:italic">  */</span>
  new_localvar(ls, str_checkname(ls), 0);
  
  <span style="color:#f00;font-style:italic">/* 给表达式填个初值先 */</span>
  init_exp(&amp;v, VLOCAL, fs-&gt;freereg);
  
  <span style="color:#f00;font-style:italic">/* 上面新增了一个locvar,用掉了一个freereg，这里扩大点maxstacksize, 更新freereg */</span>
  luaK_reserveregs(fs, 1);	<span style="color:#f00;font-style:italic">/* reserve reg:准备寄存器 */</span>

  <span style="color:#f00;font-style:italic">/* 更新fs-&gt;nactvar, 填充上面新增的p.nlocvars变量的startpc */</span>
  adjustlocalvars(ls, 1);
  
  body(ls, &amp;b, 0, ls-&gt;linenumber);
  luaK_storevar(fs, &amp;v, &amp;b);
  
  <span style="color:#f00;font-style:italic">/* debug information will only see the variable after this point! */</span>
  getlocvar(fs, fs-&gt;nactvar - 1).startpc = fs-&gt;pc;
}

<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">localstat</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* stat -&gt; LOCAL NAME {`,&#39; NAME} [`=&#39; explist1] */</span>
  <span style="color:#00f">int</span> nvars = 0;
  <span style="color:#00f">int</span> nexps;
  expdesc e;
  
  <span style="color:#00f">do</span> {	<span style="color:#f00;font-style:italic">/* 登记左边的变量名到 Proto.locvars */</span>
    new_localvar(ls, str_checkname(ls), nvars++);
  } <span style="color:#00f">while</span> (testnext(ls, <span style="color:#009c00">&#39;,&#39;</span>));
  
  <span style="color:#00f">if</span> (testnext(ls, <span style="color:#009c00">&#39;=&#39;</span>))
    nexps = explist1(ls, &amp;e);	<span style="color:#f00;font-style:italic">/* 解析表达式 */</span>
  <span style="color:#00f">else</span> {
    e.k = VVOID;
    nexps = 0;
  }
  adjust_assign(ls, nvars, nexps, &amp;e);
  adjustlocalvars(ls, nvars);
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">funcname</span> (LexState *ls, expdesc *v) {
  <span style="color:#f00;font-style:italic">/* funcname -&gt; NAME {field} [`:&#39; NAME] */</span>
  <span style="color:#00f">int</span> needself = 0;
  singlevar(ls, v);
  <span style="color:#00f">while</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;.&#39;</span>)
    field(ls, v);
  <span style="color:#00f">if</span> (ls-&gt;t.token == <span style="color:#009c00">&#39;:&#39;</span>) {
    needself = 1;	<span style="color:#f00;font-style:italic">/* 需要给函数添加一个self参数 eg:           function modName:sub () body end */</span>
    field(ls, v);
  }
  <span style="color:#00f">return</span> needself;
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">funcstat</span> (LexState *ls, <span style="color:#00f">int</span> line) {
  <span style="color:#f00;font-style:italic">/* funcstat -&gt; FUNCTION funcname body */</span>
  <span style="color:#00f">int</span> needself;
  expdesc v, b;
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip FUNCTION */</span>
  needself = funcname(ls, &amp;v);
  body(ls, &amp;b, needself, line);
  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);
  luaK_fixline(ls-&gt;fs, line);  <span style="color:#f00;font-style:italic">/* definition `happens&#39; in the first line */</span>
}

<span style="color:#f00;font-style:italic">/* 处理表达式stat */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">exprstat</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* stat -&gt; func | assignment */</span>
  FuncState *fs = ls-&gt;fs;
  <span style="color:#00f">struct</span> LHS_assign v;
  primaryexp(ls, &amp;v.v);
  <span style="color:#00f">if</span> (v.v.k == VCALL)  <span style="color:#f00;font-style:italic">/* stat -&gt; func */</span>
    SETARG_C(getcode(fs, &amp;v.v), 1);  <span style="color:#f00;font-style:italic">/* call statement uses no results */</span>
  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* stat -&gt; assignment */</span>
    v.prev = NULL;
    assignment(ls, &amp;v, 1);
  }
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">retstat</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* stat -&gt; RETURN explist */</span>
  FuncState *fs = ls-&gt;fs;
  expdesc e;
  <span style="color:#00f">int</span> first, nret;  <span style="color:#f00;font-style:italic">/* registers with returned values */</span>
  luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip RETURN */</span>
  <span style="color:#00f">if</span> (block_follow(ls-&gt;t.token) || ls-&gt;t.token == <span style="color:#009c00">&#39;;&#39;</span>)
    first = nret = 0;  <span style="color:#f00;font-style:italic">/* return no values */</span>
  <span style="color:#00f">else</span> {
    nret = explist1(ls, &amp;e);  <span style="color:#f00;font-style:italic">/* optional return values */</span>
    <span style="color:#00f">if</span> (hasmultret(e.k)) {
      luaK_setmultret(fs, &amp;e);
      <span style="color:#00f">if</span> (e.k == VCALL &amp;&amp; nret == 1) {  <span style="color:#f00;font-style:italic">/* tail call? */</span>
        SET_OPCODE(getcode(fs,&amp;e), OP_TAILCALL);
        lua_assert(GETARG_A(getcode(fs,&amp;e)) == fs-&gt;nactvar);
      }
      first = fs-&gt;nactvar;
      nret = LUA_MULTRET;  <span style="color:#f00;font-style:italic">/* return all values */</span>
    }
    <span style="color:#00f">else</span> {
      <span style="color:#00f">if</span> (nret == 1)  <span style="color:#f00;font-style:italic">/* only one single value? */</span>
        first = luaK_exp2anyreg(fs, &amp;e);
      <span style="color:#00f">else</span> {
        luaK_exp2nextreg(fs, &amp;e);  <span style="color:#f00;font-style:italic">/* values must go to the `stack&#39; */</span>
        first = fs-&gt;nactvar;  <span style="color:#f00;font-style:italic">/* return all `active&#39; values */</span>
        lua_assert(nret == fs-&gt;freereg - first);
      }
    }
  }
  luaK_ret(fs, first, nret);
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">statement</span> (LexState *ls) {
  <span style="color:#00f">int</span> line = ls-&gt;linenumber;  <span style="color:#f00;font-style:italic">/* may be needed for error messages */</span>
  <span style="color:#00f">switch</span> (ls-&gt;t.token) {
    <span style="color:#00f">case</span> TK_IF: {  <span style="color:#f00;font-style:italic">/* stat -&gt; ifstat */</span>
      ifstat(ls, line);
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_WHILE: {  <span style="color:#f00;font-style:italic">/* stat -&gt; whilestat */</span>
      whilestat(ls, line);
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_DO: {  <span style="color:#f00;font-style:italic">/* stat -&gt; DO block END */</span>
      luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip DO */</span>
      block(ls);
      check_match(ls, TK_END, TK_DO, line);
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_FOR: {  <span style="color:#f00;font-style:italic">/* stat -&gt; forstat */</span>
      forstat(ls, line);
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_REPEAT: {  <span style="color:#f00;font-style:italic">/* stat -&gt; repeatstat */</span>
      repeatstat(ls, line);
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_FUNCTION: {
      funcstat(ls, line);  <span style="color:#f00;font-style:italic">/* stat -&gt; funcstat */</span>
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_LOCAL: {  <span style="color:#f00;font-style:italic">/* stat -&gt; localstat */</span>
      luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip LOCAL */</span>
      <span style="color:#00f">if</span> (testnext(ls, TK_FUNCTION))  <span style="color:#f00;font-style:italic">/* local function? */</span>
	  	<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">	  	** local function funName()
</span><span style="color:#f00;font-style:italic">	  	** end
</span><span style="color:#f00;font-style:italic">	  	*/</span>
        localfunc(ls);	
      <span style="color:#00f">else</span>
        localstat(ls);
      <span style="color:#00f">return</span> 0;
    }
    <span style="color:#00f">case</span> TK_RETURN: {  <span style="color:#f00;font-style:italic">/* stat -&gt; retstat */</span>
      retstat(ls);
      <span style="color:#00f">return</span> 1;  <span style="color:#f00;font-style:italic">/* must be last statement */</span>
    }
    <span style="color:#00f">case</span> TK_BREAK: {  <span style="color:#f00;font-style:italic">/* stat -&gt; breakstat */</span>
      luaX_next(ls);  <span style="color:#f00;font-style:italic">/* skip BREAK */</span>
      breakstat(ls);
      <span style="color:#00f">return</span> 1;  <span style="color:#f00;font-style:italic">/* must be last statement */</span>
    }
    <span style="color:#00f">default</span>: {
      exprstat(ls);
      <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* to avoid warnings */</span>
    }
  }
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">chunk</span> (LexState *ls) {
  <span style="color:#f00;font-style:italic">/* chunk -&gt; { stat [`;&#39;] } */</span>
  <span style="color:#00f">int</span> islast = 0;
  enterlevel(ls);
  <span style="color:#00f">while</span> (!islast &amp;&amp; !block_follow(ls-&gt;t.token)) {
    islast = statement(ls);
	<span style="color:#f00;font-style:italic">/* statement后面的&#39;;&#39;是可选的 */</span>
    testnext(ls, <span style="color:#009c00">&#39;;&#39;</span>);
    lua_assert(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp;
               ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);
	
	<span style="color:#f00;font-style:italic">/* 释放上一个块占用的临时寄存器 */</span>
    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  <span style="color:#f00;font-style:italic">/* free registers */</span>
  }
  leavelevel(ls);
}

<span style="color:#f00;font-style:italic">/* }====================================================================== */</span>

</code></pre></div>
    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/lua" rel="tag" title="lua">#lua#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8Alcode.c/" rel="next" title="lua源码注释lcode.c">
        <i class="fa fa-chevron-left"></i> lua源码注释lcode.c
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lparse.h/" rel="prev" title="lua源码注释 lparse.h">
        lua源码注释 lparse.h <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">563</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">45</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">50</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>