<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>lua源码注释lcode.c - 愿星光伴你左右</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="lua源码注释lcode.c">
    <meta property="og:site_name" content="愿星光伴你左右">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="lua源码注释lcode.c - 愿星光伴你左右" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">愿星光伴你左右</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/prose/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />散文
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8Alcode.c/" itemprop="url">
        lua源码注释lcode.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-08">
    2021-06-08
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6252 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** Code generator for Lua
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define lcode_c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lua.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lcode.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;ldebug.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;ldo.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lgc.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;llex.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lmem.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lobject.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lopcodes.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;lparser.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;ltable.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* e的类型 expdesc */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">isnumeral</span>(expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VKNUM <span style="color:#f92672">&amp;&amp;</span>	<span style="color:#75715e">/* 仅仅e-&gt;k == VKNUM 不够么？ */</span>
</span></span><span style="display:flex;"><span>		  	e<span style="color:#f92672">-&gt;</span>t <span style="color:#f92672">==</span> NO_JUMP <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>		  	e<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">==</span> NO_JUMP);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 给连续的变量赋nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** OP_LOADNIL A B R(A) := ... := R(B) := nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 当可以合并前一条OP_LOADNIL时则尝试合并，可以利用fun&#39;stack的默认NIL时，直接用NIL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_nil</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> from, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>  Instruction <span style="color:#f92672">*</span>previous;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (fs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">&gt;</span> fs<span style="color:#f92672">-&gt;</span>lasttarget) {  <span style="color:#75715e">/* no jumps to current position? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {  <span style="color:#75715e">/* function start? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (from <span style="color:#f92672">&gt;=</span> fs<span style="color:#f92672">-&gt;</span>nactvar)  <span style="color:#75715e">/* 新调用一个fun时，其私有stack默认会被置NULL，这种情况直接使用默认的NULL即可 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">/* positions are already clean */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      previous <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>code[fs<span style="color:#f92672">-&gt;</span>pc<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (GET_OPCODE(<span style="color:#f92672">*</span>previous) <span style="color:#f92672">==</span> OP_LOADNIL) {	<span style="color:#75715e">/* 尝试合并前后连续的OP_LOADNIL指令 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pfrom <span style="color:#f92672">=</span> GETARG_A(<span style="color:#f92672">*</span>previous);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pto <span style="color:#f92672">=</span> GETARG_B(<span style="color:#f92672">*</span>previous);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pfrom <span style="color:#f92672">&lt;=</span> from <span style="color:#f92672">&amp;&amp;</span> from <span style="color:#f92672">&lt;=</span> pto<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) {  <span style="color:#75715e">/* can connect both? */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (from<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> pto)
</span></span><span style="display:flex;"><span>            SETARG_B(<span style="color:#f92672">*</span>previous, from<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, OP_LOADNIL, from, from<span style="color:#f92672">+</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);  <span style="color:#75715e">/* else no optimization */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** OP_JMP sBx PC += sBx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 待回填的跳转链表指向我，而我又指向其它pc，那么将上述链表和我串联在一起即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_jump</span> (FuncState <span style="color:#f92672">*</span>fs) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> jpc <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>jpc;  <span style="color:#75715e">/* save list of jumps to here */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> j;
</span></span><span style="display:flex;"><span>  fs<span style="color:#f92672">-&gt;</span>jpc <span style="color:#f92672">=</span> NO_JUMP;
</span></span><span style="display:flex;"><span>  j <span style="color:#f92672">=</span> luaK_codeAsBx(fs, OP_JMP, <span style="color:#ae81ff">0</span>, NO_JUMP);
</span></span><span style="display:flex;"><span>  luaK_concat(fs, <span style="color:#f92672">&amp;</span>j, jpc);  <span style="color:#75715e">/* keep them on hold */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> j;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 从函数返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** OP_RETURN A B return R(A), ... ,R(A+B-2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_ret</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> nret) {
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, OP_RETURN, first, nret<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);	<span style="color:#75715e">/* 这里可以反推OP_RETURNS中A,B,C的含义了 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 有条件跳转 OP_TEST, OP_TESTSET */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">condjump</span> (FuncState <span style="color:#f92672">*</span>fs, OpCode op, <span style="color:#66d9ef">int</span> A, <span style="color:#66d9ef">int</span> B, <span style="color:#66d9ef">int</span> C) {
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, op, A, B, C);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> luaK_jump(fs);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 将待回填的跳转指令pc指向dest */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fixjump</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> pc, <span style="color:#66d9ef">int</span> dest) {
</span></span><span style="display:flex;"><span>  Instruction <span style="color:#f92672">*</span>jmp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>code[pc];
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 下面计算跳转指令的跳转目标绝对值时也加了1，和这里是一致的 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> dest<span style="color:#f92672">-</span>(pc<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);		
</span></span><span style="display:flex;"><span>  lua_assert(dest <span style="color:#f92672">!=</span> NO_JUMP);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (abs(offset) <span style="color:#f92672">&gt;</span> MAXARG_sBx)
</span></span><span style="display:flex;"><span>    luaX_syntaxerror(fs<span style="color:#f92672">-&gt;</span>ls, <span style="color:#e6db74">&#34;control structure too long&#34;</span>);
</span></span><span style="display:flex;"><span>  SETARG_sBx(<span style="color:#f92672">*</span>jmp, offset);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** returns current `pc&#39; and marks it as a jump target (to avoid wrong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** optimizations(优化) with consecutive(连续) instructions not in the same basic block).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_getlabel</span> (FuncState <span style="color:#f92672">*</span>fs) {
</span></span><span style="display:flex;"><span>  fs<span style="color:#f92672">-&gt;</span>lasttarget <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>pc;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> fs<span style="color:#f92672">-&gt;</span>pc;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 获取跳转指令指向的绝对位置 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getjump</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> offset <span style="color:#f92672">=</span> GETARG_sBx(fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>code[pc]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">==</span> NO_JUMP)  <span style="color:#75715e">/* point to itself represents end of list */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NO_JUMP;  <span style="color:#75715e">/* end of list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (pc<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>offset;  <span style="color:#75715e">/* turn offset into absolute position */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> Instruction <span style="color:#f92672">*</span><span style="color:#a6e22e">getjumpcontrol</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> pc) {
</span></span><span style="display:flex;"><span>  Instruction <span style="color:#f92672">*</span>pi <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>code[pc];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (pc <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> testTMode(GET_OPCODE(<span style="color:#f92672">*</span>(pi<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pi<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pi;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** check whether list has any jump that do not produce a value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** (or produce an inverted(颠,倒) value)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">need_value</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (; list <span style="color:#f92672">!=</span> NO_JUMP; list <span style="color:#f92672">=</span> getjump(fs, list)) {
</span></span><span style="display:flex;"><span>    Instruction i <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>getjumpcontrol(fs, list);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (GET_OPCODE(i) <span style="color:#f92672">!=</span> OP_TESTSET) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">/* not found */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">patchtestreg</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> node, <span style="color:#66d9ef">int</span> reg) {
</span></span><span style="display:flex;"><span>  Instruction <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> getjumpcontrol(fs, node);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (GET_OPCODE(<span style="color:#f92672">*</span>i) <span style="color:#f92672">!=</span> OP_TESTSET)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">/* cannot patch other instructions */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">!=</span> NO_REG <span style="color:#f92672">&amp;&amp;</span> reg <span style="color:#f92672">!=</span> GETARG_B(<span style="color:#f92672">*</span>i))
</span></span><span style="display:flex;"><span>    SETARG_A(<span style="color:#f92672">*</span>i, reg);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>  <span style="color:#75715e">/* no register to put value or register already has the value */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> CREATE_ABC(OP_TEST, GETARG_B(<span style="color:#f92672">*</span>i), <span style="color:#ae81ff">0</span>, GETARG_C(<span style="color:#f92672">*</span>i));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">removevalues</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (; list <span style="color:#f92672">!=</span> NO_JUMP; list <span style="color:#f92672">=</span> getjump(fs, list))
</span></span><span style="display:flex;"><span>      patchtestreg(fs, list, NO_REG);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 回填跳转指令链表上的指令到指定目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 将待回填跳转指令列表list上指令的跳转参数sBx更新到target上 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">patchlistaux</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> list, <span style="color:#66d9ef">int</span> vtarget, <span style="color:#66d9ef">int</span> reg,
</span></span><span style="display:flex;"><span>                          <span style="color:#66d9ef">int</span> dtarget) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (list <span style="color:#f92672">!=</span> NO_JUMP) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next <span style="color:#f92672">=</span> getjump(fs, list);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (patchtestreg(fs, list, reg))
</span></span><span style="display:flex;"><span>      fixjump(fs, list, vtarget);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      fixjump(fs, list, dtarget);  <span style="color:#75715e">/* jump to default target */</span>
</span></span><span style="display:flex;"><span>    list <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 将待回填的跳转到当前指令的跳转链表上的跳转指令的sBx更新为fs-&gt;pc */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dischargejpc</span> (FuncState <span style="color:#f92672">*</span>fs) {
</span></span><span style="display:flex;"><span>  patchlistaux(fs, fs<span style="color:#f92672">-&gt;</span>jpc, fs<span style="color:#f92672">-&gt;</span>pc, NO_REG, fs<span style="color:#f92672">-&gt;</span>pc);
</span></span><span style="display:flex;"><span>  fs<span style="color:#f92672">-&gt;</span>jpc <span style="color:#f92672">=</span> NO_JUMP;	<span style="color:#75715e">/* 置空 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_patchlist</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> list, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (target <span style="color:#f92672">==</span> fs<span style="color:#f92672">-&gt;</span>pc)
</span></span><span style="display:flex;"><span>    luaK_patchtohere(fs, list);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    lua_assert(target <span style="color:#f92672">&lt;</span> fs<span style="color:#f92672">-&gt;</span>pc);
</span></span><span style="display:flex;"><span>    patchlistaux(fs, list, target, NO_REG, target);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 将待回填的跳转指令链表list挂到fs-&gt;jpc,等生成下一条指令时回填sBx */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_patchtohere</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> list) {
</span></span><span style="display:flex;"><span>  luaK_getlabel(fs);
</span></span><span style="display:flex;"><span>  luaK_concat(fs, <span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>jpc, list);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*  l1.sBx = l2 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 将l2指向的待回填跳转指令/指令链表挂到l1的跳转链表上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_concat</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>l1, <span style="color:#66d9ef">int</span> l2) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (l2 <span style="color:#f92672">==</span> NO_JUMP) <span style="color:#75715e">/* l2不是一条跳转指令，直接返回 */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>l1 <span style="color:#f92672">==</span> NO_JUMP)	<span style="color:#75715e">/* 当前跳转列表为空 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>l1 <span style="color:#f92672">=</span> l2;	<span style="color:#75715e">/* l1尚未初始化，直接赋值即可 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> list <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>l1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((next <span style="color:#f92672">=</span> getjump(fs, list)) <span style="color:#f92672">!=</span> NO_JUMP)  <span style="color:#75715e">/* find last element */</span>
</span></span><span style="display:flex;"><span>      list <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    fixjump(fs, list, l2);	<span style="color:#75715e">/* 将待回填的跳转指令链表l2挂到l1的末尾 */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 调整maxstacksize以便匹配locvar的数量 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_checkstack</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> newstack <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>freereg <span style="color:#f92672">+</span> n;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (newstack <span style="color:#f92672">&gt;</span> fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>maxstacksize) {	<span style="color:#75715e">/* 这个判断是必须的 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (newstack <span style="color:#f92672">&gt;=</span> MAXSTACK)
</span></span><span style="display:flex;"><span>      luaX_syntaxerror(fs<span style="color:#f92672">-&gt;</span>ls, <span style="color:#e6db74">&#34;function or expression too complex&#34;</span>);
</span></span><span style="display:flex;"><span>    fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>maxstacksize <span style="color:#f92672">=</span> cast_byte(newstack);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* reserve reg:预定 寄存器 实际上是占用n个寄存器的意思
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_reserveregs</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>  luaK_checkstack(fs, n);
</span></span><span style="display:flex;"><span>  fs<span style="color:#f92672">-&gt;</span>freereg <span style="color:#f92672">+=</span> n;	<span style="color:#75715e">/* 占用n个locvar,释放则n为负值或在其它函数中实现 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 重点函数，需要细读 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">freereg</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ISK(reg) <span style="color:#f92672">&amp;&amp;</span>            <span style="color:#75715e">/* 常量的就不用释放了，压根没占用reg */</span>
</span></span><span style="display:flex;"><span>      reg <span style="color:#f92672">&gt;=</span> fs<span style="color:#f92672">-&gt;</span>nactvar) {   <span style="color:#75715e">/* reg从0开始，nactvar从1开始，所以这里reg&gt;=fs-&gt;nactvar是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">      
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  	/* 释放一个reg后,reg==fs-&gt;freereg:确保只能释放最新一个被激活的reg(作为exp的临时reg占用？) */</span>
</span></span><span style="display:flex;"><span>    fs<span style="color:#f92672">-&gt;</span>freereg<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    lua_assert(reg <span style="color:#f92672">==</span> fs<span style="color:#f92672">-&gt;</span>freereg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 释放被临时占用的reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">freeexp</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VNONRELOC)		<span style="color:#75715e">/* 表达式的值已被CP_XXX到reg中的，才释放 (还没加载到reg，那压根没占用reg，释放个锤子*/</span>
</span></span><span style="display:flex;"><span>    freereg(fs, e<span style="color:#f92672">-&gt;</span>u.s.info);	<span style="color:#75715e">/* VNONRELOC info = result register */</span> 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 将常量加载到fs-&gt;f的常量表中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** local var = &#34;hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">&#34; 则本函数的k,v=&#34;hello&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">addk</span> (FuncState <span style="color:#f92672">*</span>fs, TValue <span style="color:#f92672">*</span>k, TValue <span style="color:#f92672">*</span>v) {
</span></span><span style="display:flex;"><span>  lua_State <span style="color:#f92672">*</span>L <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>L;
</span></span><span style="display:flex;"><span>  TValue <span style="color:#f92672">*</span>idx <span style="color:#f92672">=</span> luaH_set(L, fs<span style="color:#f92672">-&gt;</span>h, k);
</span></span><span style="display:flex;"><span>  Proto <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>f;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> oldsize <span style="color:#f92672">=</span> f<span style="color:#f92672">-&gt;</span>sizek;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (ttisnumber(idx)) {
</span></span><span style="display:flex;"><span>    lua_assert(luaO_rawequalObj(<span style="color:#f92672">&amp;</span>fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>k[cast_int(nvalue(idx))], v));	
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cast_int(nvalue(idx));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {  <span style="color:#75715e">/* constant not found; create a new entry */</span>
</span></span><span style="display:flex;"><span>    setnvalue(idx, cast_num(fs<span style="color:#f92672">-&gt;</span>nk));
</span></span><span style="display:flex;"><span>    luaM_growvector(L, f<span style="color:#f92672">-&gt;</span>k, fs<span style="color:#f92672">-&gt;</span>nk, f<span style="color:#f92672">-&gt;</span>sizek, TValue,
</span></span><span style="display:flex;"><span>                    MAXARG_Bx, <span style="color:#e6db74">&#34;constant table overflow&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (oldsize <span style="color:#f92672">&lt;</span> f<span style="color:#f92672">-&gt;</span>sizek) setnilvalue(<span style="color:#f92672">&amp;</span>f<span style="color:#f92672">-&gt;</span>k[oldsize<span style="color:#f92672">++</span>]);
</span></span><span style="display:flex;"><span>    setobj(L, <span style="color:#f92672">&amp;</span>f<span style="color:#f92672">-&gt;</span>k[fs<span style="color:#f92672">-&gt;</span>nk], v);
</span></span><span style="display:flex;"><span>    luaC_barrier(L, f, v);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> fs<span style="color:#f92672">-&gt;</span>nk<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 将字符串常量加载到fs-&gt;f的常量表中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_stringK</span> (FuncState <span style="color:#f92672">*</span>fs, TString <span style="color:#f92672">*</span>s) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  setsvalue(fs<span style="color:#f92672">-&gt;</span>L, <span style="color:#f92672">&amp;</span>o, s);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> addk(fs, <span style="color:#f92672">&amp;</span>o, <span style="color:#f92672">&amp;</span>o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_numberK</span> (FuncState <span style="color:#f92672">*</span>fs, lua_Number r) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  setnvalue(<span style="color:#f92672">&amp;</span>o, r);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> addk(fs, <span style="color:#f92672">&amp;</span>o, <span style="color:#f92672">&amp;</span>o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">boolK</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  setbvalue(<span style="color:#f92672">&amp;</span>o, b);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> addk(fs, <span style="color:#f92672">&amp;</span>o, <span style="color:#f92672">&amp;</span>o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nilK</span> (FuncState <span style="color:#f92672">*</span>fs) {
</span></span><span style="display:flex;"><span>  TValue k, v;
</span></span><span style="display:flex;"><span>  setnilvalue(<span style="color:#f92672">&amp;</span>v);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* cannot use nil as key; instead use table itself to represent nil */</span>
</span></span><span style="display:flex;"><span>  sethvalue(fs<span style="color:#f92672">-&gt;</span>L, <span style="color:#f92672">&amp;</span>k, fs<span style="color:#f92672">-&gt;</span>h);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> addk(fs, <span style="color:#f92672">&amp;</span>k, <span style="color:#f92672">&amp;</span>v);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* nresults:-1, C=0，表示希望返回变参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** nresults: 0, C=1, 表示希望返回0个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** nresults: 2, C=2, 表示希望返回1个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_setreturns</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e, <span style="color:#66d9ef">int</span> nresults) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* OP_CALL A B C 		R(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VCALL) {  <span style="color:#75715e">/* expression is an open function call? */</span>
</span></span><span style="display:flex;"><span>    SETARG_C(getcode(fs, e), nresults<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VVARARG) {
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">/* OP_VARARG A B 	R(A), R(A+1), ..., R(A+B-1) = vararg 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  	** 将变参拷贝到RA指定的寄存器开始的地方，拷贝B个元素，这里仅使用了一个寄存器的编码?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  	*/</span>
</span></span><span style="display:flex;"><span>    SETARG_B(getcode(fs, e), nresults<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    SETARG_A(getcode(fs, e), fs<span style="color:#f92672">-&gt;</span>freereg);
</span></span><span style="display:flex;"><span>    luaK_reserveregs(fs, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 对于可能返回变参的表达式，强制其仅返回一个值 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_setoneret</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VCALL) {  <span style="color:#75715e">/* expression is an open function call? */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">/* A B C R(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">/* 函数调用返回的第一个值占用的reg就是函数指针本身占用的reg,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  	** 不能返回到其它地方，故而这里是VNONRELOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  	*/</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VNONRELOC;	
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> GETARG_A(getcode(fs, e));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VVARARG) {
</span></span><span style="display:flex;"><span>    SETARG_B(getcode(fs, e), <span style="color:#ae81ff">2</span>);	<span style="color:#75715e">/* 2:期待返回一个返回值 */</span>
</span></span><span style="display:flex;"><span>    e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE;  <span style="color:#75715e">/* can relocate its simple result */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 生成LOAD_XXX(加载)系列指令，（为后续加载间接表达式的值到reg做准备）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 对需间接读取src.val的表达式生成对应的读值指令(eg:OP_GETTABLE),以便下一步的dst=src
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 需要间接求表达式src.val的：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 生成求表达式src.val的指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** e-&gt;u.s.info----&gt;pc.addr方便后面确定dst后进行指令回填
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** e.k        ----&gt;VNONRELOC 表达式的src.val对应读值指令已生成，但不在reg中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 表达式的src.val已经在reg中的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** src.val已在reg中的表达式(VLOCAL,VCALL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**   e.k      ----&gt; e.k=VNONRELOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 表达式的src.val是直接值的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** src.val是直接值的表达式，无需处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** discharge:释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_dischargevars</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (e<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VLOCAL: {	<span style="color:#75715e">/* exp.src已在reg中，故而这里是VNONRELOC */</span>
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VNONRELOC;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VUPVAL: {
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> luaK_codeABC(fs, OP_GETUPVAL, <span style="color:#ae81ff">0</span>, e<span style="color:#f92672">-&gt;</span>u.s.info, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VGLOBAL: {
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> luaK_codeABx(fs, OP_GETGLOBAL, <span style="color:#ae81ff">0</span>, e<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VINDEXED: {	<span style="color:#75715e">/* OP_GETTABLE A B C R(A) := R(B)[RK(C)] */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">/* !!这里是依次释放的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	  ** a.b.c.d.e... 释放a.b.c.d之前占用的reg,以便重利用reg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	  */</span>
</span></span><span style="display:flex;"><span>      freereg(fs, e<span style="color:#f92672">-&gt;</span>u.s.aux);
</span></span><span style="display:flex;"><span>      freereg(fs, e<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">/* A填 0，配合下面的可重定位VRELOCALBLE */</span>
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> luaK_codeABC(fs, OP_GETTABLE, <span style="color:#ae81ff">0</span>, e<span style="color:#f92672">-&gt;</span>u.s.info, e<span style="color:#f92672">-&gt;</span>u.s.aux);
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VVARARG:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VCALL: {
</span></span><span style="display:flex;"><span>      luaK_setoneret(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* !!!!常量，常量，常量 不需要用到reg，无需更新reg的信息e-&gt;k了 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VNIL:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VTRUE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VFALSE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VKNUM:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VK: {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 还没遇到过，不太理解 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VJMP:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* e-&gt;k已经确定了寄存器的信息了，直接返回 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VRELOCABLE:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> VNONRELOC:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;  <span style="color:#75715e">/* there is one value available (somewhere) */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">code_label</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> A, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> jump) {
</span></span><span style="display:flex;"><span>  luaK_getlabel(fs);  <span style="color:#75715e">/* those instructions may be jump targets */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** CP_XXX拷贝指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 拷贝表达式的值到指定的目的寄存器(reg(dst) = exp(src)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** step.1 生成表达式的src.val的加载指令(R(B))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** step.2 回填表达式的目标寄存器(RA),对VNONRELOC的则生成MV指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 参考init_exp 和 luaK_dischargevars函数来理解本函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">discharge2reg</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e, <span style="color:#66d9ef">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** step1. 对&#34;间接表达式&#34;生成求值指令 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** step2. 对&#34;直接表达式&#34;生成求值指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** step3. 对&#34;上述表达式&#34;进行回填处理(确定目标寄存器(R(A)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (e<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">/* 表达式的值是常值, 这里生成指令并回填R(A) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VNIL: {
</span></span><span style="display:flex;"><span>      luaK_nil(fs, reg, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VFALSE:  <span style="color:#66d9ef">case</span> VTRUE: {
</span></span><span style="display:flex;"><span>      luaK_codeABC(fs, OP_LOADBOOL, reg, e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VTRUE, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 表达式的值在e-&gt;u.s.info：常量表中，这里提出来，生成指令并回填R(A)                       */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VK: {
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">/* reg：指令的目标寄存器RA, e-&gt;u.s.info:指令中常量exp在常量表中的索引 */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABx(fs, OP_LOADK, reg, e<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 同上VK，只是nval在常量中的索引延迟到这里确定 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VKNUM: {
</span></span><span style="display:flex;"><span>      luaK_codeABx(fs, OP_LOADK, reg, luaK_numberK(fs, e<span style="color:#f92672">-&gt;</span>u.nval));
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 指令，表达式的值都已确定，这里回填指令的目的地R(A)即可 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VRELOCABLE: {
</span></span><span style="display:flex;"><span>      Instruction <span style="color:#f92672">*</span>pc <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>getcode(fs, e);
</span></span><span style="display:flex;"><span>      SETARG_A(<span style="color:#f92672">*</span>pc, reg);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 表达式的值已确定，生成OP_MOVE指令，回填R(A)=R(B)中的即可 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VNONRELOC: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (reg <span style="color:#f92672">!=</span> e<span style="color:#f92672">-&gt;</span>u.s.info)
</span></span><span style="display:flex;"><span>        luaK_codeABC(fs, OP_MOVE, reg, e<span style="color:#f92672">-&gt;</span>u.s.info, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* VJMP尚不理解 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      lua_assert(e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VVOID <span style="color:#f92672">||</span> e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VJMP);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">/* nothing to do... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 表达式的目的寄存器R(A)已确定 */</span>
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> reg;
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">discharge2anyreg</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">!=</span> VNONRELOC) {
</span></span><span style="display:flex;"><span>    luaK_reserveregs(fs, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    discharge2reg(fs, e, fs<span style="color:#f92672">-&gt;</span>freereg<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* dst=src CP_XXX指令，将表达式的值赋值给指定的寄存器reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exp2reg</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e, <span style="color:#66d9ef">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 将表达式的src.val赋值给dst(reg) */</span>
</span></span><span style="display:flex;"><span>  discharge2reg(fs, e, reg);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VJMP)
</span></span><span style="display:flex;"><span>    luaK_concat(fs, <span style="color:#f92672">&amp;</span>e<span style="color:#f92672">-&gt;</span>t, e<span style="color:#f92672">-&gt;</span>u.s.info);  <span style="color:#75715e">/* put this jump in `t&#39; list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hasjumps(e)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> final;  <span style="color:#75715e">/* position after whole expression */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p_f <span style="color:#f92672">=</span> NO_JUMP;  <span style="color:#75715e">/* position of an eventual LOAD false */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p_t <span style="color:#f92672">=</span> NO_JUMP;  <span style="color:#75715e">/* position of an eventual LOAD true */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (need_value(fs, e<span style="color:#f92672">-&gt;</span>t) <span style="color:#f92672">||</span> need_value(fs, e<span style="color:#f92672">-&gt;</span>f)) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> fj <span style="color:#f92672">=</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VJMP) <span style="color:#f92672">?</span> NO_JUMP : luaK_jump(fs);
</span></span><span style="display:flex;"><span>      p_f <span style="color:#f92672">=</span> code_label(fs, reg, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      p_t <span style="color:#f92672">=</span> code_label(fs, reg, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      luaK_patchtohere(fs, fj);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    final <span style="color:#f92672">=</span> luaK_getlabel(fs);
</span></span><span style="display:flex;"><span>    patchlistaux(fs, e<span style="color:#f92672">-&gt;</span>f, final, reg, p_f);
</span></span><span style="display:flex;"><span>    patchlistaux(fs, e<span style="color:#f92672">-&gt;</span>t, final, reg, p_t);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">=</span> e<span style="color:#f92672">-&gt;</span>t <span style="color:#f92672">=</span> NO_JUMP;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 经过dst.(reg) = src.val 后，表达式的目标地址已确定,且已在reg中 */</span>
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> reg;
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** CP_XXX 拷贝指令 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** reg(var) = exp： 将表达式的src.val拷贝给next&#39;free.reg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_exp2nextreg</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** 更新exp的reg或者op信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** 不能确定exp对应指令的则e-&gt;u.info中填入指令地址，方便回填,同时e-&gt;k:更新为VRELOCABLE，表示需要回填RA?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 释放被临时占用的reg */</span>
</span></span><span style="display:flex;"><span>  freeexp(fs, e);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 申请一个reg，并将exp赋值到reg上 */</span>
</span></span><span style="display:flex;"><span>  luaK_reserveregs(fs, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  exp2reg(fs, e, fs<span style="color:#f92672">-&gt;</span>freereg <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** LOAD_XXX 加载指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 将表达式的值加载到寄存器中(eg:VGLOBAL, VINDEXED)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 已加载到reg中的则无需此步骤(VNONRELOC)),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** RETURNS:寄存器地址 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_exp2anyreg</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 对表达式生成估值指令 */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VNONRELOC) {	<span style="color:#75715e">/* e的src.val已在reg中，则直接返回对应的reg */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>hasjumps(e)) <span style="color:#66d9ef">return</span> e<span style="color:#f92672">-&gt;</span>u.s.info;  <span style="color:#75715e">/* exp is already in a register */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">&gt;=</span> fs<span style="color:#f92672">-&gt;</span>nactvar) {  <span style="color:#75715e">/* reg. is not a local? */</span>
</span></span><span style="display:flex;"><span>      exp2reg(fs, e, e<span style="color:#f92672">-&gt;</span>u.s.info);  <span style="color:#75715e">/* put value on it */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> e<span style="color:#f92672">-&gt;</span>u.s.info;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* e的src值还不在reg则将其存入reg */</span>
</span></span><span style="display:flex;"><span>  luaK_exp2nextreg(fs, e);  <span style="color:#75715e">/* default */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> e<span style="color:#f92672">-&gt;</span>u.s.info;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 类似 LOAD_XXX 生成表达式的加载指令(！！！！不是CP_XXX拷贝一份e的值到reg的拷贝指令) */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_exp2val</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (hasjumps(e))
</span></span><span style="display:flex;"><span>    luaK_exp2anyreg(fs, e);	<span style="color:#75715e">/* 求解表达式的src.val后，将表达式的值放到下一个free.reg中 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    luaK_dischargevars(fs, e);	<span style="color:#75715e">/* 对间接表达式（原值不在reg中或不是直接值的）生成求值指令 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** LOAD_XXX 加载指令 将表达式的值加载到next’free’reg中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** VNONRELOC这种表达式的值已被加载到reg上的就无需处理了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** step.1 表达式的值不在reg中的非VNONRELOC,生成对应的加载指令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** step.2 回填上述加载指令，正式将表达式加载到reg中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** RETURNS: 加载的reg的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_exp2RK</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 对[间接]表达式e生成求值指令 */</span>
</span></span><span style="display:flex;"><span>  luaK_exp2val(fs, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* e是常量表达式，无需生成求值指令，直接返回常量表中对应的索引即可 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (e<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VKNUM:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VTRUE:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VFALSE:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VNIL: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (fs<span style="color:#f92672">-&gt;</span>nk <span style="color:#f92672">&lt;=</span> MAXINDEXRK) {  <span style="color:#75715e">/* constant fit in RK operand? */</span>
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VNIL)  <span style="color:#f92672">?</span> nilK(fs) <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                      (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VKNUM) <span style="color:#f92672">?</span> luaK_numberK(fs, e<span style="color:#f92672">-&gt;</span>u.nval) <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                                        boolK(fs, (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VTRUE));
</span></span><span style="display:flex;"><span>        e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VK;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> RKASK(e<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VK: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">&lt;=</span> MAXINDEXRK)  <span style="color:#75715e">/* constant fit in argC? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> RKASK(e<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* not a constant in the right range: put it in a register 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  **
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ** 间接表达式(非常量表达式)，将其src.val赋值到下一个free.reg中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> luaK_exp2anyreg(fs, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* var = ex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 先 LOAD_XXX (ex) 后 SET_XXX(var=ex) 的&#34;赋值组合业务&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_storevar</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>var, expdesc <span style="color:#f92672">*</span>ex) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (var<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VLOCAL: {
</span></span><span style="display:flex;"><span>      freeexp(fs, ex);
</span></span><span style="display:flex;"><span>      exp2reg(fs, ex, var<span style="color:#f92672">-&gt;</span>u.s.info);	<span style="color:#75715e">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VUPVAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> luaK_exp2anyreg(fs, ex);	<span style="color:#75715e">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABC(fs, OP_SETUPVAL, e, var<span style="color:#f92672">-&gt;</span>u.s.info, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VGLOBAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> luaK_exp2anyreg(fs, ex);	<span style="color:#75715e">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABx(fs, OP_SETGLOBAL, e, var<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VINDEXED: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> luaK_exp2RK(fs, ex);	<span style="color:#75715e">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABC(fs, OP_SETTABLE, var<span style="color:#f92672">-&gt;</span>u.s.info, var<span style="color:#f92672">-&gt;</span>u.s.aux, e);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      lua_assert(<span style="color:#ae81ff">0</span>);  <span style="color:#75715e">/* invalid var kind to store */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  freeexp(fs, ex);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* OP_SELF A B C R(A+1) := R(B); R(A) := R(B)[RK(C)] */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_self</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e, expdesc <span style="color:#f92672">*</span>key) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> func;
</span></span><span style="display:flex;"><span>  luaK_exp2anyreg(fs, e);
</span></span><span style="display:flex;"><span>  freeexp(fs, e);
</span></span><span style="display:flex;"><span>  func <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>freereg;
</span></span><span style="display:flex;"><span>  luaK_reserveregs(fs, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, OP_SELF, func, e<span style="color:#f92672">-&gt;</span>u.s.info, luaK_exp2RK(fs, key));
</span></span><span style="display:flex;"><span>  freeexp(fs, key);
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> func;
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* invert:颠倒 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">invertjump</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  Instruction <span style="color:#f92672">*</span>pc <span style="color:#f92672">=</span> getjumpcontrol(fs, e<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>  lua_assert(testTMode(GET_OPCODE(<span style="color:#f92672">*</span>pc)) <span style="color:#f92672">&amp;&amp;</span> GET_OPCODE(<span style="color:#f92672">*</span>pc) <span style="color:#f92672">!=</span> OP_TESTSET <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                                           GET_OPCODE(<span style="color:#f92672">*</span>pc) <span style="color:#f92672">!=</span> OP_TEST);
</span></span><span style="display:flex;"><span>  SETARG_A(<span style="color:#f92672">*</span>pc, <span style="color:#f92672">!</span>(GETARG_A(<span style="color:#f92672">*</span>pc)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">jumponcond</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e, <span style="color:#66d9ef">int</span> cond) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VRELOCABLE) {
</span></span><span style="display:flex;"><span>    Instruction ie <span style="color:#f92672">=</span> getcode(fs, e);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (GET_OPCODE(ie) <span style="color:#f92672">==</span> OP_NOT) {
</span></span><span style="display:flex;"><span>      fs<span style="color:#f92672">-&gt;</span>pc<span style="color:#f92672">--</span>;  <span style="color:#75715e">/* remove previous OP_NOT */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> condjump(fs, OP_TEST, GETARG_B(ie), <span style="color:#ae81ff">0</span>, <span style="color:#f92672">!</span>cond);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* else go through */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  discharge2anyreg(fs, e);
</span></span><span style="display:flex;"><span>  freeexp(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> condjump(fs, OP_TESTSET, NO_REG, e<span style="color:#f92672">-&gt;</span>u.s.info, cond);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* and */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_goiftrue</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pc;  <span style="color:#75715e">/* pc of last jump */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (e<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VK: <span style="color:#66d9ef">case</span> VKNUM: <span style="color:#66d9ef">case</span> VTRUE: {	
</span></span><span style="display:flex;"><span>      pc <span style="color:#f92672">=</span> NO_JUMP;  <span style="color:#75715e">/* always true; do nothing， keep go throught? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      invertjump(fs, e);
</span></span><span style="display:flex;"><span>      pc <span style="color:#f92672">=</span> e<span style="color:#f92672">-&gt;</span>u.s.info;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      pc <span style="color:#f92672">=</span> jumponcond(fs, e, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaK_concat(fs, <span style="color:#f92672">&amp;</span>e<span style="color:#f92672">-&gt;</span>f, pc);  <span style="color:#75715e">/* insert last jump in `f&#39; list */</span>
</span></span><span style="display:flex;"><span>  luaK_patchtohere(fs, e<span style="color:#f92672">-&gt;</span>t);
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>t <span style="color:#f92672">=</span> NO_JUMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* or */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_goiffalse</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pc;  <span style="color:#75715e">/* pc of last jump */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (e<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VNIL: <span style="color:#66d9ef">case</span> VFALSE: {
</span></span><span style="display:flex;"><span>      pc <span style="color:#f92672">=</span> NO_JUMP;  <span style="color:#75715e">/* always false; do nothing */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      pc <span style="color:#f92672">=</span> e<span style="color:#f92672">-&gt;</span>u.s.info;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      pc <span style="color:#f92672">=</span> jumponcond(fs, e, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaK_concat(fs, <span style="color:#f92672">&amp;</span>e<span style="color:#f92672">-&gt;</span>t, pc);  <span style="color:#75715e">/* insert last jump in `t&#39; list */</span>
</span></span><span style="display:flex;"><span>  luaK_patchtohere(fs, e<span style="color:#f92672">-&gt;</span>f);
</span></span><span style="display:flex;"><span>  e<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">=</span> NO_JUMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* not  A B R(A) := not R(B) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** not的stat的左边必须有左值,否则就是语法错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">codenot</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (e<span style="color:#f92672">-&gt;</span>k) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VNIL: <span style="color:#66d9ef">case</span> VFALSE: {
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VTRUE;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VK: <span style="color:#66d9ef">case</span> VKNUM: <span style="color:#66d9ef">case</span> VTRUE: {
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VFALSE;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      invertjump(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VRELOCABLE:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> VNONRELOC: {
</span></span><span style="display:flex;"><span>      discharge2anyreg(fs, e);
</span></span><span style="display:flex;"><span>      freeexp(fs, e);
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> luaK_codeABC(fs, OP_NOT, <span style="color:#ae81ff">0</span>, e<span style="color:#f92672">-&gt;</span>u.s.info, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      e<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      lua_assert(<span style="color:#ae81ff">0</span>);  <span style="color:#75715e">/* cannot happen */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* interchange true and false lists */</span>
</span></span><span style="display:flex;"><span>  { <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> e<span style="color:#f92672">-&gt;</span>f; e<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">=</span> e<span style="color:#f92672">-&gt;</span>t; e<span style="color:#f92672">-&gt;</span>t <span style="color:#f92672">=</span> temp; }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  removevalues(fs, e<span style="color:#f92672">-&gt;</span>f);
</span></span><span style="display:flex;"><span>  removevalues(fs, e<span style="color:#f92672">-&gt;</span>t);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 索引表达式t.k 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** info = table register; aux = index register (or `k&#39;) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** eg: tbl(info).aux(aux) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_indexed</span> (FuncState <span style="color:#f92672">*</span>fs, expdesc <span style="color:#f92672">*</span>t, expdesc <span style="color:#f92672">*</span>k) {
</span></span><span style="display:flex;"><span>  t<span style="color:#f92672">-&gt;</span>u.s.aux <span style="color:#f92672">=</span> luaK_exp2RK(fs, k);
</span></span><span style="display:flex;"><span>  t<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VINDEXED;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 尝试合并二元操作符以及左右两边的表达式(编译优化) */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">constfolding</span> (OpCode op, expdesc <span style="color:#f92672">*</span>e1, expdesc <span style="color:#f92672">*</span>e2) {
</span></span><span style="display:flex;"><span>  lua_Number v1, v2, r;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 两个操作数都得是numeral */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isnumeral(e1) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>isnumeral(e2)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  v1 <span style="color:#f92672">=</span> e1<span style="color:#f92672">-&gt;</span>u.nval;
</span></span><span style="display:flex;"><span>  v2 <span style="color:#f92672">=</span> e2<span style="color:#f92672">-&gt;</span>u.nval;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_ADD: r <span style="color:#f92672">=</span> luai_numadd(v1, v2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_SUB: r <span style="color:#f92672">=</span> luai_numsub(v1, v2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_MUL: r <span style="color:#f92672">=</span> luai_nummul(v1, v2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_DIV:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (v2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">/* do not attempt to divide by 0 */</span>
</span></span><span style="display:flex;"><span>      r <span style="color:#f92672">=</span> luai_numdiv(v1, v2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_MOD:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (v2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">/* do not attempt to divide by 0 */</span>
</span></span><span style="display:flex;"><span>      r <span style="color:#f92672">=</span> luai_nummod(v1, v2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_POW: r <span style="color:#f92672">=</span> luai_numpow(v1, v2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_UNM: r <span style="color:#f92672">=</span> luai_numunm(v1); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OP_LEN: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">/* no constant folding for &#39;len&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> lua_assert(<span style="color:#ae81ff">0</span>); r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (luai_numisnan(r)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">/* do not attempt to produce NaN */</span>
</span></span><span style="display:flex;"><span>  e1<span style="color:#f92672">-&gt;</span>u.nval <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** local a = b + c 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">** 表达式运行完毕后，b,c占用的临时的reg就可以被释放了，故而这一行编译完成后b,c占用的reg也可以释放了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">codearith</span> (FuncState <span style="color:#f92672">*</span>fs, OpCode op, expdesc <span style="color:#f92672">*</span>e1, expdesc <span style="color:#f92672">*</span>e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (constfolding(op, e1, e2))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> o2 <span style="color:#f92672">=</span> (op <span style="color:#f92672">!=</span> OP_UNM <span style="color:#f92672">&amp;&amp;</span> op <span style="color:#f92672">!=</span> OP_LEN) <span style="color:#f92672">?</span> luaK_exp2RK(fs, e2) <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> o1 <span style="color:#f92672">=</span> luaK_exp2RK(fs, e1);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* 释放exp的规则是从后往前free */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (o1 <span style="color:#f92672">&gt;</span> o2) {
</span></span><span style="display:flex;"><span>      freeexp(fs, e1);
</span></span><span style="display:flex;"><span>      freeexp(fs, e2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      freeexp(fs, e2);
</span></span><span style="display:flex;"><span>      freeexp(fs, e1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* 这里R(A)的值尚未确定，e-&gt;=VRELOCABLE:表示需要重定位？ */</span>
</span></span><span style="display:flex;"><span>    e1<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> luaK_codeABC(fs, op, <span style="color:#ae81ff">0</span>, o1, o2);
</span></span><span style="display:flex;"><span>    e1<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 关系表达式 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">codecomp</span> (FuncState <span style="color:#f92672">*</span>fs, OpCode op, <span style="color:#66d9ef">int</span> cond, expdesc <span style="color:#f92672">*</span>e1,
</span></span><span style="display:flex;"><span>                                                          expdesc <span style="color:#f92672">*</span>e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> o1 <span style="color:#f92672">=</span> luaK_exp2RK(fs, e1);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> o2 <span style="color:#f92672">=</span> luaK_exp2RK(fs, e2);
</span></span><span style="display:flex;"><span>  freeexp(fs, e2);
</span></span><span style="display:flex;"><span>  freeexp(fs, e1);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cond <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> op <span style="color:#f92672">!=</span> OP_EQ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> temp;  <span style="color:#75715e">/* exchange args to replace by `&lt;&#39; or `&lt;=&#39; */</span>
</span></span><span style="display:flex;"><span>    temp <span style="color:#f92672">=</span> o1; o1 <span style="color:#f92672">=</span> o2; o2 <span style="color:#f92672">=</span> temp;  <span style="color:#75715e">/* o1 &lt;==&gt; o2 */</span>
</span></span><span style="display:flex;"><span>    cond <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  e1<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> condjump(fs, op, cond, o1, o2);
</span></span><span style="display:flex;"><span>  e1<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VJMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_prefix</span> (FuncState <span style="color:#f92672">*</span>fs, UnOpr op, expdesc <span style="color:#f92672">*</span>e) {
</span></span><span style="display:flex;"><span>  expdesc e2;
</span></span><span style="display:flex;"><span>  e2.t <span style="color:#f92672">=</span> e2.f <span style="color:#f92672">=</span> NO_JUMP;
</span></span><span style="display:flex;"><span>  e2.k <span style="color:#f92672">=</span> VKNUM; e2.u.nval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_MINUS: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isnumeral(e))
</span></span><span style="display:flex;"><span>        luaK_exp2anyreg(fs, e);  <span style="color:#75715e">/* cannot operate on non-numeric constants */</span>
</span></span><span style="display:flex;"><span>      codearith(fs, OP_UNM, e, <span style="color:#f92672">&amp;</span>e2);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_NOT: codenot(fs, e); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_LEN: {
</span></span><span style="display:flex;"><span>      luaK_exp2anyreg(fs, e);  <span style="color:#75715e">/* cannot operate on constants */</span>
</span></span><span style="display:flex;"><span>      codearith(fs, OP_LEN, e, <span style="color:#f92672">&amp;</span>e2);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> lua_assert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_infix</span> (FuncState <span style="color:#f92672">*</span>fs, BinOpr op, expdesc <span style="color:#f92672">*</span>v) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_AND: {
</span></span><span style="display:flex;"><span>      luaK_goiftrue(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_OR: {
</span></span><span style="display:flex;"><span>      luaK_goiffalse(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_CONCAT: {
</span></span><span style="display:flex;"><span>      luaK_exp2nextreg(fs, v);  <span style="color:#75715e">/* operand must be on the `stack&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_ADD: <span style="color:#66d9ef">case</span> OPR_SUB: <span style="color:#66d9ef">case</span> OPR_MUL: <span style="color:#66d9ef">case</span> OPR_DIV:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_MOD: <span style="color:#66d9ef">case</span> OPR_POW: {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>isnumeral(v)) luaK_exp2RK(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>      luaK_exp2RK(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_posfix</span> (FuncState <span style="color:#f92672">*</span>fs, BinOpr op, expdesc <span style="color:#f92672">*</span>e1, expdesc <span style="color:#f92672">*</span>e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_AND: {
</span></span><span style="display:flex;"><span>      lua_assert(e1<span style="color:#f92672">-&gt;</span>t <span style="color:#f92672">==</span> NO_JUMP);  <span style="color:#75715e">/* list must be closed */</span>
</span></span><span style="display:flex;"><span>      luaK_dischargevars(fs, e2);
</span></span><span style="display:flex;"><span>      luaK_concat(fs, <span style="color:#f92672">&amp;</span>e2<span style="color:#f92672">-&gt;</span>f, e1<span style="color:#f92672">-&gt;</span>f);
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>e1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>e2;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_OR: {
</span></span><span style="display:flex;"><span>      lua_assert(e1<span style="color:#f92672">-&gt;</span>f <span style="color:#f92672">==</span> NO_JUMP);  <span style="color:#75715e">/* list must be closed */</span>
</span></span><span style="display:flex;"><span>      luaK_dischargevars(fs, e2);
</span></span><span style="display:flex;"><span>      luaK_concat(fs, <span style="color:#f92672">&amp;</span>e2<span style="color:#f92672">-&gt;</span>t, e1<span style="color:#f92672">-&gt;</span>t);
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>e1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>e2;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_CONCAT: {
</span></span><span style="display:flex;"><span>      luaK_exp2val(fs, e2);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (e2<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">==</span> VRELOCABLE <span style="color:#f92672">&amp;&amp;</span> GET_OPCODE(getcode(fs, e2)) <span style="color:#f92672">==</span> OP_CONCAT) {
</span></span><span style="display:flex;"><span>        lua_assert(e1<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">==</span> GETARG_B(getcode(fs, e2))<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        freeexp(fs, e1);
</span></span><span style="display:flex;"><span>        SETARG_B(getcode(fs, e2), e1<span style="color:#f92672">-&gt;</span>u.s.info);
</span></span><span style="display:flex;"><span>        e1<span style="color:#f92672">-&gt;</span>k <span style="color:#f92672">=</span> VRELOCABLE; e1<span style="color:#f92672">-&gt;</span>u.s.info <span style="color:#f92672">=</span> e2<span style="color:#f92672">-&gt;</span>u.s.info;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        luaK_exp2nextreg(fs, e2);  <span style="color:#75715e">/* operand must be on the &#39;stack&#39; */</span>
</span></span><span style="display:flex;"><span>        codearith(fs, OP_CONCAT, e1, e2);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_ADD: codearith(fs, OP_ADD, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_SUB: codearith(fs, OP_SUB, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_MUL: codearith(fs, OP_MUL, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_DIV: codearith(fs, OP_DIV, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_MOD: codearith(fs, OP_MOD, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_POW: codearith(fs, OP_POW, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_EQ: codecomp(fs, OP_EQ, <span style="color:#ae81ff">1</span>, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_NE: codecomp(fs, OP_EQ, <span style="color:#ae81ff">0</span>, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_LT: codecomp(fs, OP_LT, <span style="color:#ae81ff">1</span>, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_LE: codecomp(fs, OP_LE, <span style="color:#ae81ff">1</span>, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_GT: codecomp(fs, OP_LT, <span style="color:#ae81ff">0</span>, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> OPR_GE: codecomp(fs, OP_LE, <span style="color:#ae81ff">0</span>, e1, e2); <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> lua_assert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 更新上一个生成的pc对应的行信息 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_fixline</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> line) {
</span></span><span style="display:flex;"><span>  fs<span style="color:#f92672">-&gt;</span>f<span style="color:#f92672">-&gt;</span>lineinfo[fs<span style="color:#f92672">-&gt;</span>pc <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> line;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_code</span> (FuncState <span style="color:#f92672">*</span>fs, Instruction i, <span style="color:#66d9ef">int</span> line) {
</span></span><span style="display:flex;"><span>  Proto <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fs<span style="color:#f92672">-&gt;</span>f;
</span></span><span style="display:flex;"><span>  dischargejpc(fs);  <span style="color:#75715e">/* `pc&#39; will change */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* put new instruction in code array */</span>
</span></span><span style="display:flex;"><span>  luaM_growvector(fs<span style="color:#f92672">-&gt;</span>L, f<span style="color:#f92672">-&gt;</span>code, fs<span style="color:#f92672">-&gt;</span>pc, f<span style="color:#f92672">-&gt;</span>sizecode, Instruction,
</span></span><span style="display:flex;"><span>                  MAX_INT, <span style="color:#e6db74">&#34;code size overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  f<span style="color:#f92672">-&gt;</span>code[fs<span style="color:#f92672">-&gt;</span>pc] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* save corresponding line information */</span>
</span></span><span style="display:flex;"><span>  luaM_growvector(fs<span style="color:#f92672">-&gt;</span>L, f<span style="color:#f92672">-&gt;</span>lineinfo, fs<span style="color:#f92672">-&gt;</span>pc, f<span style="color:#f92672">-&gt;</span>sizelineinfo, <span style="color:#66d9ef">int</span>,
</span></span><span style="display:flex;"><span>                  MAX_INT, <span style="color:#e6db74">&#34;code size overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  f<span style="color:#f92672">-&gt;</span>lineinfo[fs<span style="color:#f92672">-&gt;</span>pc] <span style="color:#f92672">=</span> line;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> fs<span style="color:#f92672">-&gt;</span>pc<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_codeABC</span> (FuncState <span style="color:#f92672">*</span>fs, OpCode o, <span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>  lua_assert(getOpMode(o) <span style="color:#f92672">==</span> iABC);
</span></span><span style="display:flex;"><span>  lua_assert(getBMode(o) <span style="color:#f92672">!=</span> OpArgN <span style="color:#f92672">||</span> b <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  lua_assert(getCMode(o) <span style="color:#f92672">!=</span> OpArgN <span style="color:#f92672">||</span> c <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> luaK_code(fs, CREATE_ABC(o, a, b, c), fs<span style="color:#f92672">-&gt;</span>ls<span style="color:#f92672">-&gt;</span>lastline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">luaK_codeABx</span> (FuncState <span style="color:#f92672">*</span>fs, OpCode o, <span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> bc) {
</span></span><span style="display:flex;"><span>  lua_assert(getOpMode(o) <span style="color:#f92672">==</span> iABx <span style="color:#f92672">||</span> getOpMode(o) <span style="color:#f92672">==</span> iAsBx);
</span></span><span style="display:flex;"><span>  lua_assert(getCMode(o) <span style="color:#f92672">==</span> OpArgN);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> luaK_code(fs, CREATE_ABx(o, a, bc), fs<span style="color:#f92672">-&gt;</span>ls<span style="color:#f92672">-&gt;</span>lastline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">luaK_setlist</span> (FuncState <span style="color:#f92672">*</span>fs, <span style="color:#66d9ef">int</span> base, <span style="color:#66d9ef">int</span> nelems, <span style="color:#66d9ef">int</span> tostore) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span>  (nelems <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span>LFIELDS_PER_FLUSH <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> (tostore <span style="color:#f92672">==</span> LUA_MULTRET) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> tostore;	<span style="color:#75715e">/* tostore中最后一个是变参，则tostore==LUA_MULTRET */</span>
</span></span><span style="display:flex;"><span>  lua_assert(tostore <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&lt;=</span> MAXARG_C)
</span></span><span style="display:flex;"><span>    luaK_codeABC(fs, OP_SETLIST, base, b, c);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">/* c过大，将其放到下一条指令中 */</span>
</span></span><span style="display:flex;"><span>    luaK_codeABC(fs, OP_SETLIST, base, b, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    luaK_code(fs, cast(Instruction, c), fs<span style="color:#f92672">-&gt;</span>ls<span style="color:#f92672">-&gt;</span>lastline);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 这里可以回收空闲出来的寄存器了，有意思吧 */</span>
</span></span><span style="display:flex;"><span>  fs<span style="color:#f92672">-&gt;</span>freereg <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">/* free registers with list values */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/lua" rel="tag" title="lua">#lua#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/06/15/%E8%B4%B5%E5%9C%A8%E5%9D%9A%E6%8C%81/" rel="next" title="贵在坚持">
        <i class="fa fa-chevron-left"></i> 贵在坚持
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lparse.c/" rel="prev" title="lua源码注释 lparse.c">
        lua源码注释 lparse.c <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">463</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">28</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">34</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2022</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">愿星光伴你左右</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.101.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>