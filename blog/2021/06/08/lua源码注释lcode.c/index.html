<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>lua源码注释lcode.c - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="lua源码注释lcode.c">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="lua源码注释lcode.c - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/todo/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />todo
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />思考
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/life/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />life
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/food/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />food
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/distributed/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />distributed
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/finance/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />投资
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8Alcode.c/" itemprop="url">
        lua源码注释lcode.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-06-08">
    2021-06-08
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6243 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** $Id: lcode.c,v 2.25.1.5 2011/01/31 14:53:16 roberto Exp $
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** Code generator for Lua
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define lcode_c
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lcode.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lgc.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;llex.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lmem.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lparser.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* e的类型 expdesc */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">#define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">isnumeral</span>(expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> (e-&gt;k == VKNUM &amp;&amp;	<span style="color:#f00;font-style:italic">/* 仅仅e-&gt;k == VKNUM 不够么？ */</span>
</span></span><span style="display:flex;"><span>		  	e-&gt;t == NO_JUMP &amp;&amp;
</span></span><span style="display:flex;"><span>		  	e-&gt;f == NO_JUMP);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 给连续的变量赋nil
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** OP_LOADNIL A B R(A) := ... := R(B) := nil
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 当可以合并前一条OP_LOADNIL时则尝试合并，可以利用fun&#39;stack的默认NIL时，直接用NIL
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_nil</span> (FuncState *fs, <span style="color:#00f">int</span> from, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  Instruction *previous;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (fs-&gt;pc &gt; fs-&gt;lasttarget) {  <span style="color:#f00;font-style:italic">/* no jumps to current position? */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (fs-&gt;pc == 0) {  <span style="color:#f00;font-style:italic">/* function start? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (from &gt;= fs-&gt;nactvar)  <span style="color:#f00;font-style:italic">/* 新调用一个fun时，其私有stack默认会被置NULL，这种情况直接使用默认的NULL即可 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* positions are already clean */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (GET_OPCODE(*previous) == OP_LOADNIL) {	<span style="color:#f00;font-style:italic">/* 尝试合并前后连续的OP_LOADNIL指令 */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> pfrom = GETARG_A(*previous);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">int</span> pto = GETARG_B(*previous);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">if</span> (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  <span style="color:#f00;font-style:italic">/* can connect both? */</span>
</span></span><span style="display:flex;"><span>          <span style="color:#00f">if</span> (from+n-1 &gt; pto)
</span></span><span style="display:flex;"><span>            SETARG_B(*previous, from+n-1);
</span></span><span style="display:flex;"><span>          <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, OP_LOADNIL, from, from+n-1, 0);  <span style="color:#f00;font-style:italic">/* else no optimization */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** OP_JMP sBx PC += sBx
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 待回填的跳转链表指向我，而我又指向其它pc，那么将上述链表和我串联在一起即可
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_jump</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> jpc = fs-&gt;jpc;  <span style="color:#f00;font-style:italic">/* save list of jumps to here */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> j;
</span></span><span style="display:flex;"><span>  fs-&gt;jpc = NO_JUMP;
</span></span><span style="display:flex;"><span>  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
</span></span><span style="display:flex;"><span>  luaK_concat(fs, &amp;j, jpc);  <span style="color:#f00;font-style:italic">/* keep them on hold */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> j;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 从函数返回
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** OP_RETURN A B return R(A), ... ,R(A+B-2)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_ret</span> (FuncState *fs, <span style="color:#00f">int</span> first, <span style="color:#00f">int</span> nret) {
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);	<span style="color:#f00;font-style:italic">/* 这里可以反推OP_RETURNS中A,B,C的含义了 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 有条件跳转 OP_TEST, OP_TESTSET */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">condjump</span> (FuncState *fs, OpCode op, <span style="color:#00f">int</span> A, <span style="color:#00f">int</span> B, <span style="color:#00f">int</span> C) {
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, op, A, B, C);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> luaK_jump(fs);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将待回填的跳转指令pc指向dest */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">fixjump</span> (FuncState *fs, <span style="color:#00f">int</span> pc, <span style="color:#00f">int</span> dest) {
</span></span><span style="display:flex;"><span>  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 下面计算跳转指令的跳转目标绝对值时也加了1，和这里是一致的 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> offset = dest-(pc+1);		
</span></span><span style="display:flex;"><span>  lua_assert(dest != NO_JUMP);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (abs(offset) &gt; MAXARG_sBx)
</span></span><span style="display:flex;"><span>    luaX_syntaxerror(fs-&gt;ls, <span style="color:#009c00">&#34;control structure too long&#34;</span>);
</span></span><span style="display:flex;"><span>  SETARG_sBx(*jmp, offset);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** returns current `pc&#39; and marks it as a jump target (to avoid wrong
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** optimizations(优化) with consecutive(连续) instructions not in the same basic block).
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_getlabel</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  fs-&gt;lasttarget = fs-&gt;pc;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> fs-&gt;pc;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 获取跳转指令指向的绝对位置 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">getjump</span> (FuncState *fs, <span style="color:#00f">int</span> pc) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> offset = GETARG_sBx(fs-&gt;f-&gt;code[pc]);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (offset == NO_JUMP)  <span style="color:#f00;font-style:italic">/* point to itself represents end of list */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> NO_JUMP;  <span style="color:#f00;font-style:italic">/* end of list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> (pc+1)+offset;  <span style="color:#f00;font-style:italic">/* turn offset into absolute position */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> Instruction *<span style="color:#c34e00">getjumpcontrol</span> (FuncState *fs, <span style="color:#00f">int</span> pc) {
</span></span><span style="display:flex;"><span>  Instruction *pi = &amp;fs-&gt;f-&gt;code[pc];
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (pc &gt;= 1 &amp;&amp; testTMode(GET_OPCODE(*(pi-1))))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> pi-1;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> pi;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** check whether list has any jump that do not produce a value
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** (or produce an inverted(颠,倒) value)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">need_value</span> (FuncState *fs, <span style="color:#00f">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; list != NO_JUMP; list = getjump(fs, list)) {
</span></span><span style="display:flex;"><span>    Instruction i = *getjumpcontrol(fs, list);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (GET_OPCODE(i) != OP_TESTSET) <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* not found */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">patchtestreg</span> (FuncState *fs, <span style="color:#00f">int</span> node, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  Instruction *i = getjumpcontrol(fs, node);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (GET_OPCODE(*i) != OP_TESTSET)
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* cannot patch other instructions */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (reg != NO_REG &amp;&amp; reg != GETARG_B(*i))
</span></span><span style="display:flex;"><span>    SETARG_A(*i, reg);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>  <span style="color:#f00;font-style:italic">/* no register to put value or register already has the value */</span>
</span></span><span style="display:flex;"><span>    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">removevalues</span> (FuncState *fs, <span style="color:#00f">int</span> list) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (; list != NO_JUMP; list = getjump(fs, list))
</span></span><span style="display:flex;"><span>      patchtestreg(fs, list, NO_REG);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 回填跳转指令链表上的指令到指定目标
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将待回填跳转指令列表list上指令的跳转参数sBx更新到target上 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">patchlistaux</span> (FuncState *fs, <span style="color:#00f">int</span> list, <span style="color:#00f">int</span> vtarget, <span style="color:#00f">int</span> reg,
</span></span><span style="display:flex;"><span>                          <span style="color:#00f">int</span> dtarget) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">while</span> (list != NO_JUMP) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> next = getjump(fs, list);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (patchtestreg(fs, list, reg))
</span></span><span style="display:flex;"><span>      fixjump(fs, list, vtarget);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>      fixjump(fs, list, dtarget);  <span style="color:#f00;font-style:italic">/* jump to default target */</span>
</span></span><span style="display:flex;"><span>    list = next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将待回填的跳转到当前指令的跳转链表上的跳转指令的sBx更新为fs-&gt;pc */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">dischargejpc</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  patchlistaux(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc);
</span></span><span style="display:flex;"><span>  fs-&gt;jpc = NO_JUMP;	<span style="color:#f00;font-style:italic">/* 置空 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_patchlist</span> (FuncState *fs, <span style="color:#00f">int</span> list, <span style="color:#00f">int</span> target) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (target == fs-&gt;pc)
</span></span><span style="display:flex;"><span>    luaK_patchtohere(fs, list);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    lua_assert(target &lt; fs-&gt;pc);
</span></span><span style="display:flex;"><span>    patchlistaux(fs, list, target, NO_REG, target);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将待回填的跳转指令链表list挂到fs-&gt;jpc,等生成下一条指令时回填sBx */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_patchtohere</span> (FuncState *fs, <span style="color:#00f">int</span> list) {
</span></span><span style="display:flex;"><span>  luaK_getlabel(fs);
</span></span><span style="display:flex;"><span>  luaK_concat(fs, &amp;fs-&gt;jpc, list);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*  l1.sBx = l2 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将l2指向的待回填跳转指令/指令链表挂到l1的跳转链表上
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_concat</span> (FuncState *fs, <span style="color:#00f">int</span> *l1, <span style="color:#00f">int</span> l2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (l2 == NO_JUMP) <span style="color:#f00;font-style:italic">/* l2不是一条跳转指令，直接返回 */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (*l1 == NO_JUMP)	<span style="color:#f00;font-style:italic">/* 当前跳转列表为空 */</span>
</span></span><span style="display:flex;"><span>    *l1 = l2;	<span style="color:#f00;font-style:italic">/* l1尚未初始化，直接赋值即可 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> list = *l1;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> next;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> ((next = getjump(fs, list)) != NO_JUMP)  <span style="color:#f00;font-style:italic">/* find last element */</span>
</span></span><span style="display:flex;"><span>      list = next;
</span></span><span style="display:flex;"><span>    fixjump(fs, list, l2);	<span style="color:#f00;font-style:italic">/* 将待回填的跳转指令链表l2挂到l1的末尾 */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 调整maxstacksize以便匹配locvar的数量 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_checkstack</span> (FuncState *fs, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> newstack = fs-&gt;freereg + n;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (newstack &gt; fs-&gt;f-&gt;maxstacksize) {	<span style="color:#f00;font-style:italic">/* 这个判断是必须的 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (newstack &gt;= MAXSTACK)
</span></span><span style="display:flex;"><span>      luaX_syntaxerror(fs-&gt;ls, <span style="color:#009c00">&#34;function or expression too complex&#34;</span>);
</span></span><span style="display:flex;"><span>    fs-&gt;f-&gt;maxstacksize = cast_byte(newstack);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* reserve reg:预定 寄存器 实际上是占用n个寄存器的意思
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_reserveregs</span> (FuncState *fs, <span style="color:#00f">int</span> n) {
</span></span><span style="display:flex;"><span>  luaK_checkstack(fs, n);
</span></span><span style="display:flex;"><span>  fs-&gt;freereg += n;	<span style="color:#f00;font-style:italic">/* 占用n个locvar,释放则n为负值或在其它函数中实现 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 重点函数，需要细读 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">freereg</span> (FuncState *fs, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!ISK(reg) &amp;&amp;            <span style="color:#f00;font-style:italic">/* 常量的就不用释放了，压根没占用reg */</span>
</span></span><span style="display:flex;"><span>      reg &gt;= fs-&gt;nactvar) {   <span style="color:#f00;font-style:italic">/* reg从0开始，nactvar从1开始，所以这里reg&gt;=fs-&gt;nactvar是可以的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">      
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	/* 释放一个reg后,reg==fs-&gt;freereg:确保只能释放最新一个被激活的reg(作为exp的临时reg占用？) */</span>
</span></span><span style="display:flex;"><span>    fs-&gt;freereg--;
</span></span><span style="display:flex;"><span>    lua_assert(reg == fs-&gt;freereg);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 释放被临时占用的reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">freeexp</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VNONRELOC)		<span style="color:#f00;font-style:italic">/* 表达式的值已被CP_XXX到reg中的，才释放 (还没加载到reg，那压根没占用reg，释放个锤子*/</span>
</span></span><span style="display:flex;"><span>    freereg(fs, e-&gt;u.s.info);	<span style="color:#f00;font-style:italic">/* VNONRELOC info = result register */</span> 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将常量加载到fs-&gt;f的常量表中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** local var = &#34;hello
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">&#34; 则本函数的k,v=&#34;hello&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">addk</span> (FuncState *fs, TValue *k, TValue *v) {
</span></span><span style="display:flex;"><span>  lua_State *L = fs-&gt;L;
</span></span><span style="display:flex;"><span>  TValue *idx = luaH_set(L, fs-&gt;h, k);
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> oldsize = f-&gt;sizek;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (ttisnumber(idx)) {
</span></span><span style="display:flex;"><span>    lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast_int(nvalue(idx))], v));	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> cast_int(nvalue(idx));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* constant not found; create a new entry */</span>
</span></span><span style="display:flex;"><span>    setnvalue(idx, cast_num(fs-&gt;nk));
</span></span><span style="display:flex;"><span>    luaM_growvector(L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TValue,
</span></span><span style="display:flex;"><span>                    MAXARG_Bx, <span style="color:#009c00">&#34;constant table overflow&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">while</span> (oldsize &lt; f-&gt;sizek) setnilvalue(&amp;f-&gt;k[oldsize++]);
</span></span><span style="display:flex;"><span>    setobj(L, &amp;f-&gt;k[fs-&gt;nk], v);
</span></span><span style="display:flex;"><span>    luaC_barrier(L, f, v);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> fs-&gt;nk++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 将字符串常量加载到fs-&gt;f的常量表中 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_stringK</span> (FuncState *fs, TString *s) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  setsvalue(fs-&gt;L, &amp;o, s);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> addk(fs, &amp;o, &amp;o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_numberK</span> (FuncState *fs, lua_Number r) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  setnvalue(&amp;o, r);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> addk(fs, &amp;o, &amp;o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">boolK</span> (FuncState *fs, <span style="color:#00f">int</span> b) {
</span></span><span style="display:flex;"><span>  TValue o;
</span></span><span style="display:flex;"><span>  setbvalue(&amp;o, b);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> addk(fs, &amp;o, &amp;o);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">nilK</span> (FuncState *fs) {
</span></span><span style="display:flex;"><span>  TValue k, v;
</span></span><span style="display:flex;"><span>  setnilvalue(&amp;v);
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* cannot use nil as key; instead use table itself to represent nil */</span>
</span></span><span style="display:flex;"><span>  sethvalue(fs-&gt;L, &amp;k, fs-&gt;h);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> addk(fs, &amp;k, &amp;v);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* nresults:-1, C=0，表示希望返回变参
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nresults: 0, C=1, 表示希望返回0个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** nresults: 2, C=2, 表示希望返回1个参数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_setreturns</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> nresults) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* OP_CALL A B C 		R(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VCALL) {  <span style="color:#f00;font-style:italic">/* expression is an open function call? */</span>
</span></span><span style="display:flex;"><span>    SETARG_C(getcode(fs, e), nresults+1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (e-&gt;k == VVARARG) {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* OP_VARARG A B 	R(A), R(A+1), ..., R(A+B-1) = vararg 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	** 将变参拷贝到RA指定的寄存器开始的地方，拷贝B个元素，这里仅使用了一个寄存器的编码?
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	*/</span>
</span></span><span style="display:flex;"><span>    SETARG_B(getcode(fs, e), nresults+1);
</span></span><span style="display:flex;"><span>    SETARG_A(getcode(fs, e), fs-&gt;freereg);
</span></span><span style="display:flex;"><span>    luaK_reserveregs(fs, 1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 对于可能返回变参的表达式，强制其仅返回一个值 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_setoneret</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VCALL) {  <span style="color:#f00;font-style:italic">/* expression is an open function call? */</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* A B C R(A), … ,R(A+C-2) := R(A)(R(A+1), … ,R(A+B-1)) */</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 函数调用返回的第一个值占用的reg就是函数指针本身占用的reg,
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	** 不能返回到其它地方，故而这里是VNONRELOC
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  	*/</span>
</span></span><span style="display:flex;"><span>    e-&gt;k = VNONRELOC;	
</span></span><span style="display:flex;"><span>    e-&gt;u.s.info = GETARG_A(getcode(fs, e));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (e-&gt;k == VVARARG) {
</span></span><span style="display:flex;"><span>    SETARG_B(getcode(fs, e), 2);	<span style="color:#f00;font-style:italic">/* 2:期待返回一个返回值 */</span>
</span></span><span style="display:flex;"><span>    e-&gt;k = VRELOCABLE;  <span style="color:#f00;font-style:italic">/* can relocate its simple result */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 生成LOAD_XXX(加载)系列指令，（为后续加载间接表达式的值到reg做准备）
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 对需间接读取src.val的表达式生成对应的读值指令(eg:OP_GETTABLE),以便下一步的dst=src
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 需要间接求表达式src.val的：
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 生成求表达式src.val的指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** e-&gt;u.s.info----&gt;pc.addr方便后面确定dst后进行指令回填
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** e.k        ----&gt;VNONRELOC 表达式的src.val对应读值指令已生成，但不在reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式的src.val已经在reg中的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** src.val已在reg中的表达式(VLOCAL,VCALL)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**   e.k      ----&gt; e.k=VNONRELOC
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式的src.val是直接值的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** src.val是直接值的表达式，无需处理
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** discharge:释放
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_dischargevars</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VLOCAL: {	<span style="color:#f00;font-style:italic">/* exp.src已在reg中，故而这里是VNONRELOC */</span>
</span></span><span style="display:flex;"><span>      e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VUPVAL: {
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VGLOBAL: {
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VINDEXED: {	<span style="color:#f00;font-style:italic">/* OP_GETTABLE A B C R(A) := R(B)[RK(C)] */</span>
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* !!这里是依次释放的
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  ** a.b.c.d.e... 释放a.b.c.d之前占用的reg,以便重利用reg
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">	  */</span>
</span></span><span style="display:flex;"><span>      freereg(fs, e-&gt;u.s.aux);
</span></span><span style="display:flex;"><span>      freereg(fs, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* A填 0，配合下面的可重定位VRELOCALBLE */</span>
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = luaK_codeABC(fs, OP_GETTABLE, 0, e-&gt;u.s.info, e-&gt;u.s.aux);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VVARARG:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VCALL: {
</span></span><span style="display:flex;"><span>      luaK_setoneret(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* !!!!常量，常量，常量 不需要用到reg，无需更新reg的信息e-&gt;k了 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VNIL:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VTRUE:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VFALSE:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VKNUM:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VK: {
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 还没遇到过，不太理解 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VJMP:
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* e-&gt;k已经确定了寄存器的信息了，直接返回 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VRELOCABLE:
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> VNONRELOC:
</span></span><span style="display:flex;"><span>		<span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* there is one value available (somewhere) */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">code_label</span> (FuncState *fs, <span style="color:#00f">int</span> A, <span style="color:#00f">int</span> b, <span style="color:#00f">int</span> jump) {
</span></span><span style="display:flex;"><span>  luaK_getlabel(fs);  <span style="color:#f00;font-style:italic">/* those instructions may be jump targets */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** CP_XXX拷贝指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 拷贝表达式的值到指定的目的寄存器(reg(dst) = exp(src)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.1 生成表达式的src.val的加载指令(R(B))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.2 回填表达式的目标寄存器(RA),对VNONRELOC的则生成MV指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 参考init_exp 和 luaK_dischargevars函数来理解本函数
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">discharge2reg</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** step1. 对&#34;间接表达式&#34;生成求值指令 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** step2. 对&#34;直接表达式&#34;生成求值指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** step3. 对&#34;上述表达式&#34;进行回填处理(确定目标寄存器(R(A)))
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* 表达式的值是常值, 这里生成指令并回填R(A) */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: {
</span></span><span style="display:flex;"><span>      luaK_nil(fs, reg, 1);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VFALSE:  <span style="color:#00f">case</span> VTRUE: {
</span></span><span style="display:flex;"><span>      luaK_codeABC(fs, OP_LOADBOOL, reg, e-&gt;k == VTRUE, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 表达式的值在e-&gt;u.s.info：常量表中，这里提出来，生成指令并回填R(A)                       */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: {
</span></span><span style="display:flex;"><span>	  <span style="color:#f00;font-style:italic">/* reg：指令的目标寄存器RA, e-&gt;u.s.info:指令中常量exp在常量表中的索引 */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABx(fs, OP_LOADK, reg, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 同上VK，只是nval在常量中的索引延迟到这里确定 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VKNUM: {
</span></span><span style="display:flex;"><span>      luaK_codeABx(fs, OP_LOADK, reg, luaK_numberK(fs, e-&gt;u.nval));
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 指令，表达式的值都已确定，这里回填指令的目的地R(A)即可 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VRELOCABLE: {
</span></span><span style="display:flex;"><span>      Instruction *pc = &amp;getcode(fs, e);
</span></span><span style="display:flex;"><span>      SETARG_A(*pc, reg);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 表达式的值已确定，生成OP_MOVE指令，回填R(A)=R(B)中的即可 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNONRELOC: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (reg != e-&gt;u.s.info)
</span></span><span style="display:flex;"><span>        luaK_codeABC(fs, OP_MOVE, reg, e-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* VJMP尚不理解 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      lua_assert(e-&gt;k == VVOID || e-&gt;k == VJMP);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* nothing to do... */</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 表达式的目的寄存器R(A)已确定 */</span>
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = reg;
</span></span><span style="display:flex;"><span>  e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">discharge2anyreg</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k != VNONRELOC) {
</span></span><span style="display:flex;"><span>    luaK_reserveregs(fs, 1);
</span></span><span style="display:flex;"><span>    discharge2reg(fs, e, fs-&gt;freereg-1);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* dst=src CP_XXX指令，将表达式的值赋值给指定的寄存器reg */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">exp2reg</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> reg) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 将表达式的src.val赋值给dst(reg) */</span>
</span></span><span style="display:flex;"><span>  discharge2reg(fs, e, reg);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VJMP)
</span></span><span style="display:flex;"><span>    luaK_concat(fs, &amp;e-&gt;t, e-&gt;u.s.info);  <span style="color:#f00;font-style:italic">/* put this jump in `t&#39; list */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (hasjumps(e)) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> final;  <span style="color:#f00;font-style:italic">/* position after whole expression */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> p_f = NO_JUMP;  <span style="color:#f00;font-style:italic">/* position of an eventual LOAD false */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> p_t = NO_JUMP;  <span style="color:#f00;font-style:italic">/* position of an eventual LOAD true */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (need_value(fs, e-&gt;t) || need_value(fs, e-&gt;f)) {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> fj = (e-&gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
</span></span><span style="display:flex;"><span>      p_f = code_label(fs, reg, 0, 1);
</span></span><span style="display:flex;"><span>      p_t = code_label(fs, reg, 1, 0);
</span></span><span style="display:flex;"><span>      luaK_patchtohere(fs, fj);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    final = luaK_getlabel(fs);
</span></span><span style="display:flex;"><span>    patchlistaux(fs, e-&gt;f, final, reg, p_f);
</span></span><span style="display:flex;"><span>    patchlistaux(fs, e-&gt;t, final, reg, p_t);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  e-&gt;f = e-&gt;t = NO_JUMP;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 经过dst.(reg) = src.val 后，表达式的目标地址已确定,且已在reg中 */</span>
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = reg;
</span></span><span style="display:flex;"><span>  e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** CP_XXX 拷贝指令 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** reg(var) = exp： 将表达式的src.val拷贝给next&#39;free.reg
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_exp2nextreg</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 更新exp的reg或者op信息
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 不能确定exp对应指令的则e-&gt;u.info中填入指令地址，方便回填,同时e-&gt;k:更新为VRELOCABLE，表示需要回填RA?
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 释放被临时占用的reg */</span>
</span></span><span style="display:flex;"><span>  freeexp(fs, e);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 申请一个reg，并将exp赋值到reg上 */</span>
</span></span><span style="display:flex;"><span>  luaK_reserveregs(fs, 1);
</span></span><span style="display:flex;"><span>  exp2reg(fs, e, fs-&gt;freereg - 1);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** LOAD_XXX 加载指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 将表达式的值加载到寄存器中(eg:VGLOBAL, VINDEXED)
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 已加载到reg中的则无需此步骤(VNONRELOC)),
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** RETURNS:寄存器地址 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_exp2anyreg</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 对表达式生成估值指令 */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VNONRELOC) {	<span style="color:#f00;font-style:italic">/* e的src.val已在reg中，则直接返回对应的reg */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (!hasjumps(e)) <span style="color:#00f">return</span> e-&gt;u.s.info;  <span style="color:#f00;font-style:italic">/* exp is already in a register */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (e-&gt;u.s.info &gt;= fs-&gt;nactvar) {  <span style="color:#f00;font-style:italic">/* reg. is not a local? */</span>
</span></span><span style="display:flex;"><span>      exp2reg(fs, e, e-&gt;u.s.info);  <span style="color:#f00;font-style:italic">/* put value on it */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* e的src值还不在reg则将其存入reg */</span>
</span></span><span style="display:flex;"><span>  luaK_exp2nextreg(fs, e);  <span style="color:#f00;font-style:italic">/* default */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 类似 LOAD_XXX 生成表达式的加载指令(！！！！不是CP_XXX拷贝一份e的值到reg的拷贝指令) */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_exp2val</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (hasjumps(e))
</span></span><span style="display:flex;"><span>    luaK_exp2anyreg(fs, e);	<span style="color:#f00;font-style:italic">/* 求解表达式的src.val后，将表达式的值放到下一个free.reg中 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    luaK_dischargevars(fs, e);	<span style="color:#f00;font-style:italic">/* 对间接表达式（原值不在reg中或不是直接值的）生成求值指令 */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** LOAD_XXX 加载指令 将表达式的值加载到next’free’reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** VNONRELOC这种表达式的值已被加载到reg上的就无需处理了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.1 表达式的值不在reg中的非VNONRELOC,生成对应的加载指令
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** step.2 回填上述加载指令，正式将表达式加载到reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">**
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** RETURNS: 加载的reg的地址
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_exp2RK</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 对[间接]表达式e生成求值指令 */</span>
</span></span><span style="display:flex;"><span>  luaK_exp2val(fs, e);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* e是常量表达式，无需生成求值指令，直接返回常量表中对应的索引即可 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VKNUM:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VTRUE:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VFALSE:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (fs-&gt;nk &lt;= MAXINDEXRK) {  <span style="color:#f00;font-style:italic">/* constant fit in RK operand? */</span>
</span></span><span style="display:flex;"><span>        e-&gt;u.s.info = (e-&gt;k == VNIL)  ? nilK(fs) :
</span></span><span style="display:flex;"><span>                      (e-&gt;k == VKNUM) ? luaK_numberK(fs, e-&gt;u.nval) :
</span></span><span style="display:flex;"><span>                                        boolK(fs, (e-&gt;k == VTRUE));
</span></span><span style="display:flex;"><span>        e-&gt;k = VK;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> RKASK(e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (e-&gt;u.s.info &lt;= MAXINDEXRK)  <span style="color:#f00;font-style:italic">/* constant fit in argC? */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> RKASK(e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* not a constant in the right range: put it in a register 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  **
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  ** 间接表达式(非常量表达式)，将其src.val赋值到下一个free.reg中
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> luaK_exp2anyreg(fs, e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* var = ex
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 先 LOAD_XXX (ex) 后 SET_XXX(var=ex) 的&#34;赋值组合业务&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_storevar</span> (FuncState *fs, expdesc *var, expdesc *ex) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (var-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VLOCAL: {
</span></span><span style="display:flex;"><span>      freeexp(fs, ex);
</span></span><span style="display:flex;"><span>      exp2reg(fs, ex, var-&gt;u.s.info);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VUPVAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> e = luaK_exp2anyreg(fs, ex);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABC(fs, OP_SETUPVAL, e, var-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VGLOBAL: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> e = luaK_exp2anyreg(fs, ex);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABx(fs, OP_SETGLOBAL, e, var-&gt;u.s.info);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VINDEXED: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">int</span> e = luaK_exp2RK(fs, ex);	<span style="color:#f00;font-style:italic">/* var = ex */</span>
</span></span><span style="display:flex;"><span>      luaK_codeABC(fs, OP_SETTABLE, var-&gt;u.s.info, var-&gt;u.s.aux, e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      lua_assert(0);  <span style="color:#f00;font-style:italic">/* invalid var kind to store */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  freeexp(fs, ex);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* OP_SELF A B C R(A+1) := R(B); R(A) := R(B)[RK(C)] */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_self</span> (FuncState *fs, expdesc *e, expdesc *key) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> func;
</span></span><span style="display:flex;"><span>  luaK_exp2anyreg(fs, e);
</span></span><span style="display:flex;"><span>  freeexp(fs, e);
</span></span><span style="display:flex;"><span>  func = fs-&gt;freereg;
</span></span><span style="display:flex;"><span>  luaK_reserveregs(fs, 2);
</span></span><span style="display:flex;"><span>  luaK_codeABC(fs, OP_SELF, func, e-&gt;u.s.info, luaK_exp2RK(fs, key));
</span></span><span style="display:flex;"><span>  freeexp(fs, key);
</span></span><span style="display:flex;"><span>  e-&gt;u.s.info = func;
</span></span><span style="display:flex;"><span>  e-&gt;k = VNONRELOC;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* invert:颠倒 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">invertjump</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  Instruction *pc = getjumpcontrol(fs, e-&gt;u.s.info);
</span></span><span style="display:flex;"><span>  lua_assert(testTMode(GET_OPCODE(*pc)) &amp;&amp; GET_OPCODE(*pc) != OP_TESTSET &amp;&amp;
</span></span><span style="display:flex;"><span>                                           GET_OPCODE(*pc) != OP_TEST);
</span></span><span style="display:flex;"><span>  SETARG_A(*pc, !(GETARG_A(*pc)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">jumponcond</span> (FuncState *fs, expdesc *e, <span style="color:#00f">int</span> cond) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (e-&gt;k == VRELOCABLE) {
</span></span><span style="display:flex;"><span>    Instruction ie = getcode(fs, e);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (GET_OPCODE(ie) == OP_NOT) {
</span></span><span style="display:flex;"><span>      fs-&gt;pc--;  <span style="color:#f00;font-style:italic">/* remove previous OP_NOT */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">return</span> condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* else go through */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  discharge2anyreg(fs, e);
</span></span><span style="display:flex;"><span>  freeexp(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> condjump(fs, OP_TESTSET, NO_REG, e-&gt;u.s.info, cond);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* and */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_goiftrue</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> pc;  <span style="color:#f00;font-style:italic">/* pc of last jump */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: <span style="color:#00f">case</span> VKNUM: <span style="color:#00f">case</span> VTRUE: {	
</span></span><span style="display:flex;"><span>      pc = NO_JUMP;  <span style="color:#f00;font-style:italic">/* always true; do nothing， keep go throught? */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      invertjump(fs, e);
</span></span><span style="display:flex;"><span>      pc = e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      pc = jumponcond(fs, e, 0);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaK_concat(fs, &amp;e-&gt;f, pc);  <span style="color:#f00;font-style:italic">/* insert last jump in `f&#39; list */</span>
</span></span><span style="display:flex;"><span>  luaK_patchtohere(fs, e-&gt;t);
</span></span><span style="display:flex;"><span>  e-&gt;t = NO_JUMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* or */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">luaK_goiffalse</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> pc;  <span style="color:#f00;font-style:italic">/* pc of last jump */</span>
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: <span style="color:#00f">case</span> VFALSE: {
</span></span><span style="display:flex;"><span>      pc = NO_JUMP;  <span style="color:#f00;font-style:italic">/* always false; do nothing */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      pc = e-&gt;u.s.info;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      pc = jumponcond(fs, e, 1);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  luaK_concat(fs, &amp;e-&gt;t, pc);  <span style="color:#f00;font-style:italic">/* insert last jump in `t&#39; list */</span>
</span></span><span style="display:flex;"><span>  luaK_patchtohere(fs, e-&gt;f);
</span></span><span style="display:flex;"><span>  e-&gt;f = NO_JUMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* not  A B R(A) := not R(B) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** not的stat的左边必须有左值,否则就是语法错误
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codenot</span> (FuncState *fs, expdesc *e) {
</span></span><span style="display:flex;"><span>  luaK_dischargevars(fs, e);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (e-&gt;k) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNIL: <span style="color:#00f">case</span> VFALSE: {
</span></span><span style="display:flex;"><span>      e-&gt;k = VTRUE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VK: <span style="color:#00f">case</span> VKNUM: <span style="color:#00f">case</span> VTRUE: {
</span></span><span style="display:flex;"><span>      e-&gt;k = VFALSE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VJMP: {
</span></span><span style="display:flex;"><span>      invertjump(fs, e);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VRELOCABLE:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> VNONRELOC: {
</span></span><span style="display:flex;"><span>      discharge2anyreg(fs, e);
</span></span><span style="display:flex;"><span>      freeexp(fs, e);
</span></span><span style="display:flex;"><span>      e-&gt;u.s.info = luaK_codeABC(fs, OP_NOT, 0, e-&gt;u.s.info, 0);
</span></span><span style="display:flex;"><span>      e-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      lua_assert(0);  <span style="color:#f00;font-style:italic">/* cannot happen */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* interchange true and false lists */</span>
</span></span><span style="display:flex;"><span>  { <span style="color:#00f">int</span> temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  removevalues(fs, e-&gt;f);
</span></span><span style="display:flex;"><span>  removevalues(fs, e-&gt;t);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 索引表达式t.k 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** info = table register; aux = index register (or `k&#39;) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** eg: tbl(info).aux(aux) 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_indexed</span> (FuncState *fs, expdesc *t, expdesc *k) {
</span></span><span style="display:flex;"><span>  t-&gt;u.s.aux = luaK_exp2RK(fs, k);
</span></span><span style="display:flex;"><span>  t-&gt;k = VINDEXED;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 尝试合并二元操作符以及左右两边的表达式(编译优化) */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">constfolding</span> (OpCode op, expdesc *e1, expdesc *e2) {
</span></span><span style="display:flex;"><span>  lua_Number v1, v2, r;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 两个操作数都得是numeral */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (!isnumeral(e1) || !isnumeral(e2)) <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  v1 = e1-&gt;u.nval;
</span></span><span style="display:flex;"><span>  v2 = e2-&gt;u.nval;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_ADD: r = luai_numadd(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_SUB: r = luai_numsub(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_MUL: r = luai_nummul(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_DIV:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (v2 == 0) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* do not attempt to divide by 0 */</span>
</span></span><span style="display:flex;"><span>      r = luai_numdiv(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_MOD:
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (v2 == 0) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* do not attempt to divide by 0 */</span>
</span></span><span style="display:flex;"><span>      r = luai_nummod(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_POW: r = luai_numpow(v1, v2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_UNM: r = luai_numunm(v1); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OP_LEN: <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* no constant folding for &#39;len&#39; */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: lua_assert(0); r = 0; <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (luai_numisnan(r)) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* do not attempt to produce NaN */</span>
</span></span><span style="display:flex;"><span>  e1-&gt;u.nval = r;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** local a = b + c 
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">** 表达式运行完毕后，b,c占用的临时的reg就可以被释放了，故而这一行编译完成后b,c占用的reg也可以释放了
</span></span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codearith</span> (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (constfolding(op, e1, e2))
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> o2 = (op != OP_UNM &amp;&amp; op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> o1 = luaK_exp2RK(fs, e1);
</span></span><span style="display:flex;"><span>    <span style="color:#f00;font-style:italic">/* 释放exp的规则是从后往前free */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (o1 &gt; o2) {
</span></span><span style="display:flex;"><span>      freeexp(fs, e1);
</span></span><span style="display:flex;"><span>      freeexp(fs, e2);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>      freeexp(fs, e2);
</span></span><span style="display:flex;"><span>      freeexp(fs, e1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>	<span style="color:#f00;font-style:italic">/* 这里R(A)的值尚未确定，e-&gt;=VRELOCABLE:表示需要重定位？ */</span>
</span></span><span style="display:flex;"><span>    e1-&gt;u.s.info = luaK_codeABC(fs, op, 0, o1, o2);
</span></span><span style="display:flex;"><span>    e1-&gt;k = VRELOCABLE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 关系表达式 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">codecomp</span> (FuncState *fs, OpCode op, <span style="color:#00f">int</span> cond, expdesc *e1,
</span></span><span style="display:flex;"><span>                                                          expdesc *e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> o1 = luaK_exp2RK(fs, e1);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> o2 = luaK_exp2RK(fs, e2);
</span></span><span style="display:flex;"><span>  freeexp(fs, e2);
</span></span><span style="display:flex;"><span>  freeexp(fs, e1);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (cond == 0 &amp;&amp; op != OP_EQ) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">int</span> temp;  <span style="color:#f00;font-style:italic">/* exchange args to replace by `&lt;&#39; or `&lt;=&#39; */</span>
</span></span><span style="display:flex;"><span>    temp = o1; o1 = o2; o2 = temp;  <span style="color:#f00;font-style:italic">/* o1 &lt;==&gt; o2 */</span>
</span></span><span style="display:flex;"><span>    cond = 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  e1-&gt;u.s.info = condjump(fs, op, cond, o1, o2);
</span></span><span style="display:flex;"><span>  e1-&gt;k = VJMP;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_prefix</span> (FuncState *fs, UnOpr op, expdesc *e) {
</span></span><span style="display:flex;"><span>  expdesc e2;
</span></span><span style="display:flex;"><span>  e2.t = e2.f = NO_JUMP;
</span></span><span style="display:flex;"><span>  e2.k = VKNUM; e2.u.nval = 0;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MINUS: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!isnumeral(e))
</span></span><span style="display:flex;"><span>        luaK_exp2anyreg(fs, e);  <span style="color:#f00;font-style:italic">/* cannot operate on non-numeric constants */</span>
</span></span><span style="display:flex;"><span>      codearith(fs, OP_UNM, e, &amp;e2);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_NOT: codenot(fs, e); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_LEN: {
</span></span><span style="display:flex;"><span>      luaK_exp2anyreg(fs, e);  <span style="color:#f00;font-style:italic">/* cannot operate on constants */</span>
</span></span><span style="display:flex;"><span>      codearith(fs, OP_LEN, e, &amp;e2);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: lua_assert(0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_infix</span> (FuncState *fs, BinOpr op, expdesc *v) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_AND: {
</span></span><span style="display:flex;"><span>      luaK_goiftrue(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_OR: {
</span></span><span style="display:flex;"><span>      luaK_goiffalse(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_CONCAT: {
</span></span><span style="display:flex;"><span>      luaK_exp2nextreg(fs, v);  <span style="color:#f00;font-style:italic">/* operand must be on the `stack&#39; */</span>
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_ADD: <span style="color:#00f">case</span> OPR_SUB: <span style="color:#00f">case</span> OPR_MUL: <span style="color:#00f">case</span> OPR_DIV:
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MOD: <span style="color:#00f">case</span> OPR_POW: {
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (!isnumeral(v)) luaK_exp2RK(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: {
</span></span><span style="display:flex;"><span>      luaK_exp2RK(fs, v);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_posfix</span> (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_AND: {
</span></span><span style="display:flex;"><span>      lua_assert(e1-&gt;t == NO_JUMP);  <span style="color:#f00;font-style:italic">/* list must be closed */</span>
</span></span><span style="display:flex;"><span>      luaK_dischargevars(fs, e2);
</span></span><span style="display:flex;"><span>      luaK_concat(fs, &amp;e2-&gt;f, e1-&gt;f);
</span></span><span style="display:flex;"><span>      *e1 = *e2;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_OR: {
</span></span><span style="display:flex;"><span>      lua_assert(e1-&gt;f == NO_JUMP);  <span style="color:#f00;font-style:italic">/* list must be closed */</span>
</span></span><span style="display:flex;"><span>      luaK_dischargevars(fs, e2);
</span></span><span style="display:flex;"><span>      luaK_concat(fs, &amp;e2-&gt;t, e1-&gt;t);
</span></span><span style="display:flex;"><span>      *e1 = *e2;
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_CONCAT: {
</span></span><span style="display:flex;"><span>      luaK_exp2val(fs, e2);
</span></span><span style="display:flex;"><span>      <span style="color:#00f">if</span> (e2-&gt;k == VRELOCABLE &amp;&amp; GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
</span></span><span style="display:flex;"><span>        lua_assert(e1-&gt;u.s.info == GETARG_B(getcode(fs, e2))-1);
</span></span><span style="display:flex;"><span>        freeexp(fs, e1);
</span></span><span style="display:flex;"><span>        SETARG_B(getcode(fs, e2), e1-&gt;u.s.info);
</span></span><span style="display:flex;"><span>        e1-&gt;k = VRELOCABLE; e1-&gt;u.s.info = e2-&gt;u.s.info;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>        luaK_exp2nextreg(fs, e2);  <span style="color:#f00;font-style:italic">/* operand must be on the &#39;stack&#39; */</span>
</span></span><span style="display:flex;"><span>        codearith(fs, OP_CONCAT, e1, e2);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_ADD: codearith(fs, OP_ADD, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_SUB: codearith(fs, OP_SUB, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MUL: codearith(fs, OP_MUL, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_DIV: codearith(fs, OP_DIV, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_MOD: codearith(fs, OP_MOD, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_POW: codearith(fs, OP_POW, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_EQ: codecomp(fs, OP_EQ, 1, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_NE: codecomp(fs, OP_EQ, 0, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_LT: codecomp(fs, OP_LT, 1, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_LE: codecomp(fs, OP_LE, 1, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_GT: codecomp(fs, OP_LT, 0, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">case</span> OPR_GE: codecomp(fs, OP_LE, 0, e1, e2); <span style="color:#00f">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">default</span>: lua_assert(0);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00;font-style:italic">/* 更新上一个生成的pc对应的行信息 */</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_fixline</span> (FuncState *fs, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">luaK_code</span> (FuncState *fs, Instruction i, <span style="color:#00f">int</span> line) {
</span></span><span style="display:flex;"><span>  Proto *f = fs-&gt;f;
</span></span><span style="display:flex;"><span>  dischargejpc(fs);  <span style="color:#f00;font-style:italic">/* `pc&#39; will change */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* put new instruction in code array */</span>
</span></span><span style="display:flex;"><span>  luaM_growvector(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,
</span></span><span style="display:flex;"><span>                  MAX_INT, <span style="color:#009c00">&#34;code size overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  f-&gt;code[fs-&gt;pc] = i;
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* save corresponding line information */</span>
</span></span><span style="display:flex;"><span>  luaM_growvector(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, <span style="color:#00f">int</span>,
</span></span><span style="display:flex;"><span>                  MAX_INT, <span style="color:#009c00">&#34;code size overflow&#34;</span>);
</span></span><span style="display:flex;"><span>  f-&gt;lineinfo[fs-&gt;pc] = line;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> fs-&gt;pc++;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_codeABC</span> (FuncState *fs, OpCode o, <span style="color:#00f">int</span> a, <span style="color:#00f">int</span> b, <span style="color:#00f">int</span> c) {
</span></span><span style="display:flex;"><span>  lua_assert(getOpMode(o) == iABC);
</span></span><span style="display:flex;"><span>  lua_assert(getBMode(o) != OpArgN || b == 0);
</span></span><span style="display:flex;"><span>  lua_assert(getCMode(o) != OpArgN || c == 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> luaK_code(fs, CREATE_ABC(o, a, b, c), fs-&gt;ls-&gt;lastline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">int</span> <span style="color:#c34e00">luaK_codeABx</span> (FuncState *fs, OpCode o, <span style="color:#00f">int</span> a, <span style="color:#00f">unsigned</span> <span style="color:#00f">int</span> bc) {
</span></span><span style="display:flex;"><span>  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
</span></span><span style="display:flex;"><span>  lua_assert(getCMode(o) == OpArgN);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> luaK_code(fs, CREATE_ABx(o, a, bc), fs-&gt;ls-&gt;lastline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">void</span> <span style="color:#c34e00">luaK_setlist</span> (FuncState *fs, <span style="color:#00f">int</span> base, <span style="color:#00f">int</span> nelems, <span style="color:#00f">int</span> tostore) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">int</span> b = (tostore == LUA_MULTRET) ? 0 : tostore;	<span style="color:#f00;font-style:italic">/* tostore中最后一个是变参，则tostore==LUA_MULTRET */</span>
</span></span><span style="display:flex;"><span>  lua_assert(tostore != 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (c &lt;= MAXARG_C)
</span></span><span style="display:flex;"><span>    luaK_codeABC(fs, OP_SETLIST, base, b, c);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>  	<span style="color:#f00;font-style:italic">/* c过大，将其放到下一条指令中 */</span>
</span></span><span style="display:flex;"><span>    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
</span></span><span style="display:flex;"><span>    luaK_code(fs, cast(Instruction, c), fs-&gt;ls-&gt;lastline);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#f00;font-style:italic">/* 这里可以回收空闲出来的寄存器了，有意思吧 */</span>
</span></span><span style="display:flex;"><span>  fs-&gt;freereg = base + 1;  <span style="color:#f00;font-style:italic">/* free registers with list values */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/lua" rel="tag" title="lua">#lua#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/06/15/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="next" title="分布式锁实现原理与最佳实践">
        <i class="fa fa-chevron-left"></i> 分布式锁实现原理与最佳实践
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/06/08/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lparse.c/" rel="prev" title="lua源码注释 lparse.c">
        lua源码注释 lparse.c <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
        <a href="http://shanks.link/post/">
            <span class="site-state-item-name">日志</span>
        </a>
    </div>
    <div class="site-state-item site-state-categories">
        <a href="http://shanks.link/categories/">
            <span class="site-state-item-name">分类</span>
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
            <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>

      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2025</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>