<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>Go是如何设计Map的 - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="Go是如何设计Map的">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="Go是如何设计Map的 - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/06/go%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1map%E7%9A%84/" itemprop="url">
        Go是如何设计Map的
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-06">
    2021-05-06
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/go" itemprop="url" rel="index">
        <span itemprop="name">go</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">18410 字 ~37分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <h2 id="由于本文篇幅较长故将目录整理如下">由于本文篇幅较长，故将目录整理如下</h2>
<p>**
**</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/2.png" alt="img"></p>
<p><strong>什么是Map</strong></p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/1.png" alt="img"></p>
<ul>
<li><strong>维基百科的定义</strong></li>
</ul>
<p><em>In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.</em></p>
<p>说明：在计算机科学中，包含键值对（key-value）集合的抽象数据结构（关联数组、符号表或字典），其每个可能的键在该集合中最多出现一次，这样的数据结构就是一种Map。</p>
<p><strong>01</strong></p>
<p><strong>操作</strong></p>
<p>对Map的操作主要是增删改查：</p>
<ul>
<li>
<p>在集合中增加键值对</p>
</li>
<li>
<p>在集合中移除键值对</p>
</li>
<li>
<p>修改某个存在的键值对</p>
</li>
<li>
<p>根据特定的键寻找对应的值</p>
</li>
</ul>
<p><strong>02</strong></p>
<p><strong>实现</strong></p>
<p>Map的实现主要有两种方式：哈希表（hash table）和搜索树（search tree）。例如Java中的hashMap是基于哈希表实现，而C++中的Map是基于一种平衡搜索二叉树——红黑树而实现的。以下是不同实现方式的时间复杂度对比。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/3.png" alt="img"></p>
<p>可以看到，对于元素查找而言，二叉搜索树的平均和最坏效率都是O(log n)，哈希表实现的平均效率是O(1)，但最坏情况下能达到O(n)，不过如果哈希表设计优秀，最坏情况基本不会出现（所以，读者不想知道Go是如何设计的Map吗）。另外二叉搜索树返回的key是有序的，而哈希表则是乱序。</p>
<p><strong>哈希表</strong></p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/1.png" alt="img"></p>
<h2 id="heading"></h2>
<p>由于Go中map的基于哈希表（也被称为散列表）实现，本文不探讨搜索树的map实现。以下是Go官方博客对map的说明。</p>
<p><em>One of the most useful data structures in computer science is the hash table. Many hash table implementations exist with varying properties, but in general they offer fast lookups, adds, and deletes. Go provides a built-in map type that implements a hash table.</em></p>
<p>学习哈希表首先要理解两个概念：哈希函数和哈希冲突。</p>
<p><strong>01</strong></p>
<p><strong>哈希函数</strong></p>
<p>哈希函数（常被称为散列函数）是可以用于将任意大小的数据映射到固定大小值的函数，常见的包括MD5、SHA系列等。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/5.png" alt="img"></p>
<p>一个设计优秀的哈希函数应该包含以下特性：</p>
<ul>
<li><strong>均匀性</strong>：一个好的哈希函数应该在其输出范围内尽可能均匀地映射，也就是说，应以大致相同的概率生成输出范围内的每个哈希值。</li>
<li><strong>效率高</strong>：哈希效率要高，即使很长的输入参数也能快速计算出哈希值。</li>
<li><strong>可确定性</strong>：哈希过程必须是确定性的，这意味着对于给定的输入值，它必须始终生成相同的哈希值。</li>
<li><strong>雪崩效应</strong>：微小的输入值变化也会让输出值发生巨大的变化。</li>
<li><strong>不可逆</strong>：从哈希函数的输出值不可反向推导出原始的数据。</li>
</ul>
<p><strong>02</strong></p>
<p><strong>哈希冲突</strong></p>
<p>重复一遍，哈希函数是将任意大小的数据映射到固定大小值的函数。那么，我们可以预见到，即使哈希函数设计得足够优秀，几乎每个输入值都能映射为不同的哈希值。但是，当输入数据足够大，大到能超过固定大小值的组合能表达的最大数量数，冲突将不可避免！（参见抽屉原理）</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/6.png" alt="img"></p>
<p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。抽屉原理有时也被称为鸽巢原理。</p>
<ul>
<li>
<h5 id="如何解决哈希冲突">如何解决哈希冲突</h5>
</li>
</ul>
<p>比较常用的Has冲突解决方案有链地址法和开放寻址法。</p>
<p>在讲链地址法之前，先说明两个概念。</p>
<ol>
<li>哈希桶。哈希桶（也称为槽，类似于抽屉原理中的一个抽屉）可以先简单理解为一个哈希值，所有的哈希值组成了哈希空间。</li>
<li>装载因子。装载因子是表示哈希表中元素的填满程度。它的计算公式：装载因子=填入哈希表中的元素个数/哈希表的长度。装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。反之，装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数。装载因子也是决定哈希表是否进行扩容的关键指标，在java的HashMap的中，其默认装载因子为0.75；Python的dict默认装载因子为2/3。</li>
</ol>
<p><strong>A</strong></p>
<p><strong>链地址法</strong></p>
<p>链地址法的思想就是将映射在一个桶里的所有元素用链表串起来。</p>
<p>下面以一个简单的哈希函数 <code>H(key) = key MOD 7</code>（除数取余法）对一组元素 <code>[50, 700, 76, 85, 92, 73, 101]</code> 进行映射，通过图示来理解链地址法处理Hash冲突的处理逻辑。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/7.png" alt="img"></p>
<p>链地址法解决冲突的方式与图的邻接表存储方式在样式上很相似，发生冲突，就用单链表组织起来。</p>
<p><strong>B</strong></p>
<p><strong>开放寻址法</strong></p>
<h6 id="heading-1"></h6>
<p>对于链地址法而言，槽位数m与键的数目n是没有直接关系的。但是对于开放寻址法而言，所有的元素都是存储在Hash表当中的，所以无论任何时候都要保证哈希表的槽位数m大于或等于键的数据n（必要时，需要对哈希表进行动态扩容）。</p>
<p>开放寻址法有多种方式：线性探测法、平方探测法、随机探测法和双重哈希法。这里以线性探测法来帮助读者理解开放寻址法思想。</p>
<ul>
<li><strong>线性探测法</strong></li>
</ul>
<p>设 <code>Hash(key)</code> 表示关键字 <code>key</code> 的哈希值， 表示哈希表的槽位数（哈希表的大小）。</p>
<p>线性探测法则可以表示为：</p>
<p>如果 <code>Hash(x) % M</code> 已经有数据，则尝试 <code>(Hash(x) + 1) % M</code> ;</p>
<p>如果 <code>(Hash(x) + 1) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 2) % M</code> ;</p>
<p>如果 <code>(Hash(x) + 2) % M</code> 也有数据了，则尝试 <code>(Hash(x) + 3) % M</code> ;</p>
<p>……</p>
<p>我们同样以哈希函数 <code>H(key) = key MOD 7</code> （除数取余法）对 <code>[50, 700, 76, 85, 92, 73, 101]</code> 进行映射，通过图示来理解线性探测法处理 Hash 碰撞。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/8.png" alt="img"></p>
<p>其中，empty代表槽位为空，occupied代表槽位已被占（后续映射到该槽，则需要线性向下继续探测），而lazy delete则代表将槽位里面的数据清除，并不释放存储空间。</p>
<p><strong>C</strong></p>
<p><strong>两种解决方案比较</strong></p>
<p>对于开放寻址法而言，它只有数组一种数据结构就可完成存储，继承了数组的优点，对CPU缓存友好，易于序列化操作。但是它对内存的利用率不如链地址法，且发生冲突时代价更高。当数据量明确、装载因子小，适合采用开放寻址法。</p>
<p>链表节点可以在需要时再创建，不必像开放寻址法那样事先申请好足够内存，因此链地址法对于内存的利用率会比开方寻址法高。链地址法对装载因子的容忍度会更高，并且适合存储大对象、大数据量的哈希表。而且相较于开放寻址法，它更加灵活，支持更多的优化策略，比如可采用红黑树代替链表。但是链地址法需要额外的空间来存储指针。</p>
<p>值得一提的是，在Python中dict在发生哈希冲突时采用的开放寻址法，而java的HashMap采用的是链地址法。</p>
<p><strong>Go Map 实现</strong></p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/1.png" alt="img"></p>
<p>同python与java一样，Go语言中的map是也基于哈希表实现的，它解决哈希冲突的方式是链地址法，即通过使用数组+链表的数据结构来表达map。</p>
<p>注意：本文后续出现的map统一代指Go中实现的map类型。</p>
<p><strong>01</strong></p>
<p><strong>map数据结构</strong></p>
<p>map中的数据被存放于一个数组中的，数组的元素是桶（bucket），每个桶至多包含8个键值对数据。<strong>哈希值低位（low-order bits）用于选择桶，哈希值高位（high-order bits）用于在一个独立的桶中区别出键</strong>**。**哈希值高低位示意图如下</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/9.png" alt="img"></p>
<p>本文基于go 1.15.2 darwin/amd64分析，源码位于<code>src/runtime/map.go</code>.</p>
<ul>
<li><strong>map的结构体为hmap</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1// A header for a Go map.
</span></span><span style="display:flex;"><span> 2type hmap struct {
</span></span><span style="display:flex;"><span> 3    count     int // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。
</span></span><span style="display:flex;"><span> 4    flags     uint8 // 状态标志，下文常量中会解释四种状态位含义。
</span></span><span style="display:flex;"><span> 5    B         uint8  // buckets（桶）的对数log_2（哈希表元素数量最大可达到装载因子*2^B）
</span></span><span style="display:flex;"><span> 6    noverflow uint16 // 溢出桶的大概数量。
</span></span><span style="display:flex;"><span> 7    hash0     uint32 // 哈希种子。
</span></span><span style="display:flex;"><span> 8
</span></span><span style="display:flex;"><span> 9    buckets    unsafe.Pointer // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。
</span></span><span style="display:flex;"><span>10    oldbuckets unsafe.Pointer // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2。非扩容状态下，它为nil。
</span></span><span style="display:flex;"><span>11    nevacuate  uintptr        // 表示扩容进度，小于此地址的buckets代表已搬迁完成。
</span></span><span style="display:flex;"><span>12
</span></span><span style="display:flex;"><span>13    extra *mapextra // 这个字段是为了优化GC扫描而设计的。当key和value均不包含指针，并且都可以inline时使用。extra是指向mapextra类型的指针。
</span></span></code></pre></div><ul>
<li><strong>mapextra的结构体</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1// mapextra holds fields that are not present on all maps.
</span></span><span style="display:flex;"><span> 2type mapextra struct {
</span></span><span style="display:flex;"><span> 3    // 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)
</span></span><span style="display:flex;"><span> 4    // 就使用 hmap的extra字段 来存储 overflow buckets，这样可以避免 GC 扫描整个 map
</span></span><span style="display:flex;"><span> 5    // 然而 bmap.overflow 也是个指针。这时候我们只能把这些 overflow 的指针
</span></span><span style="display:flex;"><span> 6    // 都放在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中了
</span></span><span style="display:flex;"><span> 7    // overflow 包含的是 hmap.buckets 的 overflow 的 buckets
</span></span><span style="display:flex;"><span> 8    // oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket
</span></span><span style="display:flex;"><span> 9    overflow    *[]*bmap
</span></span><span style="display:flex;"><span>10    oldoverflow *[]*bmap
</span></span><span style="display:flex;"><span>11
</span></span><span style="display:flex;"><span>12    // 指向空闲的 overflow bucket 的指针
</span></span><span style="display:flex;"><span>13    nextOverflow *bmap
</span></span><span style="display:flex;"><span>14}
</span></span></code></pre></div><ul>
<li><strong>bmap结构体</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1// A bucket for a Go map.
</span></span><span style="display:flex;"><span>2type bmap struct {
</span></span><span style="display:flex;"><span>3    // tophash包含此桶中每个键的哈希值最高字节（高8位）信息（也就是前面所述的high-order bits）。
</span></span><span style="display:flex;"><span>4    // 如果tophash[0] &lt; minTopHash，tophash[0]则代表桶的搬迁（evacuation）状态。
</span></span><span style="display:flex;"><span>5    tophash [bucketCnt]uint8
</span></span><span style="display:flex;"><span>6}
</span></span></code></pre></div><p>bmap也就是bucket（桶）的内存模型图解如下（相关代码逻辑可查看<code>src/cmd/compile/internal/gc/reflect.go</code>中的<code>bmap()</code>函数）。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/10.png" alt="img"></p>
<p>在以上图解示例中，该桶的第7位cell和第8位cell还未有对应键值对。需要注意的是，key和value是各自存储起来的，并非想象中的key/value/key/value…的形式。这样做虽然会让代码组织稍显复杂，但是它的好处是能让我们消除例如map[int64]int所需要的填充（padding）。此外，在8个键值对数据后面有一个overflow指针，因为桶中最多只能装8个键值对，如果有多余的键值对落到了当前桶，那么就需要再构建一个桶（称为溢出桶），通过overflow指针链接起来。</p>
<ul>
<li><strong>重要常量标志</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1const (
</span></span><span style="display:flex;"><span> 2    // 一个桶中最多能装载的键值对（key-value）的个数为8
</span></span><span style="display:flex;"><span> 3    bucketCntBits = 3
</span></span><span style="display:flex;"><span> 4    bucketCnt     = 1 &lt;&lt; bucketCntBits
</span></span><span style="display:flex;"><span> 5
</span></span><span style="display:flex;"><span> 6  // 触发扩容的装载因子为13/2=6.5
</span></span><span style="display:flex;"><span> 7    loadFactorNum = 13
</span></span><span style="display:flex;"><span> 8    loadFactorDen = 2
</span></span><span style="display:flex;"><span> 9
</span></span><span style="display:flex;"><span>10    // 键和值超过128个字节，就会被转换为指针
</span></span><span style="display:flex;"><span>11    maxKeySize  = 128
</span></span><span style="display:flex;"><span>12    maxElemSize = 128
</span></span><span style="display:flex;"><span>13
</span></span><span style="display:flex;"><span>14    // 数据偏移量应该是bmap结构体的大小，它需要正确地对齐。
</span></span><span style="display:flex;"><span>15  // 对于amd64p32而言，这意味着：即使指针是32位的，也是64位对齐。
</span></span><span style="display:flex;"><span>16    dataOffset = unsafe.Offsetof(struct {
</span></span><span style="display:flex;"><span>17        b bmap
</span></span><span style="display:flex;"><span>18        v int64
</span></span><span style="display:flex;"><span>19    }{}.v)
</span></span><span style="display:flex;"><span>20
</span></span><span style="display:flex;"><span>21
</span></span><span style="display:flex;"><span>22  // 每个桶（如果有溢出，则包含它的overflow的链桶）在搬迁完成状态（evacuated* states）下，要么会包含它所有的键值对，要么一个都不包含（但不包括调用evacuate()方法阶段，该方法调用只会在对map发起write时发生，在该阶段其他goroutine是无法查看该map的）。简单的说，桶里的数据要么一起搬走，要么一个都还未搬。
</span></span><span style="display:flex;"><span>23  // tophash除了放置正常的高8位hash值，还会存储一些特殊状态值（标志该cell的搬迁状态）。正常的tophash值，最小应该是5，以下列出的就是一些特殊状态值。
</span></span><span style="display:flex;"><span>24    emptyRest      = 0 // 表示cell为空，并且比它高索引位的cell或者overflows中的cell都是空的。（初始化bucket时，就是该状态）
</span></span><span style="display:flex;"><span>25    emptyOne       = 1 // 空的cell，cell已经被搬迁到新的bucket
</span></span><span style="display:flex;"><span>26    evacuatedX     = 2 // 键值对已经搬迁完毕，key在新buckets数组的前半部分
</span></span><span style="display:flex;"><span>27    evacuatedY     = 3 // 键值对已经搬迁完毕，key在新buckets数组的后半部分
</span></span><span style="display:flex;"><span>28    evacuatedEmpty = 4 // cell为空，整个bucket已经搬迁完毕
</span></span><span style="display:flex;"><span>29    minTopHash     = 5 // tophash的最小正常值
</span></span><span style="display:flex;"><span>30
</span></span><span style="display:flex;"><span>31    // flags
</span></span><span style="display:flex;"><span>32    iterator     = 1 // 可能有迭代器在使用buckets
</span></span><span style="display:flex;"><span>33    oldIterator  = 2 // 可能有迭代器在使用oldbuckets
</span></span><span style="display:flex;"><span>34    hashWriting  = 4 // 有协程正在向map写人key
</span></span><span style="display:flex;"><span>35    sameSizeGrow = 8 // 等量扩容
</span></span><span style="display:flex;"><span>36
</span></span><span style="display:flex;"><span>37    // 用于迭代器检查的bucket ID
</span></span><span style="display:flex;"><span>38    noCheck = 1&lt;&lt;(8*sys.PtrSize) - 1
</span></span><span style="display:flex;"><span>39)
</span></span></code></pre></div><p>综上，我们以B等于4为例，展示一个完整的map结构图。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/11.png" alt="img"></p>
<h3 id="heading-2"></h3>
<p><strong>02</strong></p>
<p><strong>创建map</strong></p>
<p>map初始化有以下两种方式</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1make(map[k]v)
</span></span><span style="display:flex;"><span>2// 指定初始化map大小为hint
</span></span><span style="display:flex;"><span>3make(map[k]v, hint)
</span></span></code></pre></div><p>对于不指定初始化大小，和初始化值hint&lt;=8（bucketCnt）时，go会调用<code>makemap_small</code>函数（源码位置<code>src/runtime/map.go</code>），并直接从堆上进行分配。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1func makemap_small() *hmap {
</span></span><span style="display:flex;"><span>2    h := new(hmap)
</span></span><span style="display:flex;"><span>3    h.hash0 = fastrand()
</span></span><span style="display:flex;"><span>4    return h
</span></span><span style="display:flex;"><span>5}
</span></span></code></pre></div><p>当hint&gt;8时，则调用<code>makemap</code>函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1// 如果编译器认为map和第一个bucket可以直接创建在栈上，h和bucket可能都是非空
</span></span><span style="display:flex;"><span> 2// 如果h != nil，那么map可以直接在h中创建
</span></span><span style="display:flex;"><span> 3// 如果h.buckets != nil，那么h指向的bucket可以作为map的第一个bucket使用
</span></span><span style="display:flex;"><span> 4func makemap(t *maptype, hint int, h *hmap) *hmap {
</span></span><span style="display:flex;"><span> 5  // math.MulUintptr返回hint与t.bucket.size的乘积，并判断该乘积是否溢出。
</span></span><span style="display:flex;"><span> 6    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
</span></span><span style="display:flex;"><span> 7// maxAlloc的值，根据平台系统的差异而不同，具体计算方式参照src/runtime/malloc.go
</span></span><span style="display:flex;"><span> 8    if overflow || mem &gt; maxAlloc {
</span></span><span style="display:flex;"><span> 9        hint = 0
</span></span><span style="display:flex;"><span>10    }
</span></span><span style="display:flex;"><span>11
</span></span><span style="display:flex;"><span>12// initialize Hmap
</span></span><span style="display:flex;"><span>13    if h == nil {
</span></span><span style="display:flex;"><span>14        h = new(hmap)
</span></span><span style="display:flex;"><span>15    }
</span></span><span style="display:flex;"><span>16  // 通过fastrand得到哈希种子
</span></span><span style="display:flex;"><span>17    h.hash0 = fastrand()
</span></span><span style="display:flex;"><span>18
</span></span><span style="display:flex;"><span>19    // 根据输入的元素个数hint，找到能装下这些元素的B值
</span></span><span style="display:flex;"><span>20    B := uint8(0)
</span></span><span style="display:flex;"><span>21    for overLoadFactor(hint, B) {
</span></span><span style="display:flex;"><span>22        B++
</span></span><span style="display:flex;"><span>23    }
</span></span><span style="display:flex;"><span>24    h.B = B
</span></span><span style="display:flex;"><span>25
</span></span><span style="display:flex;"><span>26    // 分配初始哈希表
</span></span><span style="display:flex;"><span>27  // 如果B为0，那么buckets字段后续会在mapassign方法中lazily分配
</span></span><span style="display:flex;"><span>28    if h.B != 0 {
</span></span><span style="display:flex;"><span>29        var nextOverflow *bmap
</span></span><span style="display:flex;"><span>30    // makeBucketArray创建一个map的底层保存buckets的数组，它最少会分配h.B^2的大小。
</span></span><span style="display:flex;"><span>31        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
</span></span><span style="display:flex;"><span>32        if nextOverflow != nil {
</span></span><span style="display:flex;"><span>33    h.extra = new(mapextra)
</span></span><span style="display:flex;"><span>34            h.extra.nextOverflow = nextOverflow
</span></span><span style="display:flex;"><span>35        }
</span></span><span style="display:flex;"><span>36    }
</span></span><span style="display:flex;"><span>37
</span></span><span style="display:flex;"><span>38    return h
</span></span><span style="display:flex;"><span>39}
</span></span></code></pre></div><p>分配buckets数组的<code>makeBucketArray</code>函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1// makeBucket为map创建用于保存buckets的数组。
</span></span><span style="display:flex;"><span> 2func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
</span></span><span style="display:flex;"><span> 3    base := bucketShift(b)
</span></span><span style="display:flex;"><span> 4    nbuckets := base
</span></span><span style="display:flex;"><span> 5  // 对于小的b值（小于4），即桶的数量小于16时，使用溢出桶的可能性很小。对于此情况，就避免计算开销。
</span></span><span style="display:flex;"><span> 6    if b &gt;= 4 {
</span></span><span style="display:flex;"><span> 7    // 当桶的数量大于等于16个时，正常情况下就会额外创建2^(b-4)个溢出桶
</span></span><span style="display:flex;"><span> 8        nbuckets += bucketShift(b - 4)
</span></span><span style="display:flex;"><span> 9        sz := t.bucket.size * nbuckets
</span></span><span style="display:flex;"><span>10        up := roundupsize(sz)
</span></span><span style="display:flex;"><span>11        if up != sz {
</span></span><span style="display:flex;"><span>12            nbuckets = up / t.bucket.size
</span></span><span style="display:flex;"><span>13        }
</span></span><span style="display:flex;"><span>14    }
</span></span><span style="display:flex;"><span>15
</span></span><span style="display:flex;"><span>16 // 这里，dirtyalloc分两种情况。如果它为nil，则会分配一个新的底层数组。如果它不为nil，则它指向的是曾经分配过的底层数组，该底层数组是由之前同样的t和b参数通过makeBucketArray分配的，如果数组不为空，需要把该数组之前的数据清空并复用。
</span></span><span style="display:flex;"><span>17    if dirtyalloc == nil {
</span></span><span style="display:flex;"><span>18        buckets = newarray(t.bucket, int(nbuckets))
</span></span><span style="display:flex;"><span>19    } else {
</span></span><span style="display:flex;"><span>20        buckets = dirtyalloc
</span></span><span style="display:flex;"><span>21        size := t.bucket.size * nbuckets
</span></span><span style="display:flex;"><span>22        if t.bucket.ptrdata != 0 {
</span></span><span style="display:flex;"><span>23            memclrHasPointers(buckets, size)
</span></span><span style="display:flex;"><span>24        } else {
</span></span><span style="display:flex;"><span>25            memclrNoHeapPointers(buckets, size)
</span></span><span style="display:flex;"><span>26        }
</span></span><span style="display:flex;"><span>27}
</span></span><span style="display:flex;"><span>28
</span></span><span style="display:flex;"><span>29  // 即b大于等于4的情况下，会预分配一些溢出桶。
</span></span><span style="display:flex;"><span>30  // 为了把跟踪这些溢出桶的开销降至最低，使用了以下约定：
</span></span><span style="display:flex;"><span>31  // 如果预分配的溢出桶的overflow指针为nil，那么可以通过指针碰撞（bumping the pointer）获得更多可用桶。
</span></span><span style="display:flex;"><span>32  // （关于指针碰撞：假设内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”）
</span></span><span style="display:flex;"><span>33  // 对于最后一个溢出桶，需要一个安全的非nil指针指向它。
</span></span><span style="display:flex;"><span>34    if base != nbuckets {
</span></span><span style="display:flex;"><span>35        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span>36        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span>37        last.setoverflow(t, (*bmap)(buckets))
</span></span><span style="display:flex;"><span>38    }
</span></span><span style="display:flex;"><span>39    return buckets, nextOverflow
</span></span><span style="display:flex;"><span>40}
</span></span></code></pre></div><p>根据上述代码，我们能确定在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的，只是被<code>hmap</code> 中的不同字段引用而已。</p>
<p><strong>03</strong></p>
<p><strong>哈希函数</strong></p>
<p>在初始化go程序运行环境时（<code>src/runtime/proc.go</code>中的<code>schedinit</code>），就需要通过<code>alginit</code>方法完成对哈希的初始化。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1func schedinit() {
</span></span><span style="display:flex;"><span> 2    lockInit(&amp;sched.lock, lockRankSched)
</span></span><span style="display:flex;"><span> 3
</span></span><span style="display:flex;"><span> 4    ...
</span></span><span style="display:flex;"><span> 5
</span></span><span style="display:flex;"><span> 6    tracebackinit()
</span></span><span style="display:flex;"><span> 7    moduledataverify()
</span></span><span style="display:flex;"><span> 8    stackinit()
</span></span><span style="display:flex;"><span> 9    mallocinit()
</span></span><span style="display:flex;"><span>10    fastrandinit() // must run before mcommoninit
</span></span><span style="display:flex;"><span>11    mcommoninit(_g_.m, -1)
</span></span><span style="display:flex;"><span>12    cpuinit()       // must run before alginit
</span></span><span style="display:flex;"><span>13    // 这里调用alginit()
</span></span><span style="display:flex;"><span>14    alginit()       // maps must not be used before this call
</span></span><span style="display:flex;"><span>15    modulesinit()   // provides activeModules
</span></span><span style="display:flex;"><span>16    typelinksinit() // uses maps, activeModules
</span></span><span style="display:flex;"><span>17    itabsinit()     // uses activeModules
</span></span><span style="display:flex;"><span>18
</span></span><span style="display:flex;"><span>19    ...
</span></span><span style="display:flex;"><span>20
</span></span><span style="display:flex;"><span>21    goargs()
</span></span><span style="display:flex;"><span>22    goenvs()
</span></span><span style="display:flex;"><span>23    parsedebugvars()
</span></span><span style="display:flex;"><span>24    gcinit()
</span></span><span style="display:flex;"><span>25
</span></span><span style="display:flex;"><span>26  ...
</span></span><span style="display:flex;"><span>27}
</span></span></code></pre></div><p>对于哈希算法的选择，程序会根据当前架构判断是否支持AES，如果支持就使用AES hash，其实现代码位于<code>src/runtime/asm_{386,amd64,arm64}.s</code>中；若不支持，其hash算法则根据xxhash算法（https://code.google.com/p/xxhash/）和cityhash算法（https://code.google.com/p/cityhash/）启发而来，代码分别对应于32位（<code>src/runtime/hash32.go</code>）和64位机器（<code>src/runtime/hash32.go</code>）中，对这部分内容感兴趣的读者可以深入研究。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1func alginit() {
</span></span><span style="display:flex;"><span> 2    // Install AES hash algorithms if the instructions needed are present.
</span></span><span style="display:flex;"><span> 3    if (GOARCH == &#34;386&#34; || GOARCH == &#34;amd64&#34;) &amp;&amp;
</span></span><span style="display:flex;"><span> 4        cpu.X86.HasAES &amp;&amp; // AESENC
</span></span><span style="display:flex;"><span> 5        cpu.X86.HasSSSE3 &amp;&amp; // PSHUFB
</span></span><span style="display:flex;"><span> 6        cpu.X86.HasSSE41 { // PINSR{D,Q}
</span></span><span style="display:flex;"><span> 7        initAlgAES()
</span></span><span style="display:flex;"><span> 8        return
</span></span><span style="display:flex;"><span> 9    }
</span></span><span style="display:flex;"><span>10    if GOARCH == &#34;arm64&#34; &amp;&amp; cpu.ARM64.HasAES {
</span></span><span style="display:flex;"><span>11        initAlgAES()
</span></span><span style="display:flex;"><span>12        return
</span></span><span style="display:flex;"><span>13    }
</span></span><span style="display:flex;"><span>14    getRandomData((*[len(hashkey) * sys.PtrSize]byte)(unsafe.Pointer(&amp;hashkey))[:])
</span></span><span style="display:flex;"><span>15    hashkey[0] |= 1 // make sure these numbers are odd
</span></span><span style="display:flex;"><span>16    hashkey[1] |= 1
</span></span><span style="display:flex;"><span>17    hashkey[2] |= 1
</span></span><span style="display:flex;"><span>18    hashkey[3] |= 1
</span></span><span style="display:flex;"><span>19}
</span></span></code></pre></div><p>上文在创建map的时候，我们可以知道map的哈希种子是通过<code>h.hash0 = fastrand()</code>得到的。它是在以下<code>maptype</code>中的<code>hasher</code>中被使用到，在下文内容中会看到hash值的生成。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1type maptype struct {
</span></span><span style="display:flex;"><span> 2    typ    _type
</span></span><span style="display:flex;"><span> 3    key    *_type
</span></span><span style="display:flex;"><span> 4    elem   *_type
</span></span><span style="display:flex;"><span> 5    bucket *_type
</span></span><span style="display:flex;"><span> 6  // hasher的第一个参数就是指向key的指针，h.hash0 = fastrand()得到的hash0，就是hasher方法的第二个参数。
</span></span><span style="display:flex;"><span> 7  // hasher方法返回的就是hash值。
</span></span><span style="display:flex;"><span> 8    hasher     func(unsafe.Pointer, uintptr) uintptr
</span></span><span style="display:flex;"><span> 9    keysize    uint8  // size of key slot
</span></span><span style="display:flex;"><span>10    elemsize   uint8  // size of elem slot
</span></span><span style="display:flex;"><span>11    bucketsize uint16 // size of bucket
</span></span><span style="display:flex;"><span>12    flags      uint32
</span></span><span style="display:flex;"><span>13}
</span></span><span style="display:flex;"><span>14
</span></span></code></pre></div><p><strong>04</strong></p>
<p><strong>map操作</strong></p>
<p>假定key经过哈希计算后得到64bit位的哈希值。如果B=5，buckets数组的长度，即桶的数量是32（2的5次方）。</p>
<p>例如，现要置一key于map中，该key经过哈希后，得到的哈希值如下：</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/22.png" alt="img"></p>
<p>前面我们知道，哈希值低位（<code>low-order bits</code>）用于选择桶，哈希值高位（<code>high-order bits</code>）用于在一个独立的桶中区别出键。当B等于5时，那么我们选择的哈希值低位也是5位，即01010，它的十进制值为10，代表10号桶。再用哈希值的高8位，找到此key在桶中的位置。最开始桶中还没有key，那么新加入的key和value就会被放入第一个key空位和value空位。</p>
<p>注意：对于高低位的选择，该操作的实质是取余，但是取余开销很大，在实际代码实现中采用的是位操作。以下是tophash的实现代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1func tophash(hash uintptr) uint8 {
</span></span><span style="display:flex;"><span>2    top := uint8(hash &gt;&gt; (sys.PtrSize*8 - 8))
</span></span><span style="display:flex;"><span>3    if top &lt; minTopHash {
</span></span><span style="display:flex;"><span>4        top += minTopHash
</span></span><span style="display:flex;"><span>5    }
</span></span><span style="display:flex;"><span>6    return top
</span></span><span style="display:flex;"><span>7}
</span></span></code></pre></div><p>当两个不同的key落在了同一个桶中，这时就发生了哈希冲突。go的解决方式是链地址法（这里为了让读者更好理解，只描述非扩容且该key是第一次添加的情况）：在桶中按照顺序寻到第一个空位并记录下来，后续在该桶和它的溢出桶中均未发现存在的该key，将key置于第一个空位；否则，去该桶的溢出桶中寻找空位，如果没有溢出桶，则添加溢出桶，并将其置溢出桶的第一个空位（因为是第一次添加，所以不描述已存在该key的情况）。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/12.png" alt="img"></p>
<p>上图中的B值为5，所以桶的数量为32。通过哈希函数计算出待插入key的哈希值，低5位哈希00110，对应于6号桶；高8位10010111，十进制为151，由于桶中前6个cell已经有正常哈希值填充了(遍历)，所以将151对应的高位哈希值放置于第7位cell（第8个cell为empty Rest，表明它还未使用），对应将key和value分别置于相应的第七个空位。</p>
<p>如果是查找key，那么我们会根据高位哈希值去桶中的每个cell中找，若在桶中没找到，并且overflow不为nil，那么继续去溢出桶中寻找，直至找到，如果所有的cell都找过了，还未找到，则返回key类型的默认值（例如key是int类型，则返回0）。</p>
<p><strong>A</strong></p>
<p><strong>查找Key</strong></p>
<p>对于map的元素查找，其源码实现如下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
</span></span><span style="display:flex;"><span> 2  // 如果开启了竞态检测 -race
</span></span><span style="display:flex;"><span> 3    if raceenabled &amp;&amp; h != nil {
</span></span><span style="display:flex;"><span> 4        callerpc := getcallerpc()
</span></span><span style="display:flex;"><span> 5        pc := funcPC(mapaccess1)
</span></span><span style="display:flex;"><span> 6        racereadpc(unsafe.Pointer(h), callerpc, pc)
</span></span><span style="display:flex;"><span> 7        raceReadObjectPC(t.key, key, callerpc, pc)
</span></span><span style="display:flex;"><span> 8    }
</span></span><span style="display:flex;"><span> 9  // 如果开启了memory sanitizer -msan
</span></span><span style="display:flex;"><span>10    if msanenabled &amp;&amp; h != nil {
</span></span><span style="display:flex;"><span>11        msanread(key, t.key.size)
</span></span><span style="display:flex;"><span>12    }
</span></span><span style="display:flex;"><span>13  // 如果map为空或者元素个数为0，返回零值
</span></span><span style="display:flex;"><span>14    if h == nil || h.count == 0 {
</span></span><span style="display:flex;"><span>15        if t.hashMightPanic() {
</span></span><span style="display:flex;"><span>16            t.hasher(key, 0) // see issue 23734
</span></span><span style="display:flex;"><span>17        }
</span></span><span style="display:flex;"><span>18        return unsafe.Pointer(&amp;zeroVal[0])
</span></span><span style="display:flex;"><span>19    }
</span></span><span style="display:flex;"><span>20  // 注意，这里是按位与操作
</span></span><span style="display:flex;"><span>21  // 当h.flags对应的值为hashWriting（代表有其他goroutine正在往map中写key）时，那么位计算的结果不为0，因此抛出以下错误。
</span></span><span style="display:flex;"><span>22  // 这也表明，go的map是非并发安全的
</span></span><span style="display:flex;"><span>23    if h.flags&amp;hashWriting != 0 {
</span></span><span style="display:flex;"><span>24        throw(&#34;concurrent map read and map write&#34;)
</span></span><span style="display:flex;"><span>25    }
</span></span><span style="display:flex;"><span>26  // 不同类型的key，会使用不同的hash算法，可详见src/runtime/alg.go中typehash函数中的逻辑
</span></span><span style="display:flex;"><span>27    hash := t.hasher(key, uintptr(h.hash0))
</span></span><span style="display:flex;"><span>28    m := bucketMask(h.B)
</span></span><span style="display:flex;"><span>29  // 按位与操作，找到对应的bucket
</span></span><span style="display:flex;"><span>30    b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span>31  // 如果oldbuckets不为空，那么证明map发生了扩容
</span></span><span style="display:flex;"><span>32  // 如果有扩容发生，老的buckets中的数据可能还未搬迁至新的buckets里
</span></span><span style="display:flex;"><span>33  // 所以需要先在老的buckets中找
</span></span><span style="display:flex;"><span>34    if c := h.oldbuckets; c != nil {
</span></span><span style="display:flex;"><span>35        if !h.sameSizeGrow() {
</span></span><span style="display:flex;"><span>36            m &gt;&gt;= 1
</span></span><span style="display:flex;"><span>37        }
</span></span><span style="display:flex;"><span>38        oldb := (*bmap)(add(c, (hash&amp;m)*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span>39    // 如果在oldbuckets中tophash[0]的值，为evacuatedX、evacuatedY，evacuatedEmpty其中之一
</span></span><span style="display:flex;"><span>40    // 则evacuated()返回为true，代表搬迁完成。
</span></span><span style="display:flex;"><span>41    // 因此，只有当搬迁未完成时，才会从此oldbucket中遍历
</span></span><span style="display:flex;"><span>42        if !evacuated(oldb) {
</span></span><span style="display:flex;"><span>43            b = oldb
</span></span><span style="display:flex;"><span>44        }
</span></span><span style="display:flex;"><span>45    }
</span></span><span style="display:flex;"><span>46  // 取出当前key值的tophash值
</span></span><span style="display:flex;"><span>47    top := tophash(hash)
</span></span><span style="display:flex;"><span>48  // 以下是查找的核心逻辑
</span></span><span style="display:flex;"><span>49  // 双重循环遍历：外层循环是从桶到溢出桶遍历；内层是桶中的cell遍历
</span></span><span style="display:flex;"><span>50  // 跳出循环的条件有三种：第一种是已经找到key值；第二种是当前桶再无溢出桶；
</span></span><span style="display:flex;"><span>51  // 第三种是当前桶中有cell位的tophash值是emptyRest，这个值在前面解释过，它代表此时的桶后面的cell还未利用，所以无需再继续遍历。
</span></span><span style="display:flex;"><span>52bucketloop:
</span></span><span style="display:flex;"><span>53    for ; b != nil; b = b.overflow(t) {
</span></span><span style="display:flex;"><span>54        for i := uintptr(0); i &lt; bucketCnt; i++ {
</span></span><span style="display:flex;"><span>55      // 判断tophash值是否相等
</span></span><span style="display:flex;"><span>56            if b.tophash[i] != top {
</span></span><span style="display:flex;"><span>57                if b.tophash[i] == emptyRest {
</span></span><span style="display:flex;"><span>58                    break bucketloop
</span></span><span style="display:flex;"><span>59                }
</span></span><span style="display:flex;"><span>60                continue
</span></span><span style="display:flex;"><span>61      }
</span></span><span style="display:flex;"><span>62      // 因为在bucket中key是用连续的存储空间存储的，因此可以通过bucket地址+数据偏移量（bmap结构体的大小）+ keysize的大小，得到k的地址
</span></span><span style="display:flex;"><span>63      // 同理，value的地址也是相似的计算方法，只是再要加上8个keysize的内存地址
</span></span><span style="display:flex;"><span>64            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span style="display:flex;"><span>65            if t.indirectkey() {
</span></span><span style="display:flex;"><span>66                k = *((*unsafe.Pointer)(k))
</span></span><span style="display:flex;"><span>67            }
</span></span><span style="display:flex;"><span>68      // 判断key是否相等
</span></span><span style="display:flex;"><span>69            if t.key.equal(key, k) {
</span></span><span style="display:flex;"><span>70                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span style="display:flex;"><span>71                if t.indirectelem() {
</span></span><span style="display:flex;"><span>72                    e = *((*unsafe.Pointer)(e))
</span></span><span style="display:flex;"><span>73                }
</span></span><span style="display:flex;"><span>74                return e
</span></span><span style="display:flex;"><span>75            }
</span></span><span style="display:flex;"><span>76        }
</span></span><span style="display:flex;"><span>77    }
</span></span><span style="display:flex;"><span>78  // 所有的bucket都未找到，则返回零值
</span></span><span style="display:flex;"><span>79    return unsafe.Pointer(&amp;zeroVal[0])
</span></span><span style="display:flex;"><span>80}
</span></span></code></pre></div><p>以下是<code>mapaccess1</code>的查找过程图解</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/13.png" alt="img"></p>
<p>map的元素查找，对应go代码有两种形式</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1    // 形式一
</span></span><span style="display:flex;"><span>2    v := m[k]
</span></span><span style="display:flex;"><span>3    // 形式二
</span></span><span style="display:flex;"><span>4    v, ok := m[k]
</span></span></code></pre></div><p>形式一的代码实现，就是上述的<code>mapaccess1</code>方法。此外，在源码中还有个<code>mapaccess2</code>方法，它的函数签名如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {}
</span></span></code></pre></div><p>与<code>mapaccess1</code>相比，<code>mapaccess2</code>多了一个bool类型的返回值，它代表的是是否在map中找到了对应的key。因为和<code>mapaccess1</code>基本一致，所以详细代码就不再贴出。</p>
<p>同时，源码中还有mapaccessK方法，它的函数签名如下。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) {}
</span></span></code></pre></div><p>与<code>mapaccess1</code>相比，<code>mapaccessK</code>同时返回了key和value，其代码逻辑也一致。</p>
<p><strong>B</strong></p>
<p><strong>赋值Key</strong></p>
<p>对于写入key的逻辑，其源码实现如下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>  1func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
</span></span><span style="display:flex;"><span>  2  // 如果h是空指针，赋值会引起panic
</span></span><span style="display:flex;"><span>  3  // 例如以下语句
</span></span><span style="display:flex;"><span>  4  // var m map[string]int
</span></span><span style="display:flex;"><span>  5    // m[&#34;k&#34;] = 1
</span></span><span style="display:flex;"><span>  6    if h == nil {
</span></span><span style="display:flex;"><span>  7        panic(plainError(&#34;assignment to entry in nil map&#34;))
</span></span><span style="display:flex;"><span>  8    }
</span></span><span style="display:flex;"><span>  9  // 如果开启了竞态检测 -race
</span></span><span style="display:flex;"><span> 10    if raceenabled {
</span></span><span style="display:flex;"><span> 11        callerpc := getcallerpc()
</span></span><span style="display:flex;"><span> 12        pc := funcPC(mapassign)
</span></span><span style="display:flex;"><span> 13        racewritepc(unsafe.Pointer(h), callerpc, pc)
</span></span><span style="display:flex;"><span> 14        raceReadObjectPC(t.key, key, callerpc, pc)
</span></span><span style="display:flex;"><span> 15    }
</span></span><span style="display:flex;"><span> 16  // 如果开启了memory sanitizer -msan
</span></span><span style="display:flex;"><span> 17    if msanenabled {
</span></span><span style="display:flex;"><span> 18        msanread(key, t.key.size)
</span></span><span style="display:flex;"><span> 19    }
</span></span><span style="display:flex;"><span> 20  // 有其他goroutine正在往map中写key，会抛出以下错误
</span></span><span style="display:flex;"><span> 21    if h.flags&amp;hashWriting != 0 {
</span></span><span style="display:flex;"><span> 22        throw(&#34;concurrent map writes&#34;)
</span></span><span style="display:flex;"><span> 23    }
</span></span><span style="display:flex;"><span> 24  // 通过key和哈希种子，算出对应哈希值
</span></span><span style="display:flex;"><span> 25    hash := t.hasher(key, uintptr(h.hash0))
</span></span><span style="display:flex;"><span> 26
</span></span><span style="display:flex;"><span> 27  // 将flags的值与hashWriting做按位或运算
</span></span><span style="display:flex;"><span> 28  // 因为在当前goroutine可能还未完成key的写入，再次调用t.hasher会发生panic。
</span></span><span style="display:flex;"><span> 29    h.flags ^= hashWriting
</span></span><span style="display:flex;"><span> 30
</span></span><span style="display:flex;"><span> 31    if h.buckets == nil {
</span></span><span style="display:flex;"><span> 32        h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
</span></span><span style="display:flex;"><span> 33}
</span></span><span style="display:flex;"><span> 34
</span></span><span style="display:flex;"><span> 35again:
</span></span><span style="display:flex;"><span> 36  // bucketMask返回值是2的B次方减1
</span></span><span style="display:flex;"><span> 37  // 因此，通过hash值与bucketMask返回值做按位与操作，返回的在buckets数组中的第几号桶
</span></span><span style="display:flex;"><span> 38    bucket := hash &amp; bucketMask(h.B)
</span></span><span style="display:flex;"><span> 39  // 如果map正在搬迁（即h.oldbuckets != nil）中,则先进行搬迁工作。
</span></span><span style="display:flex;"><span> 40    if h.growing() {
</span></span><span style="display:flex;"><span> 41        growWork(t, h, bucket)
</span></span><span style="display:flex;"><span> 42    }
</span></span><span style="display:flex;"><span> 43  // 计算出上面求出的第几号bucket的内存位置
</span></span><span style="display:flex;"><span> 44  // post = start + bucketNumber * bucketsize
</span></span><span style="display:flex;"><span> 45    b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span> 46    top := tophash(hash)
</span></span><span style="display:flex;"><span> 47
</span></span><span style="display:flex;"><span> 48    var inserti *uint8
</span></span><span style="display:flex;"><span> 49    var insertk unsafe.Pointer
</span></span><span style="display:flex;"><span> 50    var elem unsafe.Pointer
</span></span><span style="display:flex;"><span> 51bucketloop:
</span></span><span style="display:flex;"><span> 52    for {
</span></span><span style="display:flex;"><span> 53    // 遍历桶中的8个cell
</span></span><span style="display:flex;"><span> 54        for i := uintptr(0); i &lt; bucketCnt; i++ {
</span></span><span style="display:flex;"><span> 55      // 这里分两种情况，第一种情况是cell位的tophash值和当前tophash值不相等
</span></span><span style="display:flex;"><span> 56      // 在 b.tophash[i] != top 的情况下
</span></span><span style="display:flex;"><span> 57      // 理论上有可能会是一个空槽位
</span></span><span style="display:flex;"><span> 58      // 一般情况下 map 的槽位分布是这样的，e 表示 empty:
</span></span><span style="display:flex;"><span> 59      // [h0][h1][h2][h3][h4][e][e][e]
</span></span><span style="display:flex;"><span> 60      // 但在执行过 delete 操作时，可能会变成这样:
</span></span><span style="display:flex;"><span> 61      // [h0][h1][e][e][h5][e][e][e]
</span></span><span style="display:flex;"><span> 62      // 所以如果再插入的话，会尽量往前面的位置插
</span></span><span style="display:flex;"><span> 63      // [h0][h1][e][e][h5][e][e][e]
</span></span><span style="display:flex;"><span> 64      //          ^
</span></span><span style="display:flex;"><span> 65      //          ^
</span></span><span style="display:flex;"><span> 66      //       这个位置
</span></span><span style="display:flex;"><span> 67      // 所以在循环的时候还要顺便把前面的空位置先记下来
</span></span><span style="display:flex;"><span> 68      // 因为有可能在后面会找到相等的key，也可能找不到相等的key
</span></span><span style="display:flex;"><span> 69            if b.tophash[i] != top {
</span></span><span style="display:flex;"><span> 70        // 如果cell位为空，那么就可以在对应位置进行插入
</span></span><span style="display:flex;"><span> 71                if isEmpty(b.tophash[i]) &amp;&amp; inserti == nil {
</span></span><span style="display:flex;"><span> 72                    inserti = &amp;b.tophash[i]
</span></span><span style="display:flex;"><span> 73                    insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span style="display:flex;"><span> 74                    elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span style="display:flex;"><span> 75                }
</span></span><span style="display:flex;"><span> 76                if b.tophash[i] == emptyRest {
</span></span><span style="display:flex;"><span> 77                    break bucketloop
</span></span><span style="display:flex;"><span> 78                }
</span></span><span style="display:flex;"><span> 79                continue
</span></span><span style="display:flex;"><span> 80            }
</span></span><span style="display:flex;"><span> 81      // 第二种情况是cell位的tophash值和当前的tophash值相等
</span></span><span style="display:flex;"><span> 82            k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
</span></span><span style="display:flex;"><span> 83            if t.indirectkey() {
</span></span><span style="display:flex;"><span> 84                k = *((*unsafe.Pointer)(k))
</span></span><span style="display:flex;"><span> 85            }
</span></span><span style="display:flex;"><span> 86      // 注意，即使当前cell位的tophash值相等，不一定它对应的key也是相等的，所以还要做一个key值判断
</span></span><span style="display:flex;"><span> 87            if !t.key.equal(key, k) {
</span></span><span style="display:flex;"><span> 88                continue
</span></span><span style="display:flex;"><span> 89            }
</span></span><span style="display:flex;"><span> 90            // 如果已经有该key了，就更新它
</span></span><span style="display:flex;"><span> 91            if t.needkeyupdate() {
</span></span><span style="display:flex;"><span> 92                typedmemmove(t.key, k, key)
</span></span><span style="display:flex;"><span> 93            }
</span></span><span style="display:flex;"><span> 94      // 这里获取到了要插入key对应的value的内存地址
</span></span><span style="display:flex;"><span> 95      // pos = start + dataOffset + 8*keysize + i*elemsize
</span></span><span style="display:flex;"><span> 96            elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))
</span></span><span style="display:flex;"><span> 97      // 如果顺利到这，就直接跳到done的结束逻辑中去
</span></span><span style="display:flex;"><span> 98            goto done
</span></span><span style="display:flex;"><span> 99        }
</span></span><span style="display:flex;"><span>100    // 如果桶中的8个cell遍历完，还未找到对应的空cell或覆盖cell，那么就进入它的溢出桶中去遍历
</span></span><span style="display:flex;"><span>101        ovf := b.overflow(t)
</span></span><span style="display:flex;"><span>102    // 如果连溢出桶中都没有找到合适的cell，跳出循环。
</span></span><span style="display:flex;"><span>103        if ovf == nil {
</span></span><span style="display:flex;"><span>104            break
</span></span><span style="display:flex;"><span>105        }
</span></span><span style="display:flex;"><span>106        b = ovf
</span></span><span style="display:flex;"><span>107    }
</span></span><span style="display:flex;"><span>108
</span></span><span style="display:flex;"><span>109    // 在已有的桶和溢出桶中都未找到合适的cell供key写入，那么有可能会触发以下两种情况
</span></span><span style="display:flex;"><span>110  // 情况一：
</span></span><span style="display:flex;"><span>111  // 判断当前map的装载因子是否达到设定的6.5阈值，或者当前map的溢出桶数量是否过多。如果存在这两种情况之一，则进行扩容操作。
</span></span><span style="display:flex;"><span>112  // hashGrow()实际并未完成扩容，对哈希表数据的搬迁（复制）操作是通过growWork()来完成的。
</span></span><span style="display:flex;"><span>113  // 重新跳入again逻辑，在进行完growWork()操作后，再次遍历新的桶。
</span></span><span style="display:flex;"><span>114    if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
</span></span><span style="display:flex;"><span>115        hashGrow(t, h)
</span></span><span style="display:flex;"><span>116        goto again // Growing the table invalidates everything, so try again
</span></span><span style="display:flex;"><span>117    }
</span></span><span style="display:flex;"><span>118
</span></span><span style="display:flex;"><span>119  // 情况二：
</span></span><span style="display:flex;"><span>120// 在不满足情况一的条件下，会为当前桶再新建溢出桶，并将tophash，key插入到新建溢出桶的对应内存的0号位置
</span></span><span style="display:flex;"><span>121    if inserti == nil {
</span></span><span style="display:flex;"><span>122        // all current buckets are full, allocate a new one.
</span></span><span style="display:flex;"><span>123        newb := h.newoverflow(t, b)
</span></span><span style="display:flex;"><span>124        inserti = &amp;newb.tophash[0]
</span></span><span style="display:flex;"><span>125        insertk = add(unsafe.Pointer(newb), dataOffset)
</span></span><span style="display:flex;"><span>126        elem = add(insertk, bucketCnt*uintptr(t.keysize))
</span></span><span style="display:flex;"><span>127    }
</span></span><span style="display:flex;"><span>128
</span></span><span style="display:flex;"><span>129  // 在插入位置存入新的key和value
</span></span><span style="display:flex;"><span>130    if t.indirectkey() {
</span></span><span style="display:flex;"><span>131        kmem := newobject(t.key)
</span></span><span style="display:flex;"><span>132        *(*unsafe.Pointer)(insertk) = kmem
</span></span><span style="display:flex;"><span>133        insertk = kmem
</span></span><span style="display:flex;"><span>134    }
</span></span><span style="display:flex;"><span>135    if t.indirectelem() {
</span></span><span style="display:flex;"><span>136        vmem := newobject(t.elem)
</span></span><span style="display:flex;"><span>137        *(*unsafe.Pointer)(elem) = vmem
</span></span><span style="display:flex;"><span>138    }
</span></span><span style="display:flex;"><span>139    typedmemmove(t.key, insertk, key)
</span></span><span style="display:flex;"><span>140    *inserti = top
</span></span><span style="display:flex;"><span>141  // map中的key数量+1
</span></span><span style="display:flex;"><span>142    h.count++
</span></span><span style="display:flex;"><span>143
</span></span><span style="display:flex;"><span>144done:
</span></span><span style="display:flex;"><span>145    if h.flags&amp;hashWriting == 0 {
</span></span><span style="display:flex;"><span>146        throw(&#34;concurrent map writes&#34;)
</span></span><span style="display:flex;"><span>147    }
</span></span><span style="display:flex;"><span>148    h.flags &amp;^= hashWriting
</span></span><span style="display:flex;"><span>149    if t.indirectelem() {
</span></span><span style="display:flex;"><span>150        elem = *((*unsafe.Pointer)(elem))
</span></span><span style="display:flex;"><span>151    }
</span></span><span style="display:flex;"><span>152    return elem
</span></span><span style="display:flex;"><span>153}
</span></span></code></pre></div><p>通过对<code>mapassign</code>的代码分析之后，发现该函数并没有将插入key对应的value写入对应的内存，而是返回了value应该插入的内存地址。为了弄清楚value写入内存的操作是发生在什么时候，分析如下map.go代码。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>1<span style="color:#00f">package</span> main
</span></span><span style="display:flex;"><span>2
</span></span><span style="display:flex;"><span>3<span style="color:#00f">func</span> <span style="color:#c34e00">main</span>() {
</span></span><span style="display:flex;"><span>4    m := make(<span style="color:#00f">map</span>[<span style="color:#00f">int</span>]<span style="color:#00f">int</span>)
</span></span><span style="display:flex;"><span>5    <span style="color:#00f">for</span> i := 0; i &lt; 100; i++ {
</span></span><span style="display:flex;"><span>6        m[i] = 666
</span></span><span style="display:flex;"><span>7    }
</span></span><span style="display:flex;"><span>8}
</span></span></code></pre></div><p><code>m[i] = 666</code>对应的汇编代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1$ go tool compile -S map.go
</span></span><span style="display:flex;"><span> 2...
</span></span><span style="display:flex;"><span> 3        0x0098 00152 (map.go:6) LEAQ    type.map[int]int(SB), CX
</span></span><span style="display:flex;"><span> 4        0x009f 00159 (map.go:6) MOVQ    CX, (SP)
</span></span><span style="display:flex;"><span> 5        0x00a3 00163 (map.go:6) LEAQ    &#34;&#34;..autotmp_2+184(SP), DX
</span></span><span style="display:flex;"><span> 6        0x00ab 00171 (map.go:6) MOVQ    DX, 8(SP)
</span></span><span style="display:flex;"><span> 7        0x00b0 00176 (map.go:6) MOVQ    AX, 16(SP)
</span></span><span style="display:flex;"><span> 8        0x00b5 00181 (map.go:6) CALL    runtime.mapassign_fast64(SB) // 调用函数runtime.mapassign_fast64，该函数实质就是mapassign（上文示例源代码是该mapassign系列的通用逻辑）
</span></span><span style="display:flex;"><span> 9        0x00ba 00186 (map.go:6) MOVQ    24(SP), AX 24(SP), AX // 返回值，即 value 应该存放的内存地址
</span></span><span style="display:flex;"><span>10        0x00bf 00191 (map.go:6) MOVQ    $666, (AX) // 把 666 放入该地址中
</span></span><span style="display:flex;"><span>11...        
</span></span></code></pre></div><p>赋值的最后一步实际上是编译器额外生成的汇编指令来完成的，可见靠 runtime 有些工作是没有做完的。所以，在go中，编译器和 runtime 配合，才能完成一些复杂的工作。同时说明，在平时学习go的源代码实现时，必要时还需要看一些汇编代码。</p>
<p><strong>C</strong></p>
<p><strong>删除Key</strong></p>
<h4 id="heading-3"></h4>
<p>理解了赋值key的逻辑，删除key的逻辑就比较简单了。本文就不再讨论该部分内容了，读者感兴趣可以自行查看<code>src/runtime/map.go</code>的<code>mapdelete</code>方法逻辑。</p>
<p><strong>D</strong></p>
<p><strong>遍历map</strong></p>
<p><strong>结论：迭代 map 的结果是无序的</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1    m := make(map[int]int)
</span></span><span style="display:flex;"><span>2    for i := 0; i &lt; 10; i++ {
</span></span><span style="display:flex;"><span>3        m[i] = i
</span></span><span style="display:flex;"><span>4    }
</span></span><span style="display:flex;"><span>5    for k, v := range m {
</span></span><span style="display:flex;"><span>6        fmt.Println(k, v)
</span></span><span style="display:flex;"><span>7    }
</span></span></code></pre></div><p>运行以上代码，我们会发现每次输出顺序都是不同的。</p>
<p>map遍历的过程，是按序遍历bucket，同时按需遍历bucket中和其overflow bucket中的cell。但是map在扩容后，会发生key的搬迁，这造成原来落在一个bucket中的key，搬迁后，有可能会落到其他bucket中了，从这个角度看，遍历map的结果就不可能是按照原来的顺序了（详见下文的map扩容内容）。</p>
<p>但其实，go为了保证遍历map的结果是无序的，做了以下事情：map在遍历时，并不是从固定的0号bucket开始遍历的，每次遍历，都会从一个<strong>随机值序号的bucket</strong>，再从其中<strong>随机的cell</strong>开始遍历。然后再按照桶序遍历下去，直到回到起始桶结束。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/14.png" alt="img"></p>
<p>上图的例子，是遍历一个处于未扩容状态的map。如果map正处于扩容状态时，需要先判断当前遍历bucket是否已经完成搬迁，如果数据还在老的bucket，那么就去老bucket中拿数据。</p>
<p>注意：在下文中会讲解到增量扩容和等量扩容。当发生了增量扩容时，一个老的bucket数据可能会分裂到两个不同的bucket中去，那么此时，如果需要从老的bucket中遍历数据，例如1号，则不能将老1号bucket中的数据全部取出，仅仅只能取出老 1 号 bucket 中那些在裂变之后，分配到新 1 号 bucket 中的那些 key（这个内容，请读者看完下文map扩容的讲解之后再回头理解）。</p>
<p>鉴于篇幅原因，本文不再对map遍历的详细源码进行注释贴出。读者可自行查看源码<code>src/runtime/map.go</code>的<code>mapiterinit()</code>和<code>mapiternext()</code>方法逻辑。</p>
<p>这里注释一下<code>mapiterinit()</code>中随机保证的关键代码</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1// 生成随机数
</span></span><span style="display:flex;"><span>2r := uintptr(fastrand())
</span></span><span style="display:flex;"><span>3if h.B &gt; 31-bucketCntBits {
</span></span><span style="display:flex;"><span>4   r += uintptr(fastrand()) &lt;&lt; 31
</span></span><span style="display:flex;"><span>5}
</span></span><span style="display:flex;"><span>6// 决定了从哪个随机的bucket开始
</span></span><span style="display:flex;"><span>7it.startBucket = r &amp; bucketMask(h.B)
</span></span><span style="display:flex;"><span>8// 决定了每个bucket中随机的cell的位置
</span></span><span style="display:flex;"><span>9it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1))
</span></span></code></pre></div><p><strong>05</strong></p>
<p><strong>map扩容</strong></p>
<p>在文中讲解装载因子时，我们提到装载因子是决定哈希表是否进行扩容的关键指标。在go的map扩容中，除了装载因子会决定是否需要扩容，溢出桶的数量也是扩容的另一关键指标。</p>
<p>为了保证访问效率，当map将要添加、修改或删除key时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。在之前源码<code>mapassign</code>中，其实已经注释map扩容条件，主要是两点:</p>
<ol>
<li>判断已经达到装载因子的临界点，即元素个数 &gt;= 桶（bucket）总数 * 6.5，这时候说明大部分的桶可能都快满了（即平均每个桶存储的键值对达到6.5个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1func overLoadFactor(count int, B uint8) bool {
</span></span><span style="display:flex;"><span>2    return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)
</span></span><span style="display:flex;"><span>3}
</span></span></code></pre></div><ol>
<li>判断溢出桶是否太多，当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;= 桶总数，则认为溢出桶过多。当桶总数 &gt;= 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出桶总数 &gt;= 2 ^ 15 时，即认为溢出桶太多了。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {
</span></span><span style="display:flex;"><span>2    if B &gt; 15 {
</span></span><span style="display:flex;"><span>3        B = 15
</span></span><span style="display:flex;"><span>4    }
</span></span><span style="display:flex;"><span>5    return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)
</span></span><span style="display:flex;"><span>6}
</span></span></code></pre></div><p>对于第2点，其实算是对第 1 点的补充。因为在装载因子比较小的情况下，有可能 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是桶数量多（真实分配的桶数量多，包括大量的溢出桶）。</p>
<p>在某些场景下，比如不断的增删，这样会造成overflow的bucket数量增多，但负载因子又不高，未达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 点判断指标。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/15.png" alt="img"></p>
<p>如上图所示，由于对map的不断增删，以0号bucket为例，该桶链中就造成了大量的稀疏桶。</p>
<p>两种情况官方采用了不同的解决方案</p>
<ul>
<li>针对 1，将 B + 1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。该方法我们称之为<strong>增量扩容</strong>。</li>
<li>针对 2，并不扩大容量，buckets数量维持不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。该方法我们称之为<strong>等量扩容</strong>。</li>
</ul>
<p>对于 2 的解决方案，其实存在一个极端的情况：如果插入 map 的 key 哈希都一样，那么它们就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。但 Go 的每一个 map 都会在初始化阶段的 makemap时定一个随机的哈希种子，所以要构造这种冲突是没那么容易的。</p>
<p>在源码中，和扩容相关的主要是<code>hashGrow()</code>函数与<code>growWork()</code>函数。<code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在<code>mapassign()</code> 和 <code>mapdelete()</code> 函数中。也就是插入（包括修改）、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。它们会先检查 oldbuckets 是否搬迁完毕（检查 oldbuckets 是否为 nil），再决定是否进行搬迁工作。</p>
<p><code>hashGrow()</code>函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1func hashGrow(t *maptype, h *hmap) {
</span></span><span style="display:flex;"><span> 2  // 如果达到条件 1，那么将B值加1，相当于是原来的2倍
</span></span><span style="display:flex;"><span> 3  // 否则对应条件 2，进行等量扩容，所以 B 不变
</span></span><span style="display:flex;"><span> 4    bigger := uint8(1)
</span></span><span style="display:flex;"><span> 5    if !overLoadFactor(h.count+1, h.B) {
</span></span><span style="display:flex;"><span> 6        bigger = 0
</span></span><span style="display:flex;"><span> 7        h.flags |= sameSizeGrow
</span></span><span style="display:flex;"><span> 8    }
</span></span><span style="display:flex;"><span> 9  // 记录老的buckets
</span></span><span style="display:flex;"><span>10    oldbuckets := h.buckets
</span></span><span style="display:flex;"><span>11  // 申请新的buckets空间
</span></span><span style="display:flex;"><span>12    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
</span></span><span style="display:flex;"><span>13  // 注意&amp;^ 运算符，这块代码的逻辑是转移标志位
</span></span><span style="display:flex;"><span>14    flags := h.flags &amp;^ (iterator | oldIterator)
</span></span><span style="display:flex;"><span>15    if h.flags&amp;iterator != 0 {
</span></span><span style="display:flex;"><span>16        flags |= oldIterator
</span></span><span style="display:flex;"><span>17    }
</span></span><span style="display:flex;"><span>18    // 提交grow (atomic wrt gc)
</span></span><span style="display:flex;"><span>19    h.B += bigger
</span></span><span style="display:flex;"><span>20    h.flags = flags
</span></span><span style="display:flex;"><span>21    h.oldbuckets = oldbuckets
</span></span><span style="display:flex;"><span>22    h.buckets = newbuckets
</span></span><span style="display:flex;"><span>23  // 搬迁进度为0
</span></span><span style="display:flex;"><span>24    h.nevacuate = 0
</span></span><span style="display:flex;"><span>25  // overflow buckets 数为0
</span></span><span style="display:flex;"><span>26    h.noverflow = 0
</span></span><span style="display:flex;"><span>27
</span></span><span style="display:flex;"><span>28  // 如果发现hmap是通过extra字段 来存储 overflow buckets时
</span></span><span style="display:flex;"><span>29    if h.extra != nil &amp;&amp; h.extra.overflow != nil {
</span></span><span style="display:flex;"><span>30        if h.extra.oldoverflow != nil {
</span></span><span style="display:flex;"><span>31            throw(&#34;oldoverflow is not nil&#34;)
</span></span><span style="display:flex;"><span>32        }
</span></span><span style="display:flex;"><span>33        h.extra.oldoverflow = h.extra.overflow
</span></span><span style="display:flex;"><span>34        h.extra.overflow = nil
</span></span><span style="display:flex;"><span>35    }
</span></span><span style="display:flex;"><span>36    if nextOverflow != nil {
</span></span><span style="display:flex;"><span>37        if h.extra == nil {
</span></span><span style="display:flex;"><span>38            h.extra = new(mapextra)
</span></span><span style="display:flex;"><span>39        }
</span></span><span style="display:flex;"><span>40        h.extra.nextOverflow = nextOverflow
</span></span><span style="display:flex;"><span>41    }
</span></span><span style="display:flex;"><span>42}
</span></span></code></pre></div><p><code>growWork()</code>函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> 1func growWork(t *maptype, h *hmap, bucket uintptr) {
</span></span><span style="display:flex;"><span> 2  // 为了确认搬迁的 bucket 是我们正在使用的 bucket
</span></span><span style="display:flex;"><span> 3  // 即如果当前key映射到老的bucket1，那么就搬迁该bucket1。
</span></span><span style="display:flex;"><span> 4    evacuate(t, h, bucket&amp;h.oldbucketmask())
</span></span><span style="display:flex;"><span> 5
</span></span><span style="display:flex;"><span> 6    // 如果还未完成扩容工作，则再搬迁一个bucket。
</span></span><span style="display:flex;"><span> 7    if h.growing() {
</span></span><span style="display:flex;"><span> 8        evacuate(t, h, h.nevacuate)
</span></span><span style="display:flex;"><span> 9    }
</span></span><span style="display:flex;"><span>10}
</span></span></code></pre></div><p>从<code>growWork()</code>函数可以知道，搬迁的核心逻辑是<code>evacuate()</code>函数。这里读者可以思考一个问题：为什么每次至多搬迁2个bucket？这其实是一种性能考量，如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，因此才采用逐步搬迁策略。</p>
<p>在讲解该逻辑之前，需要读者先理解以下两个知识点。</p>
<ul>
<li><strong>知识点1：bucket序号的变化</strong></li>
</ul>
<p>前面讲到，增量扩容（条件1）和等量扩容（条件2）都需要进行bucket的搬迁工作。对于等量扩容而言，由于buckets的数量不变，因此可以按照序号来搬迁。例如老的的0号bucket，仍然搬至新的0号bucket中。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/16.png" alt="img"></p>
<p>但是，对于增量扩容而言，就会有所不同。例如原来的B=5，那么增量扩容时，B就会变成6。那么决定key值落入哪个bucket的低位哈希值就会发生变化（从取5位变为取6位），取新的低位hash值得过程称为rehash。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/17.png" alt="img"></p>
<p>因此，在增量扩容中，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于低 hash 值第倒数第B+1位是 0 还是 1。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/18.png" alt="img"></p>
<p>如上图所示，当原始的B = 3时，旧buckets数组长度为8，在编号为2的bucket中，其2号cell和5号cell，它们的低3位哈希值相同（不相同的话，也就不会落在同一个桶中了），但是它们的低4位分别是0010、1010。当发生了增量扩容，2号就会被搬迁到新buckets数组的2号bucket中去，5号被搬迁到新buckets数组的10号bucket中去，它们的桶号差距是2的3次方。</p>
<ul>
<li><strong>知识点2：确定搬迁区间</strong></li>
</ul>
<p>在源码中，有bucket x 和bucket y的概念，其实就是增量扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为bucket x，后一半桶被称为bucket y。一个 bucket 中的 key 可能会分裂到两个桶中去，分别位于bucket x的桶，或bucket y中的桶。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个区间（而对于同一个桶而言，搬迁到bucket x和bucket y桶序号的差别是老的buckets大小，即2^old_B）。</p>
<p>思考：为什么确定key落在哪个区间很重要？</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/19.png" alt="img"></p>
<p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 key/value 值 copy 到目的地相应的位置。设置 key 在原始 buckets 的 tophash 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的bucket x或是bucket y，新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p>
<p>下面正式解读搬迁核心代码<code>evacuate()</code>函数。</p>
<p><code>evacuate()</code>函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>  1func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
</span></span><span style="display:flex;"><span>  2  // 首先定位老的bucket的地址
</span></span><span style="display:flex;"><span>  3    b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span>  4  // newbit代表扩容之前老的bucket个数
</span></span><span style="display:flex;"><span>  5    newbit := h.noldbuckets()
</span></span><span style="display:flex;"><span>  6  // 判断该bucket是否已经被搬迁
</span></span><span style="display:flex;"><span>  7    if !evacuated(b) {
</span></span><span style="display:flex;"><span>  8    // 官方TODO，后续版本也许会实现
</span></span><span style="display:flex;"><span>  9        // TODO: reuse overflow buckets instead of using new ones, if there
</span></span><span style="display:flex;"><span> 10        // is no iterator using the old buckets.  (If !oldIterator.)
</span></span><span style="display:flex;"><span> 11
</span></span><span style="display:flex;"><span> 12    // xy 包含了高低区间的搬迁目的地内存信息
</span></span><span style="display:flex;"><span> 13    // x.b 是对应的搬迁目的桶
</span></span><span style="display:flex;"><span> 14    // x.k 是指向对应目的桶中存储当前key的内存地址
</span></span><span style="display:flex;"><span> 15    // x.e 是指向对应目的桶中存储当前value的内存地址
</span></span><span style="display:flex;"><span> 16        var xy [2]evacDst
</span></span><span style="display:flex;"><span> 17        x := &amp;xy[0]
</span></span><span style="display:flex;"><span> 18        x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span> 19        x.k = add(unsafe.Pointer(x.b), dataOffset)
</span></span><span style="display:flex;"><span> 20        x.e = add(x.k, bucketCnt*uintptr(t.keysize))
</span></span><span style="display:flex;"><span> 21
</span></span><span style="display:flex;"><span> 22    // 只有当增量扩容时才计算bucket y的相关信息（和后续计算useY相呼应）
</span></span><span style="display:flex;"><span> 23        if !h.sameSizeGrow() {
</span></span><span style="display:flex;"><span> 24            y := &amp;xy[1]
</span></span><span style="display:flex;"><span> 25            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
</span></span><span style="display:flex;"><span> 26            y.k = add(unsafe.Pointer(y.b), dataOffset)
</span></span><span style="display:flex;"><span> 27            y.e = add(y.k, bucketCnt*uintptr(t.keysize))
</span></span><span style="display:flex;"><span> 28        }
</span></span><span style="display:flex;"><span> 29
</span></span><span style="display:flex;"><span> 30    // evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。
</span></span><span style="display:flex;"><span> 31    // bucket 还会链接 overflow bucket，它们同样需要搬迁。
</span></span><span style="display:flex;"><span> 32    // 因此同样会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。
</span></span><span style="display:flex;"><span> 33
</span></span><span style="display:flex;"><span> 34    // 遍历当前桶bucket和其之后的溢出桶overflow bucket
</span></span><span style="display:flex;"><span> 35    // 注意：初始的b是待搬迁的老bucket
</span></span><span style="display:flex;"><span> 36        for ; b != nil; b = b.overflow(t) {
</span></span><span style="display:flex;"><span> 37            k := add(unsafe.Pointer(b), dataOffset)
</span></span><span style="display:flex;"><span> 38            e := add(k, bucketCnt*uintptr(t.keysize))
</span></span><span style="display:flex;"><span> 39      // 遍历桶中的cell，i，k，e分别用于对应tophash，key和value
</span></span><span style="display:flex;"><span> 40            for i := 0; i &lt; bucketCnt; i, k, e = i+1, add(k, uintptr(t.keysize)), add(e, uintptr(t.elemsize)) {
</span></span><span style="display:flex;"><span> 41                top := b.tophash[i]
</span></span><span style="display:flex;"><span> 42        // 如果当前cell的tophash值是emptyOne或者emptyRest，则代表此cell没有key。并将其标记为evacuatedEmpty，表示它“已经被搬迁”。
</span></span><span style="display:flex;"><span> 43                if isEmpty(top) {
</span></span><span style="display:flex;"><span> 44                    b.tophash[i] = evacuatedEmpty
</span></span><span style="display:flex;"><span> 45                    continue
</span></span><span style="display:flex;"><span> 46                }
</span></span><span style="display:flex;"><span> 47        // 正常不会出现这种情况
</span></span><span style="display:flex;"><span> 48        // 未被搬迁的 cell 只可能是emptyOne、emptyRest或是正常的 top hash（大于等于 minTopHash）
</span></span><span style="display:flex;"><span> 49                if top &lt; minTopHash {
</span></span><span style="display:flex;"><span> 50                    throw(&#34;bad map state&#34;)
</span></span><span style="display:flex;"><span> 51                }
</span></span><span style="display:flex;"><span> 52                k2 := k
</span></span><span style="display:flex;"><span> 53        // 如果 key 是指针，则解引用
</span></span><span style="display:flex;"><span> 54                if t.indirectkey() {
</span></span><span style="display:flex;"><span> 55                    k2 = *((*unsafe.Pointer)(k2))
</span></span><span style="display:flex;"><span> 56                }
</span></span><span style="display:flex;"><span> 57                var useY uint8
</span></span><span style="display:flex;"><span> 58        // 如果是增量扩容
</span></span><span style="display:flex;"><span> 59                if !h.sameSizeGrow() {
</span></span><span style="display:flex;"><span> 60          // 计算哈希值，判断当前key和vale是要被搬迁到bucket x还是bucket y
</span></span><span style="display:flex;"><span> 61                    hash := t.hasher(k2, uintptr(h.hash0))
</span></span><span style="display:flex;"><span> 62                    if h.flags&amp;iterator != 0 &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.equal(k2, k2) {
</span></span><span style="display:flex;"><span> 63            // 有一个特殊情况：有一种 key，每次对它计算 hash，得到的结果都不一样。
</span></span><span style="display:flex;"><span> 64            // 这个 key 就是 math.NaN() 的结果，它的含义是 not a number，类型是 float64。
</span></span><span style="display:flex;"><span> 65            // 当它作为 map 的 key时，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！
</span></span><span style="display:flex;"><span> 66            // 这个 key 是永远不会被 Get 操作获取的！当使用 m[math.NaN()] 语句的时候，是查不出来结果的。
</span></span><span style="display:flex;"><span> 67            // 这个 key 只有在遍历整个 map 的时候，才能被找到。
</span></span><span style="display:flex;"><span> 68            // 并且，可以向一个 map 插入多个数量的 math.NaN() 作为 key，它们并不会被互相覆盖。
</span></span><span style="display:flex;"><span> 69            // 当搬迁碰到 math.NaN() 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。
</span></span><span style="display:flex;"><span> 70                        useY = top &amp; 1
</span></span><span style="display:flex;"><span> 71                        top = tophash(hash)
</span></span><span style="display:flex;"><span> 72          // 对于正常key，进入以下else逻辑  
</span></span><span style="display:flex;"><span> 73                    } else {
</span></span><span style="display:flex;"><span> 74                        if hash&amp;newbit != 0 {
</span></span><span style="display:flex;"><span> 75                            useY = 1
</span></span><span style="display:flex;"><span> 76                        }
</span></span><span style="display:flex;"><span> 77                    }
</span></span><span style="display:flex;"><span> 78                }
</span></span><span style="display:flex;"><span> 79
</span></span><span style="display:flex;"><span> 80                if evacuatedX+1 != evacuatedY || evacuatedX^1 != evacuatedY {
</span></span><span style="display:flex;"><span> 81                    throw(&#34;bad evacuatedN&#34;)
</span></span><span style="display:flex;"><span> 82                }
</span></span><span style="display:flex;"><span> 83
</span></span><span style="display:flex;"><span> 84        // evacuatedX + 1 == evacuatedY
</span></span><span style="display:flex;"><span> 85                b.tophash[i] = evacuatedX + useY
</span></span><span style="display:flex;"><span> 86        // useY要么为0，要么为1。这里就是选取在bucket x的起始内存位置，或者选择在bucket y的起始内存位置（只有增量同步才会有这个选择可能）。
</span></span><span style="display:flex;"><span> 87                dst := &amp;xy[useY]
</span></span><span style="display:flex;"><span> 88
</span></span><span style="display:flex;"><span> 89        // 如果目的地的桶已经装满了（8个cell），那么需要新建一个溢出桶，继续搬迁到溢出桶上去。
</span></span><span style="display:flex;"><span> 90                if dst.i == bucketCnt {
</span></span><span style="display:flex;"><span> 91                    dst.b = h.newoverflow(t, dst.b)
</span></span><span style="display:flex;"><span> 92                    dst.i = 0
</span></span><span style="display:flex;"><span> 93                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)
</span></span><span style="display:flex;"><span> 94                    dst.e = add(dst.k, bucketCnt*uintptr(t.keysize))
</span></span><span style="display:flex;"><span> 95                }
</span></span><span style="display:flex;"><span> 96                dst.b.tophash[dst.i&amp;(bucketCnt-1)] = top
</span></span><span style="display:flex;"><span> 97        // 如果待搬迁的key是指针，则复制指针过去
</span></span><span style="display:flex;"><span> 98                if t.indirectkey() {
</span></span><span style="display:flex;"><span> 99                    *(*unsafe.Pointer)(dst.k) = k2 // copy pointer
</span></span><span style="display:flex;"><span>100        // 如果待搬迁的key是值，则复制值过去  
</span></span><span style="display:flex;"><span>101                } else {
</span></span><span style="display:flex;"><span>102                    typedmemmove(t.key, dst.k, k) // copy elem
</span></span><span style="display:flex;"><span>103                }
</span></span><span style="display:flex;"><span>104        // value和key同理
</span></span><span style="display:flex;"><span>105                if t.indirectelem() {
</span></span><span style="display:flex;"><span>106                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)
</span></span><span style="display:flex;"><span>107                } else {
</span></span><span style="display:flex;"><span>108                    typedmemmove(t.elem, dst.e, e)
</span></span><span style="display:flex;"><span>109                }
</span></span><span style="display:flex;"><span>110        // 将当前搬迁目的桶的记录key/value的索引值（也可以理解为cell的索引值）加一
</span></span><span style="display:flex;"><span>111                dst.i++
</span></span><span style="display:flex;"><span>112        // 由于桶的内存布局中在最后还有overflow的指针，多以这里不用担心更新有可能会超出key和value数组的指针地址。
</span></span><span style="display:flex;"><span>113                dst.k = add(dst.k, uintptr(t.keysize))
</span></span><span style="display:flex;"><span>114                dst.e = add(dst.e, uintptr(t.elemsize))
</span></span><span style="display:flex;"><span>115            }
</span></span><span style="display:flex;"><span>116        }
</span></span><span style="display:flex;"><span>117    // 如果没有协程在使用老的桶，就对老的桶进行清理，用于帮助gc
</span></span><span style="display:flex;"><span>118        if h.flags&amp;oldIterator == 0 &amp;&amp; t.bucket.ptrdata != 0 {
</span></span><span style="display:flex;"><span>119            b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
</span></span><span style="display:flex;"><span>120      // 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态
</span></span><span style="display:flex;"><span>121            ptr := add(b, dataOffset)
</span></span><span style="display:flex;"><span>122            n := uintptr(t.bucketsize) - dataOffset
</span></span><span style="display:flex;"><span>123            memclrHasPointers(ptr, n)
</span></span><span style="display:flex;"><span>124        }
</span></span><span style="display:flex;"><span>125    }
</span></span><span style="display:flex;"><span>126
</span></span><span style="display:flex;"><span>127  // 用于更新搬迁进度
</span></span><span style="display:flex;"><span>128    if oldbucket == h.nevacuate {
</span></span><span style="display:flex;"><span>129        advanceEvacuationMark(h, t, newbit)
</span></span><span style="display:flex;"><span>130    }
</span></span><span style="display:flex;"><span>131}
</span></span><span style="display:flex;"><span>132
</span></span><span style="display:flex;"><span>133func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
</span></span><span style="display:flex;"><span>134  // 搬迁桶的进度加一
</span></span><span style="display:flex;"><span>135    h.nevacuate++
</span></span><span style="display:flex;"><span>136  // 实验表明，1024至少会比newbit高出一个数量级（newbit代表扩容之前老的bucket个数）。所以，用当前进度加上1024用于确保O(1)行为。
</span></span><span style="display:flex;"><span>137    stop := h.nevacuate + 1024
</span></span><span style="display:flex;"><span>138    if stop &gt; newbit {
</span></span><span style="display:flex;"><span>139        stop = newbit
</span></span><span style="display:flex;"><span>140    }
</span></span><span style="display:flex;"><span>141  // 计算已经搬迁完的桶数
</span></span><span style="display:flex;"><span>142    for h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) {
</span></span><span style="display:flex;"><span>143        h.nevacuate++
</span></span><span style="display:flex;"><span>144    }
</span></span><span style="display:flex;"><span>145  // 如果h.nevacuate == newbit，则代表所有的桶都已经搬迁完毕
</span></span><span style="display:flex;"><span>146    if h.nevacuate == newbit {
</span></span><span style="display:flex;"><span>147    // 搬迁完毕，所以指向老的buckets的指针置为nil
</span></span><span style="display:flex;"><span>148        h.oldbuckets = nil
</span></span><span style="display:flex;"><span>149    // 在讲解hmap的结构中，有过说明。如果key和value均不包含指针，则都可以inline。
</span></span><span style="display:flex;"><span>150    // 那么保存它们的buckets数组其实是挂在hmap.extra中的。所以，这种情况下，其实我们是搬迁的extra的buckets数组。
</span></span><span style="display:flex;"><span>151    // 因此，在这种情况下，需要在搬迁完毕后，将hmap.extra.oldoverflow指针置为nil。
</span></span><span style="display:flex;"><span>152        if h.extra != nil {
</span></span><span style="display:flex;"><span>153            h.extra.oldoverflow = nil
</span></span><span style="display:flex;"><span>154        }
</span></span><span style="display:flex;"><span>155    // 最后，清除正在扩容的标志位，扩容完毕。
</span></span><span style="display:flex;"><span>156        h.flags &amp;^= sameSizeGrow
</span></span><span style="display:flex;"><span>157    }
</span></span><span style="display:flex;"><span>158}
</span></span></code></pre></div><p>代码比较长，但是文中注释已经比较清晰了，如果对map的扩容还不清楚，可以参见以下图解。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/20.png" alt="img"></p>
<p>针对上图的map，其B为3，所以原始buckets数组为8。当map元素数变多，加载因子超过6.5，所以引起了增量扩容。</p>
<p>以3号bucket为例，可以看到，由于B值加1，所以在新选取桶时，需要取低4位哈希值，这样就会造成cell会被搬迁到新buckets数组中不同的桶（3号或11号桶）中去。注意，在一个桶中，搬迁cell的工作是有序的：它们是依序填进对应新桶的cell中去的。</p>
<p>当然，实际情况中3号桶很可能还有溢出桶，在这里为了简化绘图，假设3号桶没有溢出桶，如果有溢出桶，则相应地添加到新的3号桶和11号桶中即可，如果对应的3号和11号桶均装满，则给新的桶添加溢出桶来装载。</p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/21.png" alt="img"></p>
<p>对于上图的map，其B也为3。假设整个map中的overflow过多，触发了等量扩容。注意，等量扩容时，新的buckets数组大小和旧buckets数组是一样的。</p>
<p>以6号桶为例，它有一个bucket和3个overflow buckets，但是我们能够发现桶里的数据非常稀疏，等量扩容的目的就是为了把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。搬迁完毕后，新的6号桶中只有一个基础bucket，暂时并不需要溢出桶。这样，和原6号桶相比，数据变得紧密，使后续的数据存取变快。</p>
<p>最后回答一下上文中留下的问题：为什么确定key落在哪个区间很重要？因为对于增量扩容而言，原本一个bucket中的key会被分裂到两个bucket中去，它们分别处于bucket x和bucket y中，但是它们之间存在关系 bucket x + 2^B = bucket y （其中，B是老bucket对应的B值）。假设key所在的老bucket序号为n，那么如果key落在新的bucket x，则它应该置入 bucket x起始位置 + n<em>bucket 的内存中去；如果key落在新的bucket y，则它应该置入 bucket y起始位置 + n</em>bucket的内存中去。因此，确定key落在哪个区间，这样就很方便进行内存地址计算，快速找到key应该插入的内存地址。</p>
<p><strong>map 总结和使用建议</strong></p>
<p><img src="http://shanks.link/img/Go%E4%B9%8BMap%E7%9A%84%E8%AE%BE%E8%AE%A1/1.png" alt="img"></p>
<p><strong>01</strong></p>
<p><strong>总结</strong></p>
<h3 id="heading-4"></h3>
<p>Go语言的map，底层是哈希表实现的，通过链地址法解决哈希冲突，它依赖的核心数据结构是数组加链表。</p>
<p>map中定义了2的B次方个桶，每个桶中能够容纳8个key。根据key的不同哈希值，将其散落到不同的桶中。哈希值的低位（哈希值的后B个bit位）决定桶序号，高位（哈希值的前8个bit位）标识同一个桶中的不同 key。</p>
<p>当向桶中添加了很多 key，造成元素过多，超过了装载因子所设定的程度，或者多次增删操作，造成溢出桶过多，均会触发扩容。</p>
<p>扩容分为增量扩容和等量扩容。增量扩容，会增加桶的个数（增加一倍），把原来一个桶中的 keys 被重新分配到两个桶中。等量扩容，不会更改桶的个数，只是会将桶中的数据变得紧凑。不管是增量扩容还是等量扩容，都需要创建新的桶数组，并不是原地操作的。</p>
<p>扩容过程是渐进性的，主要是防止一次扩容需要搬迁的 key 数量过多，引发性能问题。触发扩容的时机是增加了新元素， 桶搬迁的时机则发生在赋值、删除期间，每次最多搬迁两个 桶。查找、赋值、删除的一个很核心的内容是如何定位到 key 所在的位置，需要重点理解。一旦理解，关于 map 的源码就可以看懂了。</p>
<p><strong>02</strong></p>
<p><strong>使用建议</strong></p>
<p>从map设计可以知道，它并不是一个并发安全的数据结构。同时对map进行读写时，程序很容易出错。因此，要想在并发情况下使用map，请加上锁（sync.Mutex或者sync.RwMutex）。其实，Go标准库中已经为我们实现了并发安全的map——sync.Map，我之前写过文章对它的实现进行讲解，详情可以查看本公众号《深入理解sync.Map》一文。</p>
<p>遍历map的结果是无序的，在使用中，应该注意到该点。</p>
<p>通过map的结构体可以知道，它其实是通过指针指向底层buckets数组。所以和slice一样，尽管go函数都是值传递，但是，当map作为参数被函数调用时，在函数内部对map的操作同样会影响到外部的map。</p>
<p>另外，有个特殊的key值math.NaN，它每次生成的哈希值是不一样的，这会造成m[math.NaN]是拿不到值的，而且多次对它赋值，会让map中存在多个math.NaN的key。不过这个基本用不到，知道有这个特殊情况就可以了。</p>
<ul>
<li>
<h2 id="参考链接">参考链接</h2>
</li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a></p>
<p><a href="https://blog.golang.org/maps">https://blog.golang.org/maps</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&amp;mid=2647523687&amp;idx=1&amp;sn=425d3c2b2db5f9139ad63a0af116e98b&amp;chksm=87d1be64b0a63772108124bd5c032ff910e95430ba684ab9a194640bca776c1ee9554df6dd3a&amp;scene=21#wechat_redirect">景禹 《图解：什么是哈希》</a></p>
<p><a href="https://mp.weixin.qq.com/s/OHROn0ya_nWR6qkaSFmacw">https://mp.weixin.qq.com/s/OHROn0ya_nWR6qkaSFmacw</a></p>
<p><a href="https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu6.pdf">https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu6.pdf</a></p>
<p><a href="https://github.com/cch123/golang-notes/blob/master/map.md">https://github.com/cch123/golang-notes/blob/master/map.md</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/66676224">https://zhuanlan.zhihu.com/p/66676224</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p>
<p><a href="https://github.com/talkgo/night/issues/332">https://github.com/talkgo/night/issues/332</a></p>
<p><a href="https://my.oschina.net/renhc/blog/2208417">https://my.oschina.net/renhc/blog/2208417</a></p>
<p><a href="https://mp.weixin.qq.com/s/q3qyc5uf3IMVt4KQD12IKQ">以上内容转载自机器铃砍菜刀的blog</a></p>

    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/go" rel="tag" title="go">#go#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/blog/2021/05/06/go%E5%B7%A5%E5%85%B7%E4%B9%8Bgenerate/" rel="next" title="Go工具之generate">
        <i class="fa fa-chevron-left"></i> Go工具之generate
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/04/30/%E8%AF%A6%E8%A7%A3%E5%86%85%E8%81%94%E4%BC%98%E5%8C%96/" rel="prev" title="详解内联优化">
        详解内联优化 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">501</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">34</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">39</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>