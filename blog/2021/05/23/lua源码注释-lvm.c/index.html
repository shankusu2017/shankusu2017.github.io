<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>lua源码注释-lvm.c - Golang编程语言知识介绍</title>
    <meta name="keywords" content="git,Git,Lua,lua,Golang,go">
    
    <meta property="og:title" content="lua源码注释-lvm.c">
    <meta property="og:site_name" content="Golang编程语言知识介绍">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="lua源码注释-lvm.c - Golang编程语言知识介绍" />
    <meta name="description" content="愿星光伴你左右"> 
    <link rel="shortcut icon" href="http://shanks.link/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://shanks.link/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://shanks.link/img/apple-touch-icon.png" />
    <link href="http://shanks.link/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://shanks.link/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://shanks.link/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Golang编程语言知识介绍</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://shanks.link/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/thinking/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />随想录
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E7%94%9F%E6%B4%BB/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />生活
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/os/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/lua/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />lua
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/redis/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />redis
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/go/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Golang
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/c/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />C
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/tcpip/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />TCP/IP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ebpf/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />ebpf
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/p4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />p4
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openvpn/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenVPN
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/ipsec/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IPSec
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/l2tp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />L2TP
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/dns/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />DNS
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/web/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />web
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/openwrt/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />OpenWRT
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E8%BF%90%E7%BB%B4/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />运维
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/git/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />Git
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/%E9%B8%9F%E5%93%A5%E7%9A%84%E7%A7%81%E6%88%BF%E8%8F%9C/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />鸟哥的私房菜
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/categories/it/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />IT杂谈
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />About Me
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/links/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />友情链接
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://shanks.link/ftp/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />FTP
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://shanks.link/blog/2021/05/23/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-lvm.c/" itemprop="url">
        lua源码注释-lvm.c
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2021-05-23">
    2021-05-23
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://shanks.link/categories/lua" itemprop="url" rel="index">
        <span itemprop="name">lua</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">6092 字 ~13分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p><a href="https://github.com/shankusu2017/lua">github链接</a> lua515子域</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** $Id: lvm.c,v 2.63.1.5 2011/08/17 20:43:11 roberto Exp $
</span><span style="color:#f00;font-style:italic">** Lua virtual machine
</span><span style="color:#f00;font-style:italic">** See Copyright Notice in lua.h
</span><span style="color:#f00;font-style:italic">*/</span>


<span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdio.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;stdlib.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&lt;string.h&gt;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#define lvm_c
</span><span style="color:#f00;font-style:italic">#define LUA_CORE
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lua.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldebug.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ldo.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lfunc.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lgc.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lobject.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lopcodes.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstate.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lstring.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltable.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;ltm.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic">#include</span> <span style="color:#f00;font-style:italic">&#34;lvm.h&#34;</span><span style="color:#f00;font-style:italic">
</span><span style="color:#f00;font-style:italic"></span>


<span style="color:#f00;font-style:italic">/* limit for table tag-method chains (to avoid loops) */</span>
<span style="color:#f00;font-style:italic">#define MAXTAGLOOP	100
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* number,string--&gt;number */</span>
<span style="color:#00f">const</span> TValue *<span style="color:#c34e00">luaV_tonumber</span> (<span style="color:#00f">const</span> TValue *obj, TValue *n) {
  lua_Number num;
  <span style="color:#00f">if</span> (ttisnumber(obj)) <span style="color:#00f">return</span> obj;
  <span style="color:#00f">if</span> (ttisstring(obj) &amp;&amp; luaO_str2d(svalue(obj), &amp;num)) {
    setnvalue(n, num);
    <span style="color:#00f">return</span> n;
  }
  <span style="color:#00f">else</span>
    <span style="color:#00f">return</span> NULL;
}

<span style="color:#f00;font-style:italic">/* number-&gt;string */</span>
<span style="color:#00f">int</span> <span style="color:#c34e00">luaV_tostring</span> (lua_State *L, StkId obj) {
  <span style="color:#00f">if</span> (!ttisnumber(obj))
    <span style="color:#00f">return</span> 0;
  <span style="color:#00f">else</span> {
    <span style="color:#00f">char</span> s[LUAI_MAXNUMBER2STR];
    lua_Number n = nvalue(obj);
    lua_number2str(s, n);
    setsvalue2s(L, obj, luaS_new(L, s));
    <span style="color:#00f">return</span> 1;
  }
}

<span style="color:#f00;font-style:italic">/* 判断调试MASK是否设置，以及相关条件是否已满足，满足则进入钩子函数 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">traceexec</span> (lua_State *L, <span style="color:#00f">const</span> Instruction *pc) {
  lu_byte mask = L-&gt;hookmask;
  <span style="color:#00f">const</span> Instruction *oldpc = L-&gt;savedpc;
  L-&gt;savedpc = pc;
  <span style="color:#00f">if</span> ((mask &amp; LUA_MASKCOUNT) &amp;&amp; L-&gt;hookcount == 0) {	<span style="color:#f00;font-style:italic">/* 执行了指定数量的pc，调用指定的钩子函数 */</span>
    resethookcount(L);
    luaD_callhook(L, LUA_HOOKCOUNT, -1);
  }
  <span style="color:#00f">if</span> (mask &amp; LUA_MASKLINE) {	<span style="color:#f00;font-style:italic">/* LUA_MASKLINE不是说执行到了某一行，具体的意思看下面的代码 */</span>
    Proto *p = ci_func(L-&gt;ci)-&gt;l.p;
    <span style="color:#00f">int</span> npc = pcRel(pc, p);
    <span style="color:#00f">int</span> newline = getline(p, npc);
    <span style="color:#f00;font-style:italic">/* call linehook when enter a new function, when jump back (loop),
</span><span style="color:#f00;font-style:italic">       or when enter a new line */</span>
    <span style="color:#00f">if</span> (npc == 0 || pc &lt;= oldpc || newline != getline(p, pcRel(oldpc, p)))
      luaD_callhook(L, LUA_HOOKLINE, newline);
  }
}

<span style="color:#f00;font-style:italic">/* 调用元方法，将结果返回给res */</span>
<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">callTMres</span> (lua_State *L, StkId res, <span style="color:#00f">const</span> TValue *f,
                        <span style="color:#00f">const</span> TValue *p1, <span style="color:#00f">const</span> TValue *p2) {
  ptrdiff_t result = savestack(L, res);
  setobj2s(L, L-&gt;top, f);  <span style="color:#f00;font-style:italic">/* push function */</span>
  setobj2s(L, L-&gt;top+1, p1);  <span style="color:#f00;font-style:italic">/* 1st argument */</span>
  setobj2s(L, L-&gt;top+2, p2);  <span style="color:#f00;font-style:italic">/* 2nd argument */</span>
  luaD_checkstack(L, 3);
  L-&gt;top += 3;
  luaD_call(L, L-&gt;top - 3, 1);
  res = restorestack(L, result);
  L-&gt;top--;
  setobjs2s(L, res, L-&gt;top);
}



<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">callTM</span> (lua_State *L, <span style="color:#00f">const</span> TValue *f, <span style="color:#00f">const</span> TValue *p1,
                    <span style="color:#00f">const</span> TValue *p2, <span style="color:#00f">const</span> TValue *p3) {
  setobj2s(L, L-&gt;top, f);  <span style="color:#f00;font-style:italic">/* push function */</span>
  setobj2s(L, L-&gt;top+1, p1);  <span style="color:#f00;font-style:italic">/* 1st argument */</span>
  setobj2s(L, L-&gt;top+2, p2);  <span style="color:#f00;font-style:italic">/* 2nd argument */</span>
  setobj2s(L, L-&gt;top+3, p3);  <span style="color:#f00;font-style:italic">/* 3th argument */</span>
  luaD_checkstack(L, 4);
  L-&gt;top += 4;
  luaD_call(L, L-&gt;top - 4, 0);
}


<span style="color:#00f">void</span> <span style="color:#c34e00">luaV_gettable</span> (lua_State *L, <span style="color:#00f">const</span> TValue *t, TValue *key, StkId val) {
  <span style="color:#00f">int</span> loop;
  <span style="color:#00f">for</span> (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
    <span style="color:#00f">const</span> TValue *tm;
    <span style="color:#00f">if</span> (ttistable(t)) {  <span style="color:#f00;font-style:italic">/* `t&#39; is a table? */</span>
      Table *h = hvalue(t);
      <span style="color:#00f">const</span> TValue *res = luaH_get(h, key); <span style="color:#f00;font-style:italic">/* do a primitive get */</span>
      <span style="color:#00f">if</span> (!ttisnil(res) ||  <span style="color:#f00;font-style:italic">/* result is no nil? */</span>
          (tm = fasttm(L, h-&gt;metatable, TM_INDEX)) == NULL) { <span style="color:#f00;font-style:italic">/* or no TM? */</span>
        setobj2s(L, val, res);
        <span style="color:#00f">return</span>;
      }
      <span style="color:#f00;font-style:italic">/* else will try the tag method */</span>
    }
    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
      luaG_typeerror(L, t, <span style="color:#009c00">&#34;index&#34;</span>);
    <span style="color:#00f">if</span> (ttisfunction(tm)) {
      callTMres(L, val, tm, t, key);
      <span style="color:#00f">return</span>;
    }
    t = tm;  <span style="color:#f00;font-style:italic">/* else repeat with `tm&#39; */</span> 
  }
  luaG_runerror(L, <span style="color:#009c00">&#34;loop in gettable&#34;</span>);
}


<span style="color:#00f">void</span> <span style="color:#c34e00">luaV_settable</span> (lua_State *L, <span style="color:#00f">const</span> TValue *t, TValue *key, StkId val) {
  <span style="color:#00f">int</span> loop;
  TValue temp;
  <span style="color:#00f">for</span> (loop = 0; loop &lt; MAXTAGLOOP; loop++) {
    <span style="color:#00f">const</span> TValue *tm;
    <span style="color:#00f">if</span> (ttistable(t)) {  <span style="color:#f00;font-style:italic">/* `t&#39; is a table? */</span>
      Table *h = hvalue(t);
      TValue *oldval = luaH_set(L, h, key); <span style="color:#f00;font-style:italic">/* do a primitive set */</span>
      <span style="color:#00f">if</span> (!ttisnil(oldval) ||  <span style="color:#f00;font-style:italic">/* result is no nil? */</span>
          (tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX)) == NULL) { <span style="color:#f00;font-style:italic">/* or no TM? */</span>
        setobj2t(L, oldval, val);
        h-&gt;flags = 0;	<span style="color:#f00;font-style:italic">/* 更新flags:假设所有的tm都存在 */</span>
        luaC_barriert(L, h, val);
        <span style="color:#00f">return</span>;
      }
      <span style="color:#f00;font-style:italic">/* else will try the tag method */</span>
    }
    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
      luaG_typeerror(L, t, <span style="color:#009c00">&#34;index&#34;</span>);
    <span style="color:#00f">if</span> (ttisfunction(tm)) {
      callTM(L, tm, t, key, val);
      <span style="color:#00f">return</span>;
    }
    <span style="color:#f00;font-style:italic">/* else repeat with `tm&#39; */</span>
    setobj(L, &amp;temp, tm);  <span style="color:#f00;font-style:italic">/* avoid pointing inside table (may rehash) */</span>
    t = &amp;temp;
  }
  luaG_runerror(L, <span style="color:#009c00">&#34;loop in settable&#34;</span>);
}

<span style="color:#f00;font-style:italic">/* 同上callTM，针对tblA+tblB这种两个操作数的，尝试调用特定元方法 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">call_binTM</span> (lua_State *L, <span style="color:#00f">const</span> TValue *p1, <span style="color:#00f">const</span> TValue *p2,
                       StkId res, TMS event) {
  <span style="color:#00f">const</span> TValue *tm = luaT_gettmbyobj(L, p1, event);  <span style="color:#f00;font-style:italic">/* try first operand */</span>
  <span style="color:#00f">if</span> (ttisnil(tm))
    tm = luaT_gettmbyobj(L, p2, event);  <span style="color:#f00;font-style:italic">/* try second operand */</span>
  <span style="color:#00f">if</span> (ttisnil(tm)) <span style="color:#00f">return</span> 0;
  callTMres(L, res, tm, p1, p2);
  <span style="color:#00f">return</span> 1;
}

<span style="color:#f00;font-style:italic">/* only for userdata */</span>
<span style="color:#00f">static</span> <span style="color:#00f">const</span> TValue *<span style="color:#c34e00">get_compTM</span> (lua_State *L, Table *mt1, Table *mt2,
                                  TMS event) {
  <span style="color:#00f">const</span> TValue *tm1 = fasttm(L, mt1, event);
  <span style="color:#00f">const</span> TValue *tm2;
  <span style="color:#00f">if</span> (tm1 == NULL) <span style="color:#00f">return</span> NULL;  <span style="color:#f00;font-style:italic">/* no metamethod */</span>
  <span style="color:#00f">if</span> (mt1 == mt2) <span style="color:#00f">return</span> tm1;  <span style="color:#f00;font-style:italic">/* same metatables =&gt; same metamethods */</span>
  tm2 = fasttm(L, mt2, event);
  <span style="color:#00f">if</span> (tm2 == NULL) <span style="color:#00f">return</span> NULL;  <span style="color:#f00;font-style:italic">/* no metamethod */</span>
  <span style="color:#00f">if</span> (luaO_rawequalObj(tm1, tm2))  <span style="color:#f00;font-style:italic">/* same metamethods? */</span>
    <span style="color:#00f">return</span> tm1;
  <span style="color:#00f">return</span> NULL;
}

<span style="color:#f00;font-style:italic">/* 元方法：比较操作 */</span>
<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">call_orderTM</span> (lua_State *L, <span style="color:#00f">const</span> TValue *p1, <span style="color:#00f">const</span> TValue *p2,
                         TMS event) {
  <span style="color:#00f">const</span> TValue *tm1 = luaT_gettmbyobj(L, p1, event);
  <span style="color:#00f">const</span> TValue *tm2;
  <span style="color:#00f">if</span> (ttisnil(tm1)) <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* no metamethod? */</span>
  tm2 = luaT_gettmbyobj(L, p2, event);
  <span style="color:#00f">if</span> (!luaO_rawequalObj(tm1, tm2))  <span style="color:#f00;font-style:italic">/* different metamethods? */</span>
    <span style="color:#00f">return</span> -1;
  callTMres(L, L-&gt;top, tm1, p1, p2);
  <span style="color:#00f">return</span> !l_isfalse(L-&gt;top);
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">l_strcmp</span> (<span style="color:#00f">const</span> TString *ls, <span style="color:#00f">const</span> TString *rs) {
  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *l = getstr(ls);
  size_t ll = ls-&gt;tsv.len;
  <span style="color:#00f">const</span> <span style="color:#00f">char</span> *r = getstr(rs);
  size_t lr = rs-&gt;tsv.len;
  <span style="color:#00f">for</span> (;;) {
    <span style="color:#00f">int</span> temp = strcoll(l, r);	<span style="color:#f00;font-style:italic">/* 依环境变量 LC_COLLATE 所指定的文字排列次序来比较 s1 和 s2 字符串 */</span>
    <span style="color:#00f">if</span> (temp != 0) <span style="color:#00f">return</span> temp;
    <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* strings are equal up to a `\0&#39; */</span>
      size_t len = strlen(l);  <span style="color:#f00;font-style:italic">/* index of first `\0&#39; in both strings */</span>
      <span style="color:#00f">if</span> (len == lr)  <span style="color:#f00;font-style:italic">/* r is finished? */</span>
        <span style="color:#00f">return</span> (len == ll) ? 0 : 1;
      <span style="color:#00f">else</span> <span style="color:#00f">if</span> (len == ll)  <span style="color:#f00;font-style:italic">/* l is finished? */</span>
        <span style="color:#00f">return</span> -1;  <span style="color:#f00;font-style:italic">/* l is smaller than r (because r is not finished) */</span>
      <span style="color:#f00;font-style:italic">/* both strings longer than `len&#39;; go on comparing (after the `\0&#39;) */</span>
      len++;
      l += len; ll -= len; r += len; lr -= len;
    }
  }
}

<span style="color:#f00;font-style:italic">/* 比较指令 */</span>
<span style="color:#00f">int</span> <span style="color:#c34e00">luaV_lessthan</span> (lua_State *L, <span style="color:#00f">const</span> TValue *l, <span style="color:#00f">const</span> TValue *r) {
  <span style="color:#00f">int</span> res;
  <span style="color:#00f">if</span> (ttype(l) != ttype(r))
    <span style="color:#00f">return</span> luaG_ordererror(L, l, r);
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ttisnumber(l))
    <span style="color:#00f">return</span> luai_numlt(nvalue(l), nvalue(r));
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ttisstring(l))
    <span style="color:#00f">return</span> l_strcmp(rawtsvalue(l), rawtsvalue(r)) &lt; 0;
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> ((res = call_orderTM(L, l, r, TM_LT)) != -1)
    <span style="color:#00f">return</span> res;
  <span style="color:#00f">return</span> luaG_ordererror(L, l, r);
}


<span style="color:#00f">static</span> <span style="color:#00f">int</span> <span style="color:#c34e00">lessequal</span> (lua_State *L, <span style="color:#00f">const</span> TValue *l, <span style="color:#00f">const</span> TValue *r) {
  <span style="color:#00f">int</span> res;
  <span style="color:#00f">if</span> (ttype(l) != ttype(r))
    <span style="color:#00f">return</span> luaG_ordererror(L, l, r);
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ttisnumber(l))
    <span style="color:#00f">return</span> luai_numle(nvalue(l), nvalue(r));
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (ttisstring(l))
    <span style="color:#00f">return</span> l_strcmp(rawtsvalue(l), rawtsvalue(r)) &lt;= 0;
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> ((res = call_orderTM(L, l, r, TM_LE)) != -1)  <span style="color:#f00;font-style:italic">/* first try `le&#39; */</span>
    <span style="color:#00f">return</span> res;
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> ((res = call_orderTM(L, r, l, TM_LT)) != -1)  <span style="color:#f00;font-style:italic">/* else try `lt&#39; */</span>
    <span style="color:#00f">return</span> !res;
  <span style="color:#00f">return</span> luaG_ordererror(L, l, r);
}


<span style="color:#00f">int</span> <span style="color:#c34e00">luaV_equalval</span> (lua_State *L, <span style="color:#00f">const</span> TValue *t1, <span style="color:#00f">const</span> TValue *t2) {
  <span style="color:#00f">const</span> TValue *tm;
  lua_assert(ttype(t1) == ttype(t2));
  <span style="color:#00f">switch</span> (ttype(t1)) {
    <span style="color:#00f">case</span> LUA_TNIL: <span style="color:#00f">return</span> 1;
    <span style="color:#00f">case</span> LUA_TNUMBER: <span style="color:#00f">return</span> luai_numeq(nvalue(t1), nvalue(t2));
    <span style="color:#00f">case</span> LUA_TBOOLEAN: <span style="color:#00f">return</span> bvalue(t1) == bvalue(t2);  <span style="color:#f00;font-style:italic">/* true must be 1 !! */</span>
    <span style="color:#00f">case</span> LUA_TLIGHTUSERDATA: <span style="color:#00f">return</span> pvalue(t1) == pvalue(t2);
    <span style="color:#00f">case</span> LUA_TUSERDATA: {
      <span style="color:#00f">if</span> (uvalue(t1) == uvalue(t2)) <span style="color:#00f">return</span> 1;
      tm = get_compTM(L, uvalue(t1)-&gt;metatable, uvalue(t2)-&gt;metatable,
                         TM_EQ);
      <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* will try TM */</span>
    }
    <span style="color:#00f">case</span> LUA_TTABLE: {
      <span style="color:#00f">if</span> (hvalue(t1) == hvalue(t2)) <span style="color:#00f">return</span> 1;
      tm = get_compTM(L, hvalue(t1)-&gt;metatable, hvalue(t2)-&gt;metatable, TM_EQ);
      <span style="color:#00f">break</span>;  <span style="color:#f00;font-style:italic">/* will try TM */</span>
    }
    <span style="color:#00f">default</span>: <span style="color:#00f">return</span> gcvalue(t1) == gcvalue(t2);
  }
  <span style="color:#00f">if</span> (tm == NULL) <span style="color:#00f">return</span> 0;  <span style="color:#f00;font-style:italic">/* no TM? */</span>
  callTMres(L, L-&gt;top, tm, t1, t2);  <span style="color:#f00;font-style:italic">/* call TM */</span>
  <span style="color:#00f">return</span> !l_isfalse(L-&gt;top);
}

<span style="color:#f00;font-style:italic">/* 从last开始，一共链接total个slot          */</span>
<span style="color:#00f">void</span> <span style="color:#c34e00">luaV_concat</span> (lua_State *L, <span style="color:#00f">int</span> total, <span style="color:#00f">int</span> last) {
  <span style="color:#00f">do</span> {
    StkId top = L-&gt;base + last + 1;
    <span style="color:#00f">int</span> n = 2;  <span style="color:#f00;font-style:italic">/* number of elements handled in this pass (at least 2) */</span>
    <span style="color:#00f">if</span> (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
      <span style="color:#00f">if</span> (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
        luaG_concaterror(L, top-2, top-1);
    } <span style="color:#00f">else</span> <span style="color:#00f">if</span> (tsvalue(top-1)-&gt;len == 0)  <span style="color:#f00;font-style:italic">/* second op is empty? */</span>
      (<span style="color:#00f">void</span>)tostring(L, top - 2);  <span style="color:#f00;font-style:italic">/* result is first op (as string) */</span>
    <span style="color:#00f">else</span> {
      <span style="color:#f00;font-style:italic">/* at least two string values; get as many as possible */</span>
      size_t tl = tsvalue(top-1)-&gt;len;
      <span style="color:#00f">char</span> *buffer;
      <span style="color:#00f">int</span> i;
      <span style="color:#f00;font-style:italic">/* collect total length */</span>
      <span style="color:#00f">for</span> (n = 1; n &lt; total &amp;&amp; tostring(L, top-n-1); n++) {
        size_t l = tsvalue(top-n-1)-&gt;len;
        <span style="color:#00f">if</span> (l &gt;= MAX_SIZET - tl) luaG_runerror(L, <span style="color:#009c00">&#34;string length overflow&#34;</span>);
        tl += l;
      }
      buffer = luaZ_openspace(L, &amp;G(L)-&gt;buff, tl);
      tl = 0;
      <span style="color:#00f">for</span> (i=n; i&gt;0; i--) {  <span style="color:#f00;font-style:italic">/* concat all strings */</span>
        size_t l = tsvalue(top-i)-&gt;len;
        memcpy(buffer+tl, svalue(top-i), l);
        tl += l;
      }
      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
    }
    total -= n-1;  <span style="color:#f00;font-style:italic">/* got `n&#39; strings to create 1 new */</span>
    last -= n-1;
  } <span style="color:#00f">while</span> (total &gt; 1);  <span style="color:#f00;font-style:italic">/* repeat until only 1 result left */</span>
}


<span style="color:#00f">static</span> <span style="color:#00f">void</span> <span style="color:#c34e00">Arith</span> (lua_State *L, StkId ra, <span style="color:#00f">const</span> TValue *rb,
                   <span style="color:#00f">const</span> TValue *rc, TMS op) {
  TValue tempb, tempc;
  <span style="color:#00f">const</span> TValue *b, *c;
  <span style="color:#00f">if</span> ((b = luaV_tonumber(rb, &amp;tempb)) != NULL &amp;&amp;
      (c = luaV_tonumber(rc, &amp;tempc)) != NULL) {
    lua_Number nb = nvalue(b), nc = nvalue(c);
    <span style="color:#00f">switch</span> (op) {
      <span style="color:#00f">case</span> TM_ADD: setnvalue(ra, luai_numadd(nb, nc)); <span style="color:#00f">break</span>;
      <span style="color:#00f">case</span> TM_SUB: setnvalue(ra, luai_numsub(nb, nc)); <span style="color:#00f">break</span>;
      <span style="color:#00f">case</span> TM_MUL: setnvalue(ra, luai_nummul(nb, nc)); <span style="color:#00f">break</span>;
      <span style="color:#00f">case</span> TM_DIV: setnvalue(ra, luai_numdiv(nb, nc)); <span style="color:#00f">break</span>;
      <span style="color:#00f">case</span> TM_MOD: setnvalue(ra, luai_nummod(nb, nc)); <span style="color:#00f">break</span>;
      <span style="color:#00f">case</span> TM_POW: setnvalue(ra, luai_numpow(nb, nc)); <span style="color:#00f">break</span>;
      <span style="color:#00f">case</span> TM_UNM: setnvalue(ra, luai_numunm(nb)); <span style="color:#00f">break</span>;
      <span style="color:#00f">default</span>: lua_assert(0); <span style="color:#00f">break</span>;
    }
  }
  <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!call_binTM(L, rb, rc, ra, op))
    luaG_aritherror(L, rb, rc);
}



<span style="color:#f00;font-style:italic">/*
</span><span style="color:#f00;font-style:italic">** some macros for common tasks in `luaV_execute&#39;
</span><span style="color:#f00;font-style:italic">*/</span>

<span style="color:#f00;font-style:italic">#define runtime_check(L, c)	{ if (!(c)) break; }
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* 提取指令中A,B,C的值 */</span>
<span style="color:#f00;font-style:italic">#define RA(i)	(base+GETARG_A(i))
</span><span style="color:#f00;font-style:italic"></span><span style="color:#f00;font-style:italic">/* to be used after possible stack reallocation */</span>
<span style="color:#f00;font-style:italic">#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
</span><span style="color:#f00;font-style:italic">#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
</span><span style="color:#f00;font-style:italic">#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
</span><span style="color:#f00;font-style:italic">	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
</span><span style="color:#f00;font-style:italic">#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
</span><span style="color:#f00;font-style:italic">	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
</span><span style="color:#f00;font-style:italic">#define KBx(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))
</span><span style="color:#f00;font-style:italic"></span>

<span style="color:#f00;font-style:italic">#define dojump(L,pc,i)	{(pc) += (i); luai_threadyield(L);}
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* x可能触发新的frame，这里保存和恢复“部分现场”配合下面的execute一起看 
</span><span style="color:#f00;font-style:italic">** pc:为何要存档呢？这是一个局部变量，且是相对frame有效，若切换execute则pc作为上一个execute的局部变量保存起来了，
</span><span style="color:#f00;font-style:italic">**    所以为啥要保存这个变量呢？
</span><span style="color:#f00;font-style:italic">** base: {x}可能修改stack,造成base记录的本frame的base失效，故而这里要刷新base
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#f00;font-style:italic">#define Protect(x)	{ L-&gt;savedpc = pc; {x;}; base = L-&gt;base; }
</span><span style="color:#f00;font-style:italic"></span>
<span style="color:#f00;font-style:italic">/* 这个宏有意思哈 */</span> 
<span style="color:#f00;font-style:italic">#define arith_op(op,tm) { \
</span><span style="color:#f00;font-style:italic">        TValue *rb = RKB(i); \
</span><span style="color:#f00;font-style:italic">        TValue *rc = RKC(i); \
</span><span style="color:#f00;font-style:italic">        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) { \
</span><span style="color:#f00;font-style:italic">          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
</span><span style="color:#f00;font-style:italic">          setnvalue(ra, op(nb, nc)); \
</span><span style="color:#f00;font-style:italic">        } \
</span><span style="color:#f00;font-style:italic">        else \
</span><span style="color:#f00;font-style:italic">          Protect(Arith(L, ra, rb, rc, tm)); \
</span><span style="color:#f00;font-style:italic">      }
</span><span style="color:#f00;font-style:italic"></span>

<span style="color:#f00;font-style:italic">/* 
</span><span style="color:#f00;font-style:italic">** KEYCODE
</span><span style="color:#f00;font-style:italic">** nexeccalls:Lua连续调用的层次
</span><span style="color:#f00;font-style:italic">**
</span><span style="color:#f00;font-style:italic">** eg: c(0)-&gt;Lua(1)-&gt;Lua(2)-&gt;c()-&gt;Lua(1)-&gt;Lua(2)-&gt;Lua(3)-&gt;c(0)-&gt;Lua(1)
</span><span style="color:#f00;font-style:italic">** 某次Lua调用结束，--nexeccalls，如果nexeccalls==0，表示当前lua调用链结束了，需要跳出luaV_execute函数
</span><span style="color:#f00;font-style:italic">** 大于0表示本Lua调用结束后，上一层必然还是Lua函数，需要进入reentry点
</span><span style="color:#f00;font-style:italic">*/</span>
<span style="color:#00f">void</span> <span style="color:#c34e00">luaV_execute</span> (lua_State *L, <span style="color:#00f">int</span> nexeccalls) {
  LClosure *cl;
  StkId base;
  TValue *k;
  <span style="color:#00f">const</span> Instruction *pc;
  
 reentry:  <span style="color:#f00;font-style:italic">/* entry point for new (callInfo,frame) */</span>
  lua_assert(isLua(L-&gt;ci));	<span style="color:#f00;font-style:italic">/* C函数frame的执行不在这里，亲! */</span>

  <span style="color:#f00;font-style:italic">/* KEYCODE vm执行的关键参数:base,top,pc,savedpc, closure,k, L-&gt;ci,
</span><span style="color:#f00;font-style:italic">  ** 后续因为call和return等切换调用栈时，必须正确处理上述参数
</span><span style="color:#f00;font-style:italic">  ** 
</span><span style="color:#f00;font-style:italic">  ** !!!!!!!! L-&gt;top没有在这里更新，这点要有印象，resason:类似funA(funB())一个函数(frame)运行完毕时的某些状态eg:L-&gt;top
</span><span style="color:#f00;font-style:italic">  ** 对上下文的frame可能有影响，所以这里没有更新L-&gt;top，而是让有关业务(return,call...)自行处理
</span><span style="color:#f00;font-style:italic">  */</span>
  
  pc = L-&gt;savedpc;
  cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;
  base = L-&gt;base;
  k = cl-&gt;p-&gt;k;	<span style="color:#f00;font-style:italic">/* locvars 仅在编译阶段/调试库中有效，虚拟机运行阶段无效(已编码到pc中) */</span>
  
  <span style="color:#f00;font-style:italic">/* main loop of interpreter */</span>
  <span style="color:#00f">for</span> (;;) {
    <span style="color:#00f">const</span> Instruction i = *pc++;	<span style="color:#f00;font-style:italic">/* 等效：*(pc++) */</span>
    StkId ra;
   <span style="color:#f00;font-style:italic">/* 运行钩子逻辑 */</span>
    <span style="color:#00f">if</span> ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;
        (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {
      traceexec(L, pc);
      <span style="color:#00f">if</span> (L-&gt;status == LUA_YIELD) {  <span style="color:#f00;font-style:italic">/* did hook yield? */</span>
        L-&gt;savedpc = pc - 1;
        <span style="color:#00f">return</span>;
      }
      base = L-&gt;base;
    }
    <span style="color:#f00;font-style:italic">/* warning!! several(某些) calls may realloc the stack and invalidate `ra&#39; */</span>
    ra = RA(i);
    lua_assert(base == L-&gt;base &amp;&amp; L-&gt;base == L-&gt;ci-&gt;base);
    lua_assert(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt;= L-&gt;stack + L-&gt;stacksize);

	<span style="color:#f00;font-style:italic">/* luaG_checkopenop的用途对照上面L-&gt;top的注释看就明白了 */</span>
    lua_assert(L-&gt;top == L-&gt;ci-&gt;top || luaG_checkopenop(i));
    <span style="color:#00f">switch</span> (GET_OPCODE(i)) {
      <span style="color:#00f">case</span> OP_MOVE: {
        setobjs2s(L, ra, RB(i));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_LOADK: {
        setobj2s(L, ra, KBx(i));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_LOADBOOL: {
        setbvalue(ra, GETARG_B(i));
        <span style="color:#00f">if</span> (GETARG_C(i)) pc++;  <span style="color:#f00;font-style:italic">/* skip next instruction (if C) */</span>
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_LOADNIL: {
        TValue *rb = RB(i);
        <span style="color:#00f">do</span> {
          setnilvalue(rb--);
        } <span style="color:#00f">while</span> (rb &gt;= ra);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_GETUPVAL: {
        <span style="color:#00f">int</span> b = GETARG_B(i);
        setobj2s(L, ra, cl-&gt;upvals[b]-&gt;v);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_GETGLOBAL: {
        TValue g;
        TValue *rb = KBx(i);
        sethvalue(L, &amp;g, cl-&gt;env);
        lua_assert(ttisstring(rb));	<span style="color:#f00;font-style:italic">/* 全局变量名类型必须是TString */</span>
        Protect(luaV_gettable(L, &amp;g, rb, ra));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_GETTABLE: {
        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_SETGLOBAL: {
        TValue g;
        sethvalue(L, &amp;g, cl-&gt;env);
        lua_assert(ttisstring(KBx(i)));
        Protect(luaV_settable(L, &amp;g, KBx(i), ra));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_SETUPVAL: {
        UpVal *uv = cl-&gt;upvals[GETARG_B(i)];
        setobj(L, uv-&gt;v, ra);
        luaC_barrier(L, uv, ra);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_SETTABLE: {
        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_NEWTABLE: {
        <span style="color:#00f">int</span> b = GETARG_B(i);
        <span style="color:#00f">int</span> c = GETARG_C(i);
        sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
        Protect(luaC_checkGC(L));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_SELF: {
        StkId rb = RB(i);	<span style="color:#f00;font-style:italic">/* 拿到self.sub中的self指代的表 */</span>
        setobjs2s(L, ra+1, rb);	<span style="color:#f00;font-style:italic">/* 将上述表self存起来 */</span>
        Protect(luaV_gettable(L, rb, RKC(i), ra)); <span style="color:#f00;font-style:italic">/* 计算self.sub的值 */</span>
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_ADD: {
        arith_op(luai_numadd, TM_ADD);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_SUB: {
        arith_op(luai_numsub, TM_SUB);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_MUL: {
        arith_op(luai_nummul, TM_MUL);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_DIV: {
        arith_op(luai_numdiv, TM_DIV);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_MOD: {
        arith_op(luai_nummod, TM_MOD);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_POW: {
        arith_op(luai_numpow, TM_POW);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_UNM: {
        TValue *rb = RB(i);
        <span style="color:#00f">if</span> (ttisnumber(rb)) {
          lua_Number nb = nvalue(rb);
          setnvalue(ra, luai_numunm(nb));
        }
        <span style="color:#00f">else</span> {
          Protect(Arith(L, ra, rb, rb, TM_UNM));
        }
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_NOT: {
        <span style="color:#00f">int</span> res = l_isfalse(RB(i));  <span style="color:#f00;font-style:italic">/* next assignment may change this value */</span>
        setbvalue(ra, res);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_LEN: {
        <span style="color:#00f">const</span> TValue *rb = RB(i);
        <span style="color:#00f">switch</span> (ttype(rb)) {
          <span style="color:#00f">case</span> LUA_TTABLE: {
            setnvalue(ra, cast_num(luaH_getn(hvalue(rb))));
            <span style="color:#00f">break</span>;
          }
          <span style="color:#00f">case</span> LUA_TSTRING: {
            setnvalue(ra, cast_num(tsvalue(rb)-&gt;len));
            <span style="color:#00f">break</span>;
          }
          <span style="color:#00f">default</span>: {  <span style="color:#f00;font-style:italic">/* try metamethod */</span>
            Protect(
              <span style="color:#00f">if</span> (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
                luaG_typeerror(L, rb, <span style="color:#009c00">&#34;get length of&#34;</span>);
            )
          }
        }
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_CONCAT: {
        <span style="color:#00f">int</span> b = GETARG_B(i);
        <span style="color:#00f">int</span> c = GETARG_C(i);
		<span style="color:#f00;font-style:italic">/* */</span>
        Protect(luaV_concat(L, c-b+1, c); luaC_checkGC(L));
        setobjs2s(L, RA(i), base+b);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_JMP: {
        dojump(L, pc, GETARG_sBx(i));
        <span style="color:#00f">continue</span>;
      }
	  	<span style="color:#f00;font-style:italic">/* KEYCODE 重点，难点，代表性的指令 
</span><span style="color:#f00;font-style:italic">	  	** if ((RK(B) == RK(C)) ~= A) then pc++
</span><span style="color:#f00;font-style:italic">	  	** OP_EQ后面紧跟着是跳转指令，这里猜测，跳转的值Bx应该短1，因为后面又进行了pc++
</span><span style="color:#f00;font-style:italic">	  	*/</span>
      <span style="color:#00f">case</span> OP_EQ: {
        TValue *rb = RKB(i);
        TValue *rc = RKC(i);
        Protect(
          <span style="color:#00f">if</span> (equalobj(L, rb, rc) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_LT: {
        Protect(
          <span style="color:#00f">if</span> (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_LE: {	
        Protect(
          <span style="color:#00f">if</span> (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i))
            dojump(L, pc, GETARG_sBx(*pc));
        )
        pc++;
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_TEST: {
        <span style="color:#00f">if</span> (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_TESTSET: {
        TValue *rb = RB(i);
        <span style="color:#00f">if</span> (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_CALL: {	<span style="color:#f00;font-style:italic">/* R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span>
	    <span style="color:#00f">int</span> b = GETARG_B(i);			<span style="color:#f00;font-style:italic">/* 传入参数个数，          B:0：...  1：0个，2：1个，3：2个依次类推 */</span>
        <span style="color:#00f">int</span> nresults = GETARG_C(i) - 1;	<span style="color:#f00;font-style:italic">/* 期待的返回值个数 C:0(...), 1:(期待返回0个)，2:(期待返回1个) */</span>
        
        <span style="color:#f00;font-style:italic">/* 注解99: 当传入的参数数量明确时，设置L-&gt;top告知被调用函数确切的传入参数数量,
</span><span style="color:#f00;font-style:italic">        ** 不明确时，OP_VARARG(fun(...))/	RETURN.B(funA(funB())等指令中已确定了top的位置，这里不能也不用再更改设置(否则L-&gt;top!=实际传入的参数位置)
</span><span style="color:#f00;font-style:italic">        ** 
</span><span style="color:#f00;font-style:italic">        ** L-&gt;top都是指向了最后一个参数的&#34;位置&#34;,也是告知被调用函数，我已经准备好了你要的参数且top指针已指到相应的位置了
</span><span style="color:#f00;font-style:italic">        */</span>
        <span style="color:#00f">if</span> (b != 0) 
			L-&gt;top = ra+b;  <span style="color:#f00;font-style:italic">/* else previous instruction set top */</span>
		
        L-&gt;savedpc = pc;	<span style="color:#f00;font-style:italic">/* 记下原本接下来要执行的下一条指令，等待new&#39;frame运行结束后，继续运行本frame */</span>
        <span style="color:#00f">switch</span> (luaD_precall(L, ra, nresults)) {
          <span style="color:#00f">case</span> PCRLUA: {
            nexeccalls++;
			<span style="color:#f00;font-style:italic">/* 若子函数(frame)是Lua，这里continue才真正开始执行子函数(frame)的opcode */</span>
            <span style="color:#00f">goto</span> reentry;  <span style="color:#f00;font-style:italic">/* restart luaV_execute over new Lua function */</span>
          }
          <span style="color:#00f">case</span> PCRC: {
            <span style="color:#f00;font-style:italic">/* it was a C function (`precall&#39; called it); adjust results */</span>
		  
		    <span style="color:#f00;font-style:italic">/* 注解100: C调用结束时luaD_poscall已经将所有的返回值填充到RA开头的addr上,L-&gt;top指向最后一个返回值
</span><span style="color:#f00;font-style:italic">		    ** 期待返回值个数确定时eg:local a,b = fun()，luaD_poscall函数自动赋值了a,b，L-&gt;top已经完成了使命
</span><span style="color:#f00;font-style:italic">		    **     故而这里将其复原。
</span><span style="color:#f00;font-style:italic">		    ** 期待返回个数不确定时eg:local t = {fun()}或funA(funB())，这种情况下L-&gt;top指向的最后一个返回值地址，
</span><span style="color:#f00;font-style:italic">		    **     将被下一条指令setlist(B=0)或callA(B=0)用于计算传入参数的个数，所以不能复原(下一条指令要用到)
</span><span style="color:#f00;font-style:italic">		    */</span>
            <span style="color:#00f">if</span> (nresults &gt;= 0)
				L-&gt;top = L-&gt;ci-&gt;top;
			
            base = L-&gt;base;	<span style="color:#f00;font-style:italic">/* 调用过程中stack可能变化而移动，故而重新获取最新的(L-&gt;ci-&gt;base==L-&gt;base)的base，下同 */</span>
			<span style="color:#f00;font-style:italic">/* 子函数(frame)为c,luaD_precall的返回意味着子函数(frame)已运行完毕，相关参数也调整完毕
</span><span style="color:#f00;font-style:italic">			** 这里接着运行母函数(frame)的紧跟着OP_CALL后面的下一条指令 */</span>
            <span style="color:#00f">continue</span>;	
          }
          <span style="color:#00f">default</span>: {
            <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* yield,交出lua的执行权 */</span>
          }
        } 
      }
      <span style="color:#00f">case</span> OP_TAILCALL: {
	  	<span style="color:#f00;font-style:italic">/* A B C return R(A)(R(A+1), ... ,R(A+B-1)) */</span>
        <span style="color:#00f">int</span> b = GETARG_B(i);
        <span style="color:#00f">if</span> (b != 0) {
			L-&gt;top = ra+b;  <span style="color:#f00;font-style:italic">/* else previous instruction set top */</span>
        } <span style="color:#00f">else</span> {
        	<span style="color:#f00;font-style:italic">/* return fun(...) 前面的OP_VARARG指令设置好了L-&gt;top */</span> 
        }
        L-&gt;savedpc = pc;
        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);	<span style="color:#f00;font-style:italic">/* 尾调用的定义中：必须返回其调用返回的所有值，所以这里C必须为0 */</span>
        <span style="color:#00f">switch</span> (luaD_precall(L, ra, LUA_MULTRET)) {
          <span style="color:#00f">case</span> PCRLUA: {	<span style="color:#f00;font-style:italic">/* 画图，代码不难，看懂它们 */</span>
            <span style="color:#f00;font-style:italic">/* tail call: put new frame in place of previous one */</span>
            CallInfo *ci = L-&gt;ci - 1;  <span style="color:#f00;font-style:italic">/* previous frame */</span>
            <span style="color:#00f">int</span> aux;
            StkId func = ci-&gt;func;
            StkId pfunc = (ci+1)-&gt;func;  <span style="color:#f00;font-style:italic">/* previous function index */</span>
            <span style="color:#00f">if</span> (L-&gt;openupval) luaF_close(L, ci-&gt;base);
            L-&gt;base = ci-&gt;base = ci-&gt;func + ((ci+1)-&gt;base - pfunc);

			<span style="color:#f00;font-style:italic">/* ！！！！移动后func指向的地址不变，但值改变了（由母函数变成了被尾调用的子函数) */</span>
            <span style="color:#00f">for</span> (aux = 0; pfunc+aux &lt; L-&gt;top; aux++)  <span style="color:#f00;font-style:italic">/* move frame down */</span>
              setobjs2s(L, func+aux, pfunc+aux);
			
            ci-&gt;top = L-&gt;top = func+aux;  <span style="color:#f00;font-style:italic">/* correct top */</span>
            lua_assert(L-&gt;top == L-&gt;base + clvalue(func)-&gt;l.p-&gt;maxstacksize);
            ci-&gt;savedpc = L-&gt;savedpc;	<span style="color:#f00;font-style:italic">/* 这里也要更新 */</span>
            ci-&gt;tailcalls++;  <span style="color:#f00;font-style:italic">/* one more call lost */</span>
            L-&gt;ci--;  <span style="color:#f00;font-style:italic">/* remove new frame */</span>
            <span style="color:#00f">goto</span> reentry;
          }
          <span style="color:#00f">case</span> PCRC: {  <span style="color:#f00;font-style:italic">/* it was a C function (`precall&#39; called it) */</span>
            base = L-&gt;base;	<span style="color:#f00;font-style:italic">/* restore base */</span>
            <span style="color:#00f">continue</span>;
          }
          <span style="color:#00f">default</span>: {
            <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* yield */</span>
          }
        }
      }
      <span style="color:#00f">case</span> OP_RETURN: {
	  	<span style="color:#f00;font-style:italic">/* return R(A), ... ,R(A+B-2) */</span>
        <span style="color:#00f">int</span> b = GETARG_B(i);	<span style="color:#f00;font-style:italic">/* 0：返回所有值，1：返回0个值，2：返回1个值 ... */</span>
        <span style="color:#00f">if</span> (b != 0) <span style="color:#f00;font-style:italic">/* b==0其它的指令argvar等已处理好top,eg:(return ...)或者return(a, fun()) */</span>
			L-&gt;top = ra+b-1;	<span style="color:#f00;font-style:italic">/* 以便确定返回值的确切个数 */</span>
        <span style="color:#00f">if</span> (L-&gt;openupval) luaF_close(L, base);
        L-&gt;savedpc = pc;
        b = luaD_poscall(L, ra);	<span style="color:#f00;font-style:italic">/* 将子函数的返回值移到指定地方，并适配母函数的result要求 */</span>

		<span style="color:#f00;font-style:italic">/* lua调用结束，返回值已经按照移动到指定的位置(本fun的addr)，且L-&gt;top指向了最后一个返回值的位置(可以用来计算返回值的个数)
</span><span style="color:#f00;font-style:italic">		   这里直接return，将CPU交换到母C函数 */</span>
        <span style="color:#00f">if</span> (--nexeccalls == 0)  <span style="color:#f00;font-style:italic">/* was previous function running `here&#39;? Lua层面的调用结束了，结束lua的execute的执行，返回到C */</span>
          <span style="color:#00f">return</span>;  <span style="color:#f00;font-style:italic">/* no: return */</span>
        <span style="color:#00f">else</span> {  <span style="color:#f00;font-style:italic">/* yes: continue its execution */</span>
          <span style="color:#00f">if</span> (b) <span style="color:#f00;font-style:italic">/* 同上注解100，请往上翻阅 */</span>
		  	L-&gt;top = L-&gt;ci-&gt;top;	<span style="color:#f00;font-style:italic">/*  */</span>
          lua_assert(isLua(L-&gt;ci)); <span style="color:#f00;font-style:italic">/* return后，lua连续调用链还没结束，那么上一层必然是个lua函数 */</span>
          lua_assert(GET_OPCODE(*((L-&gt;ci)-&gt;savedpc - 1)) == OP_CALL);	<span style="color:#f00;font-style:italic">/* 上一个指令必然是call */</span>
          <span style="color:#00f">goto</span> reentry;	<span style="color:#f00;font-style:italic">/* 切回到母lua的execute的frame */</span>
        }
      }
      <span style="color:#00f">case</span> OP_FORLOOP: {	<span style="color:#f00;font-style:italic">/* 先看 OP_FORPREP 指令 */</span>
        lua_Number step = nvalue(ra+2);
        lua_Number idx = luai_numadd(nvalue(ra), step); <span style="color:#f00;font-style:italic">/* increment index */</span>
        lua_Number limit = nvalue(ra+1);
        <span style="color:#00f">if</span> (luai_numlt(0, step) ? luai_numle(idx, limit)
                                : luai_numle(limit, idx)) {
          dojump(L, pc, GETARG_sBx(i));  <span style="color:#f00;font-style:italic">/* jump back */</span>
          setnvalue(ra, idx);  <span style="color:#f00;font-style:italic">/* update internal index... */</span>
          setnvalue(ra+3, idx);  <span style="color:#f00;font-style:italic">/* ...and external index 这个idx才是暴露给for循环里面的i(for i = 0; 10; 1) */</span> 
        }
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_FORPREP: {
        <span style="color:#00f">const</span> TValue *init = ra;
        <span style="color:#00f">const</span> TValue *plimit = ra+1;
        <span style="color:#00f">const</span> TValue *pstep = ra+2;
        L-&gt;savedpc = pc;  <span style="color:#f00;font-style:italic">/* next steps may throw errors */</span>
        <span style="color:#00f">if</span> (!tonumber(init, ra))
          luaG_runerror(L, LUA_QL(<span style="color:#009c00">&#34;for&#34;</span>) <span style="color:#009c00">&#34; initial value must be a number&#34;</span>);
        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!tonumber(plimit, ra+1))
          luaG_runerror(L, LUA_QL(<span style="color:#009c00">&#34;for&#34;</span>) <span style="color:#009c00">&#34; limit must be a number&#34;</span>);
        <span style="color:#00f">else</span> <span style="color:#00f">if</span> (!tonumber(pstep, ra+2))
          luaG_runerror(L, LUA_QL(<span style="color:#009c00">&#34;for&#34;</span>) <span style="color:#009c00">&#34; step must be a number&#34;</span>);
        setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep)));	<span style="color:#f00;font-style:italic">/* 这里提前-=step */</span>
        dojump(L, pc, GETARG_sBx(i));	<span style="color:#f00;font-style:italic">/* 跳到cond判断那里 */</span>
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_TFORLOOP: {
	  	<span style="color:#f00;font-style:italic">/* 编译模块保证了ra+3是个有意义的参数 
</span><span style="color:#f00;font-style:italic">	  	** next函数会吃掉传入的参数，所以这里CP了一份
</span><span style="color:#f00;font-style:italic">	    */</span>
	    <span style="color:#f00;font-style:italic">/* 结合 http://shankusu.me/lua/ANo-FrillsIntroductiontoLua51VMInstructions/ 文档来看，更容易理解 */</span>
        StkId cb = ra + 3;  <span style="color:#f00;font-style:italic">/* call base */</span>
        setobjs2s(L, cb+2, ra+2);
        setobjs2s(L, cb+1, ra+1);
        setobjs2s(L, cb, ra);
        L-&gt;top = cb+3;  <span style="color:#f00;font-style:italic">/* func. + 2 args (state and index) */</span>
        Protect(luaD_call(L, cb, GETARG_C(i)));
        L-&gt;top = L-&gt;ci-&gt;top;
        cb = RA(i) + 3;  <span style="color:#f00;font-style:italic">/* previous call may change the stack */</span>
        <span style="color:#00f">if</span> (!ttisnil(cb)) {  <span style="color:#f00;font-style:italic">/* continue loop? */</span>
          setobjs2s(L, cb-1, cb);  <span style="color:#f00;font-style:italic">/* save control variable */</span>
          dojump(L, pc, GETARG_sBx(*pc));  <span style="color:#f00;font-style:italic">/* jump back */</span>
        }
        pc++;
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_SETLIST: {	<span style="color:#f00;font-style:italic">/* local t = {...} 本指令之前可能会有一条vararg或local t2={fun(...)}产生的OP_CALL，所以结合vararg来理解本block的代码 */</span>
	  	<span style="color:#f00;font-style:italic">/* A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B */</span>
        <span style="color:#00f">int</span> n = GETARG_B(i);
        <span style="color:#00f">int</span> c = GETARG_C(i);
        <span style="color:#00f">int</span> last;
        Table *h;
        <span style="color:#00f">if</span> (n == 0) {	
          n = cast_int(L-&gt;top - ra) - 1;	<span style="color:#f00;font-style:italic">/* 计算确切的参数个数 */</span>
          L-&gt;top = L-&gt;ci-&gt;top;	<span style="color:#f00;font-style:italic">/* OP_VARARG指令L-&gt;top已经指向了{...}不定参数的最后一个slot的位置以便求n,这里将其复原 */</span>
        }
        <span style="color:#00f">if</span> (c == 0) c = cast_int(*pc++);	<span style="color:#f00;font-style:italic">/* 这行代码最好有个印象 */</span>
        runtime_check(L, ttistable(ra));	<span style="color:#f00;font-style:italic">/* 编译模块出错了 */</span>
        h = hvalue(ra);
        last = ((c-1)*LFIELDS_PER_FLUSH) + n;	<span style="color:#f00;font-style:italic">/* 计算当前能确定的数组下标的最大值 */</span>
        <span style="color:#00f">if</span> (last &gt; h-&gt;sizearray)  <span style="color:#f00;font-style:italic">/* needs more space?  数组区域大小不够，需扩展*/</span>
          luaH_resizearray(L, h, last);  <span style="color:#f00;font-style:italic">/* pre-alloc it at once */</span>
        <span style="color:#00f">for</span> (; n &gt; 0; n--) {
          TValue *val = ra+n;
          setobj2t(L, luaH_setnum(L, h, last--), val);
          luaC_barriert(L, h, val);
        }
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_CLOSE: {
	  	<span style="color:#f00;font-style:italic">/* close all variables in the stack up to (&gt;=) R(A) 编译模块如何确定参数A？*/</span>
        luaF_close(L, ra);
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_CLOSURE: {
	  	<span style="color:#f00;font-style:italic">/* A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n)) */</span>
        Proto *p;
        Closure *ncl;
        <span style="color:#00f">int</span> nup, j;
        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];	<span style="color:#f00;font-style:italic">/* 找到对应的proto */</span>
        nup = p-&gt;nups;
        ncl = luaF_newLclosure(L, nup, cl-&gt;env);
        ncl-&gt;l.p = p;
		<span style="color:#f00;font-style:italic">/* 下面的block尚未完全看懂 */</span>
        <span style="color:#00f">for</span> (j=0; j&lt;nup; j++, pc++) {
          <span style="color:#00f">if</span> (GET_OPCODE(*pc) == OP_GETUPVAL)
            ncl-&gt;l.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];
          <span style="color:#00f">else</span> {
            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
          }
        }
        setclvalue(L, ra, ncl);
        Protect(luaC_checkGC(L));
        <span style="color:#00f">continue</span>;
      }
      <span style="color:#00f">case</span> OP_VARARG: {
	  	<span style="color:#f00;font-style:italic">/* A B	R(A), R(A+1), ..., R(A+B-1) = vararg */</span>
        <span style="color:#00f">int</span> b = GETARG_B(i) - 1;
        <span style="color:#00f">int</span> j;
        CallInfo *ci = L-&gt;ci;
        <span style="color:#00f">int</span> n = cast_int(ci-&gt;base - ci-&gt;func) - cl-&gt;p-&gt;numparams - 1;	<span style="color:#f00;font-style:italic">/* 本次函数调用传入的不定参数的个数eg: funA(a,b, ...) funA */</span>
        <span style="color:#00f">if</span> (b == LUA_MULTRET) {
          Protect(luaD_checkstack(L, n));
          ra = RA(i);  <span style="color:#f00;font-style:italic">/* previous call may change the stack */</span>
          b = n;	<span style="color:#f00;font-style:italic">/* 出现在 local tbl = {...} 或者 funA(...) 需要拷贝所有的不定参数的地方 */</span>

		  <span style="color:#f00;font-style:italic">/* 为可能即将到来的C/lua函数调用做准备，(L-&gt;top-func可知即将发生的函数调用实际上有多少个传入参数) 
</span><span style="color:#f00;font-style:italic">		  ** 
</span><span style="color:#f00;font-style:italic">		  ** local tbl={...} OP_SETLIST指令也用到了L-&gt;top，故而可以推断出，这里L-&gt;top标记了实际上...携带的参数个数
</span><span style="color:#f00;font-style:italic">		  ** 以便其它指令能准确的执行(主要是获取..参数个数)，这里将实际传入的参数个数通过L-&gt;top计算好，避免其它指令再去计算一遍
</span><span style="color:#f00;font-style:italic">		  ** 其它指令用完L-&gt;top后需将其复原
</span><span style="color:#f00;font-style:italic">		  */</span>
          L-&gt;top = ra + n; 
        }
		<span style="color:#f00;font-style:italic">/* 将不定参数赋值给指定的对象？？？
</span><span style="color:#f00;font-style:italic">		** local a, b = ...
</span><span style="color:#f00;font-style:italic">		** 不定参数数量不足则补nil
</span><span style="color:#f00;font-style:italic">		*/</span>
        <span style="color:#00f">for</span> (j = 0; j &lt; b; j++) {
          <span style="color:#00f">if</span> (j &lt; n) {	<span style="color:#f00;font-style:italic">/* 本函数的不定参数的个数还能满足ra+j代表的dst寄存器 */</span>
            setobjs2s(L, ra + j, ci-&gt;base - n + j);
          }
          <span style="color:#00f">else</span> {
            setnilvalue(ra + j);	<span style="color:#f00;font-style:italic">/* local a, b = ... 本函数实际上只收到了一个不定参数，那么不足的部分(b)就要补nil值了 */</span>
          }
        }
        <span style="color:#00f">continue</span>;
      }
    }
  }
}


</code></pre></div>
    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://shanks.link/tags/lua" rel="tag" title="lua">#lua#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://shanks.link/links/" rel="next" title="友连">
        <i class="fa fa-chevron-left"></i> 友连
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://shanks.link/blog/2021/05/20/lua%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A-ltable.c/" rel="prev" title="lua源码注释-ltable.c">
        lua源码注释-ltable.c <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     





<script src="https://utteranc.es/client.js"
        repo="shankusu2017@gmail.com/"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    <section class="site-overview sidebar-panel  sidebar-panel-active ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://shanks.link/img/logo.jpg"
        alt="shankusu2017@gmail.com" />
    <p class="site-author-name" itemprop="name">shankusu2017@gmail.com</p>
    <p class="site-description motion-element" itemprop="description"> </p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://shanks.link/post/">
        <span class="site-state-item-count">569</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://shanks.link/categories/">      
         
        <span class="site-state-item-count">45</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://shanks.link/tags/">
         
        <span class="site-state-item-count">50</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/shankusu2017" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2023</span>
</div>
<div>
  <a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021068940号-1</a>
  <a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44011302003059" rel="noopener" target="_blank">粤公网安备44011302003059</a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://shanks.link/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://shanks.link/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://shanks.link/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://shanks.link/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://shanks.link/js/utils.js"></script>
<script type="text/javascript" src="http://shanks.link/js/motion.js"></script>
<script type="text/javascript" src="http://shanks.link/js/affix.js"></script>
<script type="text/javascript" src="http://shanks.link/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://shanks.link/js/scrollspy.js"></script>
<script type="text/javascript" src="http://shanks.link/js/post-details.js"></script>
<script type="text/javascript" src="http://shanks.link/js/toc.js"></script>

<script type="text/javascript" src="http://shanks.link/js/bootstrap.js"></script>

<script type="text/javascript" src="http://shanks.link/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>